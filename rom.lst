              	; --------------------------------------
              	; zasm: assemble "rom.asm"
              	; date: 2020-10-24 09:16:24
              	; --------------------------------------


              	; 
              	; ------------------------------------------------------------------------------
              	; LM80C - BOOTLOADER - R3.14
              	; ------------------------------------------------------------------------------
              	; The following code is intended to be used with LM80C Z80-based computer
              	; designed by Leonardo Miliani. Code and computer schematics are released under
              	; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
              	; kind of warranty: you can use them at your own risk.
              	; You are free to use them for any non-commercial use: you are only asked to
              	; maintain the copyright notices, include this advice and the note to the 
              	; attribution of the original version to Leonardo Miliani, if you intend to
              	; redistribuite them.
              	; https://www.leonardomiliani.com
              	; 
              	; Please support me by visiting the following links:
              	; Main project page: https://www.leonardomiliani.com
              	; Schematics and code: https://github.com/leomil72/LM80C
              	; Videos about the computer: https://www.youtube.com/user/leomil72/videos
              	; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
              	; ------------------------------------------------------------------------------
              	
              	; ADDRESS DECODING (bits A6/A5/A4)
              	; 0000xxxx : PIO
              	; 0001xxxx : CTC
              	; 0010xxxx : SIO
              	; 0011xxxx : VDP
              	; 0100xxxx : PSG
              	
              	; label defining for PIO (Parallel Input/Output)
0000:         	PIO_DA          equ %00000000
0001:         	PIO_DB          equ %00000001
0002:         	PIO_CA          equ %00000010
0003:         	PIO_CB          equ %00000011
              	
              	; label defining for CTC (Counter Timer Circuit)
0010:         	CTC_CH0         equ %00010000
0011:         	CTC_CH1         equ %00010001
0012:         	CTC_CH2         equ %00010010
0013:         	CTC_CH3         equ %00010011
              	
              	;label defining for SIO (Serial Input/Output)
0022:         	SIO_CA          equ %00100010
0023:         	SIO_CB          equ %00100011
0020:         	SIO_DA          equ %00100000
0021:         	SIO_DB          equ %00100001
              	
              	;label defining for VDP (Video Display Processor)
0030:         	VDP_DAT         equ %00110000
0032:         	VDP_SET         equ %00110010
              	
              	; label defining for PSG (Programmable Sound Generator)
0040:         	PSG_REG         equ %01000000
0041:         	PSG_DAT         equ %01000001
              	
              	; Interrupt-driven serial I/O interface lead by the Z80 SIO to run modified
              	; NASCOM Basic 4.7 - Full input buffering with incoming data hardware handshaking
              	; Handshake shows full before the buffer is totally filled to allow run-on from the sender
              	
0058:         	SER_BUFSIZE     equ     $58
0050:         	SER_FULLSIZE    equ     $50
0005:         	SER_EMPTYSIZE   equ     $05
              	
8000:         	SERBUF_START    equ     $8000           ; RAM starts here
8058:         	serInPtr        equ     SERBUF_START + SER_BUFSIZE
805A:         	serRdPtr        equ     serInPtr+2
805C:         	serBufUsed      equ     serRdPtr+2
805D:         	basicStarted    equ     serBufUsed+1
0058:         	bufWrap         equ     (SERBUF_START + SER_BUFSIZE) & $FF
818D:         	TEMPSTACK       equ     CURPOS - 3      ; top of BASIC line input buffer so is "free ram" when BASIC resets
              	
              	;------------------------------------------------------------------------------
              	; BASE MEMORY - RESET LOCATION - $0000
              	; the CPU jumps to 0000h after a reset
0000:         	                org     $0000
0000: F3      	RST00:          di                      ; be sure that INTs are disabled
0001: C35A02  	                jp      INIT_HW         ; jump to system initialization
              	
              	;------------------------------------------------------------------------------
              	; send a character over serial
0004: FFFFFFFF	                org     $0008
0008: C3F701  	RST08:          jp      TXA
              	
              	;------------------------------------------------------------------------------
              	; interrupt vector when SIO has a char available in its buffer
000B: FF      	                org     $000C
000C: 0001    	                defw    RX_CHA_AVAIL
              	
              	;------------------------------------------------------------------------------
              	; interrupt vector for SIO special conditions (i.e. buf overrun)
              	                org     $000E
000E: 9B01    	                defw    SPEC_RX_CONDITON
              	
              	;------------------------------------------------------------------------------
              	; receive a character over serial
              	                org     $0010
0010: C3CD01  	RST10:          jp      RXA
              	
              	;------------------------------------------------------------------------------
              	; check serial status
              	
0013: FFFFFFFF	                org     $0018
0017: FF      	
0018: C32402  	RST18:          jp      CKINCHAR
              	
              	;------------------------------------------------------------------------------
              	; interrupt vectors for CTC 
001B: FFFFFFFF	                org     $0040               ; for CH0 Timer - unused
001F: FF...   	
0040: D281    	                defw    CTC0IV
              	                
              	                org     $0042               ; for CH1 Timer - unused
0042: D581    	                defw    CTC1IV
              	                
              	                org     $0044               ; for CH2 timer - unused
0044: D881    	                defw    CTC2IV
              	                
              	                org     $0046               ; for CH3 Timer - used for 100ths/s counter
0046: DB81    	                defw    CTC3IV
              	
              	;------------------------------------------------------------------------------
              	; interrupt routine for NMI
0048: FFFFFFFF	                org     $0066
004C: FF...   	
0066: C36180  	                jp      NMIUSR              ; jump to execute NMI service routine
              	
              	;------------------------------------------------------------------------------
              	
0069: FFFFFFFF	                org     $0090
006D: FF...   	
0090: 4C4D3830	                defb    $4C,$4D,$38,$30,$43,$20,$43,$4F
0094: 4320434F	
0098: 4C4F5200	                defb    $4C,$4F,$52,$00,$00,$00,$00,$00
009C: 00000000	
00A0: 434F4D50	                defb    $43,$4F,$4D,$50,$55,$54,$45,$52
00A4: 55544552	
00A8: 20283230	                defb    $20,$28,$32,$30,$32,$30,$29,$00
00AC: 32302900	
00B0: 44657369	                defb    $44,$65,$73,$69,$67,$6E,$65,$64
00B4: 676E6564	
00B8: 20627900	                defb    $20,$62,$79,$00,$00,$00,$00,$00
00BC: 00000000	
00C0: 4C656F6E	                defb    $4C,$65,$6F,$6E,$61,$72,$64,$6F
00C4: 6172646F	
00C8: 204D696C	                defb    $20,$4D,$69,$6C,$69,$61,$6E,$69
00CC: 69616E69	
00D0: 46572033	FWVER:          defm    'FW 3.14',$20,__date__,$20,__time__,$00
00D4: 2E313420	
00D8: 32303230	
00DC: 2D31302D	
00E0: 32342030	
00E4: 393A3136	
00E8: 3A323400	
              	;------------------------------------------------------------------------------
              	; interrupt driven routine to get chars from Z80 SIO
00EC: FFFFFFFF	                org     $0100
00F0: FF...   	
0100: F5      	RX_CHA_AVAIL:   push    AF              ; store A
0101: E5      	                push    HL              ; and HL
0102: CD6501  	                call    A_RTS_OFF       ; disable RTS line
0105: DB20    	                in      A,(SIO_DA)      ; read char from RX buffer into A
0107: 322B82  	                ld      (TMPKEYBFR),A   ; store it into the temp key buffer
010A: CD3601  	                call    CHARINTOBFR     ; sub-routine to put the char into the input buffer
010D: D23101  	                jp      NC,LVRXCHA      ; if buffer is full, then leave without doing anything else
0110: 3A2B82  	                ld      A,(TMPKEYBFR)   ; retrieve char
0113: 32EC81  	                ld      (CHR4VID),A     ; write into buffer for video printing
0116: FE0D    	                cp      CR              ; is it RETURN?
0118: CA2001  	                jp      Z,CNTRXCHA      ; yes, continue
011B: FE20    	                cp      $20             ; is it another control char (code < 32)?
011D: DA3101  	                jp      C,LVRXCHA       ; yes, leave w/o printing it on video nor sending back to serial
0120: F5      	CNTRXCHA:       push    AF              ; store char
0121: AF      	                xor     A
0122: 322982  	                ld      (KBDNPT),A      ; a char from serial is like a char printed by BASIC
0125: 3AEB81  	                ld      A,(PRNTVIDEO)   ; load status of print-on-video
0128: FE01    	                cp      $01             ; is the print on video on?
012A: CCC806  	                call    Z,CHAR2VID      ; yes, print on screen
012D: F1      	                pop     AF              ; retrieve char
012E: CDF701  	                call    TXA             ; send back to serial
0131: E1      	LVRXCHA:        pop     HL              ; retrieve HL
0132: F1      	                pop     AF              ; and A
0133: FB      	                ei                      ; re-enable interrupts
0134: ED4D    	                reti                    ; and exit
              	
              	; put a char into the input buffer, char is into A
              	; this sub is called both from the ISR "RX_CHA_AVAIL" and when
              	; the RETURN key is pressed on the keyboard
0136: F5      	CHARINTOBFR:    push    AF              ; store it
0137: 3A5C80  	                ld      A,(serBufUsed)  ; load buffer size
013A: FE58    	                cp      SER_BUFSIZE     ; if buffer is not full
013C: DA4101  	                jp      C,NOTFULL       ; then store the char
013F: F1      	                pop     AF              ; else drop it
0140: C9      	                ret                     ; and exit
0141: 2A5880  	NOTFULL:        ld      HL,(serInPtr)   ; buffer is not full, can store the char
0144: 23      	                inc     HL              ; load pointer to find first free cell
0145: 7D      	                ld      A,L             ; only check low byte because buffer<256
0146: FE58    	                cp      bufWrap         ; check if the pointer is at the last cell
0148: 2003    	                jr      NZ,NOTWRAP      ; if not then continue
014A: 210080  	                ld      HL,SERBUF_START ; else load the address of the first cell
014D: 225880  	NOTWRAP:        ld      (serInPtr),HL   ; store the new pointer
0150: F1      	                pop     AF              ; then recover the char
0151: 77      	                ld      (HL),A          ; and store it in the appropriate cell
0152: 3A5C80  	                ld      A,(serBufUsed)  ; load the size of the input buffer
0155: 3C      	                inc     A               ; increment it
0156: 325C80  	                ld      (serBufUsed),A  ; and store the new size
0159: FE50    	                cp      SER_FULLSIZE    ; check if input buffer is full
015B: D8      	                ret     C               ; exit if buffer is not full
015C: 3A2E82  	                ld      A,(SERIALS_EN)  ; check if serial 1 is open
015F: 1F      	                rra                     ; bit 0 into Carry: if Carry is 1 then serial 0 is open and...
0160: DC6501  	                call    C,A_RTS_OFF     ; ...stop receiving further chars
0163: AF      	                xor     A               ; clear Carry to set a buffer full condition
0164: C9      	                ret
              	
              	;-------------------------------------------------------------------------------
              	; Z80 SIO MANAGEMENT
              	;-------------------------------------------------------------------------------
              	; disable RTS:
              	; by resetting RTS bit (set to 0), the RTS line is disabled (HIGH)
0165: F5      	A_RTS_OFF:      push    AF              ; store A
0166: 3E05    	                ld      A,%00000101     ; write into WR0: select WR5
0168: D322    	                out     (SIO_CA),A
016A: 3A2F82  	                ld      A,(SERABITS)    ; load data bits
016D: F628    	                or      %00101000       ; TX enable; RTS disable
016F: D322    	                out     (SIO_CA),A      ; send setting
0171: F1      	                pop     AF              ; retrieve A
0172: C9      	                ret                     ; exit
              	
              	; enable RTS
              	; by setting RTS bit (set to 1), the RTS line is enabled (LOW)
0173: F5      	A_RTS_ON:       push    AF              ; store A
0174: 3E05    	                ld      A,%00000101     ; write into WR0: select WR5
0176: D322    	                out     (SIO_CA),A
0178: 3A2F82  	                ld      A,(SERABITS)    ; load data bits
017B: F62A    	                or      %00101010       ; TX enable; RTS enable
017D: D322    	                out     (SIO_CA),A      ; send setting
017F: F1      	                pop     AF              ; retrieve A
0180: C9      	                ret                     ; return
              	
              	; disable SIO RX channel A
0181: F5      	SIO_A_DI:       push    AF              ; store A
0182: 3E03    	                ld      A,%00000011     ; write into WR0: select WR3
0184: D322    	                out     (SIO_CA),A
0186: 3A2F82  	                ld      A,(SERABITS)    ; load the serial bits; RX disabled; auto enable is OFF
0189: D322    	                out     (SIO_CA),A
018B: F1      	                pop     AF              ; retrieve A
018C: C9      	                ret                     ; return
              	
              	; enable SIO RX channel A
018D: F5      	SIO_A_EI:       push    AF              ; store A
018E: 3E03    	                ld      A,%00000011     ; write into WR0: select WR3
0190: D322    	                out     (SIO_CA),A      ; select register
0192: 3A2F82  	                ld      A,(SERABITS)    ; load the serial data bits
0195: CBC7    	                set     0,A             ; set RX enabled; auto enable is OFF
0197: D322    	                out     (SIO_CA),A      ; send setting to SIO
0199: F1      	                pop     AF              ; retrieve A
019A: C9      	                ret
              	
              	
              	; special SIO condition (i.e., buffer overrun)
              	; if buffer overruns then show an error, empty the RX buffer and send
              	; a break char
019B:         	SPEC_RX_CONDITON:
019B: F5      	                push    AF
019C: E5      	                push    HL
019D: CD6501  	                call    A_RTS_OFF       ; disable RTS
01A0: CD8101  	                call    SIO_A_DI        ; disable RX on ch. A
01A3: 3A2E82  	                ld      A,(SERIALS_EN)  ; load serial status
01A6: CB97    	                res     2,A             ; disable RX on port 1
01A8: 322E82  	                ld      (SERIALS_EN),A  ; store new serial status 
01AB: DB01    	                in      A,(PIO_DB)      ; read status LEDs
01AD: CBE7    	                set     4,A             ; set 5th pin ON
01AF: D301    	                out     (PIO_DB),A      ; send new setting
01B1: 3E30    	                ld      A,%00110000     ; write into WR0: error reset, select WR0
01B3: D322    	                out     (SIO_CA),A      ; send command to SIO
01B5: 3E03    	                ld      A,CTRLC
01B7: CD3601  	                call    CHARINTOBFR     ; send CTRL-C to BASIC
01BA: AF      	EMPTYCHABFR:    xor     A
01BB: D322    	                out     (SIO_CA),A      ; write to WR0, select RR0
01BD: DB22    	                in      A,(SIO_CA)      ; read RR0 register
01BF: E601    	                and     $01             ; check if input buffer if empty
01C1: CAC801  	                jp      Z,CHABFREMPTY   ; if yes (bit 0 = 0) then leave
01C4: DB20    	                in      A,(SIO_DA)      ; read chars
01C6: 18F2    	                jr      EMPTYCHABFR     ; repeat
01C8: E1      	CHABFREMPTY:    pop     HL
01C9: F1      	                pop     AF
01CA: FB      	                ei                      ; re-enable interrupts
01CB: ED4D    	                reti                    ; return from interrupt
              	
              	;------------------------------------------------------------------------------
              	; retrieve a char from the input buffer
01CD: 3A5C80  	RXA:            ld      A,(serBufUsed)  ; load the buffer size
01D0: A7      	                and     A               ; check if it's 0 (empty)
01D1: CACD01  	                jp      Z,RXA           ; if it's empty, wait for a char
01D4: F3      	                di                      ; disable interrupts
01D5: E5      	                push    HL              ; store HL
01D6: 2A5A80  	                ld      HL,(serRdPtr)   ; load pointer to first available char
01D9: 23      	                inc     HL              ; increment it (go to the next char)
01DA: 7D      	                ld      A,L             ; check if the end of the buffer has been reached
01DB: FE58    	                cp      bufWrap         ; (only check low byte because buffer<256)
01DD: 2003    	                jr      NZ,NOTRDWRAP    ; if not, jump straight
01DF: 210080  	                ld      HL,SERBUF_START ; else reload the starting address of the buffer
01E2: 225A80  	NOTRDWRAP:      ld      (serRdPtr),HL   ; store new pointer to the next char to read
01E5: 3A5C80  	                ld      A,(serBufUsed)  ; load buffer size
01E8: 3D      	                dec     A               ; decrement it
01E9: 325C80  	                ld      (serBufUsed),A  ; and store the new size
01EC: FE05    	                cp      SER_EMPTYSIZE   ; check if input buffer can be considered empty
01EE: 3003    	                jr      NC,RXA_EXIT     ; if not empty yet, then exit
01F0: CD7301  	                call    A_RTS_ON        ; else re-enable receiving chars
01F3: 7E      	RXA_EXIT:       ld      A,(HL)          ; recover the char and return it into A
01F4: E1      	                pop     HL              ; retrieve HL
01F5: FB      	                ei                      ; re-enable interrupts
01F6: C9      	                ret                     ; return
              	
              	;------------------------------------------------------------------------------
              	; sends a char over the serial (trick for INTs from WikiTI)
              	; char is into A
01F7: F5      	TXA:            push    AF              ; store AF
01F8: C5      	                push    BC              ; store BC
01F9: 47      	                ld      B,A             ; store char
01FA: ED57    	                ld      A,I             ; when loading I into A, P/V is set to the value of IFF (P/V is set if INTs enabled)
01FC: EA0102  	                jp      PE,CNTTXA       ; if set, jump over
01FF: ED57    	                ld      A,I             ; if not set, test again to fix "false negative" from interrupt occurring at first test
0201: F5      	CNTTXA:         push    AF              ; store current P/V flag
0202: F3      	                di                      ; disable INTs
0203: 3A2E82  	                ld      A,(SERIALS_EN)  ; load serial status
0206: FE05    	                cp      %00000101       ; check if serial 1 is open and RX/TX is enabled 
0208: 2006    	                jr      NZ,TXA_EXIT     ; no, jump over
020A: 78      	                ld      A,B             ; retrieve char
020B: D320    	                out     (SIO_DA),A      ; send char to the SIO
020D: CD1802  	                call    TX_EMP          ; wait for outgoing char to be sent
0210: F1      	TXA_EXIT:       pop     AF              ; retrieve P/V flag
0211: E21502  	                jp      PO,EXTXA        ; if P is reset, INTs were disabled so we can leave right now
0214: FB      	                ei                      ; INTs were enabled, so re-enable interrupts
0215: C1      	EXTXA:          pop     BC              ; retrieve BC
0216: F1      	                pop     AF              ; retrieve AF
0217: C9      	                ret                     ; return
              	
              	;------------------------------------------------------------------------------
              	; wait until outgoing serial has been sent
0218: 97      	TX_EMP:         sub     A               ; set A to 0
0219: 3C      	                inc     A               ; set A to 1
021A: D322    	                out     (SIO_CA),A      ; write to WR0, select RR1
021C: DB22    	                in      A,(SIO_CA)      ; read RR1 register
021E: CB47    	                bit     0,A             ; check if all chars have been sent
0220: CA1802  	                jp      Z,TX_EMP        ; if not (bit 0 = 0) then retrieve
0223: C9      	                ret                     ; else exit
              	
              	
              	;------------------------------------------------------------------------------
              	; check if there is some chars into the buffer
0224: 3A5C80  	CKINCHAR        ld      A,(serBufUsed)  ; load char in buffer
0227: A7      	                and     A               ; compare to 0
0228: C9      	                ret                     ; return
              	
              	;------------------------------------------------------------------------------
              	; print a text from memory, and terminate when $00 is found
0229: 7E      	RAWPRINT:       ld      A,(HL)          ; load character from memory cell pointed by HL
022A: B7      	                or      A               ; is it $00 (end string)?
022B: C8      	                ret     Z               ; Yes, then return
022C: 32EC81  	                ld      (CHR4VID),A     ; store char
022F: F3      	                di
0230: CDC806  	                call    CHAR2VID        ; and send it to screen
0233: FB      	                ei
0234: 23      	                inc     HL              ; and select the next one
0235: 18F2    	                jr      RAWPRINT        ; repeat
              	
              	;-------------------------------------------------
              	; Interrupt service routine (ISR) for CH3 timer
              	; this is used to increment the 100ths of a second counter and for cursor flashing
0237: F5      	CH3_TIMER:      push    AF              ; save regs. A,
0238: C5      	                push    BC              ; BC,
0239: D5      	                push    DE              ; DE,
023A: E5      	                push    HL              ; HL
023B: 21CE81  	                ld      HL,TMRCNT       ; load starting address of the timer
023E: 0604    	                ld      B,$04           ; 4 bytes to check
0240: 34      	INCTMR3:        inc     (HL)            ; increment timer
0241: 2003    	                jr      NZ,CHKCRSR      ; if not zero then exit (finished increment)
0243: 23      	                inc     HL              ; if yes, there was an overflow, so increment next byte
0244: 10FA    	                djnz    INCTMR3         ; repeat for 4 bytes
0246: CD6907  	CHKCRSR:        call    FLASHCURSOR     ; call the flashing cursor routine
0249: CD230C  	                call    MNGSNDS         ; call the tone managemenet
024C: 3ACE81  	                ld      A,(TMRCNT)      ; check for keyboard management
024F: 1F      	                rra                     ; bit 0 = 1 ?
0250: D4880C  	                call    NC,KEYBOARD     ; no, so read the keyboard inputs
0253: E1      	                pop     HL              ; retrieve HL,
0254: D1      	                pop     DE              ; DE,
0255: C1      	                pop     BC              ; BC,
0256: F1      	                pop     AF              ; and A
0257: FB      	                ei                      ; re-enable interrupts
0258: ED4D    	                reti                    ; exit from ISR
              	
              	;------------------------------------------------------------------------------
              	;------------------------------------------------------------------------------
              	; HARDWARE INITIALISATION
              	; first run - setup HW & SW
              	;
025A: 218D81  	INIT_HW:        ld      HL,TEMPSTACK    ; load temp stack pointer
025D: F9      	                ld      SP,HL           ; set stack to temp stack pointer
025E: 210080  	                ld      HL,SERBUF_START ; set beginning of input buffer
0261: 225880  	                ld      (serInPtr),HL   ; for incoming chars to store into buffer
0264: 225A80  	                ld      (serRdPtr),HL   ; and for chars to be read from buffer
0267: AF      	                xor     A               ; reset A
0268: 325C80  	                ld      (serBufUsed),A  ; actual buffer size is 0
026B: 322E82  	                ld      (SERIALS_EN),A  ; set serial ports status to OFF
026E: CDDF02  	                call    HELLOWRLD       ; little serial blink with LEDs
0271: CD0403  	                call    initCTC         ; configure CTC, then...
0274: CDC10B  	                call    initPSG         ; ...configure PSG
0277: CDA104  	                call    SHOW_LOGO       ; show computer logo
027A: 1E01    	                ld      E,$01           ; E chooses the video mode: 1:graphics 1
027C: CD7E03  	                call    initVDP         ; set video display
027F: AF      	                xor     A
0280: ED47    	                ld      I,A             ; set high byte of interrupt vectors to point to page 0
0282: ED5E    	                im      2               ; interrupt mode 2
0284: FB      	                ei                      ; enable interrupts
              	                ; print system messages
0285: AF      	                xor     A               ; A=0 so...
0286: 322982  	                ld      (KBDNPT),A      ; ...inputs don't come from keyboard
0289: 3C      	                inc     A               ; A=1...
028A: 32EB81  	                ld      (PRNTVIDEO),A   ; ...to activate the print-on-video
028D: 213A03  	                ld      HL,MSGTXT1      ; sign-on message
0290: CD2902  	                call    RAWPRINT        ; print message
0293: CD5A08  	                call    CURSOR_ON       ; enable cursor
0296: 3A5D80  	                ld      A,(basicStarted); check if BASIC is already started
0299: FE59    	                cp      'Y'             ; to see if this is a power-up
029B: 2016    	                jr      NZ,COLDSTART    ; if not, then do a COLD start
029D: 216403  	                ld      HL,MSGTXT2      ; message to choose kind of start
02A0: CD2902  	                call    RAWPRINT        ; print message
02A3: AF      	                xor     A
02A4: 32EB81  	                ld      (PRNTVIDEO),A   ; disable print-on-video
02A7: CDCD01  	CORW:           call    RXA             ; look for a pressed key
02AA: E6DF    	                and     %11011111       ; only UPPERCASE char
02AC: FE43    	                cp      'C'             ; cold start?
02AE: 200B    	                jr      NZ,CHECKWARM    ; no, let's check for warm start
02B0: CDC502  	                call    ECHO_CHAR       ; echoes the char
02B3: 3E59    	COLDSTART:      ld      A,'Y'           ; yes, set the "BASIC started" flag
02B5: 325D80  	                ld      (basicStarted),A
02B8: C3F20E  	                jp      COLD            ; start BASIC COLD
02BB: FE57    	CHECKWARM:      cp      'W'
02BD: 20E8    	                jr      NZ,CORW         ; char not recognized, wait again
02BF: CDC502  	                call    ECHO_CHAR       ; echoes the char
02C2: C3F50E  	                jp      WARM            ; start BASIC WARM
              	
              	;-------------------------------------------------------------------------------
02C5: 32EC81  	ECHO_CHAR:      ld      (CHR4VID),A     ; set char for video printing
02C8: AF      	                xor     A
02C9: 322982  	                ld      (KBDNPT),A      ; input is not from keyboard
02CC: F3      	                di                      ; disable INTs
02CD: CDC806  	                call    CHAR2VID        ; echoes back the pressed key,
02D0: 3E0D    	                ld      A,CR            ; then set a CR
02D2: 32EC81  	                ld      (CHR4VID),A     ; set char for video printing
02D5: CDC806  	                call    CHAR2VID        ; and send it to screen
02D8: FB      	                ei                      ; re-enable INTs
02D9: 3E01    	                ld      A,$01
02DB: 32EB81  	                ld      (PRNTVIDEO),A   ; re-enable video printing
02DE: C9      	                ret                     ; return to caller
              	                
              	;-------------------------------------------------------------------------------
              	; little serial blink with LEDs
02DF: 0E09    	HELLOWRLD:      ld      C,$09           ; 8 LEDs to be turned off + 1 more step to turn off the last LED
02E1: 3ECF    	                ld      A,%11001111     ; set mode 3 (mode control)
02E3: D303    	                out     (PIO_CB),A      ; for PIO port B
02E5: AF      	                xor     A               ; set pins to OUTPUT
02E6: D303    	                out     (PIO_CB),A      ; for port B
02E8: 3C      	                inc     A               ; LSB on
02E9: D301    	LEDLIGHT:       out     (PIO_DB),A      ; turn LEDs on/off for a "Supercar" sequence
02EB: 1E20    	                ld      E,$20           ; little delay
02ED: 0600    	DEC_E:          ld      B,$00           ; count to 256
02EF: 10FE    	COUNTER:        djnz    COUNTER         ; decrement inner counter
02F1: 1D      	                dec     E               ; decrement outer counter
02F2: 20F9    	                jr      NZ,DEC_E        ; finish delay
02F4: CB27    	                sla     A               ; shift reg.A to left 1 bit
02F6: 0D      	                dec     C               ; next LED
02F7: 20F0    	                jr      NZ,LEDLIGHT     ; all LEDs done? no, repeat
02F9: C9      	                ret                     ; return to caller
              	
              	;-------------------------------------------------------------------------------
              	; Z80 SIO default settings for channel A
02FA: 30      	SIO_A_SETS:     defb    %00110000       ; write into WR0: error reset, select WR0
02FB: 18      	                defb    %00011000       ; write into WR0: channel reset
02FC: 04      	                defb    %00000100       ; write into WR0: select WR4
02FD: 44      	                defb    %01000100       ; write into WR4: presc. 16x, 1 stop bit, no parity
02FE: 05      	                defb    %00000101       ; write into WR0: select WR5
02FF: E8      	                defb    %11101000       ; write into WR5: DTR on, TX 8 bits, BREAK off, TX on, RTS off
0300: 01      	SIO_B_SETS:     defb    %00000001       ; write into WR0: select WR1
0301: 04      	                defb    %00000100       ; write into WR1: status affects interrupt vectors
0302: 02      	                defb    %00000010       ; write into WR0: select WR2
0303: 00      	                defb    %00000000       ; write into WR2: set interrupt vector, but bits D3/D2/D1 of this vector
              	                                        ; will be affected by the channel & condition that raised the interrupt
              	                                        ; (see datasheet): in our example, 0x0C for Ch.A receiving A char, 0x0E
              	                                        ; for special conditions
              	;------------------------------------------------------------------------------
              	; Z80 CTC setting up
0304:         	initCTC:
0304: 212E03  	                ld      HL,CTCCONF      ; CTC configuration
0307: 11D281  	                ld      DE,CTC0IV       ; CTC interrupt vector table
030A: 010C00  	                ld      BC,$000C        ; 12 bytes
030D: EDB0    	                ldir                    ; copy data
              	;CH0, CH1, & CH2 disabled
030F: 3E03    	                ld      A,%00000011     ; interrupt off, timer mode, prescaler=16, don't care ext. TRG edge,
              	                                        ; start timer on loading constant, no time constant follows, software reset, command word
0311: D310    	                out     (CTC_CH0),A     ; set CH0
0313: D311    	                out     (CTC_CH1),A     ; set CH1
0315: D312    	                out     (CTC_CH2),A     ; set CH2
              	
              	;init CH3
              	;CH3 divides CPU CLK by 144*256 providing an interrupt signal at 100 Hz (1/100 sec).
              	;f = CPU_CLK/(144*256) => 3,686,400 / ( 36,864 ) => 100Hz
0317: 3EA7    	                ld      A,%10100111     ; interrupt on; timer mode; prescaler=256; don't care ext; automatic trigger;
              	                                        ; time constant follows; cont. operation; command word
0319: D313    	                out     (CTC_CH3),A     ; send to CH3
031B: 3E90    	                ld      A,$90           ; time constant - 90$ (144d)
031D: D313    	                out     (CTC_CH3),A     ; send to CH3
031F: 3E40    	                ld      A,%01000000     ; D7..D3 provide the first part of the int vector (in our case, $0100), followed by
              	                                        ; D2..D1, provided by the CTC (they point to the channel), D0=interrupt word
              	                                        ; so int vector is 01000xx00
0321: D310    	                out     (CTC_CH0),A     ; send to CTC
              	                ; reset cells of 100ths of a second counter
0323: AF      	                xor     A               ; reset A
0324: 21CE81  	                ld      HL,TMRCNT       ; load TMR pointer
0327: 0604    	                ld      B,$04           ; 4 memory cells
0329: 77      	RESTMR:         ld      (HL),A          ; reset n-cell of TMR
032A: 23      	                inc     HL              ; next cell
032B: 10FC    	                djnz    RESTMR          ; repeat for 4 cells
032D: C9      	                ret
              	
032E: FBED4D  	CTCCONF:        defb    $FB,$ED,$4D     ; CTC0 interrupt vector (ei; reti)
0331: FBED4D  	                defb    $FB,$ED,$4D     ; CTC1 interrupt vector (ei; reti)
0334: FBED4D  	                defb    $FB,$ED,$4D     ; CTC2 interrupt vector (ei; reti)
0337: C33702  	                jp      CH3_TIMER       ; CTC3 interrupt vector (sys tick timer)
              	;------------------------------------------------------------------------------
033A: 4C4D3830	MSGTXT1:        defm    "LM80C by Leonardo Miliani",CR
033E: 43206279	
0342: 204C656F	
0346: 6E617264	
034A: 6F204D69	
034E: 6C69616E	
0352: 690D    	
0354: 4669726D	                defm    "Firmware R3.14",CR,0
0358: 77617265	
035C: 2052332E	
0360: 31340D00	
0364: 0D      	MSGTXT2:        defb    CR
0365: 3C433E6F	                defm    "<C>old or <W>arm start? ",0
0369: 6C64206F	
036D: 72203C57	
0371: 3E61726D	
0375: 20737461	
0379: 72743F20	
037D: 00      	
              	; ------------------------------------------------------------------------------
              	; LM80C - VDP ROUTINES - R3.14
              	; ------------------------------------------------------------------------------
              	; The following code is intended to be used with LM80C Z80-based computer
              	; designed by Leonardo Miliani. Code and computer schematics are released under
              	; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
              	; kind of warranty: you can use them at your own risk.
              	; You are free to use them for any non-commercial use: you are only asked to
              	; maintain the copyright notices, include this advice and the note to the 
              	; attribution of the original version to Leonardo Miliani, if you intend to
              	; redistribuite them.
              	; https://www.leonardomiliani.com
              	; 
              	; Please support me by visiting the following links:
              	; Main project page: https://www.leonardomiliani.com
              	; Schematics and code: https://github.com/leomil72/LM80C
              	; Videos about the computer: https://www.youtube.com/user/leomil72/videos
              	; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
              	; ------------------------------------------------------------------------------
              	;
              	;------------------------------------------------------------------------------
              	; VDP INITIALISATION
              	; initialize VDP for a specific graphics mode
              	; INPUT: E -> contains the graphics mode:
              	; 0=text; 1=graphics 1; 2=graphics 2; 3=multicolor; 4=extended graphics 2
037E: D5      	initVDP:        push    DE              ; store E
037F: CDFD09  	                call    EMPTY_VRAM      ; reset VRAM
0382: CD1C0A  	                call    SET_GFX_MODE    ; load register settings
0385: CD110A  	                call    CLR_RAM_REG     ; reset RAM registers
0388: D1      	                pop     DE              ; restore reg. E
0389: AF      	                xor     A               ; reset A
038A: 47      	                ld      B,A             ; reset B (will be used later)
038B: 7B      	                ld      A,E             ; move E into A
038C: 32E081  	                ld      (SCR_MODE),A    ; store screen mode
038F: FE01    	                cp      $01             ; is it graphics 1 (A=1)?
0391: CACD03  	                jp      Z,G1MD          ; yes, jump over
0394: FE02    	                cp      $02             ; is it graphics 2 (A=2)?
0396: CA0E04  	                jp      Z,G2MD          ; yes, jump over
0399: FE03    	                cp      $03             ; is it multicolor (A=3)?
039B: CA3004  	                jp      Z,MCMD          ; yes, jump over
039E: FE04    	                cp      $04             ; is it extended graphics 2 (A=4)?
03A0: CA5304  	                jp      Z,EXG2MD        ; yes, jump over; otherwise, it must be $00 so we assume that it's text mode
              	
              	                ; LOAD VDP SETTINGS FOR SELECTED VIDEO MODE:
              	                ; TEXT MODE (G0)
03A3:         	TXTMD:          ; load charset
03A3: 60      	                ld      H,B
03A4: 68      	                ld      L,B             ; HL=first pattern cell $0000
03A5: CD380A  	                call    LOADCHARSET     ; load patterns into VRAM
              	                ; set cursor & video overlay
03A8: AF      	                xor     A               ; reset A
03A9: 32E481  	                ld      (SCR_CURS_X),A  ; set cursor position at X=0
03AC: 32E581  	                ld      (SCR_CURS_Y),A  ; and Y=0
03AF: 3E05    	                ld      A,$05           ; light blue
03B1: 32EE81  	                ld      (BKGNDCLR),A    ; set background/border color
03B4: 3E28    	                ld      A,$28
03B6: 32DE81  	                ld      (SCR_SIZE_W),A  ; screen width = 40 cols
03B9: 3E18    	                ld      A,$18
03BB: 32DF81  	                ld      (SCR_SIZE_H),A  ; screen height = 24 rows
03BE: 3E1E    	                ld      A,$1E
03C0: 32A380  	                ld      (COMMAN),A      ; width for commas (4 columns)
03C3: 110008  	                ld      DE,$0800
03C6: ED53E281	                ld      (SCR_NAM_TB),DE ; set name table address
03CA: C39604  	                jp      ENDVDPSET       ; execute the rest of the video setting
              	
              	                ; GRAPHICS 1 MODE (G1)
03CD:         	G1MD:           ; load pattern table
03CD: 68      	                ld      L,B
03CE: 60      	                ld      H,B             ; HL=first pattern cell $0000
03CF: CD380A  	                call    LOADCHARSET     ; load patterns into VRAM
              	                ; set cursor & video overlay
03D2: AF      	                xor     A               ; position cursor
03D3: 32E481  	                ld      (SCR_CURS_X),A  ; at X=0
03D6: 32E581  	                ld      (SCR_CURS_Y),A  ; and Y=0
03D9: 3E20    	                ld      A,$20
03DB: 32DE81  	                ld      (SCR_SIZE_W),A  ; screen width = 32 cols
03DE: 3E18    	                ld      A,$18
03E0: 32DF81  	                ld      (SCR_SIZE_H),A  ; screen height = 24 rows
03E3: 3E14    	                ld      A,$14
03E5: 32A380  	                ld      (COMMAN),A      ; width for commas (3 columns)
03E8: 110018  	                ld      DE,$1800
03EB: ED53E281	                ld      (SCR_NAM_TB),DE ; set name table address
              	                ; load color table
03EF: 210020  	                ld      HL,$2000        ; color table start: $2000
03F2: CDF905  	                call    SETVDPADRS
03F5: 3E01    	                ld      A,$01           ; foreground color...
03F7: 32ED81  	                ld      (FRGNDCLR),A    ; ...set to black
03FA: 3E0F    	                ld      A,$0F           ; background color...
03FC: 32EE81  	                ld      (BKGNDCLR),A    ; ...set to white
03FF: 3E1F    	                ld      A,$1F           ; reg.A loaded with colors for chars: bloack pixels on white background
0401: 0620    	                ld      B,$20           ; 32 bytes of colors
0403: 0E30    	                ld      C,VDP_DAT       ; VDP data mode
0405: ED79    	LDCLRTBMD1:     out     (C),A           ; after first byte, the VDP autoincrements VRAM pointer
0407: 00      	                nop
0408: 00      	                nop
0409: 10FA    	                djnz    LDCLRTBMD1      ; repeat for 32 bytes
040B: C39604  	                jp      ENDVDPSET       ; execute the rest of the video setting
              	
              	                ; GRAPHICS 2 MODE (G2)
040E: AF      	G2MD:           xor     A               ; position cursor
040F: 32E481  	                ld      (SCR_CURS_X),A  ; at X=0
0412: 32E581  	                ld      (SCR_CURS_Y),A  ; and Y=0
0415: 32DE81  	                ld      (SCR_SIZE_W),A  ; screen width = 256 pixels (0=256)
0418: 3C      	                inc     A               ; black on...
0419: 32ED81  	                ld      (FRGNDCLR),A    ; ...foreground
041C: 3E0F    	                ld      A,$0F           ; white on...
041E: 32EE81  	                ld      (BKGNDCLR),A    ; ...background
0421: 3EC0    	                ld      A,$C0
0423: 32DF81  	                ld      (SCR_SIZE_H),A  ; screen height = 192 pixels
0426: 110018  	                ld      DE,$1800
0429: ED53E281	                ld      (SCR_NAM_TB),DE ; set name table address
042D: C39604  	                jp      ENDVDPSET       ; execute the rest of the video setting
              	
              	                ; MULTICOLOR MODE (G3)
0430: AF      	MCMD:           xor     A               ; position cursor
0431: 32E481  	                ld      (SCR_CURS_X),A  ; at X=0
0434: 32E581  	                ld      (SCR_CURS_Y),A  ; and Y=0
0437: 3E0F    	                ld      A,$0F           ; white color for...
0439: 32EE81  	                ld      (BKGNDCLR),A    ; ...background and...
043C: 32ED81  	                ld      (FRGNDCLR),A    ; ...foreground (even this is not used in MC)
043F: 3E40    	                ld      A,$40
0441: 32DE81  	                ld      (SCR_SIZE_W),A  ; screen width = 64 blocks
0444: 3E30    	                ld      A,$30
0446: 32DF81  	                ld      (SCR_SIZE_H),A  ; screen height = 48 blocks
0449: 110008  	                ld      DE,$0800
044C: ED53E281	                ld      (SCR_NAM_TB),DE ; set name table address
0450: C39604  	                jp      ENDVDPSET       ; execute the rest of the video setting
              	
              	                ; EXTENDED GRAPHICS 2 (G4)
0453:         	EXG2MD:         ; load pattern table
0453: 60      	                ld      H,B
0454: 68      	                ld      L,B             ; HL=first pattern cell $0000
0455: CD380A  	                call    LOADCHARSET     ; load patterns into VRAM
              	                ; set cursor & video overlay
0458: AF      	                xor     A               ; position cursor
0459: 32E481  	                ld      (SCR_CURS_X),A  ; at X=0
045C: 32E581  	                ld      (SCR_CURS_Y),A  ; and Y=0
045F: 3E20    	                ld      A,$20
0461: 32DE81  	                ld      (SCR_SIZE_W),A  ; screen width = 32 cols
0464: 3E18    	                ld      A,$18
0466: 32DF81  	                ld      (SCR_SIZE_H),A  ; screen height = 24 rows
0469: 3E14    	                ld      A,$14
046B: 32A380  	                ld      (COMMAN),A      ; width for commas (3 columns)
046E: 110038  	                ld      DE,$3800
0471: ED53E281	                ld      (SCR_NAM_TB),DE ; set name table address
              	                 ; load color table
0475: 210020  	                ld      HL,$2000        ; color table start: $2000
0478: CDF905  	                call    SETVDPADRS
047B: 3E01    	                ld      A,$01           ; foreground color is...
047D: 32ED81  	                ld      (FRGNDCLR),A    ; ...set to black
0480: 3E0F    	                ld      A,$0F           ; whitefor...
0482: 32EE81  	                ld      (BKGNDCLR),A    ; ...background
0485: 3E1F    	                ld      A,$1F           ; reg.A loaded with colors for chars: bloack pixels on white background
0487: 1608    	                ld      D,$08           ; 8 pages of 
0489: 0600    	                ld      B,$00           ; 256 bytes of colors (total of 2,048 cells)
048B: 0E30    	                ld      C,VDP_DAT       ; VDP data mode
048D: ED79    	LDCLRTBEX2:     out     (C),A           ; after first byte, the VDP autoincrements VRAM pointer
048F: 00      	                nop
0490: 00      	                nop
0491: 10FA    	                djnz    LDCLRTBEX2      ; repeat for 256 bytes
0493: 15      	                dec     D               ; did we fill up all the cells?
0494: 20F7    	                jr      NZ,LDCLRTBEX2   ; no, repeat
              	                ; LAST VDP SETTINGS
0496: CD7008  	ENDVDPSET:      call    CURSOR_OFF      ; disable cursor
0499: CD6705  	                call    EMPTYVIDBUF     ; empty video buffer
049C: AF      	                xor     A
049D: 32E881  	                ld      (SCR_ORG_CHR),A ; store byte used tochar used to empty the video buffer
04A0: C9      	                ret                     ; return to caller
              	
              	
              	; show initial logo
04A1: CDFD09  	SHOW_LOGO:      call    EMPTY_VRAM      ; reset VRAM
              	                ; set VDP for G2 mode
04A4: 0607    	                ld      B,$07           ; set only the first 7 registers
04A6: 111000  	                ld      DE,$0010        ; load settings for G2 mode
04A9: CD240A  	                call    SET_GFX_MODE2   ; load register settings
04AC: 1601    	                ld      D,$01           ; backdrop color set to black
04AE: ED51    	                out     (C),D           ; send data to VDP
04B0: ED79    	                out     (C),A           ; indicate the register to send data to
              	                ; set name table 
04B2: 210018  	                ld      HL,$1800        ; name table address
04B5: CDE605  	                call    SETNAMETABLE    ; set name table (load names into table)
04B8: CD1505  	                call    ERASECLRTBL     ; erase color table (set foreground & background to black)
              	                ; set colors for logo
04BB: 210028  	                ld      HL,$2800        ; 2nd page of color table
04BE: CDF905  	                call    SETVDPADRS
04C1: 0605    	                ld      B,5             ; 5 bands
04C3: 216205  	                ld      HL,CLRTABLE
04C6: 0E30    	                ld      C,VDP_DAT
04C8: 1E08    	                ld      E,$08           ; 8 pixels each pattern        
04CA: 1640    	RPT101:         ld      D,$40           ; 64 chars each band
04CC: 7E      	                ld      A,(HL)
04CD: ED79    	RPT102:         out     (C),A
04CF: 00      	                nop
04D0: 1D      	                dec     E
04D1: 20FA    	                jr      NZ,RPT102
04D3: 1E08    	                ld      E,$08
04D5: 15      	                dec     D
04D6: 20F5    	                jr      NZ,RPT102
04D8: 23      	                inc     HL
04D9: 10EF    	                djnz    RPT101
              	                ; set pattern table
04DB: 210008  	                ld      HL,$0800        ; address of first cell of 2nd area of pattern table
04DE: 11810A  	                ld      DE,LM80CLOGO    ; pointer to logo pattern
04E1: 0600    	                ld      B,$00           ; 256 bytes, 8 rows
04E3: CD4105  	RPT103:         call    LOADLOGOCHRS
04E6: 13      	                inc     DE              ; next logo pattern
04E7: 10FA    	                djnz    RPT103
04E9: 0620    	                ld      B,$20           ; repeat for another 2 rows
04EB: CD4105  	RPT104:         call    LOADLOGOCHRS
04EE: 13      	                inc     DE              ; next logo pattern
04EF: 10FA    	                djnz    RPT104
              	                ; show logo/message, play a beep and wait a while
04F1: 0602    	                ld      B,$02
04F3: AF      	                xor     A
04F4: 57      	                ld      D,A             ; 256 times
04F5: 5F      	                ld      E,A             ; x 256 times
04F6: 32EF81  	                ld      (TMPBFR1),A     ; sound flag set to 0
04F9: 00      	DEC_D:          nop                     ; does nothing...
04FA: 00      	                nop
04FB: 00      	                nop
04FC: 00      	                nop
04FD: 00      	                nop
04FE: 00      	                nop
04FF: 1D      	                dec     E               ; decrement E
0500: 20F7    	                jr      NZ,DEC_D        ; repeat until $00
0502: 7A      	                ld      A,D
0503: FE40    	                cp      $40             ; ...equal to 64
0505: CC2D05  	                call    Z,SETBEEP       ; if yes, start sound
0508: 15      	                dec     D
0509: 20EE    	                jr      NZ,DEC_D        ; repeat
050B: 3AEF81  	                ld      A,(TMPBFR1)
050E: FE02    	                cp      $02
0510: C43905  	                call    NZ,BEEPOFF
0513: 10E4    	                djnz    DEC_D
0515:         	ERASECLRTBL:    ; erase color table
0515: 3E11    	                ld      A,$11           ; foreground and background set to black
0517: 160A    	                ld      D,$0A           ; 10 pages
0519: 0600    	                ld      B,$00           ; 256 color cells per page
051B: 210028  	                ld      HL,$2800        ; first cell of 2nd color table
051E: CDF905  	                call    SETVDPADRS      ; send address
0521: 0E30    	                ld      C,VDP_DAT       ; VDP address for passing data
0523: ED79    	RPT100:         out     (C),A           ; send data
0525: 00      	                nop
0526: 00      	                nop                     ; little delay
0527: 10FA    	                djnz    RPT100          ; repeat for entire page
0529: 15      	                dec     D
052A: 20F7    	                jr      NZ,RPT100       ; repeat for all the pages ($0A00 cells)
052C: C9      	                ret                     ; return to caller
              	
              	; play a beep
052D: 3AEF81  	SETBEEP:        ld      A,(TMPBFR1)     ; check the already-beeped flag?
0530: B7      	                or      A               ; is it 0?
0531: C0      	                ret     NZ              ; no, exit
0532: 3C      	                inc     A               ; flag to 1
0533: 32EF81  	                ld      (TMPBFR1),A     ; set sound
0536: C3EF0B  	                jp      WLCMBEEP        ; play a beep & return
              	
              	; beep off
0539: 3E02    	BEEPOFF:        ld      A,$02           ; flag for sound off
053B: 32EF81  	                ld      (TMPBFR1),A     ; set flag
053E: C3F50B  	                jp      NOBEEP          ; stop beep and return
              	
              	
              	; used to load the chars that will compose the logo of the splash screen
0541: 1A      	LOADLOGOCHRS:   ld      A,(DE)          ; load a pattern char of the logo
0542: 87      	                add     A,A
0543: 87      	                add     A,A
0544: 87      	                add     A,A             ; multiply times 8 to get the offset
0545: C5      	                push    BC
0546: D5      	                push    DE              ; store BC and DE
0547: E5      	                push    HL              ; store VRAM address to write to
0548: 21134E  	                ld      HL,LOGOFONT     ; start of logo font data
054B: 5F      	                ld      E,A
054C: 1600    	                ld      D,$00           ; put offset (A) into DE
054E: 19      	                add     HL,DE           ; get address of pattern data
054F: EB      	                ex      DE,HL           ; move address into DE
0550: E1      	                pop     HL              ; retrieve VRAM address
0551: 0608    	                ld      B,$08           ; 8 bytes per pattern
0553: CDF905  	                call    SETVDPADRS      ; set VDP address
0556: 0E30    	                ld      C,VDP_DAT
0558: 1A      	SNDLOGPT:       ld      A,(DE)          ; load data from RAM
0559: ED79    	                out     (C),A           ; and send to VRAM
055B: 13      	                inc     DE              ; next byte into RAM
055C: 23      	                inc     HL              ; next byte into VRAM (used in future iterations)
055D: 10F9    	                djnz    SNDLOGPT        ; repeat 8 times
055F: D1      	                pop     DE
0560: C1      	                pop     BC              ; retrieve BC & DE
0561: C9      	                ret                     ; return to caller
              	
0562:         	CLRTABLE:       equ $
0562: 181B1314	                defb    $18,$1B,$13,$14,$1D ; colors of background bands of the logo
0566: 1D      	
              	                
              	; empty video buffer
0567: 3AE081  	EMPTYVIDBUF:    ld      A,(SCR_MODE)    ; check screen mode
056A: FE02    	                cp      $02             ; is it G2 mode?
056C: CA9005  	                jp      Z,EMPTYG2       ; yes, jump over
056F: FE03    	                cp      $03             ; is it MC mode?
0571: CAC105  	                jp      Z,EMPTYMC       ; yes, jump over
0574: 3ADF81  	                ld      A,(SCR_SIZE_H)  ; load height of screen
0577: 47      	                ld      B,A             ; move rows into B
0578: AF      	                xor     A               ; filling char is $00
0579: 2AE281  	                ld      HL,(SCR_NAM_TB) ; load the name table address
057C: CDF905  	                call    SETVDPADRS      ; send address to VDP
057F: 0E30    	                ld      C,VDP_DAT       ; VDP address for passing data
0581: 5F      	LDCOLSTOEMPTY:  ld      E,A             ; store filling char into E
0582: 3ADE81  	                ld      A,(SCR_SIZE_W)  ; load # of cols to empty into A
0585: 57      	                ld      D,A             ; move A into D
0586: 7B      	                ld      A,E             ; recover filling char
0587: ED79    	RPTEMPTYBUF:    out     (C),A           ; write empty byte into VRAM
0589: 00      	                nop
058A: 15      	                dec     D               ; decr. D
058B: 20FA    	                jr      NZ,RPTEMPTYBUF  ; repeat for the # of cols
058D: 10F2    	                djnz    LDCOLSTOEMPTY   ; repeat for the # of rows
058F: C9      	                ret                     ; return to caller
0590: 2AE281  	EMPTYG2:        ld      HL,(SCR_NAM_TB) ; yes, additional setup for G2 - load G2 name table address (usually $1800)
0593: CDE605  	                call    SETNAMETABLE    ; set name table
0596: 210000  	                ld      HL,$0000        ; set pattern table
0599: CDF905  	                call    SETVDPADRS      ; send address to VDP
059C: AF      	                xor     A               ; empty pattern
059D: 1618    	                ld      D,$18           ; 6144 ($1800) cell to clean, 24 pages ($18)
059F: 47      	                ld      B,A             ; 256 bytes for page
05A0: 0E30    	                ld      C,VDP_DAT       ; VDP data mode
05A2: ED79    	CLRG2PTNTBL:    out     (C),A           ; clear pattern
05A4: 00      	                nop                     ; little delay
05A5: 00      	                nop
05A6: 10FA    	                djnz    CLRG2PTNTBL     ; repeat for 1 page
05A8: 15      	                dec     D               ; next page
05A9: 20F7    	                jr      NZ,CLRG2PTNTBL  ; repeat
05AB: 210020  	                ld      HL,$2000        ; load the color table address
05AE: CDF905  	                call    SETVDPADRS      ; send address to VDP
05B1: 3AED81  	                ld      A,(FRGNDCLR)    ; load foreground
05B4: 87      	                add     A,A
05B5: 87      	                add     A,A
05B6: 87      	                add     A,A
05B7: 87      	                add     A,A             ; move to high nibble
05B8: 57      	                ld      D,A             ; store into D
05B9: 3AEE81  	                ld      A,(BKGNDCLR)    ; load background color
05BC: B2      	                or      D               ; combine with background color
05BD: 1618    	                ld      D,$18           ; 6144 ($1800) cells to fill, so 24 pages ($18)
05BF: 1817    	                jr      STARTEMPTY
05C1: 210008  	EMPTYMC:        ld      HL,$0800        ; MC name table
05C4: CDE605  	                call    SETNAMETABLE    ; set name table
05C7: 210000  	                ld      HL,$0000        ; color table address
05CA: CDF905  	                call    SETVDPADRS      ; send address to VDP
05CD: 3AEE81  	                ld      A,(BKGNDCLR)    ; load background
05D0: 57      	                ld      D,A             ; store into D
05D1: 87      	                add     A,A
05D2: 87      	                add     A,A
05D3: 87      	                add     A,A
05D4: 87      	                add     A,A             ; move to high nibble
05D5: B2      	                or      D               ; set background color for high and low nibble
05D6: 1608    	                ld      D,$08           ; 2048 ($0800) cells to fill, so 8 pages ($08)
05D8: 0E30    	STARTEMPTY:     ld      C,VDP_DAT       ; VDP address for passing data
05DA: 0600    	                ld      B,$00           ; 256 bytes each page ($00=256)
05DC: ED79    	SNDCLRSET:      out     (C),A           ; send color setting
05DE: 00      	                nop                     ; wait a while
05DF: 00      	                nop
05E0: 10FA    	                djnz    SNDCLRSET       ; repeat for 1 page
05E2: 15      	                dec     D               ; have we filled all the pages?
05E3: 20F7    	                jr      NZ,SNDCLRSET    ; no, repeat
05E5: C9      	                ret                     ; return to caller
              	
              	; set name table for G2 mode (patterns from $00 to $FF for each of the 3 areas of the screen)
05E6: CDF905  	SETNAMETABLE:   call    SETVDPADRS      ; send address to VDP
05E9: 0E30    	                ld      C,VDP_DAT       ; VDP address for passing data
05EB: 1603    	                ld      D,$03           ; 3 pages to fill into VRAM (768 cells)
05ED: AF      	                xor     A               ; starting char name #0 (chars go from 0 to 255)
05EE: 47      	                ld      B,A             ; reset B
05EF: ED79    	RPTFLL1:        out     (C),A           ; send name to VRAM
05F1: 00      	                nop
05F2: 3C      	                inc     A               ; increment # of name
05F3: 10FA    	                djnz    RPTFLL1         ; repeat for 256 cells (1 page)
05F5: 15      	                dec     D               ; did we fill all the pages?
05F6: 20F7    	                jr      NZ,RPTFLL1      ; no, continue
05F8: C9      	                ret                     ; return to caller
              	
              	; set an address into VRAM: address is in HL
05F9: 0E32    	SETVDPADRS:     ld      C,VDP_SET       ; VDP address mode
05FB: CBF4    	                set     6,H             ; set bit #6 of address, to write to VRAM
05FD: ED69    	                out     (C),L           ; send low and...
05FF: ED61    	                out     (C),H           ; ...high byte of the first cell
0601: C9      	                ret                     ; return to caller
              	
              	; clear the video buffer and position the cursor at 0,0
0602: CD6705  	CLEARVIDBUF:    call    EMPTYVIDBUF     ; clear video buffer
0605: AF      	                xor     A               ; reset A
0606: 32E481  	                ld      (SCR_CURS_X),A  ; cursor X to 0
0609: 32E581  	                ld      (SCR_CURS_Y),A  ; cursor Y to 0
060C: C35506  	                jp      POS_CURSOR      ; position cursor & return to caller
              	
              	; HOME: position the cursor at coords. 0,0 
060F: AF      	ATHOME:         xor     A               ; position cursor at 0,0 by storing...
0610: 32E781  	                ld      (SCR_CUR_NY),A  ; ...new Y...
0613: 32E681  	                ld      (SCR_CUR_NX),A  ; ...and new X
0616: C35F06  	                jp      MOVCRS          ; move cursor to new location & return to caller
              	
              	; load the char or byte at the VRAM position set by HL
              	; value is returned into A
0619: C5      	READ_VIDEO_LOC: push    BC              ; store BC
061A: 0E32    	                ld      C,VDP_SET       ; VDP setting mode
061C: 44      	                ld      B,H
061D: CBB8    	                res     7,B
061F: CBB0    	                res     6,B
0621: ED69    	                out     (C),L           ; low byte then...
0623: ED41    	                out     (C),B           ; high byte
0625: 0E30    	                ld      C,VDP_DAT       ; VDP data mode
0627: 00      	                nop                     ; wait...
0628: 00      	                nop                     ; ...a while
0629: 00      	                nop
062A: ED78    	                in      A,(C)           ; read byte at current VRAM location
062C: C1      	                pop     BC              ; restore BC
062D: C9      	                ret                     ; return to caller
              	
              	; write a byte at the VRAM position pointed by HL
              	; value is in A
062E: C5      	WRITE_VIDEO_LOC:push    BC              ; store BC
062F: 0E32    	                ld      C,VDP_SET       ; VDP setting mode
0631: 44      	                ld      B,H             ; copy H into B
0632: CBB8    	                res     7,B
0634: CBF0    	                set     6,B             ; write to VRAM
0636: ED69    	                out     (C),L           ; low byte then...
0638: ED41    	                out     (C),B           ; high byte of VRAM address
063A: 0E30    	                ld      C,VDP_DAT       ; VDP data mode
063C: 00      	                nop                     ; wait...
063D: 00      	                nop                     ; ...a while
063E: 00      	                nop
063F: ED79    	                out     (C),A           ; write byte into VRAM
0641: C1      	                pop     BC              ; restore BC
0642: C9      	                ret                     ; return to caller
              	
              	; write a value into a specific VDP register
              	; value is in E, register is in A
0643: C5      	WRITE_VREG:     push    BC              ; store BC
0644: C680    	                add     A,$80           ; set VDP to write to registers
0646: 0E32    	                ld      C,VDP_SET       ; VDP setting mode
0648: ED59    	                out     (C),E           ; send data to VDP
064A: ED79    	                out     (C),A           ; select the destination register
064C: C1      	                pop     BC              ; restore BC
064D: C9      	                ret                     ; return to caller
              	
              	; read VDP status register and return value into A
064E: C5      	READ_VSTAT:     push    BC              ; store BC
064F: 0E32    	                ld      C,VDP_SET       ; VDP register access
0651: ED78    	                in      A,(C)           ; read status register
0653: C1      	                pop     BC              ; restore BC
0654: C9      	                ret                     ; return to caller
              	
              	; position the cursor at the current coordinates, preserving underlying char
0655: CD9306  	POS_CURSOR:     call    LOAD_CRSR_POS   ; load the VRAM address of cursor into HL
0658: CD1906  	                call    READ_VIDEO_LOC  ; load the current char at the cursor position (return in A)
065B: 32E881  	                ld      (SCR_ORG_CHR),A ; store the current char
065E: C9      	                ret
              	
              	; move cursor to new X,Y coordinates
065F: CD8A06  	MOVCRS:         call    RSTCHRCRS       ; restore the char in the current cursor position
0662: CD7506  	                call    NEWCRSRCOORD    ; set new cursor's coordinates
0665: CD5506  	MOVSHOWCRS:     call    POS_CURSOR      ; position cursor into new location
0668: 3AEF81  	                ld      A,(TMPBFR1)     ; load status of cursor flashing
066B: E620    	                and     $20             ; check cursor state
066D: 32EA81  	                ld      (LSTCSRSTA),A   ; store the last cursor state
0670: 3EFF    	                ld      A,$FF           ; set cursor visible after moved it
0672: C32E06  	                jp      WRITE_VIDEO_LOC ; write into video cell
              	
              	
              	; set new cursor's coordinates:
0675: 3AE681  	NEWCRSRCOORD:   ld      A,(SCR_CUR_NX)  ; load new X
0678: 32E481  	                ld      (SCR_CURS_X),A  ; write new X
067B: 3AE781  	                ld      A,(SCR_CUR_NY)  ; load new Y
067E: 32E581  	                ld      (SCR_CURS_Y),A  ; write new Y
0681: 3EFF    	                ld      A,$FF           ; delete new values
0683: 32E681  	                ld      (SCR_CUR_NX),A  ; of X
0686: 32E781  	                ld      (SCR_CUR_NY),A  ; and Y
0689: C9      	                ret
              	
              	; recover char under the cursor and prints it onto the screen
068A: CD9306  	RSTCHRCRS:      call    LOAD_CRSR_POS   ; recover old cursor position
068D: 3AE881  	                ld      A,(SCR_ORG_CHR) ; recover old char
0690: C32E06  	                jp      WRITE_VIDEO_LOC ; write char into VRAM & return
              	
              	; retrieve cursor position from either current coordinates or next place
              	; return address position into HL
0693: 3AE581  	LOAD_CRSR_POS:  ld      A,(SCR_CURS_Y)  ; load cursor Y
0696: 6F      	                ld      L,A             ; move it into reg.L
0697: AF      	                xor     A               ; reset A
0698: 67      	                ld      H,A             ; reset H
0699: 47      	                ld      B,A             ; reset B
069A: 29      	                add     HL,HL           ; create offset (each address is 2-bytes long so we need to double HL)
069B: 11CD09  	                ld      DE,POS_TB_CRS_40; load position table address of cursor for 40 cols
069E: 3ADE81  	                ld      A,(SCR_SIZE_W)  ; load screen width
06A1: FE28    	                cp      $28             ; is it 40 cols?
06A3: 2803    	                jr      Z,CONT_POS_CURS ; yes, jump over
06A5: 119D09  	                ld      DE,POS_TB_CRS_32; no, load position table address of cursor for 32 cols
06A8: 19      	CONT_POS_CURS:  add     HL,DE           ; the correct starting address of the required row is now into HL
06A9: 5E23562B	                ld      DE,(HL)         ; load starting address of the required row into DE
06AD: 2AE281  	                ld      HL,(SCR_NAM_TB) ; load starting address of name table
06B0: 19      	                add     HL,DE           ; starting address of the current row into name table
06B1: 3AE481  	                ld      A,(SCR_CURS_X)  ; load cursor X
06B4: 4F      	                ld      C,A             ; transfer A into C
06B5: 09      	                add     HL,BC           ; add X offset: now HL contains the address of the current cursor position
06B6: C9      	                ret
              	
              	; find X,Y coordinates of a screen address pointed in VRAM by HL
              	; return them into L,A for X,Y
06B7: D5      	HL2XY:          push    DE              ; store DE
06B8: ED5BE281	                ld      DE,(SCR_NAM_TB) ; load starting address of name table into DE
06BC: AF      	                xor     A               ; clear Carry
06BD: ED52    	                sbc     HL,DE           ; find position relative to screen (from 0,0)
06BF: D1      	                pop     DE
06C0: 3ADE81  	                ld      A,(SCR_SIZE_W)  ; load screen width
06C3: 4F      	                ld      C,A             ; move it into C
06C4: CD043E  	                call    DIV_16_8        ; divide position by C: return Y into L and X into A
06C7: C9      	                ret                     ; return to caller
              	
              	;-------------------------------------------------------------------------------
              	; send current char to video buffer
06C8: F5      	CHAR2VID:       push    AF              ; store AF
06C9: C5      	                push    BC              ; store BC
06CA: D5      	                push    DE              ; store DE
06CB: E5      	                push    HL              ; store HL
06CC: 3AE981  	                ld      A,(CRSR_STATE)  ; store cursor state...
06CF: F5      	                push    AF              ; into stack
06D0: CD7008  	                call    CURSOR_OFF      ; cursor off
06D3: 3AEC81  	                ld      A,(CHR4VID)     ; recover char
06D6: FE19    	                cp      HOME            ; is it HOME char ($19)?
06D8: 2006    	                jr      NZ,CHKCS        ; no, check over
06DA: CD0F06  	                call    ATHOME          ; yes, move the cursor to 0,0
06DD: C35B07  	                jp      EXITCHAR2VID    ; exit
06E0: FE0C    	CHKCS:          cp      CS              ; is it the CLEAR char ($0C)?
06E2: 2005    	                jr      NZ,CHKCR        ; no, check over
06E4: CD0206  	                call    CLEARVIDBUF     ; yes, clear video buffer and position cursor at 0,0
06E7: 1872    	                jr      EXITCHAR2VID    ; exit
06E9: FE0D    	CHKCR:          cp      CR              ; is it a carriage return ($0D)?
06EB: 2005    	                jr      NZ,CHKBKSP      ; no, jump over
06ED: CDF208  	                call    CRGRETURN       ; yes, go to the beginning of the next line
06F0: 1869    	                jr      EXITCHAR2VID    ; exit
06F2: FE08    	CHKBKSP:        cp      BKSP            ; is it the backspace ($08)?
06F4: 2005    	                jr      NZ,CHKCRSLFT    ; no, jump over
06F6: CD8D07  	                call    BACKSPACE       ; move cursor left 1 position
06F9: 1860    	                jr      EXITCHAR2VID    ; exit
06FB: FE1C    	CHKCRSLFT:      cp      CRSLFT          ; is it cursor left?
06FD: 2005    	                jr      NZ,CHKCRSUP     ; no, jump over
06FF: CDA007  	                call    CURSORLEFT      ; move cursor left...
0702: 1857    	                jr      EXITCHAR2VID    ; ...and exit
0704: FE1E    	CHKCRSUP:       cp      CRSUP           ; is it cursor up?
0706: 2005    	                jr      NZ,CHKCRSRGT    ; no, jump over
0708: CDEC07  	                call    CURSORUP        ; move cursor up...
070B: 184E    	                jr      EXITCHAR2VID    ; ...and exit
070D: FE1D    	CHKCRSRGT:      cp      CRSRGT          ; is it cursor right?
070F: 2005    	                jr      NZ,CHKCRSDWN    ; no, jump over
0711: CD0508  	                call    CURSORRIGHT     ; move cursor right...
0714: 1845    	                jr      EXITCHAR2VID    ; ...and exit
0716: FE1F    	CHKCRSDWN:      cp      CRSDN           ; is it cursor down?
0718: 2005    	                jr      NZ,CHKLF        ; no, jump over
071A: CD3A08  	                call    CURSORDOWN      ; move cursor up...
071D: 183C    	                jr      EXITCHAR2VID    ; ...and exit
071F: FE0A    	CHKLF:          cp      LF              ; is it a line feed ($0A)?
0721: 2838    	                jr      Z,EXITCHAR2VID  ; CURRENTLY WE DON'T PRINT LF, WE JUST USE CR TO SUBSTITUTE CR+LF COMBINATION
0723: CD9306  	                call    LOAD_CRSR_POS   ; recover position of cursor
0726: 3AEC81  	                ld      A,(CHR4VID)     ; recover char to print
0729: CD2E06  	                call    WRITE_VIDEO_LOC ; write A into VRAM at (HL)
072C: 3AE581  	                ld      A,(SCR_CURS_Y)  ; load cursor Y into A
072F: 5F      	                ld      E,A             ; store cursor Y into E
0730: 3AE481  	                ld      A,(SCR_CURS_X)  ; load cursor X
0733: 3C      	                inc     A               ; move 1 step to right
0734: 21DE81  	                ld      HL,SCR_SIZE_W   ; cell that keeps the width of screen
0737: BE      	                cp      (HL)            ; have we reached the most right position?
0738: 200F    	                jr      NZ,SETCSRCOORDS ; no, go over
073A: 1C      	                inc     E               ; yes, increment cursor Y (go to next line)
073B: 7B      	                ld      A,E             ; move cursor Y into A
073C: 21DF81  	                ld      HL,SCR_SIZE_H   ; cell that keeps the height of screen
073F: BE      	                cp      (HL)            ; have we reached the bottom of the screen?
0740: 2006    	                jr      NZ,SETCRSRY     ; no, jump over
0742: D5      	                push    DE
0743: CD7708  	                call    SCROLLUP        ; scroll screen up
0746: D1      	                pop     DE
0747: 1D      	                dec     E               ; decrement 1 row, to set cursor Y on the last line
0748: AF      	SETCRSRY:       xor     A               ; then set cursor X to 0 (go to beginning of line)
0749: 32E481  	SETCSRCOORDS:   ld      (SCR_CURS_X),A  ; store current cursor X
074C: 7B      	                ld      A,E             ; recover Y
074D: 32E581  	                ld      (SCR_CURS_Y),A  ; store current cursor Y
0750: CD5506  	                call    POS_CURSOR      ; position cursor into new location
0753: 3AEF81  	                ld      A,(TMPBFR1)     ; load status of cursor flashing
0756: E620    	                and     $20             ; check cursor state
0758: 32EA81  	                ld      (LSTCSRSTA),A   ; store the last cursor state
075B: AF      	EXITCHAR2VID:   xor     A               ; reset char
075C: 32EC81  	                ld      (CHR4VID),A     ; to be sent to screen
075F: F1      	                pop     AF              ; recover cursor state
0760: A7      	                and     A               ; was it off (A=0)?
0761: C45A08  	                call    NZ,CURSOR_ON    ; no, set cursor on
0764: E1      	                pop     HL              ; restore HL
0765: D1      	                pop     DE              ; restore DE
0766: C1      	                pop     BC              ; restore BC
0767: F1      	                pop     AF              ; restore AF
0768: C9      	                ret                     ; return to caller
              	
              	; flash the cursor at the current position
              	; (this sub-routine is called by CH3 timer ISR)
0769: 3AE981  	FLASHCURSOR:    ld      A,(CRSR_STATE)  ; now, check the cursor
076C: A7      	                and     A               ; cursor off (A=0)?
076D: C8      	                ret     Z               ; yes, return
076E: 3ACE81  	                ld      A,(TMRCNT)      ; no, load the first byte of the 100ths of A second's counter
0771: E620    	                and     $20             ; check if it's time to flash the cursor (check bit #6)
0773: 21EA81  	                ld      HL,LSTCSRSTA    ; load address of cell that stores the last cursor state
0776: 46      	                ld      B,(HL)          ; load last state
0777: B8      	                cp      B               ; compare current state with last state
0778: C8      	                ret     Z               ; same state, no change required - exit
0779: 77      	                ld      (HL),A          ; save new state
077A: F5      	                push    AF              ; store A (keep state for later use)
077B: CD9306  	                call    LOAD_CRSR_POS   ; load current cursor position into HL
077E: F1      	                pop     AF              ; recover current state
077F: 06FF    	                ld      B,$FF           ; cursor char
0781: FE20    	                cp      $20             ; is the cursor on video (A == $20)?
0783: 2804    	                jr      Z,PUTCRSCHR     ; yes, jump over
0785: 3AE881  	                ld      A,(SCR_ORG_CHR) ; no, load the original char
0788: 47      	                ld      B,A             ; move char into B
0789: 78      	PUTCRSCHR:      ld      A,B             ; recover char from B
078A: C32E06  	                jp      WRITE_VIDEO_LOC ; print cursor/char at the current position & return
              	
              	
              	; delete the char at the left of the cursor
078D: CDC907  	BACKSPACE:      call    MVCRS2LFT       ; prepare to move cursor to left
0790: CD8A06  	                call    RSTCHRCRS       ; restore char under the cursor
0793: CD7506  	                call    NEWCRSRCOORD    ; set new cursor's coordinates
0796: CD9306  	                call    LOAD_CRSR_POS   ; find address of new video cell
0799: AF      	                xor     A               ; null char
079A: CD2E06  	                call    WRITE_VIDEO_LOC ; write into video cell
079D: C36506  	                jp      MOVSHOWCRS      ; move cursor to the new location and set it ON
              	
              	
              	; move cursor to left
07A0: F5      	CURSORLEFT:     push    AF              ; store A
07A1: 3AE481  	                ld      A,(SCR_CURS_X)  ; load cursor X into A
07A4: A7      	                and     A               ; is it at the most left of the screen (X=0)?
07A5: 280C    	                jr      Z,CHCKYPOS      ; yes, check Y position
07A7: 3D      	                dec     A               ; no, decrement X
07A8: 32E681  	                ld      (SCR_CUR_NX),A  ; store new X
07AB: 3AE581  	                ld      A,(SCR_CURS_Y)  ; load current cursor Y
07AE: 32E781  	                ld      (SCR_CUR_NY),A  ; no move over Y axis
07B1: 1811    	                jr      CONTCRSLFT      ; go on moving cursor
07B3: 3AE581  	CHCKYPOS:       ld      A,(SCR_CURS_Y)  ; load cursor Y
07B6: A7      	                and     A               ; is it at the most top of the screen (Y=0)?
07B7: 280E    	                jr      Z,EXITCURSORLEFT; yes, exit doing nothing
07B9: 3D      	                dec     A               ; no, decrement Y
07BA: 32E781  	                ld      (SCR_CUR_NY),A  ; store new Y
07BD: 3ADE81  	                ld      A,(SCR_SIZE_W)  ; load current screen width
07C0: 3D      	                dec     A               ; cursor to the most right position (width-0)
07C1: 32E681  	                ld      (SCR_CUR_NX),A  ; set new cursor X
07C4: CD5F06  	CONTCRSLFT:     call    MOVCRS          ; move cursor into new position
07C7: F1      	EXITCURSORLEFT: pop     AF              ; restore A
07C8: C9      	                ret                     ; return to caller
              	
              	; move cursor 1 position to the left
07C9: 3AE481  	MVCRS2LFT:      ld      A,(SCR_CURS_X)  ; load cursor X into A
07CC: A7      	                and     A               ; is it at the most left of the screen (X=0)?
07CD: 280B    	                jr      Z,CHKYPOS       ; yes, check Y position
07CF: 3D      	                dec     A               ; no, decrement X
07D0: 32E681  	                ld      (SCR_CUR_NX),A  ; store new X
07D3: 3AE581  	                ld      A,(SCR_CURS_Y)  ; load current cursor Y
07D6: 32E781  	                ld      (SCR_CUR_NY),A  ; no move over Y axis
07D9: C9      	                ret                     ; go on moving cursor
07DA: 3AE581  	CHKYPOS:        ld      A,(SCR_CURS_Y)  ; load cursor Y
07DD: A7      	                and     A               ; is it at the most top of the screen (Y=0)?
07DE: 28E7    	                jr      Z,EXITCURSORLEFT; yes, exit doing nothing
07E0: 3D      	                dec     A               ; no, decrement Y
07E1: 32E781  	                ld      (SCR_CUR_NY),A  ; store new Y
07E4: 3ADE81  	                ld      A,(SCR_SIZE_W)  ; load current screen width
07E7: 3D      	                dec     A               ; cursor to the most right position (width-1)
07E8: 32E681  	                ld      (SCR_CUR_NX),A  ; set new cursor X
07EB: C9      	                ret                     ; return to caller
              	
              	; move cursor up
07EC: F5      	CURSORUP:       push    AF              ; store A
07ED: 3AE581  	                ld      A,(SCR_CURS_Y)  ; load cursor Y into A
07F0: A7      	                and     A               ; is it at the most top of the screen (Y=0)?
07F1: 2810    	                jr      Z,EXITCURSORUP  ; yes, exit doing nothing
07F3: 3D      	                dec     A               ; no, decrement Y
07F4: 32E781  	                ld      (SCR_CUR_NY),A  ; store new Y
07F7: 3AE481  	                ld      A,(SCR_CURS_X)  ; load current cursor X
07FA: 32E681  	                ld      (SCR_CUR_NX),A  ; set new cursor X
07FD: CD8A06  	                call    RSTCHRCRS       ; restore char under the cursor and print it
0800: CD5F06  	                call    MOVCRS          ; move cursor into new position
0803: F1      	EXITCURSORUP:   pop     AF              ; restore A
0804: C9      	                ret                     ; return to caller
              	
              	
              	; move cursor to right
0805: F5      	CURSORRIGHT:    push    AF              ; store A
0806: C5      	                push    BC              ; store B
0807: 3ADE81  	                ld      A,(SCR_SIZE_W)  ; load current screen width (in text modes it's 32 or 40)
080A: 3D      	                dec     A               ; decrement it (most right can only be 31 or 39)
080B: 47      	                ld      B,A             ; move A into B
080C: 3AE481  	                ld      A,(SCR_CURS_X)  ; load cursor X into A    
080F: B8      	                cp      B               ; is cursor at the most right position on the screen?
0810: 300C    	                jr      NC,CHCKYPOS2    ; yes, so jump to check Y position
0812: 3C      	                inc     A               ; no, so increment X
0813: 32E681  	                ld      (SCR_CUR_NX),A  ; store new X
0816: 3AE581  	                ld      A,(SCR_CURS_Y)  ; load current cursor Y
0819: 32E781  	                ld      (SCR_CUR_NY),A  ; no move over Y axis
081C: 1813    	                jr      CONTCRSRGT      ; go on moving cursor
081E: 3ADF81  	CHCKYPOS2:      ld      A,(SCR_SIZE_H)  ; load screen height
0821: 3D      	                dec     A               ; decrement it (last row can only be 23)
0822: 47      	                ld      B,A             ; move bottom into B
0823: 3AE581  	                ld      A,(SCR_CURS_Y)  ; load cursor Y into A
0826: B8      	                cp      B               ; is the cursor at the bottom of the screen?
0827: 300E    	                jr      NC,EXITCURSORRGHT; yes, exit doing nothing
0829: 3C      	                inc     A               ; no, increment Y
082A: 32E781  	                ld      (SCR_CUR_NY),A  ; store new Y
082D: AF      	                xor     A               ; move cursor to top left
082E: 32E681  	                ld      (SCR_CUR_NX),A  ; store new X
0831: CD8A06  	CONTCRSRGT:     call    RSTCHRCRS       ; restore char under the cursor and print it
0834: CD5F06  	                call    MOVCRS          ; move cursor into new position
0837: C1      	EXITCURSORRGHT: pop     BC              ; retrieve BC
0838: F1      	                pop     AF              ; restore A
0839: C9      	                ret                     ; return to caller
              	
              	
              	; move cursor down
083A: F5      	CURSORDOWN:     push    AF              ; store A
083B: C5      	                push    BC              ; store B
083C: 3ADF81  	                ld      A,(SCR_SIZE_H)  ; load current screen height (in text modes it's 24)
083F: 3D      	                dec     A               ; decrement it (positions can only vary between 0 and 23)
0840: 47      	                ld      B,A             ; move X into B
0841: 3AE581  	                ld      A,(SCR_CURS_Y)  ; load cursor Y into A             
0844: B8      	                cp      B               ; is current cursor position < 23?
0845: 3010    	                jr      NC,EXITCURSORDOWN; no, exit doing nothing
0847: 3C      	                inc     A               ; yes, increment Y
0848: 32E781  	                ld      (SCR_CUR_NY),A  ; store new Y
084B: 3AE481  	                ld      A,(SCR_CURS_X)  ; load current cursor X
084E: 32E681  	                ld      (SCR_CUR_NX),A  ; set new cursor X
0851: CD8A06  	                call    RSTCHRCRS       ; restore char under the cursor and print it
0854: CD5F06  	                call    MOVCRS          ; move cursor into new position
0857: C1      	EXITCURSORDOWN: pop     BC              ; retrieve BC
0858: F1      	                pop     AF              ; retrieve A
0859: C9      	                ret                     ; return to caller
              	
              	
              	; set cursor on (visible on screen)
085A: F5      	CURSOR_ON:      push    AF              ; store AF
085B: 3AE981  	                ld      A,(CRSR_STATE)  ; load cursor state
085E: FE01    	                cp      $01             ; is it on?
0860: 280C    	                jr      Z,EXITCURSOR_ON ; yes, so nothing to do
0862: 3ADF81  	                ld      A,(SCR_SIZE_H)  ; check the video mode
0865: FE30    	                cp      $30             ; graphics 2 or 3 (if value>=48)?
0867: 3005    	                jr      NC,EXITCURSOR_ON; yes, so exit (no cursor in graphics 2 or 3)
0869: 3E01    	                ld      A,$01           ; cursor state ON
086B: 32E981  	                ld      (CRSR_STATE),A  ; set state
086E: F1      	EXITCURSOR_ON:  pop     AF              ; restore AF
086F: C9      	                ret                     ; return to caller
              	
              	; set cursor off (invisible on screen)
0870: F5      	CURSOR_OFF:     push    AF              ; store AF
0871: AF      	                xor     A               ; cursor state OFF
0872: 32E981  	                ld      (CRSR_STATE),A  ; set state
0875: F1      	                pop     AF              ; restore AF
0876: C9      	                ret
              	
              	; scroll the screen 1 row up
0877: AF      	SCROLLUP:       xor     A
0878: 32EB81  	                ld      (PRNTVIDEO),A
087B: 2AE281  	                ld      HL,(SCR_NAM_TB) ; start address of the name table
087E: 221F82  	                ld      (VIDTMP1),HL    ; store address of the destination row (1st row of the screen)
0881: 3ADE81  	                ld      A,(SCR_SIZE_W)  ; load the screen width
0884: 5F      	                ld      E,A             ; move width into E
0885: 1600    	                ld      D,$00           ; reset D
0887: 19      	                add     HL,DE           ; HL now contains the address of the source row (2nd row of the screen)
0888: 222182  	                ld      (VIDTMP2),HL    ; store address of source row
088B: 3ADF81  	                ld      A,(SCR_SIZE_H)  ; load the screen height
088E: 3D      	                dec     A               ; decrement the # of rows: now, A contains the # of rows to be moved
088F: 47      	                ld      B,A             ; move # of rows into B
0890: 3ADE81  	SCROLLNXTRW:    ld      A,(SCR_SIZE_W)  ; (re)load the screen width
0893: 5F      	                ld      E,A             ; move width into E
0894: 2A2182  	                ld      HL,(VIDTMP2)    ; load source address
0897: 0E32    	                ld      C,VDP_SET       ; VDP setting mode
0899: ED69    	                out     (C),L           ; low byte of source
089B: ED61    	                out     (C),H           ; high byte of source
089D: 21F781  	                ld      HL,VIDEOBUFF    ; load address of the first cell of the video buffer
08A0: 0E30    	                ld      C,VDP_DAT       ; VDP data mode
08A2: ED78    	LOADNEXTCOL:    in      A,(C)           ; load char
08A4: 77      	                ld      (HL),A          ; store char
08A5: 23      	                inc     HL              ; next cell of the buffer
08A6: 1D      	                dec     E               ; count the chars to be read
08A7: 20F9    	                jr      NZ,LOADNEXTCOL  ; repeat until we read the entire row
08A9: 3ADE81  	                ld      A,(SCR_SIZE_W)  ; reload the screen width
08AC: 5F      	                ld      E,A             ; move # of rows into E
08AD: 1600    	                ld      D,$00           ; reset D
08AF: 2A1F82  	                ld      HL,(VIDTMP1)    ; load address of destination row
08B2: E5      	                push    HL              ; store HL
08B3: 2A2182  	                ld      HL,(VIDTMP2)    ; current source will be..
08B6: 221F82  	                ld      (VIDTMP1),HL    ; ..new destination
08B9: 19      	                add     HL,DE           ; address of new
08BA: 222182  	                ld      (VIDTMP2),HL    ; source row
08BD: E1      	                pop     HL              ; restore address of current destination row
08BE: CBF4    	                set     6,H             ; writing mode
08C0: 0E32    	                ld      C,VDP_SET       ; VDP setting mode
08C2: ED69    	                out     (C),L           ; low byte
08C4: ED61    	                out     (C),H           ; high byte of address
08C6: 21F781  	                ld      HL,VIDEOBUFF    ; video buffer address
08C9: 0E30    	                ld      C,VDP_DAT       ; VDP data mode
08CB: 7E      	WRITEBUF:       ld      A,(HL)          ; load char
08CC: ED79    	                out     (C),A           ; send char
08CE: 23      	                inc     HL              ; increment buffer index
08CF: 1D      	                dec     E               ; next row
08D0: 20F9    	                jr      NZ,WRITEBUF     ; repeat until 0
08D2: 10BC    	                djnz    SCROLLNXTRW     ; repeat for the entire screen
08D4: 3ADE81  	                ld      A,(SCR_SIZE_W)  ; reload screen width
08D7: 47      	                ld      B,A             ; cells to empty into B
08D8: AF      	                xor     A               ; null char
08D9: 0E32    	                ld      C,VDP_SET       ; VDP set mode
08DB: 2A1F82  	                ld      HL,(VIDTMP1)    ; load address of the last row
08DE: CBF4    	                set     6,H             ; writing mode
08E0: ED69    	                out     (C),L           ; low byte then..
08E2: ED61    	                out     (C),H           ; high byte of address
08E4: 0E30    	                ld      C,VDP_DAT       ; VDP data mode
08E6: ED79    	RPTEMPTYROW:    out     (C),A           ; empty cell
08E8: 00      	                nop                     ; delay
08E9: 00      	                nop
08EA: 10FA    	                djnz    RPTEMPTYROW     ; repeat until the last row has been cleaned
08EC: 3E01    	                ld      A,$01
08EE: 32EB81  	                ld      (PRNTVIDEO),A   ; set print-on-video on
08F1: C9      	                ret                     ; return to caller
              	
              	; carriage return: first, it looks for char $00 at the beginning of the line (look for the first null char),
              	; then it starts sendind every char it finds on the screen to the terminal buffer of the BASIC interpreter
              	; until another null char is found. Finally, move to the next line and position the cursor at the beginning
              	; of the row (equivalent to CR+LF), then gets back control to the screen editor to let it interpret the line
81EF:         	CUR_POS         equ     TMPBFR1         ; cursor position
81F1:         	SRTTXT          equ     TMPBFR2         ; start of text line
81F3:         	ENDTXT          equ     TMPBFR3         ; end of text line
08F2:         	CRGRETURN:      ; preliminary: disable cursor if on, and retrieve char under it
08F2: 3AE981  	                ld      A,(CRSR_STATE)  ; recover cursor state
08F5: 32F581  	                ld      (TMPBFR4),A     ; store status
08F8: A7      	                and     A               ; is cursor on?
08F9: C47008  	                call    NZ,CURSOR_OFF   ; yes, so set cursor off
08FC: CD8A06  	                call    RSTCHRCRS       ; restore char under it
              	                ; first, check if cursor if off, so that we just interpret return as a new line command
08FF: 3A2982  	                ld      A,(KBDNPT)      ; check if input from keyboad
0902: A7      	                and     A               ; if 0, input is not from keyboard...
0903: CA7C09  	                jp      Z,PRNTRETURN    ; ...so just print a carriage return; otherwise, interpret the return
              	                ; first part: look for the beginning of the text line on screen
0906: CD9306  	                call    LOAD_CRSR_POS   ; load cursor position into HL
0909: 22EF81  	                ld      (CUR_POS),HL    ; store it
090C: ED5BE281	                ld      DE,(SCR_NAM_TB) ; load VRAM address of top-left cell of screen ("home")
0910: E5      	RPTNLLSRC:      push    HL
0911: CDC53D  	                call    CMP16           ; check if at "home"
0914: E1      	                pop     HL
0915: CA2009  	                jp      Z,CNTNULL       ; yes, exit because there is nothing before
0918: 2B      	                dec     HL              ; go 1 step back
0919: CD1906  	                call    READ_VIDEO_LOC  ; read char of current position
091C: A7      	                and     A               ; is it $00 (null char)?
091D: 20F1    	                jr      NZ,RPTNLLSRC    ; no, continue searching
091F: 23      	                inc     HL              ; move 1 step forward to go back to the last cell with something in
              	                ; second part: look for the ending of the text on screen
0920: 22F181  	CNTNULL:        ld      (SRTTXT),HL     ; store beginning of text
0923: 3ADF81  	                ld      A,(SCR_SIZE_H)
0926: 5F      	                ld      E,A             ; load screen height into DE
0927: 3ADE81  	                ld      A,(SCR_SIZE_W)
092A: 6F      	                ld      L,A             ; load screen width into HL
092B: AF      	                xor     A
092C: 67      	                ld      H,A
092D: 57      	                ld      D,A
092E: CDD03D  	                call    MUL16           ; multiply HL times DE to get the screen size
0931: ED5BE281	                ld      DE,(SCR_NAM_TB) ; load screen name table start address into DE
0935: 19      	                add     HL,DE           ; get the address...
0936: 2B      	                dec     HL              ; ...of the "last" video cell
0937: EB      	                ex      DE,HL           ; store address into DE
0938: 2AEF81  	                ld      HL,(CUR_POS)    ; retrieve original cursor position
093B: E5      	RPTNLLSRC2:     push    HL
093C: CDC53D  	                call    CMP16           ; check if at last position on screen (bottom right corner)
093F: E1      	                pop     HL
0940: CA4A09  	                jp      Z,CNTNULL2      ; if yes, exit because these is nothing after
0943: 23      	                inc     HL              ; 1 more step forward
0944: CD1906  	                call    READ_VIDEO_LOC  ; read char of current position
0947: A7      	                and     A               ; is it $00 (null char)?
0948: 20F1    	                jr      NZ,RPTNLLSRC2   ; no, continue searching
094A: 22F381  	CNTNULL2:       ld      (ENDTXT),HL     ; store ending of text line
094D: ED5BF181	                ld      DE,(SRTTXT)     ; load beginning of text line
0951: A7      	                and     A               ; clear Carry
0952: ED52    	                sbc     HL,DE           ; how many chars?
0954: 2826    	                jr      Z,PRNTRETURN    ; no chars found (HL-DE=0), so just print return & leave
              	                ;---    central part: send the text on the screen to the interpreter
0956: 2AF181  	                ld      HL,(SRTTXT)     ; load beginning of text line
0959: ED5BF381	                ld      DE,(ENDTXT)     ; load ending of text line
095D: CD1906  	SNDCHRTOBFR:    call    READ_VIDEO_LOC  ; read char
0960: E5      	                push    HL
0961: CD3601  	                call    CHARINTOBFR     ; send char to buffer
0964: E1      	                pop     HL
0965: 23      	                inc     HL              ; go to next char
0966: E5      	                push    HL              ; store HL
0967: CDC53D  	                call    CMP16           ; check if DE=HL (finish chars)
096A: E1      	                pop     HL
096B: 20F0    	                jr      NZ,SNDCHRTOBFR  ; no, repeat
096D: 3E0D    	                ld      A,CR            ; yes, so now send carriage return
096F: CD3601  	                call    CHARINTOBFR     ; send to buffer
0972: 2AF381  	                ld      HL,(ENDTXT)     ; recover address of last char of input text
0975: CDB706  	                call    HL2XY           ; retrieve X,Y from address
0978: 7D      	                ld      A,L             ; move Y into A (we don't need X anymore)
0979: 32E581  	                ld      (SCR_CURS_Y),A  ; store new Y
              	                ;---    final part: go at the beginning of a new line on the screen
097C: AF      	PRNTRETURN:     xor     A               ; move to col 0
097D: 32E481  	                ld      (SCR_CURS_X),A  ; store new X
0980: 3AE581  	                ld      A,(SCR_CURS_Y)  ; load cursor Y into A
0983: 3C      	                inc     A               ; new row
0984: 21DF81  	                ld      HL,SCR_SIZE_H   ; load address of cell that keeps screen height
0987: BE      	                cp      (HL)            ; is the cursor over the bottom of the screen?
0988: 3806    	                jr      C,ADDNEWLINE    ; no, jump over
098A: 3D      	                dec     A               ; yes, so come back 1 row, then...
098B: F5      	                push    AF              ; (store A)
098C: CD7708  	                call    SCROLLUP        ; ...scroll the screen before to...
098F: F1      	                pop     AF              ; (retrieve A)
0990: 32E581  	ADDNEWLINE:     ld      (SCR_CURS_Y),A  ; ...store new Y
0993: 3AF581  	                ld      A,(TMPBFR4)     ; retrieve cursor state
0996: A7      	                and     A               ; was it off (A=0)?
0997: C45A08  	                call    NZ,CURSOR_ON    ; no, set cursor on
099A: C35506  	                jp      POS_CURSOR      ; position cursor to new location & return to caller
              	
              	; ------------------------------------------------------------------------------
              	                ; this table contains the values of the offsets to be added to
              	                ; the starting address of the name table to find the correct
              	                ; value of the first cell of the corresponding row
              	                ; (by doing so, it's faster than doing a multipication)
              	                ; table for graphics 1 text mode: 32 cols
099D: 00002000	POS_TB_CRS_32   defw    $0000,$0020,$0040,$0060,$0080,$00A0,$00C0,$00E0
09A1: 40006000	
09A5: 8000A000	
09A9: C000E000	
09AD: 00012001	                defw    $0100,$0120,$0140,$0160,$0180,$01A0,$01C0,$01E0
09B1: 40016001	
09B5: 8001A001	
09B9: C001E001	
09BD: 00022002	                defw    $0200,$0220,$0240,$0260,$0280,$02A0,$02C0,$02E0
09C1: 40026002	
09C5: 8002A002	
09C9: C002E002	
              	                ; table for pure text mode: 40 cols
09CD: 00002800	POS_TB_CRS_40   defw    $0000,$0028,$0050,$0078,$00A0,$00C8,$00F0,$0118
09D1: 50007800	
09D5: A000C800	
09D9: F0001801	
09DD: 40016801	                defw    $0140,$0168,$0190,$01B8,$01E0,$0208,$0230,$0258
09E1: 9001B801	
09E5: E0010802	
09E9: 30025802	
09ED: 8002A802	                defw    $0280,$02A8,$02D0,$02F8,$0320,$0348,$0370,$0398
09F1: D002F802	
09F5: 20034803	
09F9: 70039803	
              	
              	; ------------------------------------------------------------------------------
              	; reset VRAM
09FD: AF      	EMPTY_VRAM:     xor     A               ; reg.A cleared: we fill up VRAM with $00
09FE: 67      	                ld      H,A
09FF: 6F      	                ld      L,A             ; reset HL
0A00: CDF905  	                call    SETVDPADRS      ; set address of first VRAM cell to $0000
0A03: 0640    	                ld      B,$40           ; $40 pages of RAM...
0A05: 57      	                ld      D,A             ; ...each one with $100 cells (tot. $4000 bytes)
0A06: 0E30    	                ld      C,VDP_DAT       ; VDP data mode
0A08: ED79    	EMPTVRM:        out     (C),A           ; after first byte, the VDP autoincrements VRAM pointer
0A0A: 14      	                inc     D               ; next cell
0A0B: 00      	                nop
0A0C: 20FA    	                jr      NZ,EMPTVRM      ; repeat until page is fully cleared
0A0E: 10F8    	                djnz    EMPTVRM         ; repeat for $40 pages
0A10: C9      	                ret                     ; return to caller
              	
              	; clear video registers in SRAM
0A11: 21DE81  	CLR_RAM_REG:    ld      HL,SCR_SIZE_W   ; address of first register
0A14: AF      	                xor     A               ; $00 to clean the registers
0A15: 0645    	                ld      B,CHASNDDTN-SCR_SIZE_W; how many bytes (registers) to clean (dinamically calculated)
0A17: 77      	RSTVDPRAMREG:   ld      (HL),A          ; reset register
0A18: 23      	                inc     HL              ; next register
0A19: 10FC    	                djnz    RSTVDPRAMREG    ; repeat
0A1B: C9      	                ret                     ; return to caller
              	
              	; ------------------------------------------------------------------------------
              	; set a specific graphics mode, passed into reg. E
0A1C: 0608    	SET_GFX_MODE:   ld      B,$08           ; 8 registers means 8 bytes..
0A1E: CB23    	                sla     E               ; multiply E by 8..
0A20: CB23    	                sla     E               ; so that reg. E can point..
0A22: CB23    	                sla     E               ; to the correct settings
0A24: 1600    	SET_GFX_MODE2:  ld      D,$00           ; reset D
0A26: 21590A  	                ld      HL,VDPMODESET   ; pointer to register settings | <= here points the SHOW_LOGO sub-routine
0A29: 19      	                add     HL,DE           ; add offset to get the correct set of values for the required mode
0A2A: 3E80    	                ld      A,$80           ; start with REG0 ($80+register number)
0A2C: 0E32    	                ld      C,VDP_SET       ; VDP set
0A2E: 56      	LDREGVLS:       ld      D,(HL)          ; load register's value
0A2F: ED51    	                out     (C),D           ; send data to VDP
0A31: ED79    	                out     (C),A           ; indicate the register to send data to
0A33: 3C      	                inc     A               ; next register
0A34: 23      	                inc     HL              ; next value
0A35: 10F7    	                djnz    LDREGVLS        ; repeat for 8 registers
0A37: C9      	                ret
              	
              	; ------------------------------------------------------------------------------
0A38:         	LOADCHARSET:    ; reg. A contains the video mode
              	                ; reg. HL contains address of pattern table into VRAM
0A38: 0600    	                ld      B,$00           ; 0=256 chars to load (complete charset)
0A3A: CBF4    	                set     $06,H           ; add $4000 to address to indicate that we want to write into VRAM
0A3C: 0E32    	                ld      C,VDP_SET       ; load VDP address into C
0A3E: ED69    	                out     (C),L           ; send low byte of address
0A40: ED61    	                out     (C),H           ; send high byte
0A42: 21133E  	                ld      HL,CHRST68      ; starting address of 6x8 charset into ROM
0A45: A7      	                and     A               ; is it text mode (A=0)?
0A46: 2803    	                jr      Z,NXTCHAR       ; yes, so jump to load chars into VRAM
0A48: 211346  	                ld      HL,CHRST88      ; no, so we change and load the 8x8 charset
0A4B: 1608    	NXTCHAR:        ld      D,$08           ; 8 bytes per pattern char
0A4D: 0E30    	                ld      C,VDP_DAT       ; VDP data mode
0A4F: 7E      	SENDCHRPTRNS:   ld      A,(HL)          ; load byte to send to VDP
0A50: ED79    	                out     (C),A           ; write byte into VRAM
0A52: 23      	                inc     HL              ; inc byte pointer
0A53: 15      	                dec     D               ; 8 bytes sents (0 char)?
0A54: 20F9    	                jr      NZ,SENDCHRPTRNS ; no, continue
0A56: 10F3    	                djnz    NXTCHAR         ; yes, decrement chars counter and continue for all the chars
0A58: C9      	                ret                     ; return to caller
              	
              	;------------------------------------------------------------------------------
              	; NAME TABLE:       buffer video - contains the chars to be shown on video
              	; PATTERN TABLE:    charset - contains the chars/tiles to be loaded into the name table
              	; COLOR TABLE:      color settings for chars/tiles
              	
              	                ; VDP register settings for a text display
0A59: 00      	VDPMODESET      defb    %00000000       ; reg.0: external video off
0A5A: D0      	                defb    %11010000       ; reg.1: 16K VRAM, video on, int. off, text mode (40x24)
0A5B: 02      	                defb    $02             ; reg.2: name table set to $0800 ($02x$400)
0A5C: 00      	                defb    $00             ; reg.3: not used in text mode
0A5D: 00      	                defb    $00             ; reg.4: pattern table set to $0000
0A5E: 00      	                defb    $00             ; reg.5: not used in text mode
0A5F: 00      	                defb    $00             ; reg.6: not used in text mode
0A60: F5      	                defb    $f5             ; reg.7: white text on light blue background
              	
0A61:         	VDPMODESET1     ; VDP register settings for a graphics 1 mode
0A61: 00      	                defb    %00000000       ; reg.0: ext. video off
0A62: C0      	                defb    %11000000       ; reg.1: 16K Vram; video on, int off, graphics mode 1, sprite size 8x8, sprite magn. 0
0A63: 06      	                defb    $06             ; reg.2: name table address: $1800
0A64: 80      	                defb    $80             ; reg.3: color table address: $2000
0A65: 00      	                defb    $00             ; reg.4: pattern table address: $0000
0A66: 36      	                defb    $36             ; reg.5: sprite attr. table address: $1B00
0A67: 07      	                defb    $07             ; reg.6: sprite pattern table addr.: $3800
0A68: 05      	                defb    $05             ; reg.7: backdrop color (light blue)
              	
0A69:         	VDPMODESET2     ; VDP register settings for a graphics 2 mode
0A69: 02      	                defb    %00000010       ; reg.0: graphics 2 mode, ext. video dis.
0A6A: C0      	                defb    %11000000       ; reg.1: 16K VRAM, video on, INT off, sprite size 8x8, sprite magn. 0
0A6B: 06      	                defb    $06             ; reg.2: name table addr.: $1800
0A6C: FF      	                defb    $FF             ; reg.3: color table addr.: $2000
0A6D: 03      	                defb    $03             ; reg.4: pattern table addr.: $0000
0A6E: 36      	                defb    $36             ; reg.5: sprite attr. table addr.: $1B00
0A6F: 07      	                defb    $07             ; reg.6: sprite pattern table addr.: $3800
0A70: 05      	                defb    $05             ; reg.7: backdrop color: light blue
              	
0A71:         	VDPMODESETMC    ; VDP register settings for a multicolor mode
0A71: 00      	                defb    %00000000       ; reg.0: ext. video dis.
0A72: CB      	                defb    %11001011       ; reg.1: 16K VRAM, video on, INT off, multicolor mode, sprite size 8x8, sprite magn. 0
0A73: 02      	                defb    $02             ; reg.2: name table addr.: $0800
0A74: 00      	                defb    $00             ; reg.3: don't care
0A75: 00      	                defb    $00             ; reg.4: pattern table addr.: $0000
0A76: 36      	                defb    $36             ; reg.5: sprite attr. table addr.: $1B00
0A77: 07      	                defb    $07             ; reg.6: sprite pattern table addr.: $3800
0A78: 0F      	                defb    $0F             ; reg.7: backdrop color (white)
              	
0A79:         	VDPMODESETEX2   ; VDP register settings for an extended graphics 2 mode
0A79: 02      	                defb    %00000010       ; reg.0: graphics 2 mode, ext. video dis.
0A7A: C0      	                defb    %11000000       ; reg.1: 16K VRAM, video on, INT off, sprite size 8x8, sprite magn. 0
0A7B: 0E      	                defb    $0E             ; reg.2: name table addr.: $3800
0A7C: 9F      	                defb    $9F             ; reg.3: color table addr.: $2000
0A7D: 00      	                defb    $00             ; reg.4: pattern table addr.: $0000
0A7E: 76      	                defb    $76             ; reg.5: sprite attr. table addr.: $3B00
0A7F: 03      	                defb    $03             ; reg.6: sprite pattern table addr.: $1800
0A80: 05      	                defb    $05             ; reg.7: backdrop color: light blue
              	
0A81:         	LM80CLOGO       ; patterns to compose the splash screen logo
0A81: 00000000	                defb    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0A85: 00...   	
0AA1: 00000F0A	                defb    0,0,15,10,11,16,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0AA5: 0B100000	
0AA9: 00000000	
0AAD: 00...   	
0AC1: 00000D17	                defb    0,0,13,23,0,12,0,0,0,1,0,0,0,20,0,0,6,5,6,21,22,7,6,21,22,7,6,1,1,7,0,0
0AC5: 000C0000	
0AC9: 00010000	
0ACD: 00140000	
0AD1: 06050615	
0AD5: 16070615	
0AD9: 16070601	
0ADD: 01070000	
0AE1: 00000D00	                defb    0,0,13,0,0,12,0,0,0,1,0,0,0,1,20,6,1,5,3,5,3,5,3,5,3,5,3,5,3,5,0,0
0AE5: 000C0000	
0AE9: 00010000	
0AED: 00011406	
0AF1: 01050305	
0AF5: 03050305	
0AF9: 03050305	
0AFD: 03050000	
0B01: 00000D00	                defb    0,0,13,0,0,12,0,0,0,1,0,0,0,1,1,1,1,5,9,20,19,8,3,5,19,5,3,5,0,0,0,0
0B05: 000C0000	
0B09: 00010000	
0B0D: 00010101	
0B11: 01050914	
0B15: 13080305	
0B19: 13050305	
0B1D: 00000000	
0B21: 00000D00	                defb    0,0,13,0,0,12,0,0,0,1,0,0,0,1,0,8,3,5,6,21,22,7,3,1,22,5,3,5,0,0,0,0
0B25: 000C0000	
0B29: 00010000	
0B2D: 00010008	
0B31: 03050615	
0B35: 16070301	
0B39: 16050305	
0B3D: 00000000	
0B41: 00000D00	                defb    0,0,13,0,0,12,0,0,0,1,0,0,0,1,0,0,3,5,3,5,3,5,3,5,3,5,3,5,3,5,0,0
0B45: 000C0000	
0B49: 00010000	
0B4D: 00010000	
0B51: 03050305	
0B55: 03050305	
0B59: 03050305	
0B5D: 03050000	
0B61: 00000D00	                defb    0,0,13,0,0,12,0,0,0,1,4,4,0,1,0,0,3,5,9,20,19,8,9,20,19,8,9,1,1,8,0,0
0B65: 000C0000	
0B69: 00010404	
0B6D: 00010000	
0B71: 03050914	
0B75: 13080914	
0B79: 13080901	
0B7D: 01080000	
0B81: 00000E12	                defb    0,0,14,18,18,17,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0B85: 12110000	
0B89: 00000000	
0B8D: 00...   	
0BA1: 00000000	                defb    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0; ------------------------------------------------------------------------------
0BA5: 00...   	
              	; LM80C - PSG ROUTINES - R3.14
              	; ------------------------------------------------------------------------------
              	; The following code is intended to be used with LM80C Z80-based computer
              	; designed by Leonardo Miliani. Code and computer schematics are released under
              	; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
              	; kind of warranty: you can use them at your own risk.
              	; You are free to use them for any non-commercial use: you are only asked to
              	; maintain the copyright notices, include this advice and the note to the 
              	; attribution of the original version to Leonardo Miliani, if you intend to
              	; redistribuite them.
              	; https://www.leonardomiliani.com
              	; 
              	; Please support me by visiting the following links:
              	; Main project page: https://www.leonardomiliani.com
              	; Schematics and code: https://github.com/leomil72/LM80C
              	; Videos about the computer: https://www.youtube.com/user/leomil72/videos
              	; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
              	; ------------------------------------------------------------------------------
              	;
              	; ------------------------------------------------------------------------------
              	
              	;------------------------------------------------------------------------------
              	; configure the PSG
0BC1: 212382  	initPSG:        ld      HL,CHASNDDTN    ; starting address of sound & keyboard RAM registers
0BC4: 060B    	                ld      B,SERIALS_EN-CHASNDDTN; # of PSG sound & keyboard registers
0BC6: AF      	                xor     A               ; reset A
0BC7: 77      	EMPTSNDBFR:     ld      (HL),A          ; reset RAM register
0BC8: 23      	                inc     HL              ; next register
0BC9: 10FC    	                djnz    EMPTSNDBFR      ; repeat
0BCB: 0610    	CLRPSGREGS:     ld      B,$10           ; 16 registers to set
0BCD: 21DF0B  	                ld      HL,SNDREGCFG    ; starting address of register settings
0BD0: 1600    	                ld      D,$00           ; first register
0BD2: 7A      	RSTPSG:         ld      A,D             ; register value
0BD3: CD190C  	                call    SETSNDREG       ; select register
0BD6: 7E      	                ld      A,(HL)          ; load value
0BD7: CD1E0C  	                call    WRTSNDREG       ; write to register
0BDA: 14      	                inc     D               ; next register
0BDB: 23      	                inc     HL              ; next value
0BDC: 10F4    	                djnz    RSTPSG          ; repeat for each register
0BDE: C9      	                ret                     ; return to caller
              	
0BDF: 00000000	SNDREGCFG:      defb $00,$00,$00,$00,$00,$00,$00,%10111111
0BE3: 000000BF	
0BE7: 00000000	                defb $00,$00,$00,$00,$00,$00,$ff,$ff
0BEB: 0000FFFF	
              	                ; reg. 7: set I/O ch.A to OUTPUT, I/O ch.B to INPUT; set noise to OFF; set audio to OFF
              	
              	
              	; routine to play a welcome beep on channel C (tone 4010) and to shut it off
0BEF: 21090C  	WLCMBEEP:       ld      HL,WLCBPDAT     ; data address
0BF2: C3F80B  	                jp      SENDSND
0BF5: 21110C  	NOBEEP:         ld      HL,NOBPDAT      ; data address
0BF8: C5      	SENDSND:        push    BC
0BF9: 0604    	                ld      B,$04           ; 4 pairs
0BFB: 7E      	RPTWLCMBP:      ld      A,(HL)          ; read register #
0BFC: CD190C  	                call    SETSNDREG
0BFF: 23      	                inc     HL              ; next cell
0C00: 7E      	                ld      A,(HL)          ; read value
0C01: CD1E0C  	                call    WRTSNDREG
0C04: 23      	                inc     HL
0C05: 10F4    	                djnz    RPTWLCMBP       ; repeat
0C07: C1      	                pop     BC
0C08: C9      	                ret                     ; return to caller
              	
0C09: 077B0456	WLCBPDAT:       defb    $07,%01111011,$04,$56,$05,$00,$0A,$0F
0C0D: 05000A0F	
0C11: 04000500	NOBPDAT:        defb    $04,$00,$05,$00,$0A,$00,$07,%01111111
0C15: 0A00077F	
              	
              	
              	; select register on PSG
0C19: 0E40    	SETSNDREG:      ld      C,PSG_REG       ; PSG register port
0C1B: ED79    	                out     (C),A           ; set register
0C1D: C9      	                ret                     ; return to caller
              	
              	; send data to PSG
0C1E: 0E41    	WRTSNDREG:      ld      C,PSG_DAT       ; PSG data port
0C20: ED79    	                out     (C),A           ; send data
0C22: C9      	                ret                     ; return to caller
              	
              	; manage the sounds' duration: each time this subroutine is called, it
              	; decrements the single sound durations (measured in ms) and eventually
              	; shut off the audio channel whose counter has reached 0.
              	; (this sub-routine is called by CH3 timer ISR)
0C23: DDE5    	MNGSNDS:        push    IX              ; store IX
0C25: DD212382	                ld      IX,CHASNDDTN    ; starting address of tones duration
0C29: 0603    	                ld      B,$03           ; 3 channels to check
0C2B: 2601    	                ld      H,$01           ; mixer channels: A=>bit 1, B=>bit 2, C=>bit 3
0C2D: DD5E00  	CHKSNDCH:       ld      E,(IX+0)        ; load LSB into E
0C30: DD5601  	                ld      D,(IX+1)        ; load MSB into D
0C33: 7B      	                ld      A,E             ; load E into A
0C34: B2      	                or      D               ; check that DE=0
0C35: 2831    	                jr      Z,CNTCHKSND     ; yes, jump over
0C37: 1B      	                dec     DE              ; no, so decrement DE
0C38: 7B      	                ld      A,E             ; reload E into A...
0C39: DD7300  	                ld      (IX+0),E        ; store new...
0C3C: DD7201  	                ld      (IX+1),D        ; ...duration and...
0C3F: B2      	                or      D               ; ...do another check to see if DE=0
0C40: 2026    	                jr      NZ,CNTCHKSND    ; no, so jump over
              	                                        ; if yes, let's shut down the corresponding channel
              	                                        ; to shut down a tone we disable it into the mixer
              	                                        ; then set 0 into its tone registers
0C42: 1607    	                ld      D,$07           ; mixer register
0C44: 0E40    	                ld      C,PSG_REG       ; PSG register selector port
0C46: ED51    	                out     (C),D           ; set mixer register
0C48: ED78    	                in      A,(C)           ; load current value
0C4A: B4      	                or      H               ; set off the channel into the mixer (remember that 1=OFF)
0C4B: ED51    	                out     (C),D           ; select mixer register
0C4D: 0E41    	                ld      C,PSG_DAT       ; PSG data port
0C4F: ED79    	                out     (C),A           ; send new value for the mixer
0C51: 3E03    	                ld      A,$03           ; three channels
0C53: 90      	                sub     B               ; find current channel (0->A, 1->B, 2->C)
0C54: 87      	                add     A,A             ; and find first register (A=>0, B=>2, C=>4)
0C55: 0E40    	                ld      C,PSG_REG       ; PSG register selector port
0C57: ED79    	                out     (C),A           ; select first tone register of channel
0C59: 2E00    	                ld      L,$00           ; value 0 into L
0C5B: 0E41    	                ld      C,PSG_DAT       ; PSG data selector port
0C5D: ED69    	                out     (C),L           ; write 0 into register
0C5F: 0E40    	                ld      C,PSG_REG       ; PSG register selector port
0C61: 3C      	                inc     A               ; next tone register
0C62: ED79    	                out     (C),A           ; select second tone register of channel
0C64: 0E41    	                ld      C,PSG_DAT       ; PSG data selector port
0C66: ED69    	                out     (C),L           ; write 0 into register
0C68: DD23    	CNTCHKSND:      inc     IX              ; set for...
0C6A: DD23    	                inc     IX              ; ...next channel...
0C6C: CB24    	                sla     H               ; shift left H 1 bit
0C6E: 10BD    	                djnz    CHKSNDCH        ; repeat for 3 channels
0C70: DDE1    	                pop     IX              ; restore IX
0C72: C9      	                ret                     ; return to caller
              	
              	; read a specific row of the keyboard matrix, set by A
              	; return read into A
0C73: C5      	READKBLN:       push    BC              ; store BC
0C74: 060F    	                ld      B,$0F           ; reg #15
0C76: 0E40    	                ld      C,PSG_REG       ; PSG register port
0C78: ED41    	                out     (C),B           ; select reg #15
0C7A: 0E41    	                ld      C,PSG_DAT       ; PSG data port
0C7C: ED79    	                out     (C),A           ; activate the row
0C7E: 060E    	                ld      B,$0E           ; register #14 (port B)
0C80: 0E40    	                ld      C,PSG_REG       ; PSG register port
0C82: ED41    	                out     (C),B           ; select reg. 14 (port B)
0C84: ED78    	                in      A,(C)           ; read register #14
0C86: C1      	                pop     BC              ; retrieve BC
0C87: C9      	                ret
              	
              	; read the keyboard matrix to look for a key pressure
0C88: 0E40    	KEYBOARD:       ld      C,PSG_REG       ; PSG register port
0C8A: 0607    	                ld      B,$07           ; set register #7...
0C8C: ED41    	                out     (C),B           ; ...to work with
0C8E: ED78    	                in      A,(C)           ; read register #7
0C90: CBFF    	                set     7,A             ; port A set to output
0C92: CBB7    	                res     6,A             ; port B set to input
0C94: ED41    	                out     (C),B           ; set register #7
0C96: 0E41    	                ld      C,PSG_DAT       ; PSG data port
0C98: ED79    	                out     (C),A           ; set I/O ports w/o altering the rest of the mixer
              	                ; check special keys (SHIFT/ALT/CTRL)
0C9A: 3EFD    	                ld      A,%11111101     ; select SHIFT row
0C9C: CD730C  	                call    READKBLN        ; read row
0C9F: CB5F    	                bit     3,A             ; test if SHIFT key is pressed (4th bit is reset)
0CA1: 2005    	                jr      NZ,CHECKALT     ; no, so go on
0CA3: 212D82  	                ld      HL,CONTROLKEYS  ; control key flags
0CA6: 3601    	                ld      (HL),%00000001  ; set SHIFT flag, reset CTRL & ALT flags (currently multiply control keys are NOT supported)
0CA8: 3EFE    	CHECKALT:       ld      A,%11111110     ; select ALT row
0CAA: CD730C  	                call    READKBLN        ; read ALT row
0CAD: CB6F    	                bit     5,A             ; test if ALT key is pressed (5th bit is reset)
0CAF: 2005    	                jr      NZ,CHECKCTRL    ; no, so go on
0CB1: 212D82  	                ld      HL,CONTROLKEYS  ; control key flags
0CB4: 3604    	                ld      (HL),%00000100  ; set ALT flag, reset SHIFT & CTRL flag (currently multiply control keys are NOT supported)
0CB6: 3EFE    	CHECKCTRL:      ld      A,%11111110     ; select CTRL row
0CB8: CD730C  	                call    READKBLN        ; read CTRL row
0CBB: CB57    	                bit     2,A             ; test if CTRL key is pressed (3rd bit is reset)
0CBD: 2005    	                jr      NZ,CHECKKBD     ; no, so make a normal reading
0CBF: 212D82  	                ld      HL,CONTROLKEYS  ; control key flags
0CC2: 3602    	                ld      (HL),%00000010  ; set CTRL flag, reset SHIFT & ALT flags (currently multiply control keys are NOT supported)
0CC4: 0608    	CHECKKBD:       ld      B,$08           ; 8 lines
0CC6: 3E7F    	                ld      A,%01111111     ; start from the last line of the matrix
0CC8: 160F    	RPTKBDRD:       ld      D,$0F           ; register #15 (port B)
0CCA: 0E40    	                ld      C,PSG_REG       ; PSG register port
0CCC: ED51    	                out     (C),D           ; select reg. #15
0CCE: 0E41    	                ld      C,PSG_DAT       ; PSG data port
0CD0: ED79    	                out     (C),A           ; activate 1 line (active line is grounded, i.e. with a LOW signal)
0CD2: 5F      	                ld      E,A             ; save current line into E
0CD3: 160E    	                ld      D,$0E           ; register #14 (port A)
0CD5: 0E40    	                ld      C,PSG_REG       ; PSG register port
0CD7: ED51    	                out     (C),D           ; select reg. 14 (port A)
0CD9: 00      	                nop
0CDA: ED78    	                in      A,(C)           ; read register #14
0CDC: FEFF    	                cp      $FF             ; is there any line set to 0?
0CDE: 282E    	                jr      Z,NOKEYPRSD     ; no, go to the next row
              	                ; check control keys
0CE0: 322A82  	                ld      (KBTMP),A       ; yes, check if a control key was pressed. First, store current row
0CE3: 78      	                ld      A,B             ; copy current row (B) into A
0CE4: FE02    	                cp      $02             ; is it the row of the SHIFT?
0CE6: 200F    	                jr      NZ,TESTALT      ; no, continue checking the other control keys
0CE8: 3A2A82  	                ld      A,(KBTMP)       ; yes, retrieve current row data
0CEB: CB5F    	                bit     3,A             ; check SHIFT bit line
0CED: 202E    	                jr      NZ,FINDKEY      ; no SHIFT, continue checking
0CEF: CBDF    	                set     3,A             ; yes, it's the SHIFT. So remove SHIFT bit
0CF1: FEFF    	                cp      $FF             ; after deleting the SHIFT bit, is there any other bit selected?
0CF3: 2028    	                jr      NZ,FINDKEY      ; yes, go to check which one
0CF5: 1817    	                jr      NOKEYPRSD       ; no, go to next row        
0CF7: FE01    	TESTALT:        cp      $01             ; is it the line of ALT & CTRL?
0CF9: 3A2A82  	                ld      A,(KBTMP)       ; retrieve current row data
0CFC: 201F    	                jr      NZ,FINDKEY      ; no, continue
0CFE: CB6F    	                bit     5,A             ; yes, check ALT bit line
0D00: 2002    	                jr      NZ,TESTCTRL     ; no ALT, continue checking
0D02: CBEF    	                set     5,A             ; yes, it's the ALT. So remove ALT bit
0D04: CB57    	TESTCTRL:       bit     2,A             ; check CTRL bit line
0D06: 2002    	                jr      NZ,ENDCTRLCK    ; no CTRL, continue checking
0D08: CBD7    	                set     2,A             ; delete CTRL bit flag
0D0A: FEFF    	ENDCTRLCK:      cp      $FF             ; after deleting the ALT & CTRL bits, is there any other bit selected?
0D0C: 200F    	                jr      NZ,FINDKEY      ; yes, go to check which one
0D0E: 7B      	NOKEYPRSD:      ld      A,E             ; no key pressed, load current output port
0D0F: 0F      	                rrca                    ; rotate right by 1
0D10: 10B6    	                djnz    RPTKBDRD        ; repeat for 8 lines
0D12: AF      	                xor     A               ; if exit from here, no key has been pressed...
0D13: 322C82  	                ld      (LASTKEYPRSD),A ; ...so reset the last key cell...
0D16: 322D82  	                ld      (CONTROLKEYS),A ; ...reset contro key flags...
0D19: 322982  	                ld      (KBDNPT),A      ; ...no input from keyboard...
0D1C: C9      	                ret                     ; ...and leave
0D1D: 1EFF    	FINDKEY:        ld      E,$FF           ; counter
0D1F: 1C      	CHKLN:          inc     E               ; E goes from 0 to 7
0D20: CB3F    	                srl     A               ; is the first bit reset? (we're looking for a "0", meaning grounded line)
0D22: 38FB    	                jr      C,CHKLN         ; no, check next bit
0D24: 3A2D82  	                ld      A,(CONTROLKEYS) ; load control key flags
0D27: 21F20D  	                ld      HL,KBMAP        ; normal keymap
0D2A: FE01    	                cp      $01             ; SHIFT flag?
0D2C: 2005    	                jr      NZ,CHKCTRL      ; no, jump over
0D2E: 21320E  	                ld      HL,KBMAP_SFT    ; SHIFT keymap
0D31: 1810    	                jr      LOADMAP         ; and load it
0D33: FE02    	CHKCTRL:        cp      $02             ; CTRL flag?
0D35: 2005    	                jr      NZ,CHKALT       ; no, jump over
0D37: 21B20E  	                ld      HL,KBMAP_CTRL   ; CTRL map
0D3A: 1807    	                jr      LOADMAP         ; and load it
0D3C: FE04    	CHKALT:         cp      $04             ; ALT flag?
0D3E: 2003    	                jr      NZ,LOADMAP      ; no, check over
0D40: 21720E  	                ld      HL,KBMAP_ALT    ; ALT map
0D43: 05      	LOADMAP:        dec     B               ; decrement row # (rows go from 0 to 7)
0D44: 48      	                ld      C,B             ; move B into C and...
0D45: CB21    	                sla     C               ; ...multiply it...
0D47: CB21    	                sla     C               ; ...by 8 to find...
0D49: CB21    	                sla     C               ; ...the current row into the matrix
0D4B: 0600    	                ld      B,$00           ; reset B
0D4D: 09      	                add     HL,BC           ; find the address of the current row
0D4E: 50      	                ld      D,B             ; reset D
0D4F: 19      	                add     HL,DE           ; find the current column
0D50: 3A2C82  	                ld      A,(LASTKEYPRSD) ; load the last key pressed
0D53: BE      	                cp      (HL)            ; is it the same key?
0D54: 2847    	                jr      Z,LVKBRDCHK     ; yes, so do nothing
0D56: 7E      	                ld      A,(HL)          ; no, load it...
0D57: 322C82  	                ld      (LASTKEYPRSD),A ; ...store it...
0D5A: 322B82  	                ld      (TMPKEYBFR),A   ; ...insert it into the INKEY buffer...
0D5D: 32EC81  	                ld      (CHR4VID),A     ; ...and store char for video
0D60: FE03    	                cp      CTRLC           ; is it RUN/STOP?
0D62: 2005    	                jr      NZ,CNTKBCK      ; no, jump over
0D64: CD3601  	                call    CHARINTOBFR     ; yes, send directly to buffer and...
0D67: 1830    	                jr      LVKBRDCHK2      ; ...leave
0D69: 010008  	CNTKBCK:        ld      BC,$0800        ; 8 FN keys (B), FN key number (C)
0D6C: 21EA0D  	                ld      HL,FNKEYSORD    ; FN keys codes
0D6F: BE      	CHKFNK:         cp      (HL)            ; is it an FN key?
0D70: CA9E0D  	                jp      Z,PRNTFNKEY     ; yes, jump over
0D73: 0C      	                inc     C               ; next FN key
0D74: 23      	                inc     HL              ; next FN key code
0D75: 10F8    	                djnz    CHKFNK          ; continue for 8 FN keys
0D77: 3E01    	SNDKEYTOBFR:    ld      A,$01           ; normal key - set input flag
0D79: 322982  	                ld      (KBDNPT),A      ; to keyboard
0D7C: 3AEB81  	                ld      A,(PRNTVIDEO)   ; load status of print-on-video
0D7F: B7      	                or      A               ; is the print-on-video disabled?
0D80: CA890D  	                jp      Z,PUTCHRBUF     ; yes, so send char to input buffer
0D83: 3AE981  	                ld      A,(CRSR_STATE)  ; check cursor state
0D86: B7      	                or      A               ; is it 0 (cursor OFF)?
0D87: 200D    	                jr      NZ,PNT2VD       ; no, print on screen
0D89: AF      	PUTCHRBUF:      xor     A
0D8A: 322982  	                ld      (KBDNPT),A      ; if send to input buffer, set RETURN as from BASIC
0D8D: 3A2B82  	                ld      A,(TMPKEYBFR)   ; retrieve char
0D90: CD3601  	                call    CHARINTOBFR     ; cursor off, so send char to buffer...
0D93: C3990D  	                jp      LVKBRDCHK2      ; ...and leave
0D96: CDC806  	PNT2VD:         call    CHAR2VID        ; send char to video
0D99: AF      	LVKBRDCHK2:     xor     A
0D9A: 322D82  	                ld      (CONTROLKEYS),A ; reset control key flags
0D9D: C9      	LVKBRDCHK:      ret                     ; return to caller: the current key code is into TMPKEYBFR    
              	                ; manage FN keys          
0D9E: 57      	PRNTFNKEY:      ld      D,A             ; copy A into D
0D9F: 2AAF80  	                ld      HL,(LINEAT)     ; Get current line number
0DA2: 23      	                inc     HL              ; -1 means direct statement
0DA3: 7C      	                ld      A,H
0DA4: B5      	                or      L
0DA5: 7A      	                ld      A,D             ; retrieve char
0DA6: 20CF    	                jr      NZ,SNDKEYTOBFR  ; indirect mode - just send FN key code to buffer
0DA8: 79      	                ld      A,C             ; direct mode, so print text - first, get FN key number
0DA9: 87      	                add     A,A
0DAA: 87      	                add     A,A
0DAB: 87      	                add     A,A
0DAC: 87      	                add     A,A             ; FN key number * 16
0DAD: 4F      	                ld      C,A             ; move it into C
0DAE: 0600    	                ld      B,$00           ; reset B, to get offset
0DB0: 21B380  	                ld      HL,FNKEYS       ; load address of FN keys texts
0DB3: 09      	                add     HL,BC           ; get correct text address
0DB4: 0610    	                ld      B,$10           ; 16 chars
0DB6: 7E      	LDFNKEYCHR:     ld      A,(HL)          ; load char
0DB7: A7      	                and     A               ; null char?
0DB8: CA990D  	                jp      Z,LVKBRDCHK2    ; yes, so leave
0DBB: 57      	                ld      D,A             ; pass char into D
0DBC: 3AEB81  	                ld      A,(PRNTVIDEO)   ; load status of print-on-video
0DBF: B7      	                or      A               ; is the print-on-video disabled?
0DC0: CAD00D  	                jp      Z,PUTCHRBUF1    ; yes, so send char to input buffer
0DC3: 3AE981  	                ld      A,(CRSR_STATE)  ; check cursor state
0DC6: B7      	                or      A               ; is it 0 (cursor OFF)?
0DC7: C4DD0D  	                call    NZ,PRNTFNK      ; no, print on screen
0DCA: 23      	CNTFNK:         inc     HL              ; next char
0DCB: 10E9    	                djnz    LDFNKEYCHR      ; repeat for max. 16 chars
0DCD: C3990D  	                jp      LVKBRDCHK2      ; leave
0DD0: AF      	PUTCHRBUF1:     xor     A               ; if send to input buffer,... 
0DD1: 322982  	                ld      (KBDNPT),A      ; ...set input as from BASIC
0DD4: 7A      	                ld      A,D             ; retrieve char
0DD5: E5      	                push    HL              ; store HL
0DD6: CD3601  	                call    CHARINTOBFR     ; cursor off, so send char to buffer...
0DD9: E1      	                pop     HL              ; retrieve HL
0DDA: C3CA0D  	                jp      CNTFNK          ; repeat
0DDD: 7A      	PRNTFNK:        ld      A,D             ; recover char
0DDE: 32EC81  	                ld      (CHR4VID),A     ; store char for printing
0DE1: 3E01    	                ld      A,$01           ; normal key - set input flag
0DE3: 322982  	                ld      (KBDNPT),A      ; to keyboard
0DE6: CDC806  	                call    CHAR2VID        ; print on screen
0DE9: C9      	                ret                     ; return to caller
              	
              	
              	;-----------------------------------------------------------------------
0DEA: 01020405	FNKEYSORD:      defb 1,2,4,5,6,22,23,24                 ; order of FN Keys
0DEE: 06161718	
              	;-----------------------------------------------------------------------
              	; key codes
0DF2: 31190E03	KBMAP:          defb '1',25,14,3,' ',16,'q','2'         ; 25=HOME  14=CTRL  3=RUN/STOP 16=C=
0DF6: 20107132	
0DFA: 33776114	                defb '3','w','a',20,'z','s','e','4'     ; 20=SHIFT
0DFE: 7A736534	
0E02: 35726478	                defb '5','r','d','x','c','f','t','6'
0E06: 63667436	
0E0A: 37796776	                defb '7','y','g','v','b','h','u','8'
0E0E: 62687538	
0E12: 39696A6E	                defb '9','i','j','n','m','k','o','0'
0E16: 6D6B6F30	
0E1A: 1F706C2C	                defb 31,'p','l',',','.',':','-',30      ; 31=CURSOR DOWN  30=CURSOR UP
0E1E: 2E3A2D1E	
0E22: 1C2A3B2F	                defb 28,'*',';','/',27,'=','+',29       ; 28=CURSOR LEFT  27=ESCAPE  29=CURSOR RIGHT
0E26: 1B3D2B1D	
0E2A: 080DFC40	                defb 8,13,252,'@',1,2,4,24              ; 8=DEL(backspace)  13=RETURN  252=£  1=F1  2=F2  4=F3  24=HELP
0E2E: 01020418	
              	
              	; shifted codes - not all the keys have the shifted version
0E32: 210C0E03	KBMAP_SFT:      defb '!',12,14,3,' ',16,'Q',34          ; 12=CLEAR  14=CTRL  3=RUN/STOP 16=C=   34="
0E36: 20105122	
0E3A: 23574114	                defb '#','W','A',20,'Z','S','E','$'     ; 20=SHIFT
0E3E: 5A534524	
0E42: 25524458	                defb '%','R','D','X','C','F','T','&'
0E46: 43465426	
0E4A: 27594756	                defb 39,'Y','G','V','B','H','U','('     ; 39='
0E4E: 42485528	
0E52: 29494A4E	                defb ')','I','J','N','M','K','O',94     ; 94=^
0E56: 4D4B4F5E	
0E5A: 1F504C3C	                defb 31,'P','L','<','>','[','_',30      ; 31=CURSOR DOWN  30=CURSOR UP
0E5E: 3E5B5F1E	
0E62: 1C2A5D3F	                defb 28,'*',']','?',27,198,'+',29       ; 28=CURSOR LEFT  27=ESCAPE  29=CURSOR RIGHT
0E66: 1BC62B1D	
0E6A: 080DD340	                defb 8,13,211,'@',5,6,22,23             ; 211=€  5=F4  6=F5  22=F6  23=F7
0E6E: 05061617	
              	
              	; ALT (C=) codes - not all the keys have the alt-ed version
0E72: 310C0E03	KBMAP_ALT:      defb '1',12,14,3,' ',16,222,196         ; 12=CLEAR  14=CTRL  3=RUN/STOP  16=C=  34="
0E76: 2010DEC4	
0E7A: 33DD8514	                defb '3',221,133,20,131,130,165,'4'     ; 20=SHIFT
0E7E: 8382A534	
0E82: 35A2A684	                defb '5',162,166,132,157,163,168,'6'
0E86: 9DA3A836	
0E8A: 37ABA9A1	                defb '7',171,169,161,158,172,213,'8'    ;
0E8E: 9EACD538	
0E92: 39D6D89F	                defb '9',214,216,159,160,215,135,195    ;
0E96: A0D787C3	
0E9A: 1F888AC1	                defb 31,136,138,193,192,123,144,30      ; 31=CURSOR DOWN  123={  30=CURSOR UP
0E9E: C07B901E	
0EA2: 1C8F7DFE	                defb 28,143,125,254,27,209,148,29       ; 28=CURSOR LEFT  125=}  27=ESCAPE  29=CURSOR RIGHT
0EA6: 1BD1941D	
0EAA: 080DE089	                defb 8,13,224,137,5,6,22,23             ; 8=DEL(backspace)  13=RETURN  252=£  5=F4  6=F5  22=F6  23=F7
0EAE: 05061617	
              	
              	; CTRL codes - not all the keys have the control-ed version
0EB2: 31190E03	KBMAP_CTRL:     defb '1',25,14,3,' ',16,154,'2'         ; 25=HOME  14=CTRL  3=RUN/STOP  16=C=
0EB6: 20109A32	
0EBA: 339C9514	                defb '3',156,149,20,152,150,153,'4'     ; 20=SHIFT
0EBE: 98969934	
0EC2: 359BB097	                defb '5',155,176,151,177,175,165,'6'
0EC6: B1AFA536	
0ECA: 37A6A8B2	                defb '7',166,168,178,179,169,167,'8'
0ECE: B3A9A738	
0ED2: 39B8AAAC	                defb '9',184,170,172,171,181,164,'0'
0ED6: ABB5A430	
0EDA: 1FA3AD2C	                defb 31,163,173,',','.',':',186,30      ; 31=CURSOR DOWN  30=CURSOR UP
0EDE: 2E3ABA1E	
0EE2: 1CE13B2F	                defb 28,225,';','/',27,212,185,29       ; 28=CURSOR LEFT  27=ESCAPE  212=π  29=CURSOR RIGHT
0EE6: 1BD4B91D	
0EEA: 080DBDA2	                defb 8,13,189,162,1,2,4,24              ; 8=DEL(backspace)  13=RETURN  252=£  1=F1  2=F2  4=F3  24=HELP; ------------------------------------------------------------------------------
0EEE: 01020418	
              	; LM80C BASIC - R3.14
              	; ------------------------------------------------------------------------------
              	; The following code is intended to be used with LM80C Z80-based computer
              	; designed by Leonardo Miliani. Code and computer schematics are released under
              	; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
              	; kind of warranty: you can use them at your own risk.
              	; You are free to use them for any non-commercial use: you are only asked to
              	; maintain the copyright notices, include this advice and the note to the 
              	; attribution of the original version to Leonardo Miliani, if you intend to
              	; redistribuite them.
              	; https://www.leonardomiliani.com
              	; 
              	; Please support me by visiting the following links:
              	; Main project page: https://www.leonardomiliani.com
              	; Schematics and code: https://github.com/leomil72/LM80C
              	; Videos about the computer: https://www.youtube.com/user/leomil72/videos
              	; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
              	; ------------------------------------------------------------------------------
              	; NASCOM BASIC versions:
              	; 4.7  - original version by NASCOM
              	; 4.7b - modified version by Grant Searle (additional commands & functions)
              	; 4.8  - modified by Leonardo Miliani (new commands/functions)
              	
              	
              	;------------------------------------------------------------------------------
              	;  B A S I C
              	;------------------------------------------------------------------------------
              	
              	; GENERAL EQUATES
              	
0000:         	NLLCR           equ     $00             ; null char (used as space/empty char in video prints)
0003:         	CTRLC           equ     $03             ; Control "C"
0007:         	CTRLG           equ     $07             ; Control "G"
0008:         	BKSP            equ     $08             ; Back space
000A:         	LF              equ     $0A             ; Line feed
000C:         	CS              equ     $0C             ; Clear screen
000D:         	CR              equ     $0D             ; Carriage return
000F:         	CTRLO           equ     $0F             ; Control "O"
0011:         	CTRLQ           equ     $11             ; Control "Q"
0012:         	CTRLR           equ     $12             ; Control "R"
0013:         	CTRLS           equ     $13             ; Control "S"
0015:         	CTRLU           equ     $15             ; Control "U"
0019:         	HOME            equ     $19             ; Home (cursor at 0,0)
001B:         	ESC             equ     $1B             ; Escape
0020:         	SPC             equ     $20             ; Space
007F:         	DEL             equ     $7F             ; Delete
              	; cursor ASCII codes
001C:         	CRSLFT          equ     $1C             ; cursor left
001D:         	CRSRGT          equ     $1D             ; cursor right
001E:         	CRSUP           equ     $1E             ; cursor up
001F:         	CRSDN           equ     $1F             ; cursor down
              	
              	
              	; BASIC WORK SPACE LOCATIONS
              	; BY STARTING FROM $805E THE INTERPRETER ALLOCATES THE FOLLOWING RAM CELLS
              	; TO STORE IMPORTANT VALUES USED FOR SOME SPECIFIC FUNCTIONS:
              	; THEY CAN BE VECTOR (ADDRESSES) FUNCTIONS, SYSTEM DATAS (I.E. VARIABLES)
              	; AND SO ON. THE FIRST CELLS ARE FILLED WITH VALUES STORED INTO ROM AT $(INITAB) ADDRESS
805E:         	WRKSPC          equ     basicStarted+$01; (3) BASIC Work space
8061:         	NMIUSR          equ     WRKSPC+$03      ; (3) NMI exit point routine
8064:         	USR             equ     NMIUSR+$03      ; (3) "USR (x)" jump  <-- in $8065/8066 the user can store the address of a specific machine language routine
8067:         	OUTSUB          equ     USR+$03         ; (1) "out p,n"
8068:         	OTPORT          equ     OUTSUB+$01      ; (2) Port (p)
806A:         	DIVSUP          equ     OTPORT+$02      ; (1) Division support routine
806B:         	DIV1            equ     DIVSUP+$01      ; (4) <- Values
806F:         	DIV2            equ     DIV1+$04        ; (4) <-   to
8073:         	DIV3            equ     DIV2+$04        ; (3) <-   be
8076:         	DIV4            equ     DIV3+$03        ; (2) <-inserted
8078:         	SEED            equ     DIV4+$02        ; (35) Random number seed  <-- starting address of a seed table
809B:         	LSTRND          equ     SEED+$23        ; (4) Last random number
809F:         	INPSUB          equ     LSTRND+$04      ; (1) #INP (x)" Routine
80A0:         	INPORT          equ     INPSUB+$01      ; (2) PORT (x)
80A2:         	LWIDTH          equ     INPORT+$02      ; (1) Terminal width
80A3:         	COMMAN          equ     LWIDTH+$01      ; (1) Width for commas
80A4:         	NULFLG          equ     COMMAN+$01      ; (1) Null after input byte flag
80A5:         	CTLOFG          equ     NULFLG+$01      ; (1) Control "O" flag
80A6:         	CHKSUM          equ     CTLOFG+$01      ; (2) Array load/save check sum
80A8:         	NMIFLG          equ     CHKSUM+$02      ; (1) Flag for NMI break routine
80A9:         	BRKFLG          equ     NMIFLG+$01      ; (1) Break flag
80AA:         	RINPUT          equ     BRKFLG+$01      ; (3) Input reflection
80AD:         	STRSPC          equ     RINPUT+$03      ; (2) Bottom of string space
80AF:         	LINEAT          equ     STRSPC+$02      ; (2) Current line number
80B1:         	HLPLN           equ     LINEAT+$02      ; (2) Current line with errors
80B3:         	FNKEYS          equ     HLPLN+$02       ; (128) text of FN keys
8133:         	BASTXT          equ     FNKEYS+$80      ; (3) Pointer to start of program   <-- actually this is the last value pre-filled by the firmware at startup
8136:         	BUFFER          equ     BASTXT+$03      ; (5) Input buffer
813B:         	STACK           equ     BUFFER+$05      ; (85) Initial stack
8190:         	CURPOS          equ     STACK+$55       ; (1) Character position on line
8191:         	LCRFLG          equ     CURPOS+$01      ; (1) Locate/Create flag
8192:         	TYPE            equ     LCRFLG+$01      ; (1) Data type flag
8193:         	DATFLG          equ     TYPE+$01        ; (1) Literal statement flag
8194:         	LSTRAM          equ     DATFLG+$01      ; (2) Last available RAM
8196:         	TMSTPT          equ     LSTRAM+$02      ; (2) Temporary string pointer
8198:         	TMSTPL          equ     TMSTPT+$02      ; (12) Temporary string pool
81A4:         	TMPSTR          equ     TMSTPL+$0C      ; (4) Temporary string
81A8:         	STRBOT          equ     TMPSTR+$04      ; (2) Bottom of string space
81AA:         	CUROPR          equ     STRBOT+$02      ; (2) Current operator in EVAL
81AC:         	LOOPST          equ     CUROPR+$02      ; (2) First statement of loop
81AE:         	DATLIN          equ     LOOPST+$02      ; (2) Line of current DATA item
81B0:         	FORFLG          equ     DATLIN+$02      ; (1) "FOR" loop flag
81B1:         	LSTBIN          equ     FORFLG+$01      ; (1) Last byte entered
81B2:         	READFG          equ     LSTBIN+$01      ; (1) Read/Input flag
81B3:         	BRKLIN          equ     READFG+$01      ; (2) Line of break
81B5:         	NXTOPR          equ     BRKLIN+$02      ; (2) Next operator in EVAL
81B7:         	ERRLIN          equ     NXTOPR+$02      ; (2) Line of error
81B9:         	CONTAD          equ     ERRLIN+$02      ; (2) Where to CONTinue
81BB:         	PROGND          equ     CONTAD+$02      ; (2) End of program
81BD:         	VAREND          equ     PROGND+$02      ; (2) End of variables
81BF:         	ARREND          equ     VAREND+$02      ; (2) End of arrays
81C1:         	NXTDAT          equ     ARREND+$02      ; (2) Next data item
81C3:         	FNRGNM          equ     NXTDAT+$02      ; (2) Name of FN argument
81C5:         	FNARG           equ     FNRGNM+$02      ; (4) FN argument value
81C9:         	FPREG           equ     FNARG+$04       ; (3) Floating point register
81CC:         	FPEXP           equ     FPREG+$03       ; (1) Floating point exponent
81CD:         	SGNRES          equ     FPEXP+$01       ; (1) Sign of result
81CE:         	TMRCNT          equ     SGNRES+$01      ; (4) TMR counter for 1/100 seconds
81D2:         	CTC0IV          equ     TMRCNT+$04      ; (3) CTC0 interrupt vector
81D5:         	CTC1IV          equ     CTC0IV+$03      ; (3) CTC1 interrupt vector
81D8:         	CTC2IV          equ     CTC1IV+$03      ; (3) CTC2 interrupt vector
81DB:         	CTC3IV          equ     CTC2IV+$03      ; (3) CTC3 interrupt vector
              	; - - - - - - - - - - - - - - - - - - -   VIDEO REGISTERS - FROM HERE...
81DE:         	SCR_SIZE_W      equ     CTC3IV+$03      ; (1) screen width (it can be either 40 chars or 32 chars/bytes)
81DF:         	SCR_SIZE_H      equ     SCR_SIZE_W+$01  ; (1) screen height (it can be 24/48/192: 24 for text, 48 for MC, 192 for graphics)
81E0:         	SCR_MODE        equ     SCR_SIZE_H+$01  ; (1) screen mode (0=text, 1=G1, 2=G2, 3=MC, 4=ExG2)
81E2:         	SCR_NAM_TB      equ     SCR_MODE+$02    ; (2) video name table address
81E4:         	SCR_CURS_X      equ     SCR_NAM_TB+$02  ; (1) cursor X
81E5:         	SCR_CURS_Y      equ     SCR_CURS_X+$01  ; (1) cursor Y
81E6:         	SCR_CUR_NX      equ     SCR_CURS_Y+$01  ; (1) new cursor X position
81E7:         	SCR_CUR_NY      equ     SCR_CUR_NX+$01  ; (1) new cursor Y position
81E8:         	SCR_ORG_CHR     equ     SCR_CUR_NY+$01  ; (1) original char positioned under the cursor
81E9:         	CRSR_STATE      equ     SCR_ORG_CHR+$01 ; (1) state of cursor (1=on, 0=off)
81EA:         	LSTCSRSTA       equ     CRSR_STATE+$01  ; (1) last cursor state
81EB:         	PRNTVIDEO       equ     LSTCSRSTA+$01   ; (1) print on video buffer (1=on / 0=off) set to off on graphic only modes
81EC:         	CHR4VID         equ     PRNTVIDEO+$01   ; (1) char for video buffer
81ED:         	FRGNDCLR        equ     CHR4VID+$01     ; (1) foreground color as set by SCREEN or COLOR commands
81EE:         	BKGNDCLR        equ     FRGNDCLR+$01    ; (1) background color as set by SCREEN or COLOR commands
81EF:         	TMPBFR1         equ     BKGNDCLR+$01    ; (2) word for general purposes use (temp. buffer for 1 or 2 bytes)
81F1:         	TMPBFR2         equ     TMPBFR1+$02     ; (2) word for general purposes use (temp. buffer for 1 or 2 bytes)
81F3:         	TMPBFR3         equ     TMPBFR2+$02     ; (2) word for general purposes use (temp. buffer for 1 or 2 bytes)
81F5:         	TMPBFR4         equ     TMPBFR3+$02     ; (2) word for general purposes use (temp. buffer for 1 or 2 bytes)
81F7:         	VIDEOBUFF       equ     TMPBFR4+$02     ; (40) buffer used for video scrolling and other purposes
821F:         	VIDTMP1         equ     VIDEOBUFF+$28   ; (2) temporary video word
8221:         	VIDTMP2         equ     VIDTMP1+$02     ; (2) temporary video word
              	; - - - - - - - - - - - - - - - - - - -   ...TO HERE. DO NOT ADD ANYTHING RELATED TO VPD OUT OF THIS RANGE,
              	                                        ; OTHERWISE YOU WILL HAVE TO CHECK THE POINTER IN "CLR_RAM_REG" FUNCTION
              	; - - - - - - - - - - - - - - - - - - -   SOUND & KEYBOARD REGISTERS - FROM HERE...
8223:         	CHASNDDTN       equ     VIDTMP2+$02     ; (2) sound Ch.A duration (1/100s)
8225:         	CHBSNDDTN       equ     CHASNDDTN+$02   ; (2) sound Ch.B duration (1/100s)
8227:         	CHCSNDDTN       equ     CHBSNDDTN+$02   ; (2) sound Ch.C duration (1/100s)
8229:         	KBDNPT          equ     CHCSNDDTN+$02   ; (1) temp cell used to flag if input comes from keyboard
822A:         	KBTMP           equ     KBDNPT+$01      ; (1) temp cell used by keyboard scanner
822B:         	TMPKEYBFR       equ     KBTMP+$01       ; (1) temp buffer for last key pressed
822C:         	LASTKEYPRSD     equ     TMPKEYBFR+$01   ; (1) last key code pressed
822D:         	CONTROLKEYS     equ     LASTKEYPRSD+$01 ; (1) flags for control keys (bit#0=SHIFT; bit#1=CTRL; bit#2=C=)
              	; - - - - - - - - - - - - - - - - - - -   ...TO HERE. DO NOT ADD ANYTHING RELATED TO PSG OUT OF THIS RANGE,
              	                                        ; OTHERWISE YOU WILL HAVE TO CHANGE THE POINTER IN "initPSG" FUNCTION
822E:         	SERIALS_EN      equ     CONTROLKEYS+$01 ; (1) serial ports status: bit 0 for Port1(A), bit 1 for Port2(B): 0=OFF, 1=ON
822F:         	SERABITS        equ     SERIALS_EN+$01  ; (1) serial port A data bits
8230:         	PBUFF           equ     SERABITS+$01    ; (13) Number print buffer
823D:         	MULVAL          equ     PBUFF+$0D       ; (3) Multiplier
8240:         	PROGST          equ     MULVAL+$03      ; (100) Start of program text area
82A4:         	STLOOK          equ     PROGST+$64      ; Start of memory test
              	
              	; BASIC ERROR CODE VALUES
              	; These values act as an offset to point to the error message into the error table
              	; must be incremented by 2 because they point to a word address jump
0000:         	NF              equ     $00             ; NEXT without FOR
0002:         	SN              equ     $02             ; Syntax error
0004:         	RG              equ     $04             ; RETURN without GOSUB
0006:         	OD              equ     $06             ; Out of DATA
0008:         	FC              equ     $08             ; Function call error
000A:         	OV              equ     $0A             ; Overflow
000C:         	OM              equ     $0C             ; Out of memory
000E:         	UL              equ     $0E             ; Undefined line number
0010:         	BS              equ     $10             ; Bad subscript
0012:         	DD              equ     $12             ; Re-Dimensioned array
0014:         	DZ              equ     $14             ; Division by zero (/0)
0016:         	ID              equ     $16             ; Illegal direct
0018:         	TM              equ     $18             ; Type mis-match
001A:         	OS              equ     $1A             ; Out of string space
001C:         	LS              equ     $1C             ; String too long
001E:         	ST              equ     $1E             ; String formula too complex
0020:         	CN              equ     $20             ; Can't continue
0022:         	UF              equ     $22             ; Undefined FN function
0024:         	MO              equ     $24             ; Missing operand
0026:         	HX              equ     $26             ; HEX error
0028:         	BN              equ     $28             ; BIN error
002A:         	GM              equ     $2A             ; No Graphics Mode
002C:         	SC              equ     $2C             ; Serial configuration
002E:         	SA              equ     $2E             ; Serial port already open
0030:         	HP              equ     $30             ; HELP call
              	
0EF2: C3F80E  	COLD:   jp      STARTB          ; Jump for cold start
0EF5: C3900F  	WARM:   jp      WARMST          ; Jump for warm start
              	
0EF8: C3FF0E  	STARTB: jp      CSTART          ; Jump to initialise
0EFB: 201B    	        defw    DEINT           ; Get integer -32768 to 32767
0EFD: C922    	        defw    ABPASS          ; Return integer in AB
0EFF: 215E80  	CSTART: ld      HL,WRKSPC       ; Start of workspace RAM
0F02: F9      	        ld      SP,HL           ; Set up a temporary stack
0F03: C3B03D  	        jp      INITST          ; Go to initialise
              	
0F06: 210014  	INIT:   ld      HL,INITAB       ; Initialise workspace
0F09: 01DA00  	        ld      BC,INITBE-INITAB+3; Bytes to copy
0F0C: 115E80  	        ld      DE,WRKSPC       ; Into workspace RAM
0F0F: EDB0    	        ldir                    ; Copy data
0F11: EB      	        ex      DE,HL           ; Copy DE into HL
0F12: F9      	        ld      SP,HL           ; Temporary stack
0F13: CDB116  	        call    CLREG           ; Clear registers and stack
0F16: CD231D  	        call    PRNTCRLF        ; Output CRLF
0F19: 328F81  	        ld      (BUFFER+88+1),A ; Mark end of buffer
0F1C: 324082  	        ld      (PROGST),A      ; Initialise program area
0F1F: 1810    	        jr      MNOASK          ; usually, don't ask for memory top (only when there are errors)
0F21: 21DA0F  	MSIZE:  ld      HL,MEMMSG       ; Point to message
0F24: CDE723  	        call    PRS             ; Output "Memory size"
0F27: CDCE16  	        call    PROMPT          ; Get input with '?'
0F2A: CD6A1A  	        call    GETCHR          ; Get next character
0F2D: B7      	        or      A               ; Set flags
0F2E: C2460F  	        jp      NZ,TSTMEM       ; If number - Test if RAM there
0F31: 21A482  	MNOASK: ld      HL,STLOOK       ; Point to start of RAM
0F34: 23      	MLOOP:  inc     HL              ; Next byte
0F35: 7C      	        ld      A,H             ; Above address FFFF ?
0F36: B5      	        or      L
0F37: CA580F  	        jp      Z,SETTOP        ; Yes - 64K RAM
0F3A: 7E      	        ld      A,(HL)          ; Get contents
0F3B: 47      	        ld      B,A             ; Save it
0F3C: 2F      	        cpl                     ; Flip all bits
0F3D: 77      	        ld      (HL),A          ; Put it back
0F3E: BE      	        cp      (HL)            ; RAM there if same
0F3F: 70      	        ld      (HL),B          ; Restore old contents
0F40: CA340F  	        jp      Z,MLOOP         ; If RAM - test next byte
0F43: C3580F  	        jp      SETTOP          ; Top of RAM found
              	
0F46: CD3A1B  	TSTMEM: call    ATOH            ; Get high memory into DE
0F49: B7      	        or      A               ; Set flags on last byte
0F4A: C26515  	        jp      NZ,SNERR        ; ?SN Error if bad character
0F4D: EB      	        ex      DE,HL           ; Address into HL
0F4E: 2B      	        dec     HL              ; Back one byte
0F4F: 3ED9    	        ld      A,%11011001     ; Test byte
0F51: 46      	        ld      B,(HL)          ; Get old contents
0F52: 77      	        ld      (HL),A          ; Load test byte
0F53: BE      	        cp      (HL)            ; RAM there if same
0F54: 70      	        ld      (HL),B          ; Restore old contents
0F55: C2210F  	        jp      NZ,MSIZE        ; Ask again if no RAM
              	
0F58: 2B      	SETTOP: dec     HL              ; Back one byte
0F59: 11A382  	        ld      DE,STLOOK-1     ; See if enough RAM
0F5C: CD4118  	        call    CPDEHL          ; Compare DE with HL
0F5F: DA210F  	        jp      C,MSIZE         ; Ask again if not enough RAM
0F62: 119CFF  	        ld      DE,0-100        ; 100 Bytes string space
0F65: 229481  	        ld      (LSTRAM),HL     ; Save last available RAM
0F68: 19      	        add     HL,DE           ; Allocate string space
0F69: 22AD80  	        ld      (STRSPC),HL     ; Save string space
0F6C: CD8C16  	        call    CLRPTR          ; Clear program area
0F6F: 2AAD80  	        ld      HL,(STRSPC)     ; Get end of memory
0F72: 11EFFF  	        ld      DE,0-17         ; Offset for free bytes
0F75: 19      	        add     HL,DE           ; Adjust HL
0F76: 114082  	        ld      DE,PROGST       ; Start of program text
0F79: 7D      	        ld      A,L             ; Get LSB
0F7A: 93      	        sub     E               ; Adjust it
0F7B: 6F      	        ld      L,A             ; Re-save
0F7C: 7C      	        ld      A,H             ; Get MSB
0F7D: 9A      	        sbc     A,D             ; Adjust it
0F7E: 67      	        ld      H,A             ; Re-save
0F7F: E5      	        push    HL              ; Save bytes free
0F80: 21A90F  	        ld      HL,SIGNON       ; Sign-on message
0F83: CDE723  	        call    PRS             ; Output string
0F86: E1      	        pop     HL              ; Get bytes free back
0F87: CD872E  	        call    PRNTHL          ; Output amount of free memory
0F8A: 219C0F  	        ld      HL,BFREE        ; " Bytes free" message
0F8D: CDE723  	        call    PRS             ; Output string
              	
0F90: 313B81  	WARMST: ld      SP,STACK        ; Temporary stack
0F93: CDB116  	BRKRET: call    CLREG           ; Clear registers and stack
0F96: CD5A08  	        call    CURSOR_ON       ; enable cursor
0F99: C3BF15  	        jp      PRNTOK          ; Go to get command line
              	
0F9C: 20427974	BFREE:  defb    " Bytes free",CR,0
0FA0: 65732066	
0FA4: 7265650D	
0FA8: 00      	
              	
0FA9: 5A383020	SIGNON: defb    "Z80 BASIC Ver 4.8",CR
0FAD: 42415349	
0FB1: 43205665	
0FB5: 7220342E	
0FB9: 380D    	
0FBB: 436F7079	        defb    "Copyright ",251," 1978"
0FBF: 72696768	
0FC3: 7420FB20	
0FC7: 31393738	
0FCB: 20627920	        defb    " by Microsoft",CR,0
0FCF: 4D696372	
0FD3: 6F736F66	
0FD7: 740D00  	
              	
0FDA: 4D656D6F	MEMMSG: defb    "Memory top",0
0FDE: 72792074	
0FE2: 6F7000  	
              	
              	; The following list reports all the functions supported by the interpreter.
              	; To add a custom function, the user must first insert the reserved word here,
              	; then into the list of the reserved words below, and finally must increment the
              	; ZSGN token value and all the following ones after ZSGN by 1 for every added
              	; function.
              	
              	; FUNCTION ADDRESS TABLE (this is a sort of offset table)
              	; this list must be coherent with the tokens' functions list. This means that every
              	; entry here must have the corresponding entry in the tokens list.
0FE5: FC2C    	FNCTAB: defw    SGN
0FE7: 9122    	        defw    TMR         ; added by Leonardo Miliani
0FE9: C02D    	        defw    INT
0FEB: 122D    	        defw    ABS
0FED: 6480    	        defw    USR
0FEF: A722    	        defw    FRE
0FF1: 2227    	        defw    INP
0FF3: D522    	        defw    POS
0FF5: 862F    	        defw    SQR
0FF7: 6530    	        defw    RND
0FF9: 502B    	        defw    LOG
0FFB: D42F    	        defw    EXP
0FFD: DA30    	        defw    COS
0FFF: E030    	        defw    SIN
1001: 4131    	        defw    TAN
1003: 5631    	        defw    ATN
1005: FE27    	        defw    PEEK
1007: C131    	        defw    DEEK
1009: 0528    	        defw    VPEEK       ; added by Leonardo Miliani
100B: D529    	        defw    VSTAT       ; added by Leonardo Miliani
100D: E029    	        defw    SSTAT       ; added by Leonardo Miliani
100F: F429    	        defw    INKEY       ; added by Leonardo Miliani
1011: 2935    	        defw    POINT       ; added by Leonardo Miliani
1013: B925    	        defw    INSTR       ; added by Leonardo Miliani
1015: 5925    	        defw    LEN
1017: 7123    	        defw    STR
1019: E926    	        defw    VAL
101B: 6825    	        defw    ASC
101D: 7925    	        defw    CHR
101F: AB3C    	        defw    HEX         ; added by Grant Searle
1021: 3C3D    	        defw    BIN         ; added by Grant Searle
1023: 8925    	        defw    LEFT
1025: AF26    	        defw    RIGHT
1027: B926    	        defw    MID
              	
              	; RESERVED WORD LIST
              	; Here are all the reserved words used by the interpreter
              	; To add custom functions/commands, the user must insert the keyword
              	; in this list, following the schematic
1029: C54E44  	WORDS:  defb    'E'+$80,"ND"            ; from here the list contains the COMMANDS
102C: C64F52  	        defb    'F'+$80,"OR"
102F: CE455854	        defb    'N'+$80,"EXT"
1033: C4415441	        defb    'D'+$80,"ATA"
1037: C94E5055	        defb    'I'+$80,"NPUT"
103B: 54      	
103C: C4494D  	        defb    'D'+$80,"IM"
103F: D2454144	        defb    'R'+$80,"EAD"
1043: CC4554  	        defb    'L'+$80,"ET"
1046: C74F544F	        defb    'G'+$80,"OTO"
104A: D2554E  	        defb    'R'+$80,"UN"
104D: C946    	        defb    'I'+$80,"F"
104F: D2455354	        defb    'R'+$80,"ESTORE"
1053: 4F5245  	
1056: C74F5355	        defb    'G'+$80,"OSUB"
105A: 42      	
105B: D2455455	        defb    'R'+$80,"ETURN"
105F: 524E    	
1061: D2454D  	        defb    'R'+$80,"EM"
1064: D3544F50	        defb    'S'+$80,"TOP"
1068: CF5554  	        defb    'O'+$80,"UT"
106B: CF4E    	        defb    'O'+$80,"N"
106D: CE554C4C	        defb    'N'+$80,"ULL"
1071: D7414954	        defb    'W'+$80,"AIT"
1075: C44546  	        defb    'D'+$80,"EF"
1078: D04F4B45	        defb    'P'+$80,"OKE"
107C: C44F4B45	        defb    'D'+$80,"OKE"
1080: D6504F4B	        defb    'V'+$80,"POKE"          ; added by Leonardo Miliani
1084: 45      	
1085: D3524547	        defb    'S'+$80,"REG"           ; added by Leonardo Miliani
1089: D6524547	        defb    'V'+$80,"REG"           ; added by Leonardo Miliani
108D: D3435245	        defb    'S'+$80,"CREEN"         ; changed by Leonardo Miliani
1091: 454E    	
1093: CC4F4341	        defb    'L'+$80,"OCATE"         ; added by Leonardo Miliani
1097: 5445    	
1099: D34F554E	        defb    'S'+$80,"OUND"          ; added by Leonardo Miliani
109D: 44      	
109E: D64F4C55	        defb    'V'+$80,"OLUME"         ; added by Leonardo Miliani
10A2: 4D45    	
10A4: D0415553	        defb    'P'+$80,"AUSE"          ; added by Leonardo Miliani
10A8: 45      	
10A9: C34F4C4F	        defb    'C'+$80,"OLOR"          ; added by Leonardo Miliani
10AD: 52      	
10AE: D04C4F54	        defb    'P'+$80,"LOT"           ; added by Leonardo Miliani
10B2: C4524157	        defb    'D'+$80,"RAW"           ; added by Leonardo Miliani
10B6: C3495243	        defb    'C'+$80,"IRCLE"         ; added by Leonardo Miliani
10BA: 4C45    	
10BC: D041494E	        defb    'P'+$80,"AINT"          ; added by Leonardo Miliani
10C0: 54      	
10C1: D3455249	        defb    'S'+$80,"ERIAL"         ; added by Leonardo Miliani
10C5: 414C    	
10C7: C8454C50	        defb    'H'+$80,"ELP"           ; changed by Leonardo Miliani - was LINES
10CB: C34C53  	        defb    'C'+$80,"LS"            ; restored command
10CE: CB4559  	        defb    'K'+$80,"EY"            ; added by Leonardo Miliani
10D1: CE4D49  	        defb    'N'+$80,"MI"            ; added by Leonardo Miliani
10D4: C7505249	        defb    'G'+$80,"PRINT"         ; added by Leonardo Miliani
10D8: 4E54    	
10DA: D7494454	        defb    'W'+$80,"IDTH"
10DE: 48      	
10DF: D35953  	        defb    'S'+$80,"YS"            ; added by Leonardo Miliani
10E2: D2455345	        defb    'R'+$80,"ESET"          ; changed by Leonardo Miliani
10E6: 54      	
10E7: D052494E	        defb    'P'+$80,"RINT"
10EB: 54      	
10EC: C34F4E54	        defb    'C'+$80,"ONT"
10F0: CC495354	        defb    'L'+$80,"IST"
10F4: C34C4541	        defb    'C'+$80,"LEAR"
10F8: 52      	
10F9: C34C4F41	        defb    'C'+$80,"LOAD"
10FD: 44      	
10FE: C3534156	        defb    'C'+$80,"SAVE"
1102: 45      	
1103: CE4557  	        defb    'N'+$80,"EW"
1106: D4414228	        defb    'T'+$80,"AB("
110A: D44F    	        defb    'T'+$80,"O"
110C: C64E    	        defb    'F'+$80,"N"
110E: D3504328	        defb    'S'+$80,"PC("
1112: D448454E	        defb    'T'+$80,"HEN"
1116: CE4F54  	        defb    'N'+$80,"OT"
1119: D3544550	        defb    'S'+$80,"TEP"
              	        ; from here: operators
111D: AB      	        defb    '+'+$80
111E: AD      	        defb    '-'+$80
111F: AA      	        defb    '*'+$80
1120: AF      	        defb    '/'+$80
1121: A5      	        defb    '%'+$80
1122: A3      	        defb    '#'+$80
1123: DE      	        defb    '^'+$80
1124: C14E44  	        defb    'A'+$80,"ND"
1127: D84F52  	        defb    'X'+$80,"OR"
112A: CF52    	        defb    'O'+$80,"R"
112C: BE      	        defb    '>'+$80
112D: BD      	        defb    '='+$80
112E: BC      	        defb    '<'+$80
              	
              	        ; from here there are the tokens' FUNCTIONS list
              	        ; this list must be coherent with the functions list above
112F: D3474E  	        defb    'S'+$80,"GN"
1132: D44D52  	        defb    'T'+$80,"MR"            ; added by Leonardo Miliani
1135: C94E54  	        defb    'I'+$80,"NT"
1138: C14253  	        defb    'A'+$80,"BS"
113B: D55352  	        defb    'U'+$80,"SR"
113E: C65245  	        defb    'F'+$80,"RE"
1141: C94E50  	        defb    'I'+$80,"NP"
1144: D04F53  	        defb    'P'+$80,"OS"
1147: D35152  	        defb    'S'+$80,"QR"
114A: D24E44  	        defb    'R'+$80,"ND"
114D: CC4F47  	        defb    'L'+$80,"OG"
1150: C55850  	        defb    'E'+$80,"XP"
1153: C34F53  	        defb    'C'+$80,"OS"
1156: D3494E  	        defb    'S'+$80,"IN"
1159: D4414E  	        defb    'T'+$80,"AN"
115C: C1544E  	        defb    'A'+$80,"TN"
115F: D045454B	        defb    'P'+$80,"EEK"
1163: C445454B	        defb    'D'+$80,"EEK"
1167: D6504545	        defb    'V'+$80,"PEEK"          ; added by Leonardo Miliani
116B: 4B      	
116C: D6535441	        defb    'V'+$80,"STAT"          ; added by Leonardo Miliani
1170: 54      	
1171: D3535441	        defb    'S'+$80,"STAT"          ; added by Leonardo Miliani
1175: 54      	
1176: C94E4B45	        defb    'I'+$80,"NKEY"          ; added by Leonardo Miliani
117A: 59      	
117B: D04F494E	        defb    'P'+$80,"OINT"          ; added by Leonardo Miliani
117F: 54      	
1180: C94E5354	        defb    'I'+$80,"NSTR"          ; added by Leonardo Miliani
1184: 52      	
1185: CC454E  	        defb    'L'+$80,"EN"
1188: D3545224	        defb    'S'+$80,"TR$"
118C: D6414C  	        defb    'V'+$80,"AL"
118F: C15343  	        defb    'A'+$80,"SC"
1192: C3485224	        defb    'C'+$80,"HR$"
1196: C8455824	        defb    'H'+$80,"EX$"           ; added by Grant Searle
119A: C2494E24	        defb    'B'+$80,"IN$"           ; added by Grant Searle
119E: CC454654	        defb    'L'+$80,"EFT$"
11A2: 24      	
11A3: D2494748	        defb    'R'+$80,"IGHT$"
11A7: 5424    	
11A9: CD494424	        defb    'M'+$80,"ID$"
11AD: 80      	        defb    $80                     ; End-of-list marker
              	
              	; KEYWORD ADDRESS TABLE
              	; this list must be coherent with the commands'
              	; tokens list above
11AE: B41A    	WORDTB: defw    PEND
11B0: B119    	        defw    FOR
11B2: 941E    	        defw    NEXT
11B4: 0D1C    	        defw    DATA
11B6: 991D    	        defw    INPUT
11B8: E920    	        defw    DIM
11BA: CB1D    	        defw    READ
11BC: 241C    	        defw    LET
11BE: CA1B    	        defw    GOTO
11C0: A51B    	        defw    RUN
11C2: 9C1C    	        defw    IF
11C4: 7A1A    	        defw    RESTOR
11C6: B91B    	        defw    GOSUB
11C8: E81B    	        defw    RETURN
11CA: 0F1C    	        defw    REM
11CC: B21A    	        defw    STOP
11CE: 2E27    	        defw    POUT
11D0: 7E1C    	        defw    ON
11D2: 0F1C    	        defw    REM         ; removed - was NULL
11D4: 3427    	        defw    WAIT
11D6: DD22    	        defw    DEF
11D8: 2828    	        defw    POKE
11DA: CC31    	        defw    DOKE
11DC: 2D28    	        defw    VPOKE       ; added by Leonardo Miliani
11DE: 6A28    	        defw    SREG        ; added by Leonardo Miliani
11E0: B929    	        defw    VREG        ; added by Leonardo Miliani
11E2: 0232    	        defw    SCREEN      ; mod function: now it sets up a graphics mode (Leonardo Miliani)
11E4: 3828    	        defw    LOCATE      ; added by Leonardo Miliani
11E6: C428    	        defw    SOUND       ; added by Leonardo Miliani
11E8: 8B28    	        defw    VOLUME      ; added by Leonardo Miliani
11EA: E331    	        defw    PAUSE       ; added by Leonardo Miliani
11EC: 7D32    	        defw    COLOR       ; added by Leonardo Miliani
11EE: 7C35    	        defw    PLOT        ; added by Leonardo Miliani
11F0: 0F36    	        defw    DRAW        ; added by Leonardo Miliani
11F2: 4537    	        defw    CIRCLE      ; added by Leonardo Miliani
11F4: 2A34    	        defw    PAINT       ; added by Leonardo Miliani
11F6: 4A39    	        defw    SERIAL      ; added by Leonardo Miliani
11F8: 453B    	        defw    HELP        ; changed by Leonardo Miliani - was LINES
11FA: A531    	        defw    CLS
11FC: 603B    	        defw    KEY         ; added by Leonardo Miliani
11FE: 7627    	        defw    NMI         ; added by Leonardo Miliani
1200: 3933    	        defw    GPRINT      ; added by Leonardo Miliani
1202: B931    	        defw    WIDTH
1204: D027    	        defw    SYS         ; added by Leonardo Miliani
1206: A13D    	        defw    RESET       ; new behaviour: now it resets the system
1208: C01C    	        defw    PRINT
120A: E61A    	        defw    CONT
120C: A618    	        defw    LIST
120E: 5F1B    	        defw    CLEAR
1210: 0F1C    	        defw    REM         ; not implemented (was CLOAD)
1212: 0F1C    	        defw    REM         ; not implemented (was CSAVE)
1214: 8B16    	        defw    NEW
              	
              	; RESERVED WORD TOKEN VALUES
              	; if you add a function or command you must increment by 1
              	; the values below. Pay attention that you must increment only the
              	; values AFTER the position where you entered the function/command word
              	; in the "Reserver word list" above. I.E.: VPOKE has been added between
              	; DOKE and SCREEN, and since REM is the reserved work listed below
              	; that is before the point where VPOKE has been entered, every entry
              	; after REM has been incremented.
              	; Another example: when TMR has been added, since it's a function, every
              	; entry after & included ZSGN must be checked (read below)
              	
0080:         	ZEND    equ     $80             ; END        <-- from here, there are the commands
0081:         	ZFOR    equ     $81             ; FOR
0083:         	ZDATA   equ     $83             ; DATA
0088:         	ZGOTO   equ     $88             ; GOTO
008C:         	ZGOSUB  equ     $8C             ; GOSUB
008E:         	ZREM    equ     $8E             ; REM
00AD:         	ZPRINT  equ     $AD             ; PRINT
00B3:         	ZNEW    equ     $B3             ; NEW
              	
00B4:         	ZTAB    equ     $B4             ; TAB
00B5:         	ZTO     equ     $B5             ; TO
00B6:         	ZFN     equ     $B6             ; FN
00B7:         	ZSPC    equ     $B7             ; SPC
00B8:         	ZTHEN   equ     $B8             ; THEN
00B9:         	ZNOT    equ     $B9             ; NOT
00BA:         	ZSTEP   equ     $BA             ; STEP
              	
00BB:         	ZPLUS   equ     $BB             ; +         <-- from here, there are the math operators
00BC:         	ZMINUS  equ     $BC             ; -
00BD:         	ZTIMES  equ     $BD             ; *
00BE:         	ZDIV    equ     $BE             ; /
00BF:         	ZMOD    equ     $BF             ; %
00C0:         	ZDINT   equ     $C0             ; #
00C4:         	ZOR     equ     $C4             ; OR
00C5:         	ZGTR    equ     $C5             ; >
00C6:         	ZEQUAL  equ     $C6             ; M
00C7:         	ZLTH    equ     $C7             ; <
              	
00C8:         	ZSGN    equ     $C8             ; SGN       <-- from here, there are the functions
00DE:         	ZPOINT  equ     $DE             ; ZPOINT    <-- if the user enters a custom function, between
              	                                ;               SGN and POINT, he/she must increment this pointer by 1
00DF:         	ZINSTR  equ     $DF             ; ZINSTR    <-- same here
00E7:         	ZLEFT   equ     $E7             ; LEFT$     <-- if the user enters a custom function anywhere,
              	                                ;               he/she must increment this pointer by 1
              	
              	; ARITHMETIC PRECEDENCE TABLE
              	; in the formulas below, <last> is a number stored into the stack that must be retrieved
              	; with POP BC, POP DE; FPREG is a f.p. number store into the RAM register FPREG
1216: 79      	PRITAB: defb    $79             ; Precedence value
1217: 6E2E    	        defw    PADD            ; FPREG = <last> + FPREG
              	
1219: 79      	        defb    $79             ; Precedence value
121A: 512A    	        defw    PSUB            ; FPREG = <last> - FPREG
              	
121C: 7C      	        defb    $7C             ; Precedence value
121D: 8F2B    	        defw    MULT            ; PPREG = <last> * FPREG
              	
121F: 7C      	        defb    $7C             ; Precedence value
1220: 412C    	        defw    DIV             ; FPREG = <last> / FPREG
              	
1222: 7C      	        defb    $7C             ; Precedence value
1223: EC2B    	        defw    MOD             ; FPREG = INT(<last>)-(INT(FPREG)*INT(<last>/FPREG))
              	
1225: 7C      	        defb    $7C             ; precedence value
1226: E42B    	        defw    DINT            ; FPREG = INT(<last> / FPREG )
              	
1228: 7F      	        defb    $7F             ; Precedence value
1229: 8F2F    	        defw    POWER           ; FPREG = <last> ^ FPREG
              	
122B: 50      	        defb    $50             ; Precedence value
122C: 3220    	        defw    PAND            ; FPREG = <last> AND FPREG
              	
122E: 4A      	        defb    $4A             ; Precedence value
122F: 3A20    	        defw    PXOR            ; FPREG = <last> XOR FPREG
              	
1231: 46      	        defb    $46             ; Precedence value
1232: 3520    	        defw    POR             ; FPREG = <last> OR FPREG
              	
              	; BASIC ERROR CODE LIST
              	
1234:         	ERRORS  equ $
1234: 4E455854	NFMSG:  defb    "NEXT Without FOR",0
1238: 20576974	
123C: 686F7574	
1240: 20464F52	
1244: 00      	
1245: 53796E74	SNMSG:  defb    "Syntax",0
1249: 617800  	
124C: 52455455	RGMSG:  defb    "RETURN without GOSUB",0
1250: 524E2077	
1254: 6974686F	
1258: 75742047	
125C: 4F535542	
1260: 00      	
1261: 4F757420	ODMSG:  defb    "Out of DATA",0
1265: 6F662044	
1269: 41544100	
126D: 496C6C65	FCMSG:  defb    "Illegal Function Call",0
1271: 67616C20	
1275: 46756E63	
1279: 74696F6E	
127D: 2043616C	
1281: 6C00    	
1283: 4F766572	OVMSG:  defb    "Overflow",0
1287: 666C6F77	
128B: 00      	
128C: 4F757420	OMMSG:  defb    "Out of Memory",0
1290: 6F66204D	
1294: 656D6F72	
1298: 7900    	
129A: 556E6465	ULMSG:  defb    "Undefined Line",0
129E: 66696E65	
12A2: 64204C69	
12A6: 6E6500  	
12A9: 42616420	BSMSG:  defb    "Bad Subscript",0
12AD: 53756273	
12B1: 63726970	
12B5: 7400    	
12B7: 52652D44	DDMSG:  defb    "Re-Dimensioned Array",0
12BB: 696D656E	
12BF: 73696F6E	
12C3: 65642041	
12C7: 72726179	
12CB: 00      	
12CC: 44697669	DZMSG:  defb    "Division by Zero",0
12D0: 73696F6E	
12D4: 20627920	
12D8: 5A65726F	
12DC: 00      	
12DD: 496C6C65	IDMSG:  defb    "Illegal Direct",0
12E1: 67616C20	
12E5: 44697265	
12E9: 637400  	
12EC: 54797065	TMMSG:  defb    "Type Mis-match",0
12F0: 204D6973	
12F4: 2D6D6174	
12F8: 636800  	
12FB: 4F757420	OSMSG:  defb    "Out of String Space",0
12FF: 6F662053	
1303: 7472696E	
1307: 67205370	
130B: 61636500	
130F: 53747269	LSMSG:  defb    "String Too Long",0
1313: 6E672054	
1317: 6F6F204C	
131B: 6F6E6700	
131F: 53747269	STMSG:  defb    "String Formula Too Complex",0
1323: 6E672046	
1327: 6F726D75	
132B: 6C612054	
132F: 6F6F2043	
1333: 6F6D706C	
1337: 657800  	
133A: 43616E27	CNMSG:  defb    "Can't Continue",0
133E: 7420436F	
1342: 6E74696E	
1346: 756500  	
1349: 556E6465	UFMSG:  defb    "Undefined FN Function",0
134D: 66696E65	
1351: 6420464E	
1355: 2046756E	
1359: 6374696F	
135D: 6E00    	
135F: 4D697373	MOMSG:  defb    "Missing Operand",0
1363: 696E6720	
1367: 4F706572	
136B: 616E6400	
136F: 48455820	HXMSG:  defb    "HEX Format",0
1373: 466F726D	
1377: 617400  	
137A: 42494E20	BNMSG:  defb    "BIN Format",0
137E: 466F726D	
1382: 617400  	
1385: 4E6F2047	GMMSG:  defb    "No Graphics Mode",0
1389: 72617068	
138D: 69637320	
1391: 4D6F6465	
1395: 00      	
1396: 53657269	SCMSG:  defb    "Serial Configuration",0
139A: 616C2043	
139E: 6F6E6669	
13A2: 67757261	
13A6: 74696F6E	
13AA: 00      	
13AB: 53657269	SAMSG:  defb    "Serial Port Already Open",0
13AF: 616C2050	
13B3: 6F727420	
13B7: 416C7265	
13BB: 61647920	
13BF: 4F70656E	
13C3: 00      	
13C4: 48454C50	HPMSG:  defb    "HELP Call",0
13C8: 2043616C	
13CC: 6C00    	
              	
13CE:         	ERRTBL  equ $
13CE: 3412    	NFPTR   defw    NFMSG
13D0: 4512    	SNPTR   defw    SNMSG
13D2: 4C12    	RGPTR   defw    RGMSG
13D4: 6112    	ODPTR   defw    ODMSG
13D6: 6D12    	FCPTR   defw    FCMSG
13D8: 8312    	OVPTR   defw    OVMSG
13DA: 8C12    	OMPTR   defw    OMMSG
13DC: 9A12    	ULPTR   defw    ULMSG
13DE: A912    	BSPTR   defw    BSMSG
13E0: B712    	DDPTR   defw    DDMSG
13E2: CC12    	DZPTR   defw    DZMSG
13E4: DD12    	IDPTR   defw    IDMSG
13E6: EC12    	TMPTR   defw    TMMSG
13E8: FB12    	OSPTR   defw    OSMSG
13EA: 0F13    	LSPTR   defw    LSMSG
13EC: 1F13    	STPTR   defw    STMSG
13EE: 3A13    	CNPTR   defw    CNMSG
13F0: 4913    	UFPTR   defw    UFMSG
13F2: 5F13    	MOPTR   defw    MOMSG
13F4: 6F13    	HXPTR   defw    HXMSG
13F6: 7A13    	BNPTR   defw    BNMSG
13F8: 8513    	GMPRT   defw    GMMSG
13FA: 9613    	SCPTR   defw    SCMSG
13FC: AB13    	SAPTR   defw    SAMSG
13FE: C413    	HPPTR   defw    HPMSG
              	
              	; INITIALISATION TABLE -------------------------------------------------------
              	; these values are copied into RAM at startup
1400: C3900F  	INITAB: jp      WARMST          ; Warm start jump
1403: ED4500  	        defb    $ED,$45,$00     ; RETN + NOP for default NMI service routine
1406: C3351B  	        jp      FCERR           ; "USR (X)" jump (Set to Error)
1409: D300    	        out     (0),A           ; "out p,n" skeleton
140B: C9      	        ret
140C: D600    	        sub     $00             ; Division support routine
140E: 6F      	        ld      L,A
140F: 7C      	        ld      A,H
1410: DE00    	        sbc     A,$00
1412: 67      	        ld      H,A
1413: 78      	        ld      A,B
1414: DE00    	        sbc     A,$00
1416: 47      	        ld      B,A
1417: 3E00    	        ld      A,$00
1419: C9      	        ret
141A: 000000  	        defb    $00,$00,$00     ; Random number seed table used by RND
141D: 354ACA99	        defb    $35,$4A,$CA,$99 ;-2.65145E+07
1421: 391C7698	        defb    $39,$1C,$76,$98 ; 1.61291E+07
1425: 2295B398	        defb    $22,$95,$B3,$98 ;-1.17691E+07
1429: 0ADD4798	        defb    $0A,$DD,$47,$98 ; 1.30983E+07
142D: 53D19999	        defb    $53,$D1,$99,$99 ;-2-01612E+07
1431: 0A1A9F98	        defb    $0A,$1A,$9F,$98 ;-1.04269E+07
1435: 65BCCD98	        defb    $65,$BC,$CD,$98 ;-1.34831E+07
1439: D6773E98	        defb    $D6,$77,$3E,$98 ; 1.24825E+07
143D: 52C74F80	        defb    $52,$C7,$4F,$80 ; Last random number
1441: DB00    	        in      A,($00)         ; INP (x) skeleton
1443: C9      	        ret
1444: FF      	        defb    $FF             ; Terminal width (255 = no auto CRLF)
1445: 14      	        defb    $14             ; Width for commas (at reset, 3 columns, for G1 mode)
1446: 00      	        defb    $00             ; No nulls after input bytes
1447: 00      	        defb    $00             ; Output enabled (^O off)
1448: 0000    	        defw    $00             ; Array load/save check sum
144A: 00      	        defb    $00             ; Break not by NMI
144B: 00      	        defb    $00             ; Break flag
144C: C3C717  	        jp      TTYLIN          ; Input reflection (set to TTY)
144F: A482    	        defw    STLOOK          ; Temp string space
1451: FEFF    	        defw    -2              ; Current line number (cold)
1453: FFFF    	        defw    -1              ; Current line with errors (no errors)
1455: 4C495354	DEFFNKS:defm    "LIST",13,0,0,0,0,0,0,0,0,0,0,0     ; KEY 1
1459: 0D000000	
145D: 00000000	
1461: 00000000	
1465: 52554E0D	        defm    "RUN",13,0,0,0,0,0,0,0,0,0,0,0,0    ; KEY 2
1469: 00000000	
146D: 00...   	
1475: 53435245	        defm    "SCREEN1",13,0,0,0,0,0,0,0,0        ; KEY 3
1479: 454E310D	
147D: 00000000	
1481: 00000000	
1485: 434F4C4F	        defm    "COLOR1,15,5",13,0,0,0,0            ; KEY 4
1489: 52312C31	
148D: 352C350D	
1491: 00000000	
1495: 53455249	        defm    "SERIAL1,38400",13,0,0              ; KEY 5
1499: 414C312C	
149D: 33383430	
14A1: 300D0000	
14A5: 53435245	        defm    "SCREEN2",13,0,0,0,0,0,0,0,0        ; KEY 6
14A9: 454E320D	
14AD: 00000000	
14B1: 00000000	
14B5: 434F4E54	        defm    "CONT",13,0,0,0,0,0,0,0,0,0,0,0     ; KEY 7
14B9: 0D000000	
14BD: 00000000	
14C1: 00000000	
14C5: 48454C50	        defm    "HELP",13,0,0,0,0,0,0,0,0,0,0,0     ; KEY 8 (HELP KEY)
14C9: 0D000000	
14CD: 00000000	
14D1: 00000000	
14D5: 4182    	        defw    PROGST+1        ; Start of program text
14D7:         	INITBE:
              	
              	; END OF INITIALISATION TABLE ---------------------------------------------------
              	
14D7: 20457272	ERRMSG: defb    " Error",0
14DB: 6F7200  	
14DE: 20696E20	INMSG:  defb    " in ",0
14E2: 00      	
14E2:         	ZERBYT  equ     $-1             ; A zero byte
14E3: 4F6B0D00	OKMSG:  defb    "Ok",CR,0,0
14E7: 00      	
14E8: 42726561	BRKMSG: defb    "Break",0
14EC: 6B00    	
              	
14EE: 210400  	BAKSTK: ld      HL,$04          ; Look for "FOR" block with
14F1: 39      	        add     HL,SP           ; same index as specified
14F2: 7E      	LOKFOR: ld      A,(HL)          ; Get block ID
14F3: 23      	        inc     HL              ; Point to index address
14F4: FE81    	        cp      ZFOR            ; Is it a "FOR" token
14F6: C0      	        ret     NZ              ; No - exit
14F7: 4E      	        ld      C,(HL)          ; BC = Address of "FOR" index
14F8: 23      	        inc     HL
14F9: 46      	        ld      B,(HL)
14FA: 23      	        inc     HL              ; Point to sign of STEP
14FB: E5      	        push    HL              ; Save pointer to sign
14FC: 69      	        ld      L,C             ; HL = address of "FOR" index
14FD: 60      	        ld      H,B
14FE: 7A      	        ld      A,D             ; See if an index was specified
14FF: B3      	        or      E               ; DE = 0 if no index specified
1500: EB      	        ex      DE,HL           ; Specified index into HL
1501: CA0815  	        jp      Z,INDFND        ; Skip if no index given
1504: EB      	        ex      DE,HL           ; Index back into DE
1505: CD4118  	        call    CPDEHL          ; Compare index with one given
1508: 010D00  	INDFND: ld      BC,16-3         ; Offset to next block
150B: E1      	        pop     HL              ; Restore pointer to sign
150C: C8      	        ret     Z               ; Return if block found
150D: 09      	        add     HL,BC           ; Point to next block
150E: C3F214  	        jp      LOKFOR          ; Keep on looking
              	
1511: CD2B15  	MOVUP:  call    ENFMEM          ; See if enough memory
1514: C5      	MOVSTR: push    BC              ; Save end of source
1515: E3      	        ex      (SP),HL         ; Swap source and dest" end
1516: C1      	        pop     BC              ; Get end of destination
1517: CD4118  	MOVLP:  call    CPDEHL          ; See if list moved
151A: 7E      	        ld      A,(HL)          ; Get byte
151B: 02      	        ld      (BC),A          ; Move it
151C: C8      	        ret     Z               ; Exit if all done
151D: 0B      	        dec     BC              ; Next byte to move to
151E: 2B      	        dec     HL              ; Next byte to move
151F: C31715  	        jp      MOVLP           ; Loop until all bytes moved
              	
1522: E5      	CHKSTK: push    HL              ; Save code string address
1523: 2ABF81  	        ld      HL,(ARREND)     ; Lowest free memory
1526: 0600    	        ld      B,$00           ; BC = Number of levels to test
1528: 09      	        add     HL,BC           ; 2 Bytes for each level
1529: 09      	        add     HL,BC
152A: 3E      	        defb    $3E             ; Skip "push HL"
152B: E5      	ENFMEM: push    HL              ; Save code string address
152C: 3ED0    	        ld      A,$D0           ; LOW -48 ; 48 Bytes minimum RAM
152E: 95      	        sub     L
152F: 6F      	        ld      L,A
1530: 3EFF    	        ld      A,$FF           ; HIGH (-48) ; 48 Bytes minimum RAM
1532: 9C      	        sbc     A,H
1533: DA3A15  	        jp      C,OMERR         ; Not enough - ?OM Error
1536: 67      	        ld      H,A
1537: 39      	        add     HL,SP           ; Test if stack is overflowed
1538: E1      	        pop     HL              ; Restore code string address
1539: D8      	        ret     C               ; Return if enough memory
153A: 1E0C    	OMERR:  ld      E,OM            ; ?OM Error
153C: C37915  	        jp      ERROR
              	
              	
              	; if in graphics mode, return to text (called by "NOLIN" and "ERROR")
153F: F5      	EXITGM: push    AF              ; store AF
1540: 3AE081  	        ld      A,(SCR_MODE)    ; check screen mode
1543: FE02    	        cp      $02             ; G2?
1545: CA4C15  	        jp      Z,LDG1          ; yes, back to G1
1548: FE03    	        cp      $03             ; G3?
154A: 2011    	        jr      NZ,LDG1ND       ; no, so return
154C: E5      	LDG1:   push    HL              ; store HL
154D: D5      	        push    DE              ; store DE
154E: 110100  	        ld      DE,$0001        ; sprites set to defaults, G1 mode
1551: F3      	        di                      ; disable INTs
1552: CD7E03  	        call    initVDP         ; initialize VDP with mode pointed by E
1555: FB      	        ei                      ; re-enable INTs
1556: 3E01    	        ld      A,$01           ; activate the...
1558: 32EB81  	        ld      (PRNTVIDEO),A   ; ...video buffer...
155B: D1      	        pop     DE              ; retrieve DE
155C: E1      	        pop     HL              ; retrieve HL
155D: F1      	LDG1ND: pop     AF              ; retrieve AF
155E: C9      	        ret                     ; return to caller
              	
              	
155F: 2AAE81  	DATSNR: ld      HL,(DATLIN)     ; Get line of current DATA item
1562: 22AF80  	        ld      (LINEAT),HL     ; Save as current line
1565: 1E02    	SNERR:  ld      E,SN            ; ?SN Error
1567: 01      	        defb    $01             ; Skip "ld E,DZ"
1568: 1E14    	DZERR:  ld      E,DZ            ; ?/0 Error
156A: 01      	        defb    $01             ; Skip "ld E,NF"
156B: 1E00    	NFERR:  ld      E,NF            ; ?NF Error
156D: 01      	        defb    $01             ; Skip "ld E,DD"
156E: 1E12    	DDERR:  ld      E,DD            ; ?DD Error
1570: 01      	        defb    $01             ; Skip "ld E,UF"
1571: 1E22    	UFERR:  ld      E,UF            ; ?UF Error
1573: 01      	        defb    $01             ; Skip "ld E,OV
1574: 1E0A    	OVERR:  ld      E,OV            ; ?OV Error
1576: 01      	        defb    $01             ; Skip "ld E,TM"
1577: 1E18    	TMERR:  ld      E,TM            ; ?TM Error
              	
1579: CDB116  	ERROR:  call    CLREG           ; Clear registers and stack
157C: CD3F15  	        call    EXITGM          ; exit from graphic modes
157F: 32A580  	        ld      (CTLOFG),A      ; Enable output (A is 0)
1582: CD5A08  	        call    CURSOR_ON       ; enable cursor
1585: CD111D  	        call    STTLIN          ; Start new line
1588: 21CE13  	        ld      HL,ERRTBL       ; Point to error codes
158B: 57      	        ld      D,A             ; D = 0 (A is 0)
158C: 3E3F    	        ld      A,'?'
158E: CD5218  	        call    OUTC            ; Output '?'
1591: 19      	        add     HL,DE           ; Offset to correct error code
1592: 5E      	        ld      E,(HL)          ; load pointer to error message
1593: 23      	        inc     HL              ; by loading LSB,
1594: 56      	        ld      D,(HL)          ; then MSB
1595: 626B    	        ld      HL,DE           ; load pointer to HL
1597: CDE723  	        call    PRS             ; Output error message
159A: 21D714  	        ld      HL,ERRMSG       ; "Error" message
159D: CDE723  	ERRIN:  call    PRS             ; Output message
15A0: 2AAF80  	        ld      HL,(LINEAT)     ; Get line of error
15A3: 11FEFF  	        ld      DE,-2           ; Cold start error if -2
15A6: CD4118  	        call    CPDEHL          ; See if cold start error
15A9: CAFF0E  	        jp      Z,CSTART        ; Cold start error - Restart
15AC: 7C      	        ld      A,H             ; Was it a direct error?
15AD: A5      	        and     L               ; Line = -1 if direct error
15AE: 3C      	        inc     A
15AF: CABA15  	        jp      Z,PTLN          ; Yes, jump over
15B2: E5      	        push    HL              ; indirect mode - store HL
15B3: 2AAF80  	        ld      HL,(LINEAT)     ; copy current line number
15B6: 22B180  	        ld      (HLPLN),HL      ; save in HELP line register
15B9: E1      	        pop     HL              ; retrieve HL
15BA: C47F2E  	PTLN:   call    NZ,LINEIN       ; No - output line of error
              	
15BD: 3E      	        defb    $3E             ; Skip "pop BC"
15BE: C1      	POPNOK: pop     BC              ; Drop address in input buffer
              	
              	; run into direct mode: print OK and get command
15BF: AF      	PRNTOK: xor     A               ; Output "Ok" and get command
15C0: 32A580  	        ld      (CTLOFG),A      ; Enable output
15C3: CD111D  	        call    STTLIN          ; Start new line
15C6: 21E314  	        ld      HL,OKMSG        ; "Ok" message
15C9: CDE723  	        call    PRS             ; Output "Ok"
15CC: CD5A08  	GETCMD: call    CURSOR_ON       ; enable cursor
15CF: 21FFFF  	        ld      HL,-1           ; Flag direct mode
15D2: 22AF80  	        ld      (LINEAT),HL     ; Save as current line
15D5: CDC717  	        call    GETLIN          ; Get an input line
15D8: DACC15  	        jp      C,GETCMD        ; Get line again if break
15DB: CD6A1A  	        call    GETCHR          ; Get first character
15DE: 17      	        rla                     ; 8th bit is copied into carry and original carry is copied into bit 0)
15DF: DA6515  	        jp      C,SNERR         ; if char >=128 (8th bit set) then raise an error
15E2: 1F      	        rra                     ; recover original char and Carry
15E3: 3C      	        inc     A               ; Test if end of line
15E4: 3D      	        dec     A               ; Without affecting Carry
15E5: CACC15  	        jp      Z,GETCMD        ; Nothing entered - Get another
15E8: F5      	        push    AF              ; Save Carry status
15E9: CD7008  	        call    CURSOR_OFF      ; cursor disabled
15EC: CD3A1B  	        call    ATOH            ; Get line number into DE
15EF: D5      	        push    DE              ; Save line number
15F0: CDDE16  	        call    CRUNCH          ; Tokenise rest of line
15F3: 47      	        ld      B,A             ; Length of tokenised line
15F4: D1      	        pop     DE              ; Restore line number
15F5: F1      	        pop     AF              ; Restore Carry
15F6: D24A1A  	        jp      NC,EXCUTE       ; No line number - Direct mode
15F9: D5      	        push    DE              ; Save line number
15FA: C5      	        push    BC              ; Save length of tokenised line
15FB: AF      	        xor     A
15FC: 32B181  	        ld      (LSTBIN),A      ; Clear last byte input
15FF: CD6A1A  	        call    GETCHR          ; Get next character
1602: B7      	        or      A               ; Set flags
1603: F5      	        push    AF              ; And save them
1604: CD6B16  	        call    SRCHLN          ; Search for line number in DE
1607: DA1016  	        jp      C,LINFND        ; Jump if line found
160A: F1      	        pop     AF              ; Get status
160B: F5      	        push    AF              ; And re-save
160C: CAE31B  	        jp      Z,ULERR         ; Nothing after number - Error
160F: B7      	        or      A               ; Clear Carry
1610: C5      	LINFND: push    BC              ; Save address of line in prog
1611: D22716  	        jp      NC,INEWLN       ; Line not found - Insert new
1614: EB      	        ex      DE,HL           ; Next line address in DE
1615: 2ABB81  	        ld      HL,(PROGND)     ; End of program
1618: 1A      	SFTPRG: ld      A,(DE)          ; Shift rest of program down
1619: 02      	        ld      (BC),A
161A: 03      	        inc     BC              ; Next destination
161B: 13      	        inc     DE              ; Next source
161C: CD4118  	        call    CPDEHL          ; All done?
161F: C21816  	        jp      NZ,SFTPRG       ; More to do
1622: 60      	        ld      H,B             ; HL - New end of program
1623: 69      	        ld      L,C
1624: 22BB81  	        ld      (PROGND),HL     ; Update end of program
              	
1627: D1      	INEWLN: pop     DE              ; Get address of line,
1628: F1      	        pop     AF              ; Get status
1629: CA4E16  	        jp      Z,SETPTR        ; No text - Set up pointers
162C: 2ABB81  	        ld      HL,(PROGND)     ; Get end of program
162F: E3      	        ex      (SP),HL         ; Get length of input line
1630: C1      	        pop     BC              ; End of program to BC
1631: 09      	        add     HL,BC           ; Find new end
1632: E5      	        push    HL              ; Save new end
1633: CD1115  	        call    MOVUP           ; Make space for line
1636: E1      	        pop     HL              ; Restore new end
1637: 22BB81  	        ld      (PROGND),HL     ; Update end of program pointer
163A: EB      	        ex      DE,HL           ; Get line to move up in HL
163B: 74      	        ld      (HL),H          ; Save MSB
163C: D1      	        pop     DE              ; Get new line number
163D: 23      	        inc     HL              ; Skip pointer
163E: 23      	        inc     HL
163F: 73      	        ld      (HL),E          ; Save LSB of line number
1640: 23      	        inc     HL
1641: 72      	        ld      (HL),D          ; Save MSB of line number
1642: 23      	        inc     HL              ; To first byte in line
1643: 113681  	        ld      DE,BUFFER       ; Copy buffer to program
1646: 1A      	MOVBUF: ld      A,(DE)          ; Get source
1647: 77      	        ld      (HL),A          ; Save destinations
1648: 23      	        inc     HL              ; Next source
1649: 13      	        inc     DE              ; Next destination
164A: B7      	        or      A               ; Done?
164B: C24616  	        jp      NZ,MOVBUF       ; No - Repeat
164E: CD9716  	SETPTR: call    RUNFST          ; Set line pointers
1651: 23      	        inc     HL              ; To LSB of pointer
1652: EB      	        ex      DE,HL           ; Address to DE
1653: 62      	PTRLP:  ld      H,D             ; Address to HL
1654: 6B      	        ld      L,E
1655: 7E      	        ld      A,(HL)          ; Get LSB of pointer
1656: 23      	        inc     HL              ; To MSB of pointer
1657: B6      	        or      (HL)            ; Compare with MSB pointer
1658: CACC15  	        jp      Z,GETCMD        ; Get command line if end
165B: 23      	        inc     HL              ; To LSB of line number
165C: 23      	        inc     HL              ; Skip line number
165D: 23      	        inc     HL              ; Point to first byte in line
165E: AF      	        xor     A               ; Looking for 00 byte
165F: BE      	FNDEND: cp      (HL)            ; Found end of line?
1660: 23      	        inc     HL              ; Move to next byte
1661: C25F16  	        jp      NZ,FNDEND       ; No - Keep looking
1664: EB      	        ex      DE,HL           ; Next line address to HL
1665: 73      	        ld      (HL),E          ; Save LSB of pointer
1666: 23      	        inc     HL
1667: 72      	        ld      (HL),D          ; Save MSB of pointer
1668: C35316  	        jp      PTRLP           ; Do next line
              	
166B: 2A3381  	SRCHLN: ld      HL,(BASTXT)     ; Start of program text
166E: 44      	SRCHLP: ld      B,H             ; BC = Address to look at
166F: 4D      	        ld      C,L
1670: 7E      	        ld      A,(HL)          ; Get address of next line
1671: 23      	        inc     HL
1672: B6      	        or      (HL)            ; End of program found?
1673: 2B      	        dec     HL
1674: C8      	        ret     Z               ; Yes - Line not found
1675: 23      	        inc     HL
1676: 23      	        inc     HL
1677: 7E      	        ld      A,(HL)          ; Get LSB of line number
1678: 23      	        inc     HL
1679: 66      	        ld      H,(HL)          ; Get MSB of line number
167A: 6F      	        ld      L,A
167B: CD4118  	        call    CPDEHL          ; Compare with line in DE
167E: 60      	        ld      H,B             ; HL = Start of this line
167F: 69      	        ld      L,C
1680: 7E      	        ld      A,(HL)          ; Get LSB of next line address
1681: 23      	        inc     HL
1682: 66      	        ld      H,(HL)          ; Get MSB of next line address
1683: 6F      	        ld      L,A             ; Next line to HL
1684: 3F      	        ccf
1685: C8      	        ret     Z               ; Lines found - Exit
1686: 3F      	        ccf
1687: D0      	        ret     NC              ; Line not found,at line after
1688: C36E16  	        jp      SRCHLP          ; Keep looking
              	
168B: C0      	NEW:    ret     NZ              ; Return if any more on line
168C: 2A3381  	CLRPTR: ld      HL,(BASTXT)     ; Point to start of program
168F: AF      	        xor     A               ; Set program area to empty
1690: 77      	        ld      (HL),A          ; Save LSB = 00
1691: 23      	        inc     HL
1692: 77      	        ld      (HL),A          ; Save MSB = 00
1693: 23      	        inc     HL
1694: 22BB81  	        ld      (PROGND),HL     ; Set program end
              	
1697: 2A3381  	RUNFST: ld      HL,(BASTXT)     ; Clear all variables
169A: 2B      	        dec     HL
              	
169B: 22B381  	INTVAR: ld      (BRKLIN),HL     ; Initialise RUN variables
169E: 2A9481  	        ld      HL,(LSTRAM)     ; Get end of RAM
16A1: 22A881  	        ld      (STRBOT),HL     ; Clear string space
16A4: AF      	        xor     A
16A5: CD7A1A  	        call    RESTOR          ; Reset DATA pointers
16A8: 2ABB81  	        ld      HL,(PROGND)     ; Get end of program
16AB: 22BD81  	        ld      (VAREND),HL     ; Clear variables
16AE: 22BF81  	        ld      (ARREND),HL     ; Clear arrays
              	
16B1: C1      	CLREG:  pop     BC              ; Save return address
16B2: 2AAD80  	        ld      HL,(STRSPC)     ; Get end of working RAM
16B5: F9      	        ld      SP,HL           ; Set stack
16B6: 219881  	        ld      HL,TMSTPL       ; Temporary string pool
16B9: 229681  	        ld      (TMSTPT),HL     ; Reset temporary string ptr
16BC: AF      	        xor     A               ; A = 00
16BD: 6F      	        ld      L,A             ; HL = 0000
16BE: 67      	        ld      H,A
16BF: 22B981  	        ld      (CONTAD),HL     ; No CONTinue
16C2: 32B081  	        ld      (FORFLG),A      ; Clear FOR flag
16C5: 22C381  	        ld      (FNRGNM),HL     ; Clear FN argument
16C8: E5      	        push    HL              ; HL = 0000
16C9: C5      	        push    BC              ; Put back return
16CA: 2AB381  	DOAGN:  ld      HL,(BRKLIN)     ; Get address of code to RUN
16CD: C9      	        ret                     ; Return to execution driver
              	
16CE: 3E3F    	PROMPT: ld      A,'?'           ; '?'
16D0: CD5218  	        call    OUTC            ; Output character
16D3: 3E00    	        ld      A,NLLCR         ; null char
16D5: CD5218  	        call    OUTC            ; Output character
16D8: CD5A08  	        call    CURSOR_ON       ; enable cursor
16DB: C3AA80  	        jp      RINPUT          ; Get input line
              	
16DE: AF      	CRUNCH: xor     A               ; Tokenise line @ HL to BUFFER
16DF: 329381  	        ld      (DATFLG),A      ; Reset literal flag
16E2: 0E05    	        ld      C,2+3           ; 2 byte number and 3 nulls
16E4: 113681  	        ld      DE,BUFFER       ; Start of input buffer
16E7: 7E      	CRNCLP: ld      A,(HL)          ; Get byte
16E8: FE20    	        cp      SPC             ; Is it a space?
16EA: CA6617  	        jp      Z,MOVDIR        ; Yes - Copy direct
16ED: 47      	        ld      B,A             ; Save character
16EE: FE22    	        cp      22H             ; '"'             ; Is it a quote?
16F0: CA8617  	        jp      Z,CPYLIT        ; Yes - Copy literal string
16F3: B7      	        or      A               ; Is it end of buffer?
16F4: CA8D17  	        jp      Z,ENDBUF        ; Yes - End buffer
16F7: 3A9381  	        ld      A,(DATFLG)      ; Get data type
16FA: B7      	        or      A               ; Literal?
16FB: 7E      	        ld      A,(HL)          ; Get byte to copy
16FC: C26617  	        jp      NZ,MOVDIR       ; Literal - Copy direct
16FF: FE3F    	        cp      '?'             ; Is it '?' short for PRINT
1701: 3EAD    	        ld      A,ZPRINT        ; "PRINT" token
1703: CA6617  	        jp      Z,MOVDIR        ; Yes - replace it
1706: 7E      	        ld      A,(HL)          ; Get byte again
1707: FE30    	        cp      '0'             ; Is it less than '0'
1709: DA1117  	        jp      C,FNDWRD        ; Yes - Look for reserved words
170C: FE3C    	        cp      $3C  ;60; ";"+1       ; Is it "0123456789:;" ?
170E: DA6617  	        jp      C,MOVDIR        ; Yes - copy it direct
1711: D5      	FNDWRD: push    DE              ; Look for reserved words
1712: 112810  	        ld      DE,WORDS-1      ; Point to table
1715: C5      	        push    BC              ; Save count
1716: 016217  	        ld      BC,RETNAD       ; Where to return to
1719: C5      	        push    BC              ; Save return address
171A: 067F    	        ld      B,ZEND-1        ; First token value -1
171C: 7E      	        ld      A,(HL)          ; Get byte
171D: FE61    	        cp      'a'             ; Less than 'a' ?
171F: DA2A17  	        jp      C,SEARCH        ; Yes - search for words
1722: FE7B    	        cp      'z'+1           ; Greater than 'z' ?
1724: D22A17  	        jp      NC,SEARCH       ; Yes - search for words
1727: E65F    	        and     %01011111       ; Force upper case
1729: 77      	        ld      (HL),A          ; Replace byte
172A: 4E      	SEARCH: ld      C,(HL)          ; Search for a word
172B: EB      	        ex      DE,HL
172C: 23      	GETNXT: inc     HL              ; Get next reserved word
172D: B6      	        or      (HL)            ; Start of word?
172E: F22C17  	        jp      P,GETNXT        ; No - move on
1731: 04      	        inc     B               ; Increment token value
1732: 7E      	        ld      A,(HL)          ; Get byte from table
1733: E67F    	        and     %01111111       ; Strip bit 7
1735: C8      	        ret     Z               ; Return if end of list
1736: B9      	        cp      C               ; Same character as in buffer?
1737: C22C17  	        jp      NZ,GETNXT       ; No - get next word
173A: EB      	        ex      DE,HL
173B: E5      	        push    HL              ; Save start of word
              	
173C: 13      	NXTBYT: inc     DE              ; Look through rest of word
173D: 1A      	        ld      A,(DE)          ; Get byte from table
173E: B7      	        or      A               ; End of word ?
173F: FA5E17  	        jp      M,MATCH         ; Yes - Match found
1742: 4F      	        ld      C,A             ; Save it
1743: 78      	        ld      A,B             ; Get token value
1744: FE88    	        cp      ZGOTO           ; Is it "GOTO" token ?
1746: C24D17  	        jp      NZ,NOSPC        ; No - Don't allow spaces
1749: CD6A1A  	        call    GETCHR          ; Get next character
174C: 2B      	        dec     HL              ; Cancel increment from GETCHR
174D: 23      	NOSPC:  inc     HL              ; Next byte
174E: 7E      	        ld      A,(HL)          ; Get byte
174F: FE61    	        cp      'a'             ; Less than 'a' ?
1751: DA5617  	        jp      C,NOCHNG        ; Yes - don't change
1754: E65F    	        and     %01011111       ; Make upper case
1756: B9      	NOCHNG: cp      C               ; Same as in buffer ?
1757: CA3C17  	        jp      Z,NXTBYT        ; Yes - keep testing
175A: E1      	        pop     HL              ; Get back start of word
175B: C32A17  	        jp      SEARCH          ; Look at next word
              	
175E: 48      	MATCH:  ld      C,B             ; Word found - Save token value
175F: F1      	        pop     AF              ; Throw away return
1760: EB      	        ex      DE,HL
1761: C9      	        ret                     ; Return to "RETNAD"
1762: EB      	RETNAD: ex      DE,HL           ; Get address in string
1763: 79      	        ld      A,C             ; Get token value
1764: C1      	        pop     BC              ; Restore buffer length
1765: D1      	        pop     DE              ; Get destination address
1766: 23      	MOVDIR: inc     HL              ; Next source in buffer
1767: 12      	        ld      (DE),A          ; Put byte in buffer
1768: 13      	        inc     DE              ; Move up buffer
1769: 0C      	        inc     C               ; Increment length of buffer
176A: D63A    	        sub     ':'             ; End of statement?
176C: CA7417  	        jp      Z,SETLIT        ; Jump if multi-statement line
176F: FE49    	        cp      ZDATA-$3A       ; Is it DATA statement ?
1771: C27717  	        jp      NZ,TSTREM       ; No - see if REM
1774: 329381  	SETLIT: ld      (DATFLG),A      ; Set literal flag
1777: D654    	TSTREM: sub     ZREM-$3A        ; Is it REM?
1779: C2E716  	        jp      NZ,CRNCLP       ; No - Leave flag
177C: 47      	        ld      B,A             ; Copy rest of buffer
177D: 7E      	NXTCHR: ld      A,(HL)          ; Get byte
177E: B7      	        or      A               ; End of line ?
177F: CA8D17  	        jp      Z,ENDBUF        ; Yes - Terminate buffer
1782: B8      	        cp      B               ; End of statement ?
1783: CA6617  	        jp      Z,MOVDIR        ; Yes - Get next one
1786: 23      	CPYLIT: inc     HL              ; Move up source string
1787: 12      	        ld      (DE),A          ; Save in destination
1788: 0C      	        inc     C               ; Increment length
1789: 13      	        inc     DE              ; Move up destination
178A: C37D17  	        jp      NXTCHR          ; Repeat
              	
178D: 213581  	ENDBUF: ld      HL,BUFFER-1     ; Point to start of buffer
1790: 12      	        ld      (DE),A          ; Mark end of buffer (A = 00)
1791: 13      	        inc     DE
1792: 12      	        ld      (DE),A          ; A = 00
1793: 13      	        inc     DE
1794: 12      	        ld      (DE),A          ; A = 00
1795: C9      	        ret
              	
1796: 3AA480  	DODEL:  ld      A,(NULFLG)      ; Get null flag status
1799: B7      	        or      A               ; Is it zero?
179A: 3E00    	        ld      A,$00           ; Zero A - Leave flags
179C: 32A480  	        ld      (NULFLG),A      ; Zero null flag
179F: C2AA17  	        jp      NZ,ECHDEL       ; Set - Echo it
17A2: 05      	        dec     B               ; Decrement length
17A3: CAC717  	        jp      Z,GETLIN        ; Get line again if empty
17A6: CD5218  	        call    OUTC            ; Output null character
17A9: 3E      	        defb    $3E             ; Skip "dec B"
17AA: 05      	ECHDEL: dec     B               ; Count bytes in buffer
17AB: 2B      	        dec     HL              ; Back space buffer
17AC: CABE17  	        jp      Z,OTKLN         ; No buffer - Try again
17AF: 7E      	        ld      A,(HL)          ; Get deleted byte
17B0: CD5218  	        call    OUTC            ; Echo it
17B3: C3D017  	        jp      MORINP          ; Get more input
              	
17B6: 05      	DELCHR: dec     B               ; Count bytes in buffer
17B7: 2B      	        dec     HL              ; Back space buffer
17B8: CD5218  	        call    OUTC            ; Output character in A
17BB: C2D017  	        jp      NZ,MORINP       ; Not end - Get more
17BE: CD5218  	OTKLN:  call    OUTC            ; Output character in A
17C1: CD231D  	KILIN:  call    PRNTCRLF        ; Output CRLF
17C4: C3C717  	        jp      TTYLIN          ; Get line again
              	
17C7:         	GETLIN:
17C7: 213681  	TTYLIN: ld      HL,BUFFER       ; Get a line by character
17CA: 0601    	        ld      B,$01           ; Set buffer as empty
17CC: AF      	        xor     A
17CD: 32A480  	        ld      (NULFLG),A      ; Clear null flag
17D0: CD9318  	MORINP: call    CLOTST          ; Get character and test ^O
17D3: 4F      	        ld      C,A             ; Save character in C
17D4: FE7F    	        cp      DEL             ; Delete character?
17D6: CA9617  	        jp      Z,DODEL         ; Yes - Process it
17D9: 3AA480  	        ld      A,(NULFLG)      ; Get null flag
17DC: B7      	        or      A               ; Test null flag status
17DD: CAE917  	        jp      Z,PROCES        ; Reset - Process character
17E0: 3E00    	        ld      A,$00           ; Set a null
17E2: CD5218  	        call    OUTC            ; Output null
17E5: AF      	        xor     A               ; Clear A
17E6: 32A480  	        ld      (NULFLG),A      ; Reset null flag
17E9: 79      	PROCES: ld      A,C             ; Get character
17EA: FE07    	        cp      CTRLG           ; Bell?
17EC: CA2918  	        jp      Z,PUTCTL        ; Yes - Save it
17EF: FE03    	        cp      CTRLC           ; Is it control "C"?
17F1: CC1E18  	        call    Z,GMNCR         ; Yes - exit from graphic mode & Output CRLF
17F4: 37      	        scf                     ; Flag break
17F5: C8      	        ret     Z               ; Return if control "C"
17F6: FE0D    	        cp      CR              ; Is it enter?
17F8: CA191D  	        jp      Z,ENDINP        ; Yes - Terminate input
17FB: FE15    	        cp      CTRLU           ; Is it control "U"?
17FD: CAC117  	        jp      Z,KILIN         ; Yes - Get another line
1800: FE08    	        cp      BKSP            ; Is it backspace?
1802: CAB617  	        jp      Z,DELCHR        ; Yes - Delete character
1805: FE12    	        cp      CTRLR           ; Is it control "R"?
1807: C22418  	        jp      NZ,PUTBUF       ; No - Put in buffer
180A: C5      	        push    BC              ; Save buffer length
180B: D5      	        push    DE              ; Save DE
180C: E5      	        push    HL              ; Save buffer address
180D: 3600    	        ld      (HL),$00        ; Mark end of buffer
180F: CDBF3D  	        call    OUTNCR          ; Output and do CRLF
1812: 213681  	        ld      HL,BUFFER       ; Point to buffer start
1815: CDE723  	        call    PRS             ; Output buffer
1818: E1      	        pop     HL              ; Restore buffer address
1819: D1      	        pop     DE              ; Restore DE
181A: C1      	        pop     BC              ; Restore buffer length
181B: C3D017  	        jp      MORINP          ; Get another character
181E: CD3F15  	GMNCR:  call    EXITGM          ; exit from graphic mode
1821: C3231D  	        jp      PRNTCRLF        ; output CRLF
              	
1824: FE20    	PUTBUF: cp      SPC             ; Is it a control code?
1826: DAD017  	        jp      C,MORINP        ; Yes - Ignore
1829: 78      	PUTCTL: ld      A,B             ; Get number of bytes in buffer
182A: FE59    	        cp      $58+$01         ; Test for line overflow
182C: 3E08    	        ld      A,BKSP          ; Set a bell
182E: D23B18  	        jp      NC,OUTNBS       ; Ring bell if buffer full
1831: 79      	        ld      A,C             ; Get character
1832: 71      	        ld      (HL),C          ; Save in buffer
1833: 32B181  	        ld      (LSTBIN),A      ; Save last input byte
1836: 23      	        inc     HL              ; Move up buffer
1837: 04      	        inc     B               ; Increment length
1838: C3D017  	OUTIT:  jp      MORINP          ; Get another character
              	
183B: CD5218  	OUTNBS: call    OUTC            ; Output bell and back over it
              	        ;ld      A,BKSP          ; send back space
              	        ;call    OUTC            ;
183E: C33818  	        jp      OUTIT           ; get more chars
              	
1841: 7C      	CPDEHL: ld      A,H             ; Get H
1842: 92      	        sub     D               ; Compare with D
1843: C0      	        ret     NZ              ; Different - Exit
1844: 7D      	        ld      A,L             ; Get L
1845: 93      	        sub     E               ; Compare with E
1846: C9      	        ret                     ; Return status
              	
1847: 7E      	CHKSYN: ld      A,(HL)          ; Check syntax of character
1848: E3      	        ex      (SP),HL         ; Address of test byte
1849: BE      	        cp      (HL)            ; Same as in code string?
184A: 23      	        inc     HL              ; Return address
184B: E3      	        ex      (SP),HL         ; Put it back
184C: CA6A1A  	        jp      Z,GETCHR        ; Yes - Get next character
184F: C36515  	        jp      SNERR           ; Different - ?SN Error
              	
1852: F5      	OUTC:   push    AF              ; Save character
1853: 3AA580  	        ld      A,(CTLOFG)      ; Get control "O" flag
1856: B7      	        or      A               ; Is it set?
1857: C21C24  	        jp      NZ,POPAF        ; Yes - don't output
185A: F1      	        pop     AF              ; Restore character
185B: C5      	        push    BC              ; Save buffer length
185C: F5      	        push    AF              ; Save character
185D: FE20    	        cp      SPC             ; Is it a control code?
185F: DA7618  	        jp      C,DINPOS        ; Yes - Don't inc POS(X)
1862: 3AA280  	        ld      A,(LWIDTH)      ; Get line width
1865: 47      	        ld      B,A             ; To B
1866: 3A9081  	        ld      A,(CURPOS)      ; Get cursor position
1869: 04      	        inc     B               ; Width 255?
186A: CA7218  	        jp      Z,INCLEN        ; Yes - No width limit
186D: 05      	        dec     B               ; Restore width
186E: B8      	        cp      B               ; At end of line?
186F: CC231D  	        call    Z,PRNTCRLF      ; Yes - output CRLF
1872: 3C      	INCLEN: inc     A               ; Move on one character
1873: 329081  	        ld      (CURPOS),A      ; Save new position
1876: AF      	DINPOS: xor     A
1877: 322982  	        ld      (KBDNPT),A      ; set flag for no char from keyboard
187A: F1      	        pop     AF              ; Restore character
187B: C1      	        pop     BC              ; Restore buffer length
187C: F5      	        push    AF
187D: CD8518  	        call    SND2VID         ; send char to video
1880: F1      	        pop     AF
1881: CD9E3D  	        call    MONOUT          ; send char to serial if enabled
1884: C9      	        ret
              	
              	; print char to video if cursor is on
1885: 32EC81  	SND2VID:ld      (CHR4VID),A     ; store A
1888: 3AEB81  	        ld      A,(PRNTVIDEO)   ; check print-on-video
188B: B7      	        or      A               ; is it off?
188C: C8      	        ret     Z               ; yes, so return
188D: F3      	        di                      ; disable INTs
188E: CDC806  	        call    CHAR2VID        ; cursor is on, so print char on screen
1891: FB      	        ei                      ; re-enable INTs
1892: C9      	        ret                     ; return to caller
              	
1893: CDA331  	CLOTST: call    GETINP          ; Get input character
1896: FE0F    	        cp      CTRLO           ; Is it control "O"?
1898: C0      	        ret     NZ              ; No don't flip flag
1899: 3AA580  	        ld      A,(CTLOFG)      ; Get flag
189C: 2F      	        cpl                     ; Flip it
189D: 32A580  	        ld      (CTLOFG),A      ; Put it back
18A0: A7      	        and     A               ; is output enabled?
18A1: CC5A08  	        call    Z,CURSOR_ON     ; yes, so cursor on
18A4: AF      	        xor     A               ; Null character
18A5: C9      	        ret
              	
              	; LIST: list the program stored into memory
18A6: C1      	LIST:   pop     BC              ; rubbish - not needed (legacy from original call of LIST)
18A7: 2B      	        dec     HL              ; dec 'cos GETCHR INCs
18A8: CD6A1A  	        call    GETCHR          ; Get next character
18AB: CAF718  	        jp      Z,LSTALL        ; list all if nothing follows
18AE: FEBC    	        cp      ZMINUS          ; is it '-'?
18B0: 2020    	        jr      NZ,LST01        ; no, look for a line number
18B2: 110000  	        ld      DE,$0000        ; yes, set search from 0
18B5: CD9219  	        call    SRCHLIN         ; find address of line number
18B8: ED43EF81	        ld      (TMPBFR1),BC    ; store address of starting line
18BC: CD4718  	        call    CHKSYN          ; skip '-'
18BF: BC      	        defb    ZMINUS
18C0: CD3A1B  	        call    ATOH            ; now, look for another number (ASCII number to DE)
18C3: CD9219  	        call    SRCHLIN         ; find address of line number
18C6: ED43F181	        ld      (TMPBFR2),BC    ; store address of ending line
18CA: ED4BEF81	        ld      BC,(TMPBFR1)    ; retrieve address of starting line
18CE: C5      	        push    BC              ; store address of line for later use
18CF: C32919  	        jp      LISTLP          ; go listing
18D2: CD3A1B  	LST01:  call    ATOH            ; get a line number (ASCII number to DE)
18D5: CD9219  	LST01H: call    SRCHLIN         ; find address of line number
18D8: ED43EF81	        ld      (TMPBFR1),BC    ; store address of starting line
18DC: ED43F181	        ld      (TMPBFR2),BC    ; same address for ending line (we'll change later if needed)
18E0: 2B      	        dec     HL              ; dec 'cos GETCHR INCs
18E1: CD6A1A  	        call    GETCHR          ; Get next character
18E4: CAF318  	        jp      Z,LST06         ; nothing follows, so ending & starting lines are the same
18E7: FEBC    	        cp      ZMINUS          ; is it '-'?
18E9: CA0F19  	        jp      Z,LST03         ; yes, read ending line
18EC: CD9219  	LST04:  call    SRCHLIN         ; find address of line number
18EF: ED43F181	        ld      (TMPBFR2),BC    ; set address of ending line
18F3: C5      	LST06:  push    BC              ; store address for later use
18F4: C32919  	        jp      LISTLP          ; jump to list
18F7: 11F9FF  	LSTALL  ld      DE,65529        ; set ending line to max. allowed line number
18FA: CD9219  	        call    SRCHLIN         ; get address of last line
18FD: ED43F181	        ld      (TMPBFR2),BC    ; store it
1901: 110000  	        ld      DE,$0000        ; set start to first line in memory
1904: CD9219  	        call    SRCHLIN         ; get address of first line
1907: ED43EF81	        ld      (TMPBFR1),BC    ; store it
190B: C5      	        push    BC              ; store address of starting line for later use
190C: C32919  	        jp      LISTLP          ; start printing
190F: CD4718  	LST03:  call    CHKSYN          ; skip '-'
1912: BC      	        defb    ZMINUS
1913: CD3A1B  	        call    ATOH            ; look for another number (return into DE)
1916: 7A      	        ld      A,D
1917: B3      	        or      E               ; is line=0?
1918: 2003    	        jr      NZ,LST05        ; no, jump over
191A: 11F9FF  	        ld      DE,65529        ; yes set last valid line number
191D: CD9219  	LST05:  call    SRCHLIN         ; find address of line number
1920: ED43F181	        ld      (TMPBFR2),BC    ; store address of ending line
1924: ED4BEF81	        ld      BC,(TMPBFR1)    ; retrieve address of starting line
1928: C5      	        push    BC              ; store it for later use
1929: E1      	LISTLP: pop     HL              ; Restore address of line
192A: 4E      	        ld      C,(HL)          ; Get LSB of next line
192B: 23      	        inc     HL
192C: 46      	        ld      B,(HL)          ; Get MSB of next line
192D: 23      	        inc     HL
192E: 78      	        ld      A,B             ; BC = 0 (End of program)?
192F: B1      	        or      C
1930: CABF15  	        jp      Z,PRNTOK        ; Yes - Go to command mode
1933: CD951A  	        call    TSTBRK          ; Test for break key
1936: CD9819  	        call    TSTSPC          ; test for space
1939: C5      	        push    BC              ; Save address of next line
193A: 3AE481  	        ld      A,(SCR_CURS_X)  ; load current X pos of cursor
193D: A7      	        and     A               ; is it at the beginning of a new line?
193E: 200B    	        jr      NZ,LST08        ; No, jump over
1940: 3E0D    	        ld      A,CR            ; yes, so just send a CR
1942: CD9E3D  	        call    MONOUT          ; to serial if it's open
1945: AF      	        xor     A               ; then, set cursor
1946: 329081  	        ld      (CURPOS),A      ; to position 0
1949: 1803    	        jr      LST07           ; and continue
194B: CD231D  	LST08:  call    PRNTCRLF        ; output CRLF
194E: 5E      	LST07:  ld      E,(HL)          ; Get LSB of line number
194F: 23      	        inc     HL
1950: 56      	        ld      D,(HL)          ; Get MSB of line number
1951: 23      	        inc     HL
1952: E5      	        push    HL              ; Save address of line start
1953: EB      	        ex      DE,HL           ; Line number to HL
1954: CD872E  	        call    PRNTHL          ; Output line number in decimal
1957: 3E20    	        ld      A,SPC           ; Space after line number
1959: E1      	        pop     HL              ; Restore start of line address
195A: CD5218  	LSTLP2: call    OUTC            ; Output character in A
195D: 7E      	LSTLP3: ld      A,(HL)          ; Get next byte in line
195E: B7      	        or      A               ; End of line?
195F: 23      	        inc     HL              ; To next byte in line
1960: CA8419  	        jp      Z,NXTLN         ; Yes - check next line
1963: F25A19  	        jp      P,LSTLP2        ; No token - output it
1966: D67F    	        sub     ZEND-1          ; Find and output word
1968: 4F      	        ld      C,A             ; Token offset+1 to C
1969: 112910  	        ld      DE,WORDS        ; Reserved word list
196C: 1A      	FNDTOK: ld      A,(DE)          ; Get character in list
196D: 13      	        inc     DE              ; Move on to next
196E: B7      	        or      A               ; Is it start of word?
196F: F26C19  	        jp      P,FNDTOK        ; No - Keep looking for word
1972: 0D      	        dec     C               ; Count words
1973: C26C19  	        jp      NZ,FNDTOK       ; Not there - keep looking
1976: E67F    	OUTWRD: and     %01111111       ; Strip bit 7
1978: CD5218  	        call    OUTC            ; Output character
197B: 1A      	        ld      A,(DE)          ; Get next character
197C: 13      	        inc     DE              ; Move on to next
197D: B7      	        or      A               ; Is it end of word?
197E: F27619  	        jp      P,OUTWRD        ; No - output the rest
1981: C35D19  	        jp      LSTLP3          ; Next byte in line
1984: D1      	NXTLN:  pop     DE              ; recover address of current line
1985: 2AF181  	        ld      HL,(TMPBFR2)    ; address of last line to print
1988: CDC53D  	        call    CMP16           ; check if current line is over last printable line
198B: DABF15  	        jp      C,PRNTOK        ; finish - leave & print OK
198E: D5      	        push    DE              ; store address of current line
198F: C32919  	        jp      LISTLP          ; continue listing
1992: E5      	SRCHLIN:push    HL              ; store HL (this is needed because HL store the pointer to the input buffer)
1993: CD6B16  	        call    SRCHLN          ; search for line number in DE
1996: E1      	        pop     HL              ; retrieve HL
1997: C9      	        ret                     ; return to caller
              	
              	; during LISTing, check if PAUSE is pressed, then pause listing and
              	; wait for another pressing of PAUSE to continue or CTRL-C/BREAK to exit
1998: 3A2B82  	TSTSPC: ld      A,(TMPKEYBFR)   ; Get input character
199B: FE20    	        cp      SPC             ; Is it SPACE?
199D: C0      	        ret     NZ              ; No, return
199E: CDA331  	WTSPC   call    GETINP          ; Yes, stop listing and wait for another space or BREAK
19A1: FE20    	        cp      SPC             ; is it SPACE?
19A3: 2005    	        jr      NZ,CNTWTSP      ; no, continue
19A5: AF      	        xor     A
19A6: 322B82  	        ld      (TMPKEYBFR),A   ; reset key
19A9: C9      	        ret                     ; return to caller
19AA: FE03    	CNTWTSP:cp      CTRLC           ; is it CTRL-C/BREAK?
19AC: 20F0    	        jr      NZ,WTSPC        ; no, loop
19AE: C3930F  	        jp      BRKRET          ; exit and output "Ok"
              	
              	
19B1: 3E64    	FOR:    ld      A,$64           ; Flag "FOR" assignment
19B3: 32B081  	        ld      (FORFLG),A      ; Save "FOR" flag
19B6: CD241C  	        call    LET             ; Set up initial index
19B9: C1      	        pop     BC              ; Drop RETurn address
19BA: E5      	        push    HL              ; Save code string address
19BB: CD0D1C  	        call    DATA            ; Get next statement address
19BE: 22AC81  	        ld      (LOOPST),HL     ; Save it for start of loop
19C1: 210200  	        ld      HL,$0002        ; Offset for "FOR" block
19C4: 39      	        add     HL,SP           ; Point to it
19C5: CDF214  	FORSLP: call    LOKFOR          ; Look for existing "FOR" block
19C8: D1      	        pop     DE              ; Get code string address
19C9: C2E119  	        jp      NZ,FORFND       ; No nesting found
19CC: 09      	        add     HL,BC           ; Move into "FOR" block
19CD: D5      	        push    DE              ; Save code string address
19CE: 2B      	        dec     HL
19CF: 56      	        ld      D,(HL)          ; Get MSB of loop statement
19D0: 2B      	        dec     HL
19D1: 5E      	        ld      E,(HL)          ; Get LSB of loop statement
19D2: 23      	        inc     HL
19D3: 23      	        inc     HL
19D4: E5      	        push    HL              ; Save block address
19D5: 2AAC81  	        ld      HL,(LOOPST)     ; Get address of loop statement
19D8: CD4118  	        call    CPDEHL          ; Compare the FOR loops
19DB: E1      	        pop     HL              ; Restore block address
19DC: C2C519  	        jp      NZ,FORSLP       ; Different FORs - Find another
19DF: D1      	        pop     DE              ; Restore code string address
19E0: F9      	        ld      SP,HL           ; Remove all nested loops
              	
19E1: EB      	FORFND: ex      DE,HL           ; Code string address to HL
19E2: 0E08    	        ld      C,$08
19E4: CD2215  	        call    CHKSTK          ; Check for 8 levels of stack
19E7: E5      	        push    HL              ; Save code string address
19E8: 2AAC81  	        ld      HL,(LOOPST)     ; Get first statement of loop
19EB: E3      	        ex      (SP),HL         ; Save and restore code string
19EC: E5      	        push    HL              ; Re-save code string address
19ED: 2AAF80  	        ld      HL,(LINEAT)     ; Get current line number
19F0: E3      	        ex      (SP),HL         ; Save and restore code string
19F1: CDE21E  	        call    TSTNUM          ; Make sure it's a number
19F4: CD4718  	        call    CHKSYN          ; Make sure "TO" is next
19F7: B5      	        defb    ZTO             ; "TO" token
19F8: CDDF1E  	        call    GETNUM          ; Get "TO" expression value
19FB: E5      	        push    HL              ; Save code string address
19FC: CD392D  	        call    BCDEFP          ; Move "TO" value to BCDE
19FF: E1      	        pop     HL              ; Restore code string address
1A00: C5      	        push    BC              ; Save "TO" value in block
1A01: D5      	        push    DE
1A02: 010081  	        ld      BC,$8100        ; BCDE - 1 (default STEP)
1A05: 51      	        ld      D,C             ; C=0
1A06: 5A      	        ld      E,D             ; D=0
1A07: 7E      	        ld      A,(HL)          ; Get next byte in code string
1A08: FEBA    	        cp      ZSTEP           ; See if "STEP" is stated
1A0A: 3E01    	        ld      A,$01           ; Sign of step = 1
1A0C: C21D1A  	        jp      NZ,SAVSTP       ; No STEP given - Default to 1
1A0F: CD6A1A  	        call    GETCHR          ; Jump over "STEP" token
1A12: CDDF1E  	        call    GETNUM          ; Get step value
1A15: E5      	        push    HL              ; Save code string address
1A16: CD392D  	        call    BCDEFP          ; Move STEP to BCDE
1A19: CDED2C  	        call    TSTSGN          ; Test sign of FPREG
1A1C: E1      	        pop     HL              ; Restore code string address
1A1D: C5      	SAVSTP: push    BC              ; Save the STEP value in block
1A1E: D5      	        push    DE
1A1F: F5      	        push    AF              ; Save sign of STEP
1A20: 33      	        inc     SP              ; Don't save flags
1A21: E5      	        push    HL              ; Save code string address
1A22: 2AB381  	        ld      HL,(BRKLIN)     ; Get address of index variable
1A25: E3      	        ex      (SP),HL         ; Save and restore code string
1A26: 0681    	PUTFID: ld      B,ZFOR          ; "FOR" block marker
1A28: C5      	        push    BC              ; Save it
1A29: 33      	        inc     SP              ; Don't save C
              	
1A2A: CD951A  	RUNCNT: call    TSTBRK          ; Execution driver - Test break
1A2D: 22B381  	        ld      (BRKLIN),HL     ; Save code address for break
1A30: 7E      	        ld      A,(HL)          ; Get next byte in code string
1A31: FE3A    	        cp      ':'             ; Multi statement line?
1A33: CA4A1A  	        jp      Z,EXCUTE        ; Yes - Execute it
1A36: B7      	        or      A               ; End of line?
1A37: C26515  	        jp      NZ,SNERR        ; No - Syntax error
1A3A: 23      	        inc     HL              ; Point to address of next line
1A3B: 7E      	        ld      A,(HL)          ; Get LSB of line pointer
1A3C: 23      	        inc     HL
1A3D: B6      	        or      (HL)            ; Is it zero (End of prog)?
1A3E: CABC1A  	        jp      Z,ENDPRG        ; Yes - Terminate execution
1A41: 23      	        inc     HL              ; Point to line number
1A42: 5E      	        ld      E,(HL)          ; Get LSB of line number
1A43: 23      	        inc     HL
1A44: 56      	        ld      D,(HL)          ; Get MSB of line number
1A45: EB      	        ex      DE,HL           ; Line number to HL
1A46: 22AF80  	        ld      (LINEAT),HL     ; Save as current line number
1A49: EB      	        ex      DE,HL           ; Line number back to DE
1A4A: CD6A1A  	EXCUTE: call    GETCHR          ; Get key word
1A4D: 112A1A  	        ld      DE,RUNCNT       ; Where to RETurn to
1A50: D5      	        push    DE              ; Save for RETurn
1A51: C8      	IFJMP:  ret     Z               ; Go to RUNCNT if end of STMT
              	
1A52: D680    	ONJMP:  sub     ZEND            ; Is it a token?
1A54: DA241C  	        jp      C,LET           ; No - try to assign it
1A57: FE34    	        cp      ZNEW+1-ZEND     ; END to NEW ?
1A59: D26515  	        jp      NC,SNERR        ; Not a key word - ?SN Error
1A5C: 07      	        rlca                    ; Double it
1A5D: 4F      	        ld      C,A             ; BC = Offset into table
1A5E: 0600    	        ld      B,0
1A60: EB      	        ex      DE,HL           ; Save code string address
1A61: 21AE11  	        ld      HL,WORDTB       ; Keyword address table
1A64: 09      	        add     HL,BC           ; Point to routine address
1A65: 4E      	        ld      C,(HL)          ; Get LSB of routine address
1A66: 23      	        inc     HL
1A67: 46      	        ld      B,(HL)          ; Get MSB of routine address
1A68: C5      	        push    BC              ; Save routine address
1A69: EB      	        ex      DE,HL           ; Restore code string address
              	
              	; get a char from input buffer: exit with NC if character found is
              	; not a number; exit with Z if nothing found; char is into A
1A6A: 23      	GETCHR: inc     HL              ; Point to next character
1A6B: 7E      	        ld      A,(HL)          ; Get next code string byte
1A6C: FE3A    	        cp      ':'             ; Z if ':'
1A6E: D0      	        ret     NC              ; NC if > "9"
1A6F: FE20    	        cp      SPC
1A71: CA6A1A  	        jp      Z,GETCHR        ; Skip over spaces
1A74: FE30    	        cp      '0'
1A76: 3F      	        ccf                     ; NC if < '0'
1A77: 3C      	        inc     A               ; Test for zero - Leave carry
1A78: 3D      	        dec     A               ; Z if Null
1A79: C9      	        ret
              	
1A7A: EB      	RESTOR: ex      DE,HL           ; Save code string address
1A7B: 2A3381  	        ld      HL,(BASTXT)     ; Point to start of program
1A7E: CA8F1A  	        jp      Z,RESTNL        ; Just RESTORE - reset pointer
1A81: EB      	        ex      DE,HL           ; Restore code string address
1A82: CD3A1B  	        call    ATOH            ; Get line number to DE
1A85: E5      	        push    HL              ; Save code string address
1A86: CD6B16  	        call    SRCHLN          ; Search for line number in DE
1A89: 60      	        ld      H,B             ; HL = Address of line
1A8A: 69      	        ld      L,C
1A8B: D1      	        pop     DE              ; Restore code string address
1A8C: D2E31B  	        jp      NC,ULERR        ; ?UL Error if not found
1A8F: 2B      	RESTNL: dec     HL              ; Byte before DATA statement
1A90: 22C181  	UPDATA: ld      (NXTDAT),HL     ; Update DATA pointer
1A93: EB      	        ex      DE,HL           ; Restore code string address
1A94: C9      	        ret
              	
              	
1A95: DF      	TSTBRK: rst     $18             ; Check input status
1A96: C8      	        ret     Z               ; No key, go back
1A97: D7      	        rst     $10             ; Get the key into A
1A98: FE1B    	        cp      ESC             ; Escape key?
1A9A: 2811    	        jr      Z,BRK           ; Yes, break
1A9C: FE03    	        cp      CTRLC           ; <Ctrl-C>
1A9E: 280D    	        jr      Z,BRK           ; Yes, break
1AA0: FE13    	        cp      CTRLS           ; Stop scrolling?
1AA2: C0      	        ret     NZ              ; Other key, ignore
              	
              	
1AA3: D7      	STALL:  rst     $10             ; Wait for key
1AA4: FE11    	        cp      CTRLQ           ; Resume scrolling?
1AA6: C8      	        ret     Z               ; Release the chokehold
1AA7: FE03    	        cp      CTRLC           ; Second break?
1AA9: 2807    	        jr      Z,STOP          ; Break during hold exits prog
1AAB: 18F6    	        jr      STALL           ; Loop until <Ctrl-Q> or <brk>
              	
1AAD: 3EFF    	BRK:    ld      A,$FF           ; Set BRKFLG
1AAF: 32A980  	        ld      (BRKFLG),A      ; Store it
              	
1AB2: C0      	STOP:   ret     NZ              ; Exit if anything else
1AB3: F6      	        defb    $F6             ; Flag "STOP"
1AB4: C0      	PEND:   ret     NZ              ; Exit if anything else
1AB5: 22B381  	        ld      (BRKLIN),HL     ; Save point of break
1AB8: 21      	        defb    $21             ; Skip "OR 11111111B"
1AB9: F6FF    	INPBRK: or      %11111111       ; Flag "Break" wanted
1ABB: C1      	        pop     BC              ; Return not needed and more
1ABC: 2AAF80  	ENDPRG: ld      HL,(LINEAT)     ; Get current line number
1ABF: F5      	        push    AF              ; Save STOP / END status
1AC0: 7D      	        ld      A,L             ; Is it direct break?
1AC1: A4      	        and     H
1AC2: 3C      	        inc     A               ; Line is -1 if direct break
1AC3: CACF1A  	        jp      Z,NOLIN         ; Yes - No line number
1AC6: 22B781  	        ld      (ERRLIN),HL     ; Save line of break
1AC9: 2AB381  	        ld      HL,(BRKLIN)     ; Get point of break
1ACC: 22B981  	        ld      (CONTAD),HL     ; Save point to CONTinue
1ACF: AF      	NOLIN:  xor     A
1AD0: 32A580  	        ld      (CTLOFG),A      ; Enable output
1AD3: CD111D  	        call    STTLIN          ; Start a new line
1AD6: F1      	        pop     AF              ; Restore STOP / END status
1AD7: 21E814  	        ld      HL,BRKMSG       ; "Break" message
1ADA: C2E01A  	        jp      NZ,ERRINT       ; "in line" wanted?
1ADD: C3BF15  	        jp      PRNTOK          ; Go to command mode
1AE0: CD3F15  	ERRINT: call    EXITGM          ; exit from graphics mode
1AE3: C39D15  	        jp      ERRIN           ; print message
              	
              	
1AE6: 21FFFF  	CONT:   ld      HL,-1           ; reset...
1AE9: 22B180  	        ld      (HLPLN),HL      ; ...HELP line register
1AEC: 2AB981  	        ld      HL,(CONTAD)     ; Get CONTinue address
1AEF: 7C      	        ld      A,H             ; Is it zero?
1AF0: B5      	        or      L
1AF1: 1E20    	        ld      E,CN            ; ?CN Error
1AF3: CA7915  	        jp      Z,ERROR         ; Yes - output "?CN Error"
1AF6: EB      	        ex      DE,HL           ; Save code string address
1AF7: 2AB781  	        ld      HL,(ERRLIN)     ; Get line of last break
1AFA: 22AF80  	        ld      (LINEAT),HL     ; Set up current line number
1AFD: EB      	        ex      DE,HL           ; Restore code string address
1AFE: C9      	        ret                     ; CONTinue where left off
              	
1AFF: E5      	ACCSUM: push    HL              ; Save address in array
1B00: 2AA680  	        ld      HL,(CHKSUM)     ; Get check sum
1B03: 0600    	        ld      B,$00           ; BC - Value of byte
1B05: 4F      	        ld      C,A
1B06: 09      	        add     HL,BC           ; Add byte to check sum
1B07: 22A680  	        ld      (CHKSUM),HL     ; Re-save check sum
1B0A: E1      	        pop     HL              ; Restore address in array
1B0B: C9      	        ret
              	
1B0C: 7E      	CHKLTR: ld      A,(HL)          ; Get byte
1B0D: FE41    	        cp      'A'             ; < 'a' ?
1B0F: D8      	        ret     C               ; Carry set if not letter
1B10: FE5B    	        cp      'Z'+1           ; > 'z' ?
1B12: 3F      	        ccf
1B13: C9      	        ret                     ; Carry set if not letter
              	
1B14: CD6A1A  	FPSINT: call    GETCHR          ; Get next character
1B17: CDDF1E  	POSINT: call    GETNUM          ; Get integer 0 to 32767
1B1A: CDED2C  	DEPINT: call    TSTSGN          ; Test sign of FPREG
1B1D: FA351B  	        jp      M,FCERR         ; Negative - ?FC Error
1B20: 3ACC81  	DEINT:  ld      A,(FPEXP)       ; Get integer value to DE
1B23: FE90    	        cp      $80+$10         ; Exponent in range (16 bits)?
1B25: DA952D  	        jp      C,FPINT         ; Yes - convert it
1B28: 018090  	        ld      BC,$9080        ; BCDE = -32768
1B2B: 110000  	        ld      DE,$0000
1B2E: E5      	        push    HL              ; Save code string address
1B2F: CD682D  	        call    CMPNUM          ; Compare FPREG with BCDE
1B32: E1      	        pop     HL              ; Restore code string address
1B33: 51      	        ld      D,C             ; MSB to D
1B34: C8      	        ret     Z               ; Return if in range
1B35: 1E08    	FCERR:  ld      E,FC            ; ?FC Error
1B37: C37915  	        jp      ERROR           ; Output error-
              	
1B3A: 2B      	ATOH:   dec     HL              ; ASCII number to DE binary
1B3B: 110000  	GETLN:  ld      DE,$0000        ; Get number to DE
1B3E: CD6A1A  	GTLNLP: call    GETCHR          ; Get next character
1B41: D0      	        ret     NC              ; Exit if not a digit
1B42: E5      	        push    HL              ; Save code string address
1B43: F5      	        push    AF              ; Save digit
1B44: 219819  	        ld      HL,65529/10     ; Largest number 65529
1B47: CD4118  	        call    CPDEHL          ; Number in range?
1B4A: DA6515  	        jp      C,SNERR         ; No - ?SN Error
1B4D: 62      	        ld      H,D             ; HL = Number
1B4E: 6B      	        ld      L,E
1B4F: 19      	        add     HL,DE           ; Times 2
1B50: 29      	        add     HL,HL           ; Times 4
1B51: 19      	        add     HL,DE           ; Times 5
1B52: 29      	        add     HL,HL           ; Times 10
1B53: F1      	        pop     AF              ; Restore digit
1B54: D630    	        sub     '0'             ; Make it 0 to 9
1B56: 5F      	        ld      E,A             ; DE = Value of digit
1B57: 1600    	        ld      D,0
1B59: 19      	        add     HL,DE           ; Add to number
1B5A: EB      	        ex      DE,HL           ; Number to DE
1B5B: E1      	        pop     HL              ; Restore code string address
1B5C: C33E1B  	        jp      GTLNLP          ; Go to next character
              	
1B5F: CA9B16  	CLEAR:  jp      Z,INTVAR        ; Just "CLEAR" Keep parameters
1B62: CD171B  	        call    POSINT          ; Get integer 0 to 32767 to DE
1B65: 2B      	        dec     HL              ; Cancel increment
1B66: CD6A1A  	        call    GETCHR          ; Get next character
1B69: E5      	        push    HL              ; Save code string address
1B6A: 2A9481  	        ld      HL,(LSTRAM)     ; Get end of RAM
1B6D: CA821B  	        jp      Z,STORED        ; No value given - Use stored
1B70: E1      	        pop     HL              ; Restore code string address
1B71: CD4718  	        call    CHKSYN          ; Check for comma
1B74: 2C      	        defb    ','
1B75: D5      	        push    DE              ; Save number
1B76: CD171B  	        call    POSINT          ; Get integer 0 to 32767
1B79: 2B      	        dec     HL              ; Cancel increment
1B7A: CD6A1A  	        call    GETCHR          ; Get next character
1B7D: C26515  	        jp      NZ,SNERR        ; ?SN Error if more on line
1B80: E3      	        ex      (SP),HL         ; Save code string address
1B81: EB      	        ex      DE,HL           ; Number to DE
1B82: 7D      	STORED: ld      A,L             ; Get LSB of new RAM top
1B83: 93      	        sub     E               ; Subtract LSB of string space
1B84: 5F      	        ld      E,A             ; Save LSB
1B85: 7C      	        ld      A,H             ; Get MSB of new RAM top
1B86: 9A      	        sbc     A,D             ; Subtract MSB of string space
1B87: 57      	        ld      D,A             ; Save MSB
1B88: DA3A15  	        jp      C,OMERR         ; ?OM Error if not enough mem
1B8B: E5      	        push    HL              ; Save RAM top
1B8C: 2ABB81  	        ld      HL,(PROGND)     ; Get program end
1B8F: 012800  	        ld      BC,$28          ; 40 Bytes minimum working RAM
1B92: 09      	        add     HL,BC           ; Get lowest address
1B93: CD4118  	        call    CPDEHL          ; Enough memory?
1B96: D23A15  	        jp      NC,OMERR        ; No - ?OM Error
1B99: EB      	        ex      DE,HL           ; RAM top to HL
1B9A: 22AD80  	        ld      (STRSPC),HL     ; Set new string space
1B9D: E1      	        pop     HL              ; End of memory to use
1B9E: 229481  	        ld      (LSTRAM),HL     ; Set new top of RAM
1BA1: E1      	        pop     HL              ; Restore code string address
1BA2: C39B16  	        jp      INTVAR          ; Initialise variables
              	
1BA5: E5      	RUN:    push    HL              ; store HL
1BA6: 21FFFF  	        ld      HL,-1           ; reset...
1BA9: 22B180  	        ld      (HLPLN),HL      ; ...HELP line register
1BAC: E1      	        pop     HL              ; retrieve HL
1BAD: CA9716  	        jp      Z,RUNFST        ; RUN from start if just RUN
1BB0: CD9B16  	        call    INTVAR          ; Initialise variables
1BB3: 012A1A  	        ld      BC,RUNCNT       ; Execution driver loop
1BB6: C3C91B  	        jp      RUNLIN          ; RUN from line number
              	
1BB9: 0E03    	GOSUB:  ld      C,$03           ; 3 Levels of stack needed
1BBB: CD2215  	        call    CHKSTK          ; Check for 3 levels of stack
1BBE: C1      	        pop     BC              ; Get return address
1BBF: E5      	        push    HL              ; Save code string for RETURN
1BC0: E5      	        push    HL              ; And for GOSUB routine
1BC1: 2AAF80  	        ld      HL,(LINEAT)     ; Get current line
1BC4: E3      	        ex      (SP),HL         ; Into stack - Code string out
1BC5: 3E8C    	        ld      A,ZGOSUB        ; "GOSUB" token
1BC7: F5      	        push    AF              ; Save token
1BC8: 33      	        inc     SP              ; Don't save flags
              	
1BC9: C5      	RUNLIN: push    BC              ; Save return address
1BCA: CD3A1B  	GOTO:   call    ATOH            ; ASCII number to DE binary
1BCD: CD0F1C  	        call    REM             ; Get end of line
1BD0: E5      	        push    HL              ; Save end of line
1BD1: 2AAF80  	        ld      HL,(LINEAT)     ; Get current line
1BD4: CD4118  	        call    CPDEHL          ; Line after current?
1BD7: E1      	        pop     HL              ; Restore end of line
1BD8: 23      	        inc     HL              ; Start of next line
1BD9: DC6E16  	        call    C,SRCHLP        ; Line is after current line
1BDC: D46B16  	        call    NC,SRCHLN       ; Line is before current line
1BDF: 60      	        ld      H,B             ; Set up code string address
1BE0: 69      	        ld      L,C
1BE1: 2B      	        dec     HL              ; Incremented after
1BE2: D8      	        ret     C               ; Line found
1BE3: 1E0E    	ULERR:  ld      E,UL            ; ?UL Error
1BE5: C37915  	        jp      ERROR           ; Output error message
              	
1BE8: C0      	RETURN: ret     NZ              ; Return if not just RETURN
1BE9: 16FF    	        ld      D,-1            ; Flag "GOSUB" search
1BEB: CDEE14  	        call    BAKSTK          ; Look "GOSUB" block
1BEE: F9      	        ld      SP,HL           ; Kill all FORs in subroutine
1BEF: FE8C    	        cp      ZGOSUB          ; Test for "GOSUB" token
1BF1: 1E04    	        ld      E,RG            ; ?RG Error
1BF3: C27915  	        jp      NZ,ERROR        ; Error if no "GOSUB" found
1BF6: E1      	        pop     HL              ; Get RETURN line number
1BF7: 22AF80  	        ld      (LINEAT),HL     ; Save as current
1BFA: 23      	        inc     HL              ; Was it from direct statement?
1BFB: 7C      	        ld      A,H
1BFC: B5      	        or      L               ; Return to line
1BFD: C2071C  	        jp      NZ,RETLIN       ; No - Return to line
1C00: 3AB181  	        ld      A,(LSTBIN)      ; Any INPUT in subroutine?
1C03: B7      	        or      A               ; If so buffer is corrupted
1C04: C2BE15  	        jp      NZ,POPNOK       ; Yes - Go to command mode
1C07: 212A1A  	RETLIN: ld      HL,RUNCNT       ; Execution driver loop
1C0A: E3      	        ex      (SP),HL         ; Into stack - Code string out
1C0B: 3E      	        defb    $3E             ; Skip "pop HL"
1C0C: E1      	NXTDTA: pop     HL              ; Restore code string address
              	
1C0D: 013A    	DATA:   defb    $01,$3A         ; ':' End of statement
1C0F: 0E00    	REM:    ld      C,$00           ; 00  End of statement
1C11: 0600    	        ld      B,$00
1C13: 79      	NXTSTL: ld      A,C             ; Statement and byte
1C14: 48      	        ld      C,B
1C15: 47      	        ld      B,A             ; Statement end byte
1C16: 7E      	NXTSTT: ld      A,(HL)          ; Get byte
1C17: B7      	        or      A               ; End of line?
1C18: C8      	        ret     Z               ; Yes - Exit
1C19: B8      	        cp      B               ; End of statement?
1C1A: C8      	        ret     Z               ; Yes - Exit
1C1B: 23      	        inc     HL              ; Next byte
1C1C: FE22    	        cp      $22             ; '"'             ; Literal string?
1C1E: CA131C  	        jp      Z,NXTSTL        ; Yes - Look for another '"'
1C21: C3161C  	        jp      NXTSTT          ; Keep looking
              	
1C24: CDEE20  	LET:    call    GETVAR          ; Get variable name
1C27: CD4718  	        call    CHKSYN          ; Make sure "=" follows
1C2A: C6      	        defb    ZEQUAL          ; "=" token
1C2B: D5      	        push    DE              ; Save address of variable
1C2C: 3A9281  	        ld      A,(TYPE)        ; Get data type
1C2F: F5      	        push    AF              ; Save type
1C30: CDF11E  	        call    EVAL            ; Evaluate expression
1C33: F1      	        pop     AF              ; Restore type
1C34: E3      	        ex      (SP),HL         ; Save code - Get var addr
1C35: 22B381  	        ld      (BRKLIN),HL     ; Save address of variable
1C38: 1F      	        rra                     ; Adjust type
1C39: CDE41E  	        call    CHKTYP          ; Check types are the same
1C3C: CA771C  	        jp      Z,LETNUM        ; Numeric - Move value
1C3F: E5      	LETSTR: push    HL              ; Save address of string var
1C40: 2AC981  	        ld      HL,(FPREG)      ; Pointer to string entry
1C43: E5      	        push    HL              ; Save it on stack
1C44: 23      	        inc     HL              ; Skip over length
1C45: 23      	        inc     HL
1C46: 5E      	        ld      E,(HL)          ; LSB of string address
1C47: 23      	        inc     HL
1C48: 56      	        ld      D,(HL)          ; MSB of string address
1C49: 2A3381  	        ld      HL,(BASTXT)     ; Point to start of program
1C4C: CD4118  	        call    CPDEHL          ; Is string before program?
1C4F: D2661C  	        jp      NC,CRESTR       ; Yes - Create string entry
1C52: 2AAD80  	        ld      HL,(STRSPC)     ; Point to string space
1C55: CD4118  	        call    CPDEHL          ; Is string literal in program?
1C58: D1      	        pop     DE              ; Restore address of string
1C59: D26E1C  	        jp      NC,MVSTPT       ; Yes - Set up pointer
1C5C: 21A481  	        ld      HL,TMPSTR       ; Temporary string pool
1C5F: CD4118  	        call    CPDEHL          ; Is string in temporary pool?
1C62: D26E1C  	        jp      NC,MVSTPT       ; No - Set up pointer
1C65: 3E      	        defb    $3E             ; Skip "pop DE"
1C66: D1      	CRESTR: pop     DE              ; Restore address of string
1C67: CD4825  	        call    BAKTMP          ; Back to last tmp-str entry
1C6A: EB      	        ex      DE,HL           ; Address of string entry
1C6B: CD8123  	        call    SAVSTR          ; Save string in string area
1C6E: CD4825  	MVSTPT: call    BAKTMP          ; Back to last tmp-str entry
1C71: E1      	        pop     HL              ; Get string pointer
1C72: CD482D  	        call    DETHL4          ; Move string pointer to var
1C75: E1      	        pop     HL              ; Restore code string address
1C76: C9      	        ret
              	
1C77: E5      	LETNUM: push    HL              ; Save address of variable
1C78: CD452D  	        call    FPTHL           ; Move value to variable
1C7B: D1      	        pop     DE              ; Restore address of variable
1C7C: E1      	        pop     HL              ; Restore code string address
1C7D: C9      	        ret
              	
1C7E: CD6527  	ON:     call    GETINT          ; Get integer 0-255
1C81: 7E      	        ld      A,(HL)          ; Get "GOTO" or "GOSUB" token
1C82: 47      	        ld      B,A             ; Save in B
1C83: FE8C    	        cp      ZGOSUB          ; "GOSUB" token?
1C85: CA8D1C  	        jp      Z,ONGO          ; Yes - Find line number
1C88: CD4718  	        call    CHKSYN          ; Make sure it's "GOTO"
1C8B: 88      	        defb    ZGOTO           ; "GOTO" token
1C8C: 2B      	        dec     HL              ; Cancel increment
1C8D: 4B      	ONGO:   ld      C,E             ; Integer of branch value
1C8E: 0D      	ONGOLP: dec     C               ; Count branches
1C8F: 78      	        ld      A,B             ; Get "GOTO" or "GOSUB" token
1C90: CA521A  	        jp      Z,ONJMP         ; Go to that line if right one
1C93: CD3B1B  	        call    GETLN           ; Get line number to DE
1C96: FE2C    	        cp      ','             ; Another line number?
1C98: C0      	        ret     NZ              ; No - Drop through
1C99: C38E1C  	        jp      ONGOLP          ; Yes - loop
              	
1C9C: CDF11E  	IF:     call    EVAL            ; Evaluate expression
1C9F: 7E      	        ld      A,(HL)          ; Get token
1CA0: FE88    	        cp      ZGOTO           ; "GOTO" token?
1CA2: CAAA1C  	        jp      Z,IFGO          ; Yes - Get line
1CA5: CD4718  	        call    CHKSYN          ; Make sure it's "THEN"
1CA8: B8      	        defb    ZTHEN           ; "THEN" token
1CA9: 2B      	        dec     HL              ; Cancel increment
1CAA: CDE21E  	IFGO:   call    TSTNUM          ; Make sure it's numeric
1CAD: CDED2C  	        call    TSTSGN          ; Test state of expression
1CB0: CA0F1C  	        jp      Z,REM           ; False - Drop through
1CB3: CD6A1A  	        call    GETCHR          ; Get next character
1CB6: DACA1B  	        jp      C,GOTO          ; Number - GOTO that line
1CB9: C3511A  	        jp      IFJMP           ; Otherwise do statement
              	
1CBC: 2B      	MRPRNT: dec     HL              ; dec 'cos GETCHR INCs
1CBD: CD6A1A  	        call    GETCHR          ; Get next character
1CC0: CA231D  	PRINT:  jp      Z,PRNTCRLF      ; CRLF if just PRINT
1CC3: C8      	PRNTLP: ret     Z               ; End of list - Exit
1CC4: FEB4    	        cp      ZTAB            ; "TAB(" token?
1CC6: CA4B1D  	        jp      Z,DOTAB         ; Yes - Do TAB routine
1CC9: FEB7    	        cp      ZSPC            ; "SPC(" token?
1CCB: CA4B1D  	        jp      Z,DOTAB         ; Yes - Do SPC routine
1CCE: E5      	        push    HL              ; Save code string address
1CCF: FE2C    	        cp      ','             ; Comma?
1CD1: CA321D  	        jp      Z,DOCOM         ; Yes - Move to next zone
1CD4: FE3B    	        cp      ';'             ; Semi-colon?
1CD6: CA6F1D  	        jp      Z,NEXITM        ; Do semi-colon routine
1CD9: C1      	        pop     BC              ; Code string address to BC
1CDA: CDF11E  	        call    EVAL            ; Evaluate expression
1CDD: E5      	        push    HL              ; Save code string address
1CDE: 3A9281  	        ld      A,(TYPE)        ; Get variable type
1CE1: B7      	        or      A               ; Is it a string variable?
1CE2: C20A1D  	        jp      NZ,PRNTST       ; Yes - Output string contents
1CE5: CD922E  	        call    NUMASC          ; Convert number to text
1CE8: CDA523  	        call    CRTST           ; Create temporary string
1CEB: 3600    	        ld      (HL),NLLCR      ; Followed by a NULL char (was SPC, space)
1CED: 2AC981  	        ld      HL,(FPREG)      ; Get length of output
1CF0: 34      	        inc     (HL)            ; Plus 1 for the space
1CF1: 2AC981  	        ld      HL,(FPREG)      ; < Not needed >
1CF4: 3AA280  	        ld      A,(LWIDTH)      ; Get width of line
1CF7: 47      	        ld      B,A             ; To B
1CF8: 04      	        inc     B               ; Width 255 (No limit)?
1CF9: CA061D  	        jp      Z,PRNTNB        ; Yes - Output number string
1CFC: 04      	        inc     B               ; Adjust it
1CFD: 3A9081  	        ld      A,(CURPOS)      ; Get cursor position
1D00: 86      	        add     A,(HL)          ; Add length of string
1D01: 3D      	        dec     A               ; Adjust it
1D02: B8      	        cp      B               ; Will output fit on this line?
1D03: D4231D  	        call    NC,PRNTCRLF     ; No - CRLF first
1D06: CDEA23  	PRNTNB: call    PRS1            ; Output string at (HL)
1D09: AF      	        xor     A               ; Skip call by setting 'z' flag
1D0A: C4EA23  	PRNTST: call    NZ,PRS1         ; Output string at (HL)
1D0D: E1      	        pop     HL              ; Restore code string address
1D0E: C3BC1C  	        jp      MRPRNT          ; See if more to PRINT
              	
1D11: 3A9081  	STTLIN: ld      A,(CURPOS)      ; Make sure on new line
1D14: B7      	        or      A               ; Already at start?
1D15: C8      	        ret     Z               ; Yes - Do nothing
1D16: C3231D  	        jp      PRNTCRLF        ; Start a new line
              	
1D19: AF      	ENDINP: xor     A
1D1A: 322982  	        ld      (KBDNPT),A      ; char is not from keyboard
1D1D: 77      	        ld      (HL),A          ; Mark end of buffer
1D1E: 213581  	        ld      HL,BUFFER-1     ; Point to buffer
1D21: 180A    	        jr      CNTEND
1D23: 3E0D    	PRNTCRLF:ld     A,CR            ; Load a CR
1D25: CD5218  	        call    OUTC            ; Output character
1D28: 3E0A    	        ld      A,LF            ; Load a LF
1D2A: CD5218  	        call    OUTC            ; Output character
1D2D: AF      	CNTEND: xor     A               ; Set to position 0
1D2E: 329081  	        ld      (CURPOS),A      ; Store it
1D31: C9      	        ret                     ; return to caller
              	
1D32: 3AA380  	DOCOM:  ld      A,(COMMAN)      ; Get comma width
1D35: 47      	        ld      B,A             ; Save in B
1D36: 3AE481  	        ld      A,(SCR_CURS_X)  ; Get current position
1D39: B8      	        cp      B               ; Within the limit?
1D3A: D4231D  	        call    NC,PRNTCRLF     ; No - output CRLF
1D3D: D26F1D  	        jp      NC,NEXITM       ; Get next item
1D40: D60A    	ZONELP: sub     $0A             ; Next zone of 10 characters
1D42: D2401D  	        jp      NC,ZONELP       ; Repeat if more zones
1D45: 2F      	        cpl                     ; Number of null chars to output
1D46: 0E00    	        ld      C,NLLCR         ; null char
1D48: C3651D  	        jp      ASPCS           ; Output them
              	
1D4B: F5      	DOTAB:  push    AF              ; Save token
1D4C: CD6227  	        call    FNDNUM          ; Evaluate expression
1D4F: CD4718  	        call    CHKSYN          ; Make sure ")" follows
1D52: 29      	        defb    ')'
1D53: 2B      	        dec     HL              ; Back space on to ")"
1D54: F1      	        pop     AF              ; Restore token
1D55: 0E00    	        ld      C,NLLCR         ; for SPC we use NULL char (was SPACE)
1D57: D6B7    	        sub     ZSPC            ; Was it "SPC(" ?
1D59: E5      	        push    HL              ; Save code string address
1D5A: CA601D  	        jp      Z,DOSPC         ; Yes - Do 'E' spaces
1D5D: 3AE481  	        ld      A,(SCR_CURS_X)  ; Get current X position
1D60: 2F      	DOSPC:  cpl                     ; Number of spaces to print to
1D61: 83      	        add     A,E             ; Total number to print
1D62: D26F1D  	        jp      NC,NEXITM       ; TAB < Current POS(X)
1D65: 3C      	ASPCS:  inc     A               ; Output A spaces
1D66: 47      	        ld      B,A             ; Save number to print
1D67: 79      	SPCLP:  ld      A,C             ; char to print
1D68: CD5218  	        call    OUTC            ; Output character in A
1D6B: 05      	        dec     B               ; Count them
1D6C: C2671D  	        jp      NZ,SPCLP        ; Repeat if more
1D6F: E1      	NEXITM: pop     HL              ; Restore code string address
1D70: CD6A1A  	        call    GETCHR          ; Get next character
1D73: C3C31C  	        jp      PRNTLP          ; More to print
              	
1D76: 3F526564	REDO:   defb    "?Redo from start",CR,0
1D7A: 6F206672	
1D7E: 6F6D2073	
1D82: 74617274	
1D86: 0D00    	
              	
1D88: 3AB281  	BADINP: ld      A,(READFG)      ; READ or INPUT?
1D8B: B7      	        or      A
1D8C: C25F15  	        jp      NZ,DATSNR       ; READ - ?SN Error
1D8F: C1      	        pop     BC              ; Throw away code string addr
1D90: 21761D  	        ld      HL,REDO         ; "Redo from start" message
1D93: CDE723  	        call    PRS             ; Output string
1D96: C3CA16  	        jp      DOAGN           ; Do last INPUT again
              	
1D99: CD5223  	INPUT:  call    IDTEST          ; Test for illegal direct
1D9C: 7E      	        ld      A,(HL)          ; Get character after "INPUT"
1D9D: FE22    	        cp      $22             ; '"' ; Is there a prompt string?
1D9F: 3E00    	        ld      A,$00           ; Clear A and leave flags
1DA1: 32A580  	        ld      (CTLOFG),A      ; Enable output
1DA4: C2B31D  	        jp      NZ,NOPMPT       ; No prompt - get input
1DA7: CDA623  	        call    QTSTR           ; Get string terminated by '"'
1DAA: CD4718  	        call    CHKSYN          ; Check for ';' after prompt
1DAD: 3B      	        defb    ";"
1DAE: E5      	        push    HL              ; Save code string address
1DAF: CDEA23  	        call    PRS1            ; Output prompt string
1DB2: 3E      	        defb    $3E             ; Skip "push HL"
1DB3: E5      	NOPMPT: push    HL              ; Save code string address
1DB4: CDCE16  	        call    PROMPT          ; Get input with "? " prompt
1DB7: C1      	        pop     BC              ; Restore code string address
1DB8: DAB91A  	        jp      C,INPBRK        ; Break pressed - Exit
1DBB: 23      	        inc     HL              ; Next byte
1DBC: 7E      	        ld      A,(HL)          ; Get it
1DBD: B7      	        or      A               ; End of line?
1DBE: 2B      	        dec     HL              ; Back again
1DBF: C5      	        push    BC              ; Re-save code string address
1DC0: CD7008  	        call    CURSOR_OFF      ; disable cursor
1DC3: CA0C1C  	        jp      Z,NXTDTA        ; Yes - Find next DATA stmt
1DC6: 362C    	        ld      (HL),','        ; Store comma as separator
1DC8: C3D01D  	        jp      NXTITM          ; Get next item
              	
1DCB: E5      	READ:   push    HL              ; Save code string address
1DCC: 2AC181  	        ld      HL,(NXTDAT)     ; Next DATA statement
1DCF: F6      	        defb    $F6             ; Flag "READ"
1DD0: AF      	NXTITM: xor     A               ; Flag "INPUT"
1DD1: 32B281  	        ld      (READFG),A      ; Save "READ"/"INPUT" flag
1DD4: E3      	        ex      (SP),HL         ; Get code str' , Save pointer
1DD5: C3DC1D  	        jp      GTVLUS          ; Get values
              	
1DD8: CD4718  	NEDMOR: call    CHKSYN          ; Check for comma between items
1DDB: 2C      	        defb    ','
1DDC: CDEE20  	GTVLUS: call    GETVAR          ; Get variable name
1DDF: E3      	        ex      (SP),HL         ; Save code str" , Get pointer
1DE0: D5      	        push    DE              ; Save variable address
1DE1: 7E      	        ld      A,(HL)          ; Get next "INPUT"/"DATA" byte
1DE2: FE2C    	        cp      ','             ; Comma?
1DE4: CA041E  	        jp      Z,ANTVLU        ; Yes - Get another value
1DE7: 3AB281  	        ld      A,(READFG)      ; Is it READ?
1DEA: B7      	        or      A
1DEB: C2701E  	        jp      NZ,FDTLP        ; Yes - Find next DATA stmt
1DEE: 3E3F    	        ld      A,'?'           ; More INPUT needed
1DF0: CD5218  	        call    OUTC            ; Output character
1DF3: CDCE16  	        call    PROMPT          ; Get INPUT with prompt
1DF6: D1      	        pop     DE              ; Variable address
1DF7: C1      	        pop     BC              ; Code string address
1DF8: DAB91A  	        jp      C,INPBRK        ; Break pressed
1DFB: 23      	        inc     HL              ; Point to next DATA byte
1DFC: 7E      	        ld      A,(HL)          ; Get byte
1DFD: B7      	        or      A               ; Is it zero (No input) ?
1DFE: 2B      	        dec     HL              ; Back space INPUT pointer
1DFF: C5      	        push    BC              ; Save code string address
1E00: CA0C1C  	        jp      Z,NXTDTA        ; Find end of buffer
1E03: D5      	        push    DE              ; Save variable address
1E04: 3A9281  	ANTVLU: ld      A,(TYPE)        ; Check data type
1E07: B7      	        or      A               ; Is it numeric?
1E08: CA2E1E  	        jp      Z,INPBIN        ; Yes - Convert to binary
1E0B: CD6A1A  	        call    GETCHR          ; Get next character
1E0E: 57      	        ld      D,A             ; Save input character
1E0F: 47      	        ld      B,A             ; Again
1E10: FE22    	        cp      $22             ; '"'     ; Start of literal sting?
1E12: CA221E  	        jp      Z,STRENT        ; Yes - Create string entry
1E15: 3AB281  	        ld      A,(READFG)      ; "READ" or "INPUT" ?
1E18: B7      	        or      A
1E19: 57      	        ld      D,A             ; Save 00 if "INPUT"
1E1A: CA1F1E  	        jp      Z,ITMSEP        ; "INPUT" - End with 00
1E1D: 163A    	        ld      D,':'           ; "DATA" - End with 00 or ':'
1E1F: 062C    	ITMSEP: ld      B,','           ; Item separator
1E21: 2B      	        dec     HL              ; Back space for DTSTR
1E22: CDA923  	STRENT: call    DTSTR           ; Get string terminated by D
1E25: EB      	        ex      DE,HL           ; String address to DE
1E26: 21391E  	        ld      HL,LTSTND       ; Where to go after LETSTR
1E29: E3      	        ex      (SP),HL         ; Save HL , get input pointer
1E2A: D5      	        push    DE              ; Save address of string
1E2B: C33F1C  	        jp      LETSTR          ; Assign string to variable
              	
1E2E: CD6A1A  	INPBIN: call    GETCHR          ; Get next character
1E31: CDF42D  	        call    ASCTFP          ; Convert ASCII to FP number
1E34: E3      	        ex      (SP),HL         ; Save input ptr, Get var addr
1E35: CD452D  	        call    FPTHL           ; Move FPREG to variable
1E38: E1      	        pop     HL              ; Restore input pointer
1E39: 2B      	LTSTND: dec     HL              ; dec 'cos GETCHR INCs
1E3A: CD6A1A  	        call    GETCHR          ; Get next character
1E3D: CA451E  	        jp      Z,MORDT         ; End of line - More needed?
1E40: FE2C    	        cp      ','             ; Another value?
1E42: C2881D  	        jp      NZ,BADINP       ; No - Bad input
1E45: E3      	MORDT:  ex      (SP),HL         ; Get code string address
1E46: 2B      	        dec     HL              ; dec 'cos GETCHR INCs
1E47: CD6A1A  	        call    GETCHR          ; Get next character
1E4A: C2D81D  	        jp      NZ,NEDMOR       ; More needed - Get it
1E4D: D1      	        pop     DE              ; Restore DATA pointer
1E4E: 3AB281  	        ld      A,(READFG)      ; "READ" or "INPUT" ?
1E51: B7      	        or      A
1E52: EB      	        ex      DE,HL           ; DATA pointer to HL
1E53: C2901A  	        jp      NZ,UPDATA       ; Update DATA pointer if "READ"
1E56: D5      	        push    DE              ; Save code string address
1E57: B6      	        or      (HL)            ; More input given?
1E58: 21601E  	        ld      HL,EXTIG        ; "?Extra ignored" message
1E5B: C4E723  	        call    NZ,PRS          ; Output string if extra given
1E5E: E1      	        pop     HL              ; Restore code string address
1E5F: C9      	        ret
              	
1E60: 3F457874	EXTIG:  defb    "?Extra ignored",CR,0
1E64: 72612069	
1E68: 676E6F72	
1E6C: 65640D00	
              	
1E70: CD0D1C  	FDTLP:  call    DATA            ; Get next statement
1E73: B7      	        or      A               ; End of line?
1E74: C2891E  	        jp      NZ,FANDT        ; No - See if DATA statement
1E77: 23      	        inc     HL
1E78: 7E      	        ld      A,(HL)          ; End of program?
1E79: 23      	        inc     HL
1E7A: B6      	        or      (HL)            ; 00 00 Ends program
1E7B: 1E06    	        ld      E,OD            ; ?OD Error
1E7D: CA7915  	        jp      Z,ERROR         ; Yes - Out of DATA
1E80: 23      	        inc     HL
1E81: 5E      	        ld      E,(HL)          ; LSB of line number
1E82: 23      	        inc     HL
1E83: 56      	        ld      D,(HL)          ; MSB of line number
1E84: EB      	        ex      DE,HL
1E85: 22AE81  	        ld      (DATLIN),HL     ; Set line of current DATA item
1E88: EB      	        ex      DE,HL
1E89: CD6A1A  	FANDT:  call    GETCHR          ; Get next character
1E8C: FE83    	        cp      ZDATA           ; "DATA" token
1E8E: C2701E  	        jp      NZ,FDTLP        ; No "DATA" - Keep looking
1E91: C3041E  	        jp      ANTVLU          ; Found - Convert input
              	
1E94: 110000  	NEXT:   ld      DE,$0000        ; In case no index given
1E97: C4EE20  	NEXT1:  call    NZ,GETVAR       ; Get index address
1E9A: 22B381  	        ld      (BRKLIN),HL     ; Save code string address
1E9D: CDEE14  	        call    BAKSTK          ; Look for "FOR" block
1EA0: C26B15  	        jp      NZ,NFERR        ; No "FOR" - ?NF Error
1EA3: F9      	        ld      SP,HL           ; Clear nested loops
1EA4: D5      	        push    DE              ; Save index address
1EA5: 7E      	        ld      A,(HL)          ; Get sign of STEP
1EA6: 23      	        inc     HL
1EA7: F5      	        push    AF              ; Save sign of STEP
1EA8: D5      	        push    DE              ; Save index address
1EA9: CD2B2D  	        call    PHLTFP          ; Move index value to FPREG
1EAC: E3      	        ex      (SP),HL         ; Save address of TO value
1EAD: E5      	        push    HL              ; Save address of index
1EAE: CD472A  	        call    ADDPHL          ; Add STEP to index value
1EB1: E1      	        pop     HL              ; Restore address of index
1EB2: CD452D  	        call    FPTHL           ; Move value to index variable
1EB5: E1      	        pop     HL              ; Restore address of TO value
1EB6: CD3C2D  	        call    LOADFP          ; Move TO value to BCDE
1EB9: E5      	        push    HL              ; Save address of line of FOR
1EBA: CD682D  	        call    CMPNUM          ; Compare index with TO value
1EBD: E1      	        pop     HL              ; Restore address of line num
1EBE: C1      	        pop     BC              ; Address of sign of STEP
1EBF: 90      	        sub     B               ; Compare with expected sign
1EC0: CD3C2D  	        call    LOADFP          ; BC = Loop stmt,DE = Line num
1EC3: CACF1E  	        jp      Z,KILFOR        ; Loop finished - Terminate it
1EC6: EB      	        ex      DE,HL           ; Loop statement line number
1EC7: 22AF80  	        ld      (LINEAT),HL     ; Set loop line number
1ECA: 69      	        ld      L,C             ; Set code string to loop
1ECB: 60      	        ld      H,B
1ECC: C3261A  	        jp      PUTFID          ; Put back "FOR" and continue
              	
1ECF: F9      	KILFOR: ld      SP,HL           ; Remove "FOR" block
1ED0: 2AB381  	        ld      HL,(BRKLIN)     ; Code string after "NEXT"
1ED3: 7E      	        ld      A,(HL)          ; Get next byte in code string
1ED4: FE2C    	        cp      ','             ; More NEXTs ?
1ED6: C22A1A  	        jp      NZ,RUNCNT       ; No - Do next statement
1ED9: CD6A1A  	        call    GETCHR          ; Position to index name
1EDC: CD971E  	        call    NEXT1           ; Re-enter NEXT routine
              	; < will not RETurn to here , Exit to RUNCNT or Loop >
              	
1EDF: CDF11E  	GETNUM: call    EVAL            ; Get a numeric expression
1EE2: F6      	TSTNUM: defb    $F6             ; Clear carry (numeric)
1EE3: 37      	TSTSTR: scf                     ; Set carry (string)
1EE4: 3A9281  	CHKTYP: ld      A,(TYPE)        ; Check types match
1EE7: 8F      	        adc     A,A             ; Expected + actual
1EE8: B7      	        or      A               ; Clear carry , set parity
1EE9: E8      	        ret     PE              ; Even parity - Types match
1EEA: C37715  	        jp      TMERR           ; Different types - Error
              	
1EED: CD4718  	OPNPAR: call    CHKSYN          ; Make sure "(" follows
1EF0: 28      	        defb    '('
1EF1: 2B      	EVAL:   dec     HL              ; Evaluate expression & save
1EF2: 1600    	        ld      D,$00           ; Precedence value
1EF4: D5      	EVAL1:  push    DE              ; Save precedence
1EF5: 0E01    	        ld      C,$01
1EF7: CD2215  	        call    CHKSTK          ; Check for 1 level of stack
1EFA: CD681F  	        call    OPRND           ; Get next expression value
1EFD: 22B581  	EVAL2:  ld      (NXTOPR),HL     ; Save address of next operator
1F00: 2AB581  	EVAL3:  ld      HL,(NXTOPR)     ; Restore address of next opr
1F03: C1      	        pop     BC              ; Precedence value and operator
1F04: 78      	        ld      A,B             ; Get precedence value
1F05: FE78    	        cp      $78             ; "AND", "OR", or "XOR" ?
1F07: D4E21E  	        call    NC,TSTNUM       ; No - Make sure it's a number
1F0A: 7E      	        ld      A,(HL)          ; Get next operator / function
1F0B: 1600    	        ld      D,$00           ; Clear Last relation
1F0D: D6C5    	RLTLP:  sub     ZGTR            ; ">" Token
1F0F: DA291F  	        jp      C,FOPRND        ; + - * / ^ AND OR XOR - Test it
1F12: FE03    	        cp      ZLTH+1-ZGTR     ; < = >
1F14: D2291F  	        jp      NC,FOPRND       ; Function - Call it
1F17: FE01    	        cp      ZEQUAL-ZGTR     ; "="
1F19: 17      	        rla                     ; <- Test for legal
1F1A: AA      	        xor     D               ; <- combinations of < = >
1F1B: BA      	        cp      D               ; <- by combining last token
1F1C: 57      	        ld      D,A             ; <- with current one
1F1D: DA6515  	        jp      C,SNERR         ; Error if "<<' '==" or ">>"
1F20: 22AA81  	        ld      (CUROPR),HL     ; Save address of current token
1F23: CD6A1A  	        call    GETCHR          ; Get next character
1F26: C30D1F  	        jp      RLTLP           ; Treat the two as one
              	
1F29: 7A      	FOPRND: ld      A,D             ; < = > found ?
1F2A: B7      	        or      A
1F2B: C26920  	        jp      NZ,TSTRED       ; Yes - Test for reduction
1F2E: 7E      	        ld      A,(HL)          ; Get operator token
1F2F: 22AA81  	        ld      (CUROPR),HL     ; Save operator address
1F32: D6BB    	        sub     ZPLUS           ; Operator or function?
1F34: D8      	        ret     C               ; Neither - Exit
1F35: FE0A    	        cp      ZOR+1-ZPLUS     ; Is it + - * / ^ AND XOR OR ?
1F37: D0      	        ret     NC              ; No - Exit
1F38: 5F      	        ld      E,A             ; Coded operator
1F39: 3A9281  	        ld      A,(TYPE)        ; Get data type
1F3C: 3D      	        dec     A               ; FF = numeric , 00 = string
1F3D: B3      	        or      E               ; Combine with coded operator
1F3E: 7B      	        ld      A,E             ; Get coded operator
1F3F: CADD24  	        jp      Z,CONCAT        ; String concatenation
1F42: 07      	        rlca                    ; Times 2
1F43: 83      	        add     A,E             ; Times 3
1F44: 5F      	        ld      E,A             ; To DE (D is 0)
1F45: 211612  	        ld      HL,PRITAB       ; Precedence table
1F48: 19      	        add     HL,DE           ; To the operator concerned
1F49: 78      	        ld      A,B             ; Last operator precedence
1F4A: 56      	        ld      D,(HL)          ; Get evaluation precedence
1F4B: BA      	        cp      D               ; Compare with eval precedence
1F4C: D0      	        ret     NC              ; Exit if higher precedence
1F4D: 23      	        inc     HL              ; Point to routine address
1F4E: CDE21E  	        call    TSTNUM          ; Make sure it's a number
              	
1F51: C5      	STKTHS: push    BC              ; Save last precedence & token
1F52: 01001F  	        ld      BC,EVAL3        ; Where to go on prec' break
1F55: C5      	        push    BC              ; Save on stack for return
1F56: 43      	        ld      B,E             ; Save operator
1F57: 4A      	        ld      C,D             ; Save precedence
1F58: CD1E2D  	        call    STAKFP          ; Move value to stack
1F5B: 58      	        ld      E,B             ; Restore operator
1F5C: 51      	        ld      D,C             ; Restore precedence
1F5D: 4E      	        ld      C,(HL)          ; Get LSB of routine address
1F5E: 23      	        inc     HL
1F5F: 46      	        ld      B,(HL)          ; Get MSB of routine address
1F60: 23      	        inc     HL
1F61: C5      	        push    BC              ; Save routine address
1F62: 2AAA81  	        ld      HL,(CUROPR)     ; Address of current operator
1F65: C3F41E  	        jp      EVAL1           ; Loop until prec' break
              	
1F68: AF      	OPRND:  xor     A               ; Get operand routine
1F69: 329281  	        ld      (TYPE),A        ; Set numeric expected
1F6C: CD6A1A  	        call    GETCHR          ; Get next character
1F6F: 1E24    	        ld      E,MO            ; ?MO Error
1F71: CA7915  	        jp      Z,ERROR         ; No operand - Error
1F74: DAF42D  	        jp      C,ASCTFP        ; Number - Get value
1F77: CD0C1B  	        call    CHKLTR          ; See if a letter
1F7A: D2CF1F  	        jp      NC,CONVAR       ; Letter - Find variable
1F7D: FE26    	        cp      '&'             ; &H = HEX, &B = BINARY
1F7F: 2012    	        jr      NZ,NOTAMP
1F81: CD6A1A  	        call    GETCHR          ; Get next character
1F84: FE48    	        cp      'H'             ; Hex number indicated? [function added]
1F86: CAFE3C  	        jp      Z,HEXTFP        ; Convert Hex to FPREG
1F89: FE42    	        cp      'B'             ; Binary number indicated? [function added]
1F8B: CA6E3D  	        jp      Z,BINTFP        ; Convert Bin to FPREG
1F8E: 1E02    	        ld      E,SN            ; If neither then a ?SN Error
1F90: CA7915  	        jp      Z,ERROR         ;
1F93: FEBB    	NOTAMP: cp      ZPLUS           ; '+' Token ?
1F95: CA681F  	        jp      Z,OPRND         ; Yes - Look for operand
1F98: FE2E    	        cp      '.'             ; '.' ?
1F9A: CAF42D  	        jp      Z,ASCTFP        ; Yes - Create FP number
1F9D: FEBC    	        cp      ZMINUS          ; '-' Token ?
1F9F: CABE1F  	        jp      Z,MINUS         ; Yes - Do minus
1FA2: FE22    	        cp      $22             ; '"'             ; Literal string ?
1FA4: CAA623  	        jp      Z,QTSTR         ; Get string terminated by '"'
1FA7: FEB9    	        cp      ZNOT            ; "NOT" Token ?
1FA9: CAC920  	        jp      Z,EVNOT         ; Yes - Eval NOT expression
1FAC: FEB6    	        cp      ZFN             ; "FN" Token ?
1FAE: CA0A23  	        jp      Z,DOFN          ; Yes - Do FN routine
1FB1: D6C8    	        sub     ZSGN            ; Is it a function?
1FB3: D2E01F  	        jp      NC,FNOFST       ; Yes - Evaluate function
1FB6: CDED1E  	EVLPAR: call    OPNPAR          ; Evaluate expression in "()"
1FB9: CD4718  	        call    CHKSYN          ; Make sure ")" follows
1FBC: 29      	        defb    ')'
1FBD: C9      	        ret
              	
1FBE: 167D    	MINUS:  ld      D,$7D           ; '-' precedence
1FC0: CDF41E  	        call    EVAL1           ; Evaluate until prec' break
1FC3: 2AB581  	        ld      HL,(NXTOPR)     ; Get next operator address
1FC6: E5      	        push    HL              ; Save next operator address
1FC7: CD162D  	        call    INVSGN          ; Negate value
1FCA: CDE21E  	RETNUM: call    TSTNUM          ; Make sure it's a number
1FCD: E1      	        pop     HL              ; Restore next operator address
1FCE: C9      	        ret
              	
1FCF: CDEE20  	CONVAR: call    GETVAR          ; Get variable address to DE
1FD2: E5      	FRMEVL: push    HL              ; Save code string address
1FD3: EB      	        ex      DE,HL           ; Variable address to HL
1FD4: 22C981  	        ld      (FPREG),HL      ; Save address of variable
1FD7: 3A9281  	        ld      A,(TYPE)        ; Get type
1FDA: B7      	        or      A               ; Numeric?
1FDB: CC2B2D  	        call    Z,PHLTFP        ; Yes - Move contents to FPREG
1FDE: E1      	        pop     HL              ; Restore code string address
1FDF: C9      	        ret
              	
1FE0: 0600    	FNOFST: ld      B,$00           ; Get address of function
1FE2: 07      	        rlca                    ; Double function offset
1FE3: 4F      	        ld      C,A             ; BC = Offset in function table
1FE4: C5      	        push    BC              ; Save adjusted token value
1FE5: CD6A1A  	        call    GETCHR          ; Get next character
1FE8: 79      	        ld      A,C             ; Get adjusted token value
1FE9: FE2C    	        cp      2*(ZPOINT-ZSGN) ; "POINT" token?
1FEB: CA2935  	        jp      Z,POINT         ; Yes, do "POINT"
1FEE: FE2E    	        cp      2*(ZINSTR-ZSGN) ; "INSTR" token?
1FF0: CAB925  	        jp      Z,INSTR         ; Yes, do "INSTR"
1FF3: FE3D    	        cp      2*(ZLEFT-ZSGN)-1; Adj' LEFT$,RIGHT$ or MID$ ?
1FF5: DA1120  	        jp      C,FNVAL         ; No - Do function
1FF8: CDED1E  	        call    OPNPAR          ; Evaluate expression  (X,...
1FFB: CD4718  	        call    CHKSYN          ; Make sure ',' follows
1FFE: 2C      	        defb    ','
1FFF: CDE31E  	        call    TSTSTR          ; Make sure it's a string
2002: EB      	        ex      DE,HL           ; Save code string address
2003: 2AC981  	        ld      HL,(FPREG)      ; Get address of string
2006: E3      	        ex      (SP),HL         ; Save address of string
2007: E5      	        push    HL              ; Save adjusted token value
2008: EB      	        ex      DE,HL           ; Restore code string address
2009: CD6527  	        call    GETINT          ; Get integer 0-255
200C: EB      	        ex      DE,HL           ; Save code string address
200D: E3      	        ex      (SP),HL         ; Save integer,HL = adj' token
200E: C31920  	        jp      GOFUNC          ; Jump to string function
              	
2011: CDB61F  	FNVAL:  call    EVLPAR          ; Evaluate expression
2014: E3      	        ex      (SP),HL         ; HL = Adjusted token value
2015: 11CA1F  	        ld      DE,RETNUM       ; Return number from function
2018: D5      	        push    DE              ; Save on stack
2019: 01E50F  	GOFUNC: ld      BC,FNCTAB       ; Function routine addresses
201C: 09      	        add     HL,BC           ; Point to right address
201D: 4E      	        ld      C,(HL)          ; Get LSB of address
201E: 23      	        inc     HL              ;
201F: 66      	        ld      H,(HL)          ; Get MSB of address
2020: 69      	        ld      L,C             ; Address to HL
2021: E9      	        jp      (HL)            ; Jump to function
              	
2022: 15      	SGNEXP: dec     D               ; Dee to flag negative exponent
2023: FEBC    	        cp      ZMINUS          ; '-' token ?
2025: C8      	        ret     Z               ; Yes - Return
2026: FE2D    	        cp      '-'             ; '-' ASCII ?
2028: C8      	        ret     Z               ; Yes - Return
2029: 14      	        inc     D               ; Inc to flag positive exponent
202A: FE2B    	        cp      '+'             ; '+' ASCII ?
202C: C8      	        ret     Z               ; Yes - Return
202D: FEBB    	        cp      ZPLUS           ; '+' token ?
202F: C8      	        ret     Z               ; Yes - Return
2030: 2B      	        dec     HL              ; dec 'cos GETCHR INCs
2031: C9      	        ret                     ; Return "NZ"
              	
              	; execute OR, AND, and XOR operations
2032: AF      	PAND:   xor     A               ; for AND, Z=1
2033: 1807    	        jr      CNTLGC          
2035: AF      	POR     xor     A               ; for OR, Z=0, S=1
2036: D601    	        sub     $01
2038: 1802    	        jr      CNTLGC
203A: AF      	PXOR:   xor     A               ; for XOR, Z=0, S=0
203B: 3C      	        inc     A
203C: F5      	CNTLGC: push    AF              ; store operand's flags
203D: CDE21E  	        call    TSTNUM          ; Make sure it's a number
2040: CD201B  	        call    DEINT           ; Get integer -32768 to 32767
2043: F1      	        pop     AF              ; retrieve operand's flags
2044: EB      	        ex      DE,HL           ; <- Get last
2045: C1      	        pop     BC              ; <-  value
2046: E3      	        ex      (SP),HL         ; <-  from
2047: EB      	        ex      DE,HL           ; <-  stack
2048: CD2E2D  	        call    FPBCDE          ; Move last value to FPREG
204B: F5      	        push    AF              ; store operand's flags
204C: CD201B  	        call    DEINT           ; Get integer -32768 to 32767
204F: F1      	        pop     AF              ; retrieve operand's flags
2050: C1      	        pop     BC              ; Get value
2051: 79      	        ld      A,C             ; Get LSB
2052: 21C822  	        ld      HL,ACPASS       ; Address of save AC as current
2055: 2005    	        jr      NZ,POR1         ; if X/OR, jump over
2057: A3      	PAND1:  and     E               ; "AND" LSBs
2058: 4F      	        ld      C,A             ; Save LSB
2059: 78      	        ld      A,B             ; Get MSB
205A: A2      	        and     D               ; "AND" MSBs
205B: E9      	        jp      (HL)            ; Save AC as current (ACPASS)
205C: F26420  	POR1:   jp      P,PXOR1         ; if S=0, jump to XOR
205F: B3      	        or      E               ; "OR" LSBs
2060: 4F      	        ld      C,A             ; Save LSB
2061: 78      	        ld      A,B             ; Get MSB
2062: B2      	        or      D               ; "OR" MSBs
2063: E9      	        jp      (HL)            ; Save AC as current (ACPASS)
2064: AB      	PXOR1:  xor     E               ; "XOR" LSBs
2065: 4F      	        ld      C,A             ; Save LSB
2066: 78      	        ld      A,B             ; Get MSB
2067: AA      	        xor     D               ; "XOR" MSBs
2068: E9      	        jp      (HL)            ; Save AC as current (ACPASS) 
              	
2069: 217B20  	TSTRED: ld      HL,CMPLOG       ; Logical compare routine
206C: 3A9281  	        ld      A,(TYPE)        ; Get data type
206F: 1F      	        rra                     ; Carry set = string
2070: 7A      	        ld      A,D             ; Get last precedence value
2071: 17      	        rla                     ; Times 2 plus carry
2072: 5F      	        ld      E,A             ; To E
2073: 1664    	        ld      D,$64           ; Relational precedence
2075: 78      	        ld      A,B             ; Get current precedence
2076: BA      	        cp      D               ; Compare with last
2077: D0      	        ret     NC              ; Eval if last was rel' or log'
2078: C3511F  	        jp      STKTHS          ; Stack this one and get next
              	
207B: 7D20    	CMPLOG: defw    CMPLG1          ; Compare two values / strings
207D: 79      	CMPLG1: ld      A,C             ; Get data type
207E: B7      	        or      A
207F: 1F      	        rra
2080: C1      	        pop     BC              ; Get last expression to BCDE
2081: D1      	        pop     DE
2082: F5      	        push    AF              ; Save status
2083: CDE41E  	        call    CHKTYP          ; Check that types match
2086: 21BF20  	        ld      HL,CMPRES       ; Result to comparison
2089: E5      	        push    HL              ; Save for RETurn
208A: CA682D  	        jp      Z,CMPNUM        ; Compare values if numeric
208D: AF      	        xor     A               ; Compare two strings
208E: 329281  	        ld      (TYPE),A        ; Set type to numeric
2091: D5      	        push    DE              ; Save string name
2092: CD2A25  	        call    GSTRCU          ; Get current string
2095: 7E      	        ld      A,(HL)          ; Get length of string
2096: 23      	        inc     HL
2097: 23      	        inc     HL
2098: 4E      	        ld      C,(HL)          ; Get LSB of address
2099: 23      	        inc     HL
209A: 46      	        ld      B,(HL)          ; Get MSB of address
209B: D1      	        pop     DE              ; Restore string name
209C: C5      	        push    BC              ; Save address of string
209D: F5      	        push    AF              ; Save length of string
209E: CD2E25  	        call    GSTRDE          ; Get second string
20A1: CD3C2D  	        call    LOADFP          ; Get address of second string
20A4: F1      	        pop     AF              ; Restore length of string 1
20A5: 57      	        ld      D,A             ; Length to D
20A6: E1      	        pop     HL              ; Restore address of string 1
20A7: 7B      	CMPSTR: ld      A,E             ; Bytes of string 2 to do
20A8: B2      	        or      D               ; Bytes of string 1 to do
20A9: C8      	        ret     Z               ; Exit if all bytes compared
20AA: 7A      	        ld      A,D             ; Get bytes of string 1 to do
20AB: D601    	        sub     $01
20AD: D8      	        ret     C               ; Exit if end of string 1
20AE: AF      	        xor     A
20AF: BB      	        cp      E               ; Bytes of string 2 to do
20B0: 3C      	        inc     A
20B1: D0      	        ret     NC              ; Exit if end of string 2
20B2: 15      	        dec     D               ; Count bytes in string 1
20B3: 1D      	        dec     E               ; Count bytes in string 2
20B4: 0A      	        ld      A,(BC)          ; Byte in string 2
20B5: BE      	        cp      (HL)            ; Compare to byte in string 1
20B6: 23      	        inc     HL              ; Move up string 1
20B7: 03      	        inc     BC              ; Move up string 2
20B8: CAA720  	        jp      Z,CMPSTR        ; Same - Try next bytes
20BB: 3F      	        ccf                     ; Flag difference (">" or "<")
20BC: C3F82C  	        jp      FLGDIF          ; "<" gives -1 , ">" gives +1
              	
20BF: 3C      	CMPRES: inc     A               ; Increment current value
20C0: 8F      	        adc     A,A             ; Double plus carry
20C1: C1      	        pop     BC              ; Get other value
20C2: A0      	        and     B               ; Combine them
20C3: C6FF    	        add     A,-1            ; Carry set if different
20C5: 9F      	        sbc     A,A             ; 00 - Equal , FF - Different
20C6: C3FF2C  	        jp      FLGREL          ; Set current value & continue
              	
20C9: 165A    	EVNOT:  ld      D,$5A           ; Precedence value for "NOT"
20CB: CDF41E  	        call    EVAL1           ; Eval until precedence break
20CE: CDE21E  	        call    TSTNUM          ; Make sure it's a number
20D1: CD201B  	        call    DEINT           ; Get integer -32768 - 32767
20D4: 7B      	        ld      A,E             ; Get LSB
20D5: 2F      	        cpl                     ; Invert LSB
20D6: 4F      	        ld      C,A             ; Save "NOT" of LSB
20D7: 7A      	        ld      A,D             ; Get MSB
20D8: 2F      	        cpl                     ; Invert MSB
20D9: CDC822  	        call    ACPASS          ; Save AC as current
20DC: C1      	        pop     BC              ; Clean up stack
20DD: C3001F  	        jp      EVAL3           ; Continue evaluation
              	
20E0: 2B      	DIMRET: dec     HL              ; dec 'cos GETCHR INCs
20E1: CD6A1A  	        call    GETCHR          ; Get next character
20E4: C8      	        ret     Z               ; End of DIM statement
20E5: CD4718  	        call    CHKSYN          ; Make sure ',' follows
20E8: 2C      	        defb    ','
20E9: 01E020  	DIM:    ld      BC,DIMRET       ; Return to "DIMRET"
20EC: C5      	        push    BC              ; Save on stack
20ED: F6      	        defb    $F6             ; Flag "Create" variable
20EE: AF      	GETVAR: xor     A               ; Find variable address,to DE
20EF: 329181  	        ld      (LCRFLG),A      ; Set locate / create flag
20F2: 46      	        ld      B,(HL)          ; Get First byte of name
20F3: CD0C1B  	GTFNAM: call    CHKLTR          ; See if a letter
20F6: DA6515  	        jp      C,SNERR         ; ?SN Error if not a letter
20F9: AF      	        xor     A
20FA: 4F      	        ld      C,A             ; Clear second byte of name
20FB: 329281  	        ld      (TYPE),A        ; Set type to numeric
20FE: CD6A1A  	        call    GETCHR          ; Get next character
2101: DA0A21  	        jp      C,SVNAM2        ; Numeric - Save in name
2104: CD0C1B  	        call    CHKLTR          ; See if a letter
2107: DA1721  	        jp      C,CHARTY        ; Not a letter - Check type
210A: 4F      	SVNAM2: ld      C,A             ; Save second byte of name
210B: CD6A1A  	ENDNAM: call    GETCHR          ; Get next character
210E: DA0B21  	        jp      C,ENDNAM        ; Numeric - Get another
2111: CD0C1B  	        call    CHKLTR          ; See if a letter
2114: D20B21  	        jp      NC,ENDNAM       ; Letter - Get another
2117: D624    	CHARTY: sub     '$'             ; String variable?
2119: C22621  	        jp      NZ,NOTSTR       ; No - Numeric variable
211C: 3C      	        inc     A               ; A = 1 (string type)
211D: 329281  	        ld      (TYPE),A        ; Set type to string
2120: 0F      	        rrca                    ; A = 80H , Flag for string
2121: 81      	        add     A,C             ; 2nd byte of name has bit 7 on
2122: 4F      	        ld      C,A             ; Resave second byte on name
2123: CD6A1A  	        call    GETCHR          ; Get next character
2126: 3AB081  	NOTSTR: ld      A,(FORFLG)      ; Array name needed ?
2129: 3D      	        dec     A
212A: CAD321  	        jp      Z,ARLDSV        ; Yes - Get array name
212D: F23621  	        jp      P,NSCFOR        ; No array with "FOR" or "FN"
2130: 7E      	        ld      A,(HL)          ; Get byte again
2131: D628    	        sub     '('             ; Subscripted variable?
2133: CAAB21  	        jp      Z,SBSCPT        ; Yes - Sort out subscript
              	
2136: AF      	NSCFOR: xor     A               ; Simple variable
2137: 32B081  	        ld      (FORFLG),A      ; Clear "FOR" flag
213A: E5      	        push    HL              ; Save code string address
213B: 50      	        ld      D,B             ; DE = Variable name to find
213C: 59      	        ld      E,C
213D: 2AC381  	        ld      HL,(FNRGNM)     ; FN argument name
2140: CD4118  	        call    CPDEHL          ; Is it the FN argument?
2143: 11C581  	        ld      DE,FNARG        ; Point to argument value
2146: CADD2B  	        jp      Z,POPHRT        ; Yes - Return FN argument value
2149: 2ABD81  	        ld      HL,(VAREND)     ; End of variables
214C: EB      	        ex      DE,HL           ; Address of end of search
214D: 2ABB81  	        ld      HL,(PROGND)     ; Start of variables address
2150: CD4118  	FNDVAR: call    CPDEHL          ; End of variable list table?
2153: CA6921  	        jp      Z,CFEVAL        ; Yes - Called from EVAL?
2156: 79      	        ld      A,C             ; Get second byte of name
2157: 96      	        sub     (HL)            ; Compare with name in list
2158: 23      	        inc     HL              ; Move on to first byte
2159: C25E21  	        jp      NZ,FNTHR        ; Different - Find another
215C: 78      	        ld      A,B             ; Get first byte of name
215D: 96      	        sub     (HL)            ; Compare with name in list
215E: 23      	FNTHR:  inc     HL              ; Move on to LSB of value
215F: CA9D21  	        jp      Z,RETADR        ; Found - Return address
2162: 23      	        inc     HL              ; <- Skip
2163: 23      	        inc     HL              ; <- over
2164: 23      	        inc     HL              ; <- F.P.
2165: 23      	        inc     HL              ; <- value
2166: C35021  	        jp      FNDVAR          ; Keep looking
              	
2169: E1      	CFEVAL: pop     HL              ; Restore code string address
216A: E3      	        ex      (SP),HL         ; Get return address
216B: D5      	        push    DE              ; Save address of variable
216C: 11D21F  	        ld      DE,FRMEVL       ; Return address in EVAL
216F: CD4118  	        call    CPDEHL          ; Called from EVAL ?
2172: D1      	        pop     DE              ; Restore address of variable
2173: CAA021  	        jp      Z,RETNUL        ; Yes - Return null variable
2176: E3      	        ex      (SP),HL         ; Put back return
2177: E5      	        push    HL              ; Save code string address
2178: C5      	        push    BC              ; Save variable name
2179: 010600  	        ld      BC,$0006        ; 2 byte name plus 4 byte data
217C: 2ABF81  	        ld      HL,(ARREND)     ; End of arrays
217F: E5      	        push    HL              ; Save end of arrays
2180: 09      	        add     HL,BC           ; Move up 6 bytes
2181: C1      	        pop     BC              ; Source address in BC
2182: E5      	        push    HL              ; Save new end address
2183: CD1115  	        call    MOVUP           ; Move arrays up
2186: E1      	        pop     HL              ; Restore new end address
2187: 22BF81  	        ld      (ARREND),HL     ; Set new end address
218A: 60      	        ld      H,B             ; End of variables to HL
218B: 69      	        ld      L,C
218C: 22BD81  	        ld      (VAREND),HL     ; Set new end address
              	
218F: 2B      	ZEROLP: dec     HL              ; Back through to zero variable
2190: 3600    	        ld      (HL),$00        ; Zero byte in variable
2192: CD4118  	        call    CPDEHL          ; Done them all?
2195: C28F21  	        jp      NZ,ZEROLP       ; No - Keep on going
2198: D1      	        pop     DE              ; Get variable name
2199: 73      	        ld      (HL),E          ; Store second character
219A: 23      	        inc     HL
219B: 72      	        ld      (HL),D          ; Store first character
219C: 23      	        inc     HL
219D: EB      	RETADR: ex      DE,HL           ; Address of variable in DE
219E: E1      	        pop     HL              ; Restore code string address
219F: C9      	        ret
              	
21A0: 32CC81  	RETNUL: ld      (FPEXP),A       ; Set result to zero
21A3: 21E214  	        ld      HL,ZERBYT       ; Also set a null string
21A6: 22C981  	        ld      (FPREG),HL      ; Save for EVAL
21A9: E1      	        pop     HL              ; Restore code string address
21AA: C9      	        ret
              	
21AB: E5      	SBSCPT: push    HL              ; Save code string address
21AC: 2A9181  	        ld      HL,(LCRFLG)     ; Locate/Create and Type
21AF: E3      	        ex      (SP),HL         ; Save and get code string
21B0: 57      	        ld      D,A             ; Zero number of dimensions
21B1: D5      	SCPTLP: push    DE              ; Save number of dimensions
21B2: C5      	        push    BC              ; Save array name
21B3: CD141B  	        call    FPSINT          ; Get subscript (0-32767)
21B6: C1      	        pop     BC              ; Restore array name
21B7: F1      	        pop     AF              ; Get number of dimensions
21B8: EB      	        ex      DE,HL
21B9: E3      	        ex      (SP),HL         ; Save subscript value
21BA: E5      	        push    HL              ; Save LCRFLG and TYPE
21BB: EB      	        ex      DE,HL
21BC: 3C      	        inc     A               ; Count dimensions
21BD: 57      	        ld      D,A             ; Save in D
21BE: 7E      	        ld      A,(HL)          ; Get next byte in code string
21BF: FE2C    	        cp      ','             ; Comma (more to come)?
21C1: CAB121  	        jp      Z,SCPTLP        ; Yes - More subscripts
21C4: CD4718  	        call    CHKSYN          ; Make sure ")" follows
21C7: 29      	        defb    ')'
21C8: 22B581  	        ld      (NXTOPR),HL     ; Save code string address
21CB: E1      	        pop     HL              ; Get LCRFLG and TYPE
21CC: 229181  	        ld      (LCRFLG),HL     ; Restore Locate/create & type
21CF: 1E00    	        ld      E,$00           ; Flag not CSAVE* or CLOAD*
21D1: D5      	        push    DE              ; Save number of dimensions (D)
21D2: 11      	        defb    $11             ; Skip "push HL" and "push AF'
              	
21D3: E5      	ARLDSV: push    HL              ; Save code string address
21D4: F5      	        push    AF              ; A = 00 , Flags set = Z,N
21D5: 2ABD81  	        ld      HL,(VAREND)     ; Start of arrays
21D8: 3E      	        defb    $3E             ; Skip "add HL,DE"
21D9: 19      	FNDARY: add     HL,DE           ; Move to next array start
21DA: EB      	        ex      DE,HL
21DB: 2ABF81  	        ld      HL,(ARREND)     ; End of arrays
21DE: EB      	        ex      DE,HL           ; Current array pointer
21DF: CD4118  	        call    CPDEHL          ; End of arrays found?
21E2: CA0B22  	        jp      Z,CREARY        ; Yes - Create array
21E5: 7E      	        ld      A,(HL)          ; Get second byte of name
21E6: B9      	        cp      C               ; Compare with name given
21E7: 23      	        inc     HL              ; Move on
21E8: C2ED21  	        jp      NZ,NXTARY       ; Different - Find next array
21EB: 7E      	        ld      A,(HL)          ; Get first byte of name
21EC: B8      	        cp      B               ; Compare with name given
21ED: 23      	NXTARY: inc     HL              ; Move on
21EE: 5E      	        ld      E,(HL)          ; Get LSB of next array address
21EF: 23      	        inc     HL
21F0: 56      	        ld      D,(HL)          ; Get MSB of next array address
21F1: 23      	        inc     HL
21F2: C2D921  	        jp      NZ,FNDARY       ; Not found - Keep looking
21F5: 3A9181  	        ld      A,(LCRFLG)      ; Found Locate or Create it?
21F8: B7      	        or      A
21F9: C26E15  	        jp      NZ,DDERR        ; Create - ?DD Error
21FC: F1      	        pop     AF              ; Locate - Get number of dim'ns
21FD: 44      	        ld      B,H             ; BC Points to array dim'ns
21FE: 4D      	        ld      C,L
21FF: CADD2B  	        jp      Z,POPHRT        ; Jump if array load/save
2202: 96      	        sub     (HL)            ; Same number of dimensions?
2203: CA6922  	        jp      Z,FINDEL        ; Yes - Find element
2206: 1E10    	BSERR:  ld      E,BS            ; ?BS Error
2208: C37915  	        jp      ERROR           ; Output error
              	
220B: 110400  	CREARY: ld      DE,$0004        ; 4 Bytes per entry
220E: F1      	        pop     AF              ; Array to save or 0 dim'ns?
220F: CA351B  	        jp      Z,FCERR         ; Yes - ?FC Error
2212: 71      	        ld      (HL),C          ; Save second byte of name
2213: 23      	        inc     HL
2214: 70      	        ld      (HL),B          ; Save first byte of name
2215: 23      	        inc     HL
2216: 4F      	        ld      C,A             ; Number of dimensions to C
2217: CD2215  	        call    CHKSTK          ; Check if enough memory
221A: 23      	        inc     HL              ; Point to number of dimensions
221B: 23      	        inc     HL
221C: 22AA81  	        ld      (CUROPR),HL     ; Save address of pointer
221F: 71      	        ld      (HL),C          ; Set number of dimensions
2220: 23      	        inc     HL
2221: 3A9181  	        ld      A,(LCRFLG)      ; Locate of Create?
2224: 17      	        rla                     ; Carry set = Create
2225: 79      	        ld      A,C             ; Get number of dimensions
2226: 010B00  	CRARLP: ld      BC,10+1         ; Default dimension size 10
2229: D22E22  	        jp      NC,DEFSIZ       ; Locate - Set default size
222C: C1      	        pop     BC              ; Get specified dimension size
222D: 03      	        inc     BC              ; Include zero element
222E: 71      	DEFSIZ: ld      (HL),C          ; Save LSB of dimension size
222F: 23      	        inc     HL
2230: 70      	        ld      (HL),B          ; Save MSB of dimension size
2231: 23      	        inc     HL
2232: F5      	        push    AF              ; Save num' of dim'ns an status
2233: E5      	        push    HL              ; Save address of dim'n size
2234: CDD92D  	        call    MLDEBC          ; Multiply DE by BC to find
2237: EB      	        ex      DE,HL           ; amount of mem needed (to DE)
2238: E1      	        pop     HL              ; Restore address of dimension
2239: F1      	        pop     AF              ; Restore number of dimensions
223A: 3D      	        dec     A               ; Count them
223B: C22622  	        jp      NZ,CRARLP       ; Do next dimension if more
223E: F5      	        push    AF              ; Save locate/create flag
223F: 42      	        ld      B,D             ; MSB of memory needed
2240: 4B      	        ld      C,E             ; LSB of memory needed
2241: EB      	        ex      DE,HL
2242: 19      	        add     HL,DE           ; Add bytes to array start
2243: DA3A15  	        jp      C,OMERR         ; Too big - Error
2246: CD2B15  	        call    ENFMEM          ; See if enough memory
2249: 22BF81  	        ld      (ARREND),HL     ; Save new end of array
              	
224C: 2B      	ZERARY: dec     HL              ; Back through array data
224D: 3600    	        ld      (HL),$00        ; Set array element to zero
224F: CD4118  	        call    CPDEHL          ; All elements zeroed?
2252: C24C22  	        jp      NZ,ZERARY       ; No - Keep on going
2255: 03      	        inc     BC              ; Number of bytes + 1
2256: 57      	        ld      D,A             ; A=0
2257: 2AAA81  	        ld      HL,(CUROPR)     ; Get address of array
225A: 5E      	        ld      E,(HL)          ; Number of dimensions
225B: EB      	        ex      DE,HL           ; To HL
225C: 29      	        add     HL,HL           ; Two bytes per dimension size
225D: 09      	        add     HL,BC           ; Add number of bytes
225E: EB      	        ex      DE,HL           ; Bytes needed to DE
225F: 2B      	        dec     HL
2260: 2B      	        dec     HL
2261: 73      	        ld      (HL),E          ; Save LSB of bytes needed
2262: 23      	        inc     HL
2263: 72      	        ld      (HL),D          ; Save MSB of bytes needed
2264: 23      	        inc     HL
2265: F1      	        pop     AF              ; Locate / Create?
2266: DA8D22  	        jp      C,ENDDIM        ; A is 0 , End if create
2269: 47      	FINDEL: ld      B,A             ; Find array element
226A: 4F      	        ld      C,A
226B: 7E      	        ld      A,(HL)          ; Number of dimensions
226C: 23      	        inc     HL
226D: 16      	        defb    $16             ; Skip "pop HL"
226E: E1      	FNDELP: pop     HL              ; Address of next dim' size
226F: 5E      	        ld      E,(HL)          ; Get LSB of dim'n size
2270: 23      	        inc     HL
2271: 56      	        ld      D,(HL)          ; Get MSB of dim'n size
2272: 23      	        inc     HL
2273: E3      	        ex      (SP),HL         ; Save address - Get index
2274: F5      	        push    AF              ; Save number of dim'ns
2275: CD4118  	        call    CPDEHL          ; Dimension too large?
2278: D20622  	        jp      NC,BSERR        ; Yes - ?BS Error
227B: E5      	        push    HL              ; Save index
227C: CDD92D  	        call    MLDEBC          ; Multiply previous by size
227F: D1      	        pop     DE              ; Index supplied to DE
2280: 19      	        add     HL,DE           ; Add index to pointer
2281: F1      	        pop     AF              ; Number of dimensions
2282: 3D      	        dec     A               ; Count them
2283: 44      	        ld      B,H             ; MSB of pointer
2284: 4D      	        ld      C,L             ; LSB of pointer
2285: C26E22  	        jp      NZ,FNDELP       ; More - Keep going
2288: 29      	        add     HL,HL           ; 4 Bytes per element
2289: 29      	        add     HL,HL
228A: C1      	        pop     BC              ; Start of array
228B: 09      	        add     HL,BC           ; Point to element
228C: EB      	        ex      DE,HL           ; Address of element to DE
228D: 2AB581  	ENDDIM: ld      HL,(NXTOPR)     ; Got code string address
2290: C9      	        ret
              	
              	
              	; returns the value of the 32-bit system tick counter as
              	; two 16-bit words
2291: CDE21E  	TMR:    call    TSTNUM          ; Make sure it's a number
2294: CD201B  	        call    DEINT           ; Get integer (-32768 to 32767)
2297: 2ACE81  	        ld      HL,(TMRCNT)     ; load the LSBytes of timer
229A: 7B      	        ld      A,E
229B: B2      	        or      D               ; is it 0?
229C: CAA222  	        jp      Z,ENDTMR        ; yes, jump over
229F: 2AD081  	        ld      HL,(TMRCNT+2)   ; load the MSBytes of timer
22A2: 45      	ENDTMR: ld      B,L             ; move bytes...
22A3: 7C      	        ld      A,H             ; ...into AB
22A4: C3C922  	        jp      ABPASS          ; return word into AB
              	
              	
              	; returns the free space for BASIC or into the string pool
22A7: 2ABF81  	FRE:    ld      HL,(ARREND)     ; Start of free memory
22AA: EB      	        ex      DE,HL           ; To DE
22AB: 210000  	        ld      HL,$0000        ; End of free memory
22AE: 39      	        add     HL,SP           ; Current stack value
22AF: 3A9281  	        ld      A,(TYPE)        ; Dummy argument type
22B2: B7      	        or      A
22B3: CAC322  	        jp      Z,FRENUM        ; Numeric - Free variable space
22B6: CD2A25  	        call    GSTRCU          ; Current string to pool
22B9: CD2A24  	        call    GARBGE          ; Garbage collection
22BC: 2AAD80  	        ld      HL,(STRSPC)     ; Bottom of string space in use
22BF: EB      	        ex      DE,HL           ; To DE
22C0: 2AA881  	        ld      HL,(STRBOT)     ; Bottom of string space
22C3: 7D      	FRENUM: ld      A,L             ; Get LSB of end
22C4: 93      	        sub     E               ; Subtract LSB of beginning
22C5: 4F      	        ld      C,A             ; Save difference if C
22C6: 7C      	        ld      A,H             ; Get MSB of end
22C7: 9A      	        sbc     A,D             ; Subtract MSB of beginning
22C8: 41      	ACPASS: ld      B,C             ; Return integer AC
22C9: 50      	ABPASS: ld      D,B             ; Return integer AB
22CA: 1E00    	        ld      E,$00
22CC: 219281  	        ld      HL,TYPE         ; Point to type
22CF: 73      	        ld      (HL),E          ; Set type to numeric
22D0: 0690    	        ld      B,$80+$10       ; 16 bit integer
22D2: C3042D  	        jp      RETINT          ; Return the integer
              	
              	; returns the X position of the cursor during a print
22D5: 3A9081  	POS:    ld      A,(CURPOS)      ; Get cursor position
22D8: 47      	PASSA:  ld      B,A             ; Put A into AB
22D9: AF      	        xor     A               ; Zero A
22DA: C3C922  	        jp      ABPASS          ; Return integer AB
              	
22DD: CD6023  	DEF:    call    CHEKFN          ; Get "FN" and name
22E0: CD5223  	        call    IDTEST          ; Test for illegal direct
22E3: 010D1C  	        ld      BC,DATA         ; To get next statement
22E6: C5      	        push    BC              ; Save address for RETurn
22E7: D5      	        push    DE              ; Save address of function ptr
22E8: CD4718  	        call    CHKSYN          ; Make sure "(" follows
22EB: 28      	        defb    '('
22EC: CDEE20  	        call    GETVAR          ; Get argument variable name
22EF: E5      	        push    HL              ; Save code string address
22F0: EB      	        ex      DE,HL           ; Argument address to HL
22F1: 2B      	        dec     HL
22F2: 56      	        ld      D,(HL)          ; Get first byte of arg name
22F3: 2B      	        dec     HL
22F4: 5E      	        ld      E,(HL)          ; Get second byte of arg name
22F5: E1      	        pop     HL              ; Restore code string address
22F6: CDE21E  	        call    TSTNUM          ; Make sure numeric argument
22F9: CD4718  	        call    CHKSYN          ; Make sure ")" follows
22FC: 29      	        defb    ')'
22FD: CD4718  	        call    CHKSYN          ; Make sure "=" follows
2300: C6      	        defb    ZEQUAL          ; "=" token
2301: 44      	        ld      B,H             ; Code string address to BC
2302: 4D      	        ld      C,L
2303: E3      	        ex      (SP),HL         ; Save code str , Get FN ptr
2304: 71      	        ld      (HL),C          ; Save LSB of FN code string
2305: 23      	        inc     HL
2306: 70      	        ld      (HL),B          ; Save MSB of FN code string
2307: C39F23  	        jp      SVSTAD          ; Save address and do function
              	
230A: CD6023  	DOFN:   call    CHEKFN          ; Make sure FN follows
230D: D5      	        push    DE              ; Save function pointer address
230E: CDB61F  	        call    EVLPAR          ; Evaluate expression in "()"
2311: CDE21E  	        call    TSTNUM          ; Make sure numeric result
2314: E3      	        ex      (SP),HL         ; Save code str , Get FN ptr
2315: 5E      	        ld      E,(HL)          ; Get LSB of FN code string
2316: 23      	        inc     HL
2317: 56      	        ld      D,(HL)          ; Get MSB of FN code string
2318: 23      	        inc     HL
2319: 7A      	        ld      A,D             ; And function DEFined?
231A: B3      	        or      E
231B: CA7115  	        jp      Z,UFERR         ; No - ?UF Error
231E: 7E      	        ld      A,(HL)          ; Get LSB of argument address
231F: 23      	        inc     HL
2320: 66      	        ld      H,(HL)          ; Get MSB of argument address
2321: 6F      	        ld      L,A             ; HL = Arg variable address
2322: E5      	        push    HL              ; Save it
2323: 2AC381  	        ld      HL,(FNRGNM)     ; Get old argument name
2326: E3      	        ex      (SP),HL         ; Save old , Get new
2327: 22C381  	        ld      (FNRGNM),HL     ; Set new argument name
232A: 2AC781  	        ld      HL,(FNARG+2)    ; Get LSB,NLSB of old arg value
232D: E5      	        push    HL              ; Save it
232E: 2AC581  	        ld      HL,(FNARG)      ; Get MSB,EXP of old arg value
2331: E5      	        push    HL              ; Save it
2332: 21C581  	        ld      HL,FNARG        ; HL = Value of argument
2335: D5      	        push    DE              ; Save FN code string address
2336: CD452D  	        call    FPTHL           ; Move FPREG to argument
2339: E1      	        pop     HL              ; Get FN code string address
233A: CDDF1E  	        call    GETNUM          ; Get value from function
233D: 2B      	        dec     HL              ; dec 'cos GETCHR INCs
233E: CD6A1A  	        call    GETCHR          ; Get next character
2341: C26515  	        jp      NZ,SNERR        ; Bad character in FN - Error
2344: E1      	        pop     HL              ; Get MSB,EXP of old arg
2345: 22C581  	        ld      (FNARG),HL      ; Restore it
2348: E1      	        pop     HL              ; Get LSB,NLSB of old arg
2349: 22C781  	        ld      (FNARG+2),HL    ; Restore it
234C: E1      	        pop     HL              ; Get name of old arg
234D: 22C381  	        ld      (FNRGNM),HL     ; Restore it
2350: E1      	        pop     HL              ; Restore code string address
2351: C9      	        ret
              	
2352: E5      	IDTEST: push    HL              ; Save code string address
2353: 2AAF80  	        ld      HL,(LINEAT)     ; Get current line number
2356: 23      	        inc     HL              ; -1 means direct statement
2357: 7C      	        ld      A,H
2358: B5      	        or      L
2359: E1      	        pop     HL              ; Restore code string address
235A: C0      	        ret     NZ              ; Return if in program
235B: 1E16    	        ld      E,ID            ; ?ID Error
235D: C37915  	        jp      ERROR
              	
2360: CD4718  	CHEKFN: call    CHKSYN          ; Make sure FN follows
2363: B6      	        defb    ZFN             ; "FN" token
2364: 3E80    	        ld      A,$80
2366: 32B081  	        ld      (FORFLG),A      ; Flag FN name to find
2369: B6      	        or      (HL)            ; FN name has bit 7 set
236A: 47      	        ld      B,A             ; in first byte of name
236B: CDF320  	        call    GTFNAM          ; Get FN name
236E: C3E21E  	        jp      TSTNUM          ; Make sure numeric function
              	
2371: CDE21E  	STR:    call    TSTNUM          ; Make sure it's a number
2374: CD922E  	        call    NUMASC          ; Turn number into text
2377: CDA523  	STR1:   call    CRTST           ; Create string entry for it
237A: CD2A25  	        call    GSTRCU          ; Current string to pool
237D: 018525  	        ld      BC,TOPOOL       ; Save in string pool
2380: C5      	        push    BC              ; Save address on stack
              	
2381: 7E      	SAVSTR: ld      A,(HL)          ; Get string length
2382: 23      	        inc     HL
2383: 23      	        inc     HL
2384: E5      	        push    HL              ; Save pointer to string
2385: CD0024  	        call    TESTR           ; See if enough string space
2388: E1      	        pop     HL              ; Restore pointer to string
2389: 4E      	        ld      C,(HL)          ; Get LSB of address
238A: 23      	        inc     HL
238B: 46      	        ld      B,(HL)          ; Get MSB of address
238C: CD9923  	        call    CRTMST          ; Create string entry
238F: E5      	        push    HL              ; Save pointer to MSB of addr
2390: 6F      	        ld      L,A             ; Length of string
2391: CD1D25  	        call    TOSTRA          ; Move to string area
2394: D1      	        pop     DE              ; Restore pointer to MSB
2395: C9      	        ret
              	
2396: CD0024  	MKTMST: call    TESTR           ; See if enough string space
2399: 21A481  	CRTMST: ld      HL,TMPSTR       ; Temporary string
239C: E5      	        push    HL              ; Save it
239D: 77      	        ld      (HL),A          ; Save length of string
239E: 23      	        inc     HL
239F: 23      	SVSTAD: inc     HL
23A0: 73      	        ld      (HL),E          ; Save LSB of address
23A1: 23      	        inc     HL
23A2: 72      	        ld      (HL),D          ; Save MSB of address
23A3: E1      	        pop     HL              ; Restore pointer
23A4: C9      	        ret
              	
23A5: 2B      	CRTST:  dec     HL              ; dec - INCed after
23A6: 0622    	QTSTR:  ld      B,$22           ; '"'           ; Terminating quote
23A8: 50      	        ld      D,B             ; Quote to D
23A9: E5      	DTSTR:  push    HL              ; Save start
23AA: 0EFF    	        ld      C,-1            ; Set counter to -1
23AC: 23      	QTSTLP: inc     HL              ; Move on
23AD: 7E      	        ld      A,(HL)          ; Get byte
23AE: 0C      	        inc     C               ; Count bytes
23AF: B7      	        or      A               ; End of line?
23B0: CABB23  	        jp      Z,CRTSTE        ; Yes - Create string entry
23B3: BA      	        cp      D               ; Terminator D found?
23B4: CABB23  	        jp      Z,CRTSTE        ; Yes - Create string entry
23B7: B8      	        cp      B               ; Terminator B found?
23B8: C2AC23  	        jp      NZ,QTSTLP       ; No - Keep looking
23BB: FE22    	CRTSTE: cp      $22             ; '"'             ; End with '"'?
23BD: CC6A1A  	        call    Z,GETCHR        ; Yes - Get next character
23C0: E3      	        ex      (SP),HL         ; Starting quote
23C1: 23      	        inc     HL              ; First byte of string
23C2: EB      	        ex      DE,HL           ; To DE
23C3: 79      	        ld      A,C             ; Get length
23C4: CD9923  	        call    CRTMST          ; Create string entry
23C7: 11A481  	TSTOPL: ld      DE,TMPSTR       ; Temporary string
23CA: 2A9681  	        ld      HL,(TMSTPT)     ; Temporary string pool pointer
23CD: 22C981  	        ld      (FPREG),HL      ; Save address of string ptr
23D0: 3E01    	        ld      A,$01
23D2: 329281  	        ld      (TYPE),A        ; Set type to string
23D5: CD482D  	        call    DETHL4          ; Move string to pool
23D8: CD4118  	        call    CPDEHL          ; Out of string pool?
23DB: 229681  	        ld      (TMSTPT),HL     ; Save new pointer
23DE: E1      	        pop     HL              ; Restore code string address
23DF: 7E      	        ld      A,(HL)          ; Get next code byte
23E0: C0      	        ret     NZ              ; Return if pool OK
23E1: 1E1E    	        ld      E,ST            ; ?ST Error
23E3: C37915  	        jp      ERROR           ; String pool overflow
              	
23E6: 23      	PRNUMS: inc     HL              ; Skip leading space
23E7: CDA523  	PRS:    call    CRTST           ; Create string entry for it
23EA: CD2A25  	PRS1:   call    GSTRCU          ; Current string to pool
23ED: CD3C2D  	        call    LOADFP          ; Move string block to BCDE
23F0: 1C      	        inc     E               ; Length + 1
23F1: 1D      	PRSLP:  dec     E               ; Count characters
23F2: C8      	        ret     Z               ; End of string
23F3: 0A      	        ld      A,(BC)          ; Get byte to output
23F4: CD5218  	        call    OUTC            ; Output character in A
23F7: FE0D    	        cp      CR              ; Return?
23F9: CC2D1D  	        call    Z,CNTEND        ; Yes - Position cursor to 0
23FC: 03      	        inc     BC              ; Next byte in string
23FD: C3F123  	        jp      PRSLP           ; More characters to output
              	
2400: B7      	TESTR:  or      A               ; Test if enough room
2401: 0E      	        defb    $0E             ; No garbage collection done
2402: F1      	GRBDON: pop     AF              ; Garbage collection done
2403: F5      	        push    AF              ; Save status
2404: 2AAD80  	        ld      HL,(STRSPC)     ; Bottom of string space in use
2407: EB      	        ex      DE,HL           ; To DE
2408: 2AA881  	        ld      HL,(STRBOT)     ; Bottom of string area
240B: 2F      	        cpl                     ; Negate length (Top down)
240C: 4F      	        ld      C,A             ; -Length to BC
240D: 06FF    	        ld      B,-1            ; BC = -ve length of string
240F: 09      	        add     HL,BC           ; Add to bottom of space in use
2410: 23      	        inc     HL              ; Plus one for 2's complement
2411: CD4118  	        call    CPDEHL          ; Below string RAM area?
2414: DA1E24  	        jp      C,TESTOS        ; Tidy up if not done else err
2417: 22A881  	        ld      (STRBOT),HL     ; Save new bottom of area
241A: 23      	        inc     HL              ; Point to first byte of string
241B: EB      	        ex      DE,HL           ; Address to DE
241C: F1      	POPAF:  pop     AF              ; Throw away status push
241D: C9      	        ret
              	
241E: F1      	TESTOS: pop     AF              ; Garbage collect been done?
241F: 1E1A    	        ld      E,OS            ; ?OS Error
2421: CA7915  	        jp      Z,ERROR         ; Yes - Not enough string space
2424: BF      	        cp      A               ; Flag garbage collect done
2425: F5      	        push    AF              ; Save status
2426: 010224  	        ld      BC,GRBDON       ; Garbage collection done
2429: C5      	        push    BC              ; Save for RETurn
242A: 2A9481  	GARBGE: ld      HL,(LSTRAM)     ; Get end of RAM pointer
242D: 22A881  	GARBLP: ld      (STRBOT),HL     ; Reset string pointer
2430: 210000  	        ld      HL,$0000
2433: E5      	        push    HL              ; Flag no string found
2434: 2AAD80  	        ld      HL,(STRSPC)     ; Get bottom of string space
2437: E5      	        push    HL              ; Save bottom of string space
2438: 219881  	        ld      HL,TMSTPL       ; Temporary string pool
243B: EB      	GRBLP:  ex      DE,HL
243C: 2A9681  	        ld      HL,(TMSTPT)     ; Temporary string pool pointer
243F: EB      	        ex      DE,HL
2440: CD4118  	        call    CPDEHL          ; Temporary string pool done?
2443: 013B24  	        ld      BC,GRBLP        ; Loop until string pool done
2446: C28F24  	        jp      NZ,STPOOL       ; No - See if in string area
2449: 2ABB81  	        ld      HL,(PROGND)     ; Start of simple variables
244C: EB      	SMPVAR: ex      DE,HL
244D: 2ABD81  	        ld      HL,(VAREND)     ; End of simple variables
2450: EB      	        ex      DE,HL
2451: CD4118  	        call    CPDEHL          ; All simple strings done?
2454: CA6224  	        jp      Z,ARRLP         ; Yes - Do string arrays
2457: 7E      	        ld      A,(HL)          ; Get type of variable
2458: 23      	        inc     HL
2459: 23      	        inc     HL
245A: B7      	        or      A               ; "S" flag set if string
245B: CD9224  	        call    STRADD          ; See if string in string area
245E: C34C24  	        jp      SMPVAR          ; Loop until simple ones done
              	
2461: C1      	GNXARY: pop     BC              ; Scrap address of this array
2462: EB      	ARRLP:  ex      DE,HL
2463: 2ABF81  	        ld      HL,(ARREND)     ; End of string arrays
2466: EB      	        ex      DE,HL
2467: CD4118  	        call    CPDEHL          ; All string arrays done?
246A: CAB824  	        jp      Z,SCNEND        ; Yes - Move string if found
246D: CD3C2D  	        call    LOADFP          ; Get array name to BCDE
2470: 7B      	        ld      A,E             ; Get type of array
2471: E5      	        push    HL              ; Save address of num of dim'ns
2472: 09      	        add     HL,BC           ; Start of next array
2473: B7      	        or      A               ; Test type of array
2474: F26124  	        jp      P,GNXARY        ; Numeric array - Ignore it
2477: 22AA81  	        ld      (CUROPR),HL     ; Save address of next array
247A: E1      	        pop     HL              ; Get address of num of dim'ns
247B: 4E      	        ld      C,(HL)          ; BC = Number of dimensions
247C: 0600    	        ld      B,$00
247E: 09      	        add     HL,BC           ; Two bytes per dimension size
247F: 09      	        add     HL,BC
2480: 23      	        inc     HL              ; Plus one for number of dim'ns
2481: EB      	GRBARY: ex      DE,HL
2482: 2AAA81  	        ld      HL,(CUROPR)     ; Get address of next array
2485: EB      	        ex      DE,HL
2486: CD4118  	        call    CPDEHL          ; Is this array finished?
2489: CA6224  	        jp      Z,ARRLP         ; Yes - Get next one
248C: 018124  	        ld      BC,GRBARY       ; Loop until array all done
248F: C5      	STPOOL: push    BC              ; Save return address
2490: F680    	        or      $80             ; Flag string type
2492: 7E      	STRADD: ld      A,(HL)          ; Get string length
2493: 23      	        inc     HL
2494: 23      	        inc     HL
2495: 5E      	        ld      E,(HL)          ; Get LSB of string address
2496: 23      	        inc     HL
2497: 56      	        ld      D,(HL)          ; Get MSB of string address
2498: 23      	        inc     HL
2499: F0      	        ret     P               ; Not a string - Return
249A: B7      	        or      A               ; Set flags on string length
249B: C8      	        ret     Z               ; Null string - Return
249C: 44      	        ld      B,H             ; Save variable pointer
249D: 4D      	        ld      C,L
249E: 2AA881  	        ld      HL,(STRBOT)     ; Bottom of new area
24A1: CD4118  	        call    CPDEHL          ; String been done?
24A4: 60      	        ld      H,B             ; Restore variable pointer
24A5: 69      	        ld      L,C
24A6: D8      	        ret     C               ; String done - Ignore
24A7: E1      	        pop     HL              ; Return address
24A8: E3      	        ex      (SP),HL         ; Lowest available string area
24A9: CD4118  	        call    CPDEHL          ; String within string area?
24AC: E3      	        ex      (SP),HL         ; Lowest available string area
24AD: E5      	        push    HL              ; Re-save return address
24AE: 60      	        ld      H,B             ; Restore variable pointer
24AF: 69      	        ld      L,C
24B0: D0      	        ret     NC              ; Outside string area - Ignore
24B1: C1      	        pop     BC              ; Get return , Throw 2 away
24B2: F1      	        pop     AF              ;
24B3: F1      	        pop     AF              ;
24B4: E5      	        push    HL              ; Save variable pointer
24B5: D5      	        push    DE              ; Save address of current
24B6: C5      	        push    BC              ; Put back return address
24B7: C9      	        ret                     ; Go to it
              	
24B8: D1      	SCNEND: pop     DE              ; Addresses of strings
24B9: E1      	        pop     HL              ;
24BA: 7D      	        ld      A,L             ; HL = 0 if no more to do
24BB: B4      	        or      H
24BC: C8      	        ret     Z               ; No more to do - Return
24BD: 2B      	        dec     HL
24BE: 46      	        ld      B,(HL)          ; MSB of address of string
24BF: 2B      	        dec     HL
24C0: 4E      	        ld      C,(HL)          ; LSB of address of string
24C1: E5      	        push    HL              ; Save variable address
24C2: 2B      	        dec     HL
24C3: 2B      	        dec     HL
24C4: 6E      	        ld      L,(HL)          ; HL = Length of string
24C5: 2600    	        ld      H,$00
24C7: 09      	        add     HL,BC           ; Address of end of string+1
24C8: 50      	        ld      D,B             ; String address to DE
24C9: 59      	        ld      E,C
24CA: 2B      	        dec     HL              ; Last byte in string
24CB: 44      	        ld      B,H             ; Address to BC
24CC: 4D      	        ld      C,L
24CD: 2AA881  	        ld      HL,(STRBOT)     ; Current bottom of string area
24D0: CD1415  	        call    MOVSTR          ; Move string to new address
24D3: E1      	        pop     HL              ; Restore variable address
24D4: 71      	        ld      (HL),C          ; Save new LSB of address
24D5: 23      	        inc     HL
24D6: 70      	        ld      (HL),B          ; Save new MSB of address
24D7: 69      	        ld      L,C             ; Next string area+1 to HL
24D8: 60      	        ld      H,B
24D9: 2B      	        dec     HL              ; Next string area address
24DA: C32D24  	        jp      GARBLP          ; Look for more strings
              	
24DD: C5      	CONCAT: push    BC              ; Save prec' opr & code string
24DE: E5      	        push    HL              ;
24DF: 2AC981  	        ld      HL,(FPREG)      ; Get first string
24E2: E3      	        ex      (SP),HL         ; Save first string
24E3: CD681F  	        call    OPRND           ; Get second string
24E6: E3      	        ex      (SP),HL         ; Restore first string
24E7: CDE31E  	        call    TSTSTR          ; Make sure it's a string
24EA: 7E      	        ld      A,(HL)          ; Get length of second string
24EB: E5      	        push    HL              ; Save first string
24EC: 2AC981  	        ld      HL,(FPREG)      ; Get second string
24EF: E5      	        push    HL              ; Save second string
24F0: 86      	        add     A,(HL)          ; Add length of second string
24F1: 1E1C    	        ld      E,LS            ; ?LS Error
24F3: DA7915  	        jp      C,ERROR         ; String too long - Error
24F6: CD9623  	        call    MKTMST          ; Make temporary string
24F9: D1      	        pop     DE              ; Get second string to DE
24FA: CD2E25  	        call    GSTRDE          ; Move to string pool if needed
24FD: E3      	        ex      (SP),HL         ; Get first string
24FE: CD2D25  	        call    GSTRHL          ; Move to string pool if needed
2501: E5      	        push    HL              ; Save first string
2502: 2AA681  	        ld      HL,(TMPSTR+2)   ; Temporary string address
2505: EB      	        ex      DE,HL           ; To DE
2506: CD1425  	        call    SSTSA           ; First string to string area
2509: CD1425  	        call    SSTSA           ; Second string to string area
250C: 21FD1E  	        ld      HL,EVAL2        ; Return to evaluation loop
250F: E3      	        ex      (SP),HL         ; Save return,get code string
2510: E5      	        push    HL              ; Save code string address
2511: C3C723  	        jp      TSTOPL          ; To temporary string to pool
              	
2514: E1      	SSTSA:  pop     HL              ; Return address
2515: E3      	        ex      (SP),HL         ; Get string block,save return
2516: 7E      	        ld      A,(HL)          ; Get length of string
2517: 23      	        inc     HL
2518: 23      	        inc     HL
2519: 4E      	        ld      C,(HL)          ; Get LSB of string address
251A: 23      	        inc     HL
251B: 46      	        ld      B,(HL)          ; Get MSB of string address
251C: 6F      	        ld      L,A             ; Length to L
251D: 2C      	TOSTRA: inc     L               ; inc - DECed after
251E: 2D      	TSALP:  dec     L               ; Count bytes moved
251F: C8      	        ret     Z               ; End of string - Return
2520: 0A      	        ld      A,(BC)          ; Get source
2521: 12      	        ld      (DE),A          ; Save destination
2522: 03      	        inc     BC              ; Next source
2523: 13      	        inc     DE              ; Next destination
2524: C31E25  	        jp      TSALP           ; Loop until string moved
              	
2527: CDE31E  	GETSTR: call    TSTSTR          ; Make sure it's a string
252A: 2AC981  	GSTRCU: ld      HL,(FPREG)      ; Get current string
252D: EB      	GSTRHL: ex      DE,HL           ; Save DE
252E: CD4825  	GSTRDE: call    BAKTMP          ; Was it last tmp-str?
2531: EB      	        ex      DE,HL           ; Restore DE
2532: C0      	        ret     NZ              ; No - Return
2533: D5      	        push    DE              ; Save string
2534: 50      	        ld      D,B             ; String block address to DE
2535: 59      	        ld      E,C
2536: 1B      	        dec     DE              ; Point to length
2537: 4E      	        ld      C,(HL)          ; Get string length
2538: 2AA881  	        ld      HL,(STRBOT)     ; Current bottom of string area
253B: CD4118  	        call    CPDEHL          ; Last one in string area?
253E: C24625  	        jp      NZ,POPHL        ; No - Return
2541: 47      	        ld      B,A             ; Clear B (A=0)
2542: 09      	        add     HL,BC           ; Remove string from str' area
2543: 22A881  	        ld      (STRBOT),HL     ; Save new bottom of str' area
2546: E1      	POPHL:  pop     HL              ; Restore string
2547: C9      	        ret
              	
2548: 2A9681  	BAKTMP: ld      HL,(TMSTPT)     ; Get temporary string pool top
254B: 2B      	        dec     HL              ; Back
254C: 46      	        ld      B,(HL)          ; Get MSB of address
254D: 2B      	        dec     HL              ; Back
254E: 4E      	        ld      C,(HL)          ; Get LSB of address
254F: 2B      	        dec     HL              ; Back
2550: 2B      	        dec     HL              ; Back
2551: CD4118  	        call    CPDEHL          ; String last in string pool?
2554: C0      	        ret     NZ              ; Yes - Leave it
2555: 229681  	        ld      (TMSTPT),HL     ; Save new string pool top
2558: C9      	        ret
              	
2559: 01D822  	LEN:    ld      BC,PASSA        ; To return integer A
255C: C5      	        push    BC              ; Save address
255D: CD2725  	GETLEN: call    GETSTR          ; Get string and its length
2560: AF      	        xor     A
2561: 57      	        ld      D,A             ; Clear D
2562: 329281  	        ld      (TYPE),A        ; Set type to numeric
2565: 7E      	        ld      A,(HL)          ; Get length of string
2566: B7      	        or      A               ; Set status flags
2567: C9      	        ret
              	
2568: 01D822  	ASC:    ld      BC,PASSA        ; To return integer A
256B: C5      	        push    BC              ; Save address
256C: CD5D25  	GTFLNM: call    GETLEN          ; Get length of string
256F: CA351B  	        jp      Z,FCERR         ; Null string - Error
2572: 23      	        inc     HL
2573: 23      	        inc     HL
2574: 5E      	        ld      E,(HL)          ; Get LSB of address
2575: 23      	        inc     HL
2576: 56      	        ld      D,(HL)          ; Get MSB of address
2577: 1A      	        ld      A,(DE)          ; Get first byte of string
2578: C9      	        ret
              	
2579: 3E01    	CHR:    ld      A,$01           ; One character string
257B: CD9623  	        call    MKTMST          ; Make a temporary string
257E: CD6827  	        call    MAKINT          ; Make it integer A
2581: 2AA681  	        ld      HL,(TMPSTR+2)   ; Get address of string
2584: 73      	        ld      (HL),E          ; Save character
2585: C1      	TOPOOL: pop     BC              ; Clean up stack
2586: C3C723  	        jp      TSTOPL          ; Temporary string to pool
              	
2589: CD1827  	LEFT:   call    LFRGNM          ; Get number and ending ")"
258C: AF      	        xor     A               ; Start at first byte in string
258D: E3      	RIGHT1: ex      (SP),HL         ; Save code string,Get string
258E: 4F      	        ld      C,A             ; Starting position in string
258F: E5      	MID1:   push    HL              ; Save string block address
2590: 7E      	        ld      A,(HL)          ; Get length of string
2591: B8      	        cp      B               ; Compare with number given
2592: DA9725  	        jp      C,ALLFOL        ; All following bytes required
2595: 78      	        ld      A,B             ; Get new length
2596: 11      	        defb    $11             ; Skip "ld C,0"
2597: 0E00    	ALLFOL: ld      C,$00           ; First byte of string
2599: C5      	        push    BC              ; Save position in string
259A: CD0024  	        call    TESTR           ; See if enough string space
259D: C1      	        pop     BC              ; Get position in string
259E: E1      	        pop     HL              ; Restore string block address
259F: E5      	        push    HL              ; And re-save it
25A0: 23      	        inc     HL
25A1: 23      	        inc     HL
25A2: 46      	        ld      B,(HL)          ; Get LSB of address
25A3: 23      	        inc     HL
25A4: 66      	        ld      H,(HL)          ; Get MSB of address
25A5: 68      	        ld      L,B             ; HL = address of string
25A6: 0600    	        ld      B,$00           ; BC = starting address
25A8: 09      	        add     HL,BC           ; Point to that byte
25A9: 44      	        ld      B,H             ; BC = source string
25AA: 4D      	        ld      C,L
25AB: CD9923  	        call    CRTMST          ; Create a string entry
25AE: 6F      	        ld      L,A             ; Length of new string
25AF: CD1D25  	        call    TOSTRA          ; Move string to string area
25B2: D1      	        pop     DE              ; Clear stack
25B3: CD2E25  	        call    GSTRDE          ; Move to string pool if needed
25B6: C3C723  	        jp      TSTOPL          ; Temporary string to pool
              	
              	
              	; INSTR statement - look for a string inside another string
              	; usage: INSTR(A$,B$) -> search for B$ into A$
              	; return 0 if B$ is not contained into A$ or LEN(A$)<LEN(B$)
              	; return 1~255 to indicate the starting position of B$ into A$
              	; ex.: INSTR("HELLO","LO") returns 4
              	;PT=0
              	;DO
              	;  TF=0:TP=0
              	;  IF S1(PT)=S2(0) THEN
              	;    TF=1:TP=PT:PT1=PT:PT2=0
              	;    DO
              	;      IF S1(PT1)<>S2(PT2) THEN TF=0:EXIT
              	;      PT1=PT1+1
              	;      PT2=PT2+1
              	;    LOOP UNTIL PT2=LEN(S2)
              	;  IF TF<>0 THEN EXIT
              	;  PT=PT+1
              	;LOOP UNTIL PT>=LEN(S1)-LEN(S2)
              	;IF TF=0 THEN RETURN 0 ELSE RETURN TP
81EF:         	LNS1    equ     TMPBFR1
81F1:         	ADRS1   equ     TMPBFR2
81F3:         	LNS2    equ     TMPBFR3
81F5:         	ADRS2   equ     TMPBFR4
81F7:         	PT      equ     VIDEOBUFF
81F9:         	PT1     equ     VIDEOBUFF+2
81FB:         	PT2     equ     VIDEOBUFF+4
81FD:         	TP      equ     VIDEOBUFF+6
81FF:         	TF      equ     VIDEOBUFF+8
25B9: CD4718  	INSTR:  call    CHKSYN          ; make sure "(" follows
25BC: 28      	        defb    '('
25BD: 2B      	        dec     HL              ; dec 'cause GETCHR increments
25BE: CD6A1A  	        call    GETCHR          ; check if something follows
25C1: CA6515  	        jp      Z,SNERR         ; if nothing else, raise a syntax error
25C4: CDF11E  	        call    EVAL            ; Evaluate expression
25C7: CDE31E  	        call    TSTSTR          ; Make sure it's a string
25CA: 22F781  	        ld      (VIDEOBUFF),HL  ; store code string pointer into a temp buffer
25CD: CD2A25  	        call    GSTRCU          ; check that a string follows
25D0: CD3C2D  	        call    LOADFP          ; Move string block to BCDE (BC=pointer, E=length)
25D3: ED53EF81	        ld      (LNS1),DE       ; store values into
25D7: ED43F181	        ld      (ADRS1),BC      ; temp buffers
25DB: 2AF781  	        ld      HL,(VIDEOBUFF)  ; retrieve code string pointer from temp buffer
25DE: CD4718  	        call    CHKSYN          ; Make sure ',' follows
25E1: 2C      	        defb    ','
25E2: 2B      	        dec     HL              ; dec 'cause GETCHR increments
25E3: CD6A1A  	        call    GETCHR          ; check if something follows
25E6: CA6515  	        jp      Z,SNERR         ; if nothing else, raise a syntax error
25E9: CDF11E  	        call    EVAL            ; Evaluate expression
25EC: CDE31E  	        call    TSTSTR          ; Make sure it's a string
25EF: 22F781  	        ld      (VIDEOBUFF),HL  ; store code string pointer into a temp buffer
25F2: CD2A25  	        call    GSTRCU          ; check that a string follows
25F5: CD3C2D  	        call    LOADFP          ; Move string block to BCDE (BC=pointer, E=length)
25F8: ED53F381	        ld      (LNS2),DE       ; store values into
25FC: ED43F581	        ld      (ADRS2),BC      ; temp buffers
2600: 2AF781  	        ld      HL,(VIDEOBUFF)  ; retrieve code string pointer from temp buffer
2603: CD4718  	        call    CHKSYN          ; make sure ")" follows
2606: 29      	        defb    ')'
2607: E5      	        push    HL              ; store current code string pointer (the point after the ")" ) ...
2608: FDE1    	        pop     IY              ; ...into IY
260A: AF      	        xor     A               ; reset 10 RAM cells
260B: 060A    	        ld      B,$0A           ; (INSTR registers)
260D: 21F781  	        ld      HL,PT           ; first cell
2610: 77      	EMPTINS:ld      (HL),A          ; reset cell
2611: 23      	        inc     HL              ; next cell
2612: 10FC    	        djnz    EMPTINS         ; repeat
2614: ED5BF381	        ld      DE,(LNS2)       ; load len(S2) into DE
2618: 2AEF81  	        ld      HL,(LNS1)       ; load len(S1) into HL
261B: CDC53D  	        call    CMP16           ; check that len(S1)>=len(S2)
261E: DA9326  	        jp      C,RZINSTR       ; if len(S2)>len(S1) then return 0
2621: AF      	RPTINST:xor     A               ; reset...
2622: 32FD81  	        ld      (TP),A          ; ...TP...
2625: 32FF81  	        ld      (TF),A          ; ...and TF
2628: ED4BF781	        ld      BC,(PT)         ; pointer to S1
262C: 2AF181  	        ld      HL,(ADRS1)      ; first cell of S1
262F: 09      	        add     HL,BC           ; get current position into RAM
2630: 7E      	        ld      A,(HL)          ; load S1(PT)
2631: 2AF581  	        ld      HL,(ADRS2)      ; pointer to first char of S2
2634: BE      	        cp      (HL)            ; is S1(PT)=S2(0)?
2635: 203A    	        jr      NZ,CNT1INS      ; no, continue
2637: 3AF781  	        ld      A,(PT)          ; load current PT
263A: 32FD81  	        ld      (TP),A          ; TP=PT
263D: 32F981  	        ld      (PT1),A         ; P1=PT
2640: AF      	        xor     A               ; set...
2641: 32FB81  	        ld      (PT2),A         ; ...PT2=0
2644: 3C      	        inc     A               ;
2645: 32FF81  	        ld      (TF),A          ; set TF=1
2648: ED4BF981	RP2INST:ld      BC,(PT1)        ; load pointer PT1
264C: 2AF181  	        ld      HL,(ADRS1)      ; load address of S1
264F: 09      	        add     HL,BC           ; find char of S1 pointed by PT1
2650: 7E      	        ld      A,(HL)          ; load S1(PT1)
2651: ED4BFB81	        ld      BC,(PT2)        ; load pointer PT2
2655: 2AF581  	        ld      HL,(ADRS2)      ; load char of S2 pointed by PT2
2658: 09      	        add     HL,BC           ; find S2(PT2)
2659: BE      	        cp      (HL)            ; is S1(PT1)=S2(PT2)?
265A: 204C    	        jr      NZ,CNTZIN       ; no, exit inner loop
265C: 21F981  	        ld      HL,PT1
265F: 34      	        inc     (HL)            ; increment PT1
2660: 3AFB81  	        ld      A,(PT2)
2663: 3C      	        inc     A               ; increment PT2
2664: 32FB81  	        ld      (PT2),A
2667: CA7126  	        jp      Z,CNT1INS       ; if PT2>255 then exit
266A: 21F381  	        ld      HL,LNS2         ; len(S2)
266D: BE      	        cp      (HL)            ; PT2=len(S2)?
266E: DA4826  	        jp      C,RP2INST       ; no (PT2<len(S2) - repeat
2671: 3AFF81  	CNT1INS:ld      A,(TF)          ; check TF
2674: A7      	        and     A               ; TF=0? (clears also Carry for next SBC)
2675: 201C    	        jr      NZ,RZINSTR      ; no, exit
2677: 2AEF81  	        ld      HL,(LNS1)       ; load len(S1)
267A: ED4BF381	        ld      BC,(LNS2)       ; load len(S2)
267E: ED42    	        sbc     HL,BC           ; HL=len(S1)-len(S2)
2680: ED5BF781	        ld      DE,(PT)         ; load pointer
2684: 1C      	        inc     E               ; PT=PT+1
2685: ED53F781	        ld      (PT),DE         ; store new value
2689: EB      	        ex      DE,HL           ; invert registers
268A: CDC53D  	        call    CMP16           ; check if PT>len(S1)-len(S2)
268D: DA2126  	        jp      C,RPTINST       ; repeat if <
2690: CA2126  	        jp      Z,RPTINST       ; repeat if =
2693: 3AFF81  	RZINSTR:ld      A,(TF)          ; current value of TF
2696: A7      	        and     A               ; is it 0?
2697: CA9E26  	        jp      Z,LVINSTR       ; yes, return 0
269A: 3AFD81  	        ld      A,(TP)          ; return TP...
269D: 3C      	        inc     A               ; ...incremented by 1
269E: E1      	LVINSTR:pop     HL              ; drop original return point
269F: FDE5    	        push    IY              ; load current string address from IY into stack
26A1: 11CA1F  	        ld      DE,RETNUM       ; Address of Return number from function...
26A4: D5      	        push    DE              ; ...saved on stack
26A5: C3D822  	        jp      PASSA           ; return TP
26A8: AF      	CNTZIN: xor     A               ; set...
26A9: 32FF81  	        ld      (TF),A          ; TF=0
26AC: C37126  	        jp      CNT1INS         ; continue
              	
              	
26AF: CD1827  	RIGHT:  call    LFRGNM          ; Get number and ending ")"
26B2: D1      	        pop     DE              ; Get string length
26B3: D5      	        push    DE              ; And re-save
26B4: 1A      	        ld      A,(DE)          ; Get length
26B5: 90      	        sub     B               ; Move back N bytes
26B6: C38D25  	        jp      RIGHT1          ; Go and get sub-string
              	
26B9: EB      	MID:    ex      DE,HL           ; Get code string address
26BA: 7E      	        ld      A,(HL)          ; Get next byte ',' or ")"
26BB: CD1D27  	        call    MIDNUM          ; Get number supplied
26BE: 04      	        inc     B               ; Is it character zero?
26BF: 05      	        dec     B
26C0: CA351B  	        jp      Z,FCERR         ; Yes - Error
26C3: C5      	        push    BC              ; Save starting position
26C4: 1EFF    	        ld      E,$FF           ; All of string
26C6: FE29    	        cp      ')'             ; Any length given?
26C8: CAD226  	        jp      Z,RSTSTR        ; No - Rest of string
26CB: CD4718  	        call    CHKSYN          ; Make sure ',' follows
26CE: 2C      	        defb    ','
26CF: CD6527  	        call    GETINT          ; Get integer 0-255
26D2: CD4718  	RSTSTR: call    CHKSYN          ; Make sure ")" follows
26D5: 29      	        defb    ')'
26D6: F1      	        pop     AF              ; Restore starting position
26D7: E3      	        ex      (SP),HL         ; Get string,save code string
26D8: 018F25  	        ld      BC,MID1         ; Continuation of MID$ routine
26DB: C5      	        push    BC              ; Save for return
26DC: 3D      	        dec     A               ; Starting position-1
26DD: BE      	        cp      (HL)            ; Compare with length
26DE: 0600    	        ld      B,$00           ; Zero bytes length
26E0: D0      	        ret     NC              ; Null string if start past end
26E1: 4F      	        ld      C,A             ; Save starting position-1
26E2: 7E      	        ld      A,(HL)          ; Get length of string
26E3: 91      	        sub     C               ; Subtract start
26E4: BB      	        cp      E               ; Enough string for it?
26E5: 47      	        ld      B,A             ; Save maximum length available
26E6: D8      	        ret     C               ; Truncate string if needed
26E7: 43      	        ld      B,E             ; Set specified length
26E8: C9      	        ret                     ; Go and create string
              	
26E9: CD5D25  	VAL:    call    GETLEN          ; Get length of string
26EC: CABC2A  	        jp      Z,RESZER        ; Result zero
26EF: 5F      	        ld      E,A             ; Save length
26F0: 23      	        inc     HL
26F1: 23      	        inc     HL
26F2: 7E      	        ld      A,(HL)          ; Get LSB of address
26F3: 23      	        inc     HL
26F4: 66      	        ld      H,(HL)          ; Get MSB of address
26F5: 6F      	        ld      L,A             ; HL = String address
26F6: E5      	        push    HL              ; Save string address
26F7: 19      	        add     HL,DE
26F8: 46      	        ld      B,(HL)          ; Get end of string+1 byte
26F9: 72      	        ld      (HL),D          ; Zero it to terminate
26FA: E3      	        ex      (SP),HL         ; Save string end,get start
26FB: C5      	        push    BC              ; Save end+1 byte
26FC: 7E      	        ld      A,(HL)          ; Get starting byte
26FD: FE24    	        cp      '$'             ; Hex number indicated? [function added]
26FF: C20727  	        jp      NZ,VAL1
2702: CDFE3C  	        call    HEXTFP          ; Convert Hex to FPREG
2705: 180D    	        jr      VAL3
2707: FE25    	VAL1:   cp      '%'             ; Binary number indicated? [function added]
2709: C21127  	        jp      NZ,VAL2
270C: CD6E3D  	        call    BINTFP          ; Convert Bin to FPREG
270F: 1803    	        jr      VAL3
2711: CDF42D  	VAL2:   call    ASCTFP          ; Convert ASCII string to FP
2714: C1      	VAL3:   pop     BC              ; Restore end+1 byte
2715: E1      	        pop     HL              ; Restore end+1 address
2716: 70      	        ld      (HL),B          ; Put back original byte
2717: C9      	        ret
              	
2718: EB      	LFRGNM: ex      DE,HL           ; Code string address to HL
2719: CD4718  	        call    CHKSYN          ; Make sure ")" follows
271C: 29      	        defb    ')'
271D: C1      	MIDNUM: pop     BC              ; Get return address
271E: D1      	        pop     DE              ; Get number supplied
271F: C5      	        push    BC              ; Re-save return address
2720: 43      	        ld      B,E             ; Number to B
2721: C9      	        ret
              	
2722: CD6827  	INP:    call    MAKINT          ; Make it integer A
2725: 32A080  	        ld      (INPORT),A      ; Set input port
2728: CD9F80  	        call    INPSUB          ; Get input from port
272B: C3D822  	        jp      PASSA           ; Return integer A
              	
272E: CD5227  	POUT:   call    SETIO           ; Set up port number
2731: C36780  	        jp      OUTSUB          ; Output data and return
              	
2734: CD5227  	WAIT:   call    SETIO           ; Set up port number
2737: F5      	        push    AF              ; Save AND mask
2738: 1E00    	        ld      E,$00           ; Assume zero if none given
273A: 2B      	        dec     HL              ; dec 'cos GETCHR INCs
273B: CD6A1A  	        call    GETCHR          ; Get next character
273E: CA4827  	        jp      Z,NOXOR         ; No XOR byte given
2741: CD4718  	        call    CHKSYN          ; Make sure ',' follows
2744: 2C      	        defb    ','
2745: CD6527  	        call    GETINT          ; Get integer 0-255 to XOR with
2748: C1      	NOXOR:  pop     BC              ; Restore AND mask
2749: CD9F80  	WAITLP: call    INPSUB          ; Get input
274C: AB      	        xor     E               ; Flip selected bits
274D: A0      	        and     B               ; Result non-zero?
274E: CA4927  	        jp      Z,WAITLP        ; No = keep waiting
2751: C9      	        ret
              	
2752: CD6527  	SETIO:  call    GETINT          ; Get integer 0-255
2755: 32A080  	        ld      (INPORT),A      ; Set input port
2758: 326880  	        ld      (OTPORT),A      ; Set output port
275B: CD4718  	        call    CHKSYN          ; Make sure ',' follows
275E: 2C      	        defb    ','
275F: C36527  	        jp      GETINT          ; Get integer 0-255 and return
              	
2762: CD6A1A  	FNDNUM: call    GETCHR          ; Get next character
2765: CDDF1E  	GETINT: call    GETNUM          ; Get a number from 0 to 255
2768: CD1A1B  	MAKINT: call    DEPINT          ; Make sure value 0 - 255
276B: 7A      	        ld      A,D             ; Get MSB of number
276C: B7      	        or      A               ; Zero?
276D: C2351B  	        jp      NZ,FCERR        ; No - Error
2770: 2B      	        dec     HL              ; dec 'cos GETCHR INCs
2771: CD6A1A  	        call    GETCHR          ; Get next character
2774: 7B      	        ld      A,E             ; Get number to A
2775: C9      	        ret
              	
              	
              	; activate a Non-Maskable Interrupt hooked to VDP interrupt signal
2776: CDDF1E  	NMI:    call    GETNUM          ; Get memory address
2779: CD201B  	        call    DEINT           ; get integer -32768 to 32767
277C: 7B      	        ld      A,E             ; check if address is 0
277D: B2      	        or      D
277E: 2011    	        jr      NZ,NM1          ; no, so jump over
2780: F3      	DISNMI: di                      ; disable INTs
2781: CDAD27  	        call    NMIDINT         ; disable VDP INT
2784: E5      	        push    HL              ; store HL
2785: 21ED45  	        ld      HL,$45ED        ; these are the op-codes for "RETN"
2788: 226180  	        ld      (NMIUSR),HL     ; store RETN
278B: AF      	        xor     A
278C: 326380  	        ld      (NMIUSR+2),A    ; "NOP"
278F: 1811    	        jr      NMI2            ; execute the last part of code
2791: E5      	NM1:    push    HL              ; store current HL
2792: EB      	        ex      DE,HL           ; move address argument into HL
2793: F3      	        di                      ; disable INTs
2794: CDAD27  	        call    NMIDINT         ; disable VDP INT, if enabled
2797: 3EC3    	        ld      A,$C3           ; "jp" instruction
2799: 326180  	        ld      (NMIUSR),A      ; store it
279C: 226280  	        ld      (NMIUSR+1),HL   ; store address
279F: CDA627  	        call    NMIEINT         ; re-enable VDP INT
27A2: FB      	NMI2:   ei                      ; re-enable INTS
27A3: 00      	        nop                     ; wait for INTs
27A4: E1      	        pop    HL               ; retrieve HL
27A5: C9      	        ret                     ; return to caller
              	; enable VDP INT
27A6: CDBC27  	NMIEINT:call    NMIVR1          ; load default VReg #1 setting
27A9: F620    	        or      %00100000       ; enable VDP INT
27AB: 1803    	        jr      NMIINT          ; rest of code is shared
              	; disable VDP INT
27AD: CDBC27  	NMIDINT:call    NMIVR1          ; load default VReg #1 setting
27B0: D5      	NMIINT: push    DE              ; store DE
27B1: 5F      	        ld      E,A             ; move value into E
27B2: 3E01    	        ld      A,$01           ; VREG #1
27B4: F3      	        di                      ; disable INTs
27B5: CD4306  	        call    WRITE_VREG      ; disable VDP INT
27B8: FB      	        ei                      ; re-enable INTs
27B9: 00      	        nop                     ; wait for INTs being enabled
27BA: D1      	        pop     DE              ; retrieve DE
27BB: C9      	        ret                     ; return to caller
              	
              	; load VREG #1 setting for current screen mode and return it into A
27BC: E5      	NMIVR1: push    HL              ; store HL
27BD: D5      	        push    DE              ; store DE
27BE: 3AE081  	        ld      A,(SCR_MODE)    ; check screen mode
27C1: 87      	        add     A,A             ; multiply A by 8...
27C2: 87      	        add     A,A             ; ...so that reg. A can points..
27C3: 87      	        add     A,A             ; to the correct settings
27C4: 3C      	        inc     A               ; need to change VREG 1
27C5: 5F      	        ld      E,A             ; copy A into E
27C6: 1600    	        ld      D,$00           ; reset D
27C8: 21590A  	        ld      HL,VDPMODESET   ; pointer to register #1 setting...
27CB: 19      	        add     HL,DE           ; ...for current screen mode
27CC: 7E      	        ld      A,(HL)          ; load current setting
27CD: D1      	        pop     DE              ; retrieve DE
27CE: E1      	        pop     HL              ; retrieve HL
27CF: C9      	        ret                     ; return to caller
              	
              	; execute a machine language routine, eventually passing a param into A
27D0: CDDF1E  	SYS:    call    GETNUM          ; Get memory address
27D3: CD201B  	        call    DEINT           ; Get integer -32768 to 32767
27D6: ED53F181	        ld      (TMPBFR2),DE    ; store user routine's address
27DA: AF      	        xor     A               ; reset A
27DB: 32EF81  	        ld      (TMPBFR1),A     ; store into temp buffer
27DE: 2B      	        dec     HL              ; dec 'cos GETCHR INCs
27DF: CD6A1A  	        call    GETCHR          ; check next character
27E2: 280A    	        jr      Z,NOSYSPR       ; jump if nothing follows
27E4: CD4718  	        call    CHKSYN          ; Make sure ',' follows
27E7: 2C      	        defb    ','
27E8: CD6527  	        call    GETINT          ; get byte value (0~255) if something follows
27EB: 32EF81  	        ld      (TMPBFR1),A     ; store into temp buffer
27EE: 3AEF81  	NOSYSPR:ld      A,(TMPBFR1)     ; recover A
27F1: ED5BF181	        ld      DE,(TMPBFR2)    ; recover user routine's address
27F5: E5      	        push    HL              ; save code string address
27F6: EB      	        ex      DE,HL           ; move user routine's address into HL
27F7: 11FC27  	        ld      DE,SYSRET       ; set point of return after the user routine
27FA: D5      	        push    DE              ; store into stack
27FB: E9      	        jp      (HL)            ; call user routine
27FC: E1      	SYSRET: pop     HL              ; retrieve code string address
27FD: C9      	        ret                     ; return to caller
              	
              	
              	; read the contents of a byte from RAM
27FE: CD201B  	PEEK:   call    DEINT           ; Get memory address into DE
2801: 1A      	        ld      A,(DE)          ; Read value of memory cell
2802: C3D822  	        jp      PASSA           ; Return into A
              	
              	; read the contents of a byte from VRAM
2805: CD201B  	VPEEK:  call    DEINT           ; Get VRAM address into DE
2808: EB      	        ex      DE,HL           ; Copy param into HL
2809: F3      	        di                      ; Disable interrupts
280A: CD1906  	        call    READ_VIDEO_LOC  ; Read data from VRAM at address HL
280D: FB      	        ei                      ; Re-enable interrupts
280E: EB      	        ex      DE,HL           ; Restore HL
280F: C3D822  	        jp      PASSA           ; Return value into A
              	
              	; recover params for POKE/VPOKE commands
              	; returns address into DE and byte to be written into A
2812: CDDF1E  	PKEPRMS:call    GETNUM          ; Get memory address
2815: CD201B  	        call    DEINT           ; Get integer -32768 to 32767
2818: ED53EF81	        ld      (TMPBFR1),DE    ; Store DE into a temp. buffer
281C: CD4718  	        call    CHKSYN          ; Make sure ',' follows
281F: 2C      	        defb    ','
2820: CD6527  	        call    GETINT          ; Get integer 0-255
2823: ED5BEF81	        ld      DE,(TMPBFR1)    ; Restore memory address
2827: C9      	        ret                     ; Return to caller
              	
              	; write a byte into SRAM
2828: CD1228  	POKE:   call    PKEPRMS         ; Get params: address and value, return into DE and A, resp.
282B: 12      	        ld      (DE),A          ; Load it into memory
282C: C9      	        ret
              	
              	; write a byte into VRAM
282D: CD1228  	VPOKE:  call    PKEPRMS         ; Get params: address and value, return into DE and A, resp.
2830: EB      	        ex      DE,HL           ; Copy address into HL
2831: F3      	        di                      ; Disable interrupts
2832: CD2E06  	        call    WRITE_VIDEO_LOC ; write data into VRAM at address HL
2835: FB      	        ei                      ; Re-enable interrupts
2836: EB      	        ex      DE,HL           ; Restore HL
2837: C9      	        ret                     ; Return to caller
              	
              	; position the cursor at a specific X,Y location onto screen
2838: CD6527  	LOCATE: call    GETINT          ; get the first param into A
283B: E5      	        push    HL              ; store HL
283C: 21DE81  	        ld      HL,SCR_SIZE_W   ; load address of screen width
283F: 5E      	        ld      E,(HL)          ; load screen width into E
2840: E1      	        pop     HL              ; restore HL
2841: BB      	        cp      E               ; compare witdh with param
2842: D2351B  	        jp      NC,FCERR        ; value over the width of the screen, exit with Illegal F.C. error
2845: 32EF81  	        ld      (TMPBFR1),A     ; Store X into a temp. buffer
2848: CD4718  	        call    CHKSYN          ; Make sure ',' follows
284B: 2C      	        defb    ','
284C: CD6527  	        call    GETINT          ; Get the second param into A
284F: E5      	        push    HL              ; store HL
2850: 21DF81  	        ld      HL,SCR_SIZE_H   ; load address of screen width
2853: 5E      	        ld      E,(HL)          ; load screen width into A
2854: E1      	        pop     HL              ; restore HL
2855: BB      	        cp      E               ; compare witdh with param
2856: D2351B  	        jp      NC,FCERR        ; value over the height of the screen, exit with Illegal F.C. error
2859: 32E781  	        ld      (SCR_CUR_NY),A  ; store new Y
285C: 3AEF81  	        ld      A,(TMPBFR1)     ; recover the new X
285F: 32E681  	        ld      (SCR_CUR_NX),A  ; store new X
2862: E5      	        push    HL              ; store HL
2863: F3      	        di                      ; disable INTs
2864: CD5F06  	        call    MOVCRS          ; move cursor to new location
2867: FB      	        ei                      ; re-enable INTs
2868: E1      	        pop     HL              ; restore HL
2869: C9      	        ret                     ; return to caller
              	
              	; write a byte into one of the PSG registers
286A: CD6527  	SREG:   call    GETINT          ; Get register number back into A
286D: FE10    	        cp      $10             ; check if value >= 16 (PSG registers go from 0 to 15)
286F: D2351B  	        jp      NC,FCERR        ; If yes, exit and raise an Illegal function call Error
2872: 32EF81  	        ld      (TMPBFR1),A     ; Store A into a temp. buffer
2875: CD4718  	        call    CHKSYN          ; Make sure ',' follows
2878: 2C      	        defb    ','
2879: CD6527  	        call    GETINT          ; get second value (0-255), returned into A
287C: 5F      	        ld      E,A             ; store value into E
287D: 3AEF81  	        ld      A,(TMPBFR1)     ; recover VDP register and store into D
2880: F3      	        di                      ; disable INTs
2881: 0E40    	        ld      C,PSG_REG       ; output port to access PSG registers
2883: ED79    	        out     (C),A           ; send register # to PSG
2885: 0E41    	        ld      C,PSG_DAT       ; output port to send data to PSG
2887: ED59    	        out     (C),E           ; send byte to write into selected register
2889: FB      	        ei                      ; re-enable INTs
288A: C9      	        ret                     ; return to caller
              	
              	; VOLUME ch,vol
              	; set the volume for the audio channels
              	; "ch" is 1~3 for corresponding channel, or 0 for all; "vol" is 0~15 (0=OFF, 15=MAX)
288B: CD6527  	VOLUME: call    GETINT          ; get integer 0-255 (recover channel)
288E: FE04    	        cp      $04             ; check if it's in the range 0~3
2890: D2351B  	        jp      NC,FCERR        ; if not, exit with Illegal function call error
2893: 32EF81  	        ld      (TMPBFR1),A     ; Store A into a temp. buffer
2896: CD4718  	        call    CHKSYN          ; Make sure ',' follows
2899: 2C      	        defb    ','
289A: CD6527  	        call    GETINT          ; get integer 0-255 (recover channel)
289D: FE10    	        cp      $10             ; check if it's in the range 0~15
289F: D2351B  	        jp      NC,FCERR        ; if not, exit with Illegal funcion call
28A2: 57      	        ld      D,A             ; store volume into D
28A3: 3AEF81  	        ld      A,(TMPBFR1)     ; retrieve channel
28A6: A7      	        and     A               ; is it 0? (0=every channel)
28A7: 2010    	        jr      NZ,VOLCH        ; no, jump over
28A9: 0603    	        ld      B,$03           ; yes, set every channel
28AB: 1E08    	        ld      E,$08           ; register volume of first channel
28AD: 0E40    	RPVOLCG:ld      C,PSG_REG       ; PSG register port
28AF: ED59    	        out     (C),E           ; set register #
28B1: 0E41    	        ld      C,PSG_DAT       ; PSG data port
28B3: ED51    	        out     (C),D           ; send volume
28B5: 1C      	        inc     E               ; next register
28B6: 10F5    	        djnz    RPVOLCG         ; repeat for each channel
28B8: C9      	        ret                     ; return to caller
28B9: 0E40    	VOLCH:  ld      C,PSG_REG       ; PSG register port
28BB: C607    	        add     $07             ; add 7 to A so that we have the correct register (1->8, 2->9, 3->10)
28BD: ED79    	        out     (C),A           ; set register
28BF: 0E41    	        ld      C,PSG_DAT       ; PSG data port
28C1: ED51    	        out     (C),D           ; send volume level
28C3: C9      	        ret                     ; return to caller
              	
              	; SOUND ch,tone,dur
              	; play a tone or noise of "tone" frequency from selected channel "ch" for duration "dur"
              	; "ch" is 1~6 (0=means sound OFF,1~3 for tone, 4~6 for noise) / "tone" is 1~4,095 (0=means no tone) /
              	; "dur" is 1~16383 h.o.s.,0.001~163s (0=means non-stop tone)
28C4: CD6527  	SOUND:  call    GETINT          ; get integer 0-255 (recover channel)
28C7: A7      	        and     A               ; is it zero?
28C8: 2008    	        jr      NZ,CTSNDC       ; no, continue with checking of params
28CA: E5      	        push    HL              ; store HL
28CB: F3      	        di                      ; disable INTs
28CC: CDCB0B  	        call    CLRPSGREGS      ; yes, it's zero, so reset PSG registers to shut down every sound
28CF: FB      	        ei                      ; re-enable INTs
28D0: E1      	        pop     HL              ; retrieve HL
28D1: C9      	        ret                     ; return to caller
28D2: 32EF81  	CTSNDC: ld      (TMPBFR1),A     ; no, continue by storing A into a temp. buffer
28D5: FE04    	        cp      $04             ; is channel >3?
28D7: D25729  	        jp      NC,NOISUP       ; Yes - check to see if it's a noise channel
28DA: CD4718  	        call    CHKSYN          ; No, continue checking by making sure ',' follows
28DD: 2C      	        defb    ','
28DE: CDDF1E  	        call    GETNUM          ; Get tone frequency
28E1: CD201B  	        call    DEINT           ; Get integer -32768 to 32767
28E4: ED53F181	        ld      (TMPBFR2),DE    ; Store frequency
28E8: CD4718  	        call    CHKSYN          ; Make sure ',' follows
28EB: 2C      	        defb    ','
28EC: CDDF1E  	        call    GETNUM          ; Get duration
28EF: CD201B  	        call    DEINT           ; Get integer -32768 to 32767
28F2: ED53F381	        ld      (TMPBFR3),DE    ; Store duration
              	                                ; CHECK CHANNEL
28F6: 3AEF81  	        ld      A,(TMPBFR1)     ; recover channel
28F9: FE01    	        cp      $01             ; is channel <1?
28FB: DA351B  	        jp      C,FCERR         ; Yes - Illegal function call error
              	                                ; CHECK FREQUENCY
28FE: ED5BF181	        ld      DE,(TMPBFR2)    ; restore frequency from temp buffer
2902: 7A      	        ld      A,D             ; move D into A and check if it is in the range 0~4095...
2903: FE10    	        cp      $10             ; ...so D must not be greater than $0F (15)
2905: D2351B  	        jp      NC,FCERR        ; if not in the range, exit with an Illegal function call error
              	                                ; CHECK DURATION
2908: ED5BF381	        ld      DE,(TMPBFR3)    ; restore duration from temp buffer
290C: 7A      	        ld      A,D             ; check if it is in the range 0~16383...
290D: E6C0    	        and     $C0             ; ...(15th & 14th bits must not be set)
290F: C2351B  	        jp      NZ,FCERR        ; if not in the range, exit with an Illegal function call error
              	                                ;
              	                                ; SET TONE:
              	                                ; let's start by setting up the channel
2912: 3AEF81  	        ld      A,(TMPBFR1)     ; restore channel value
2915: FE03    	        cp      $03             ; is it 3?
2917: 2002    	        jr      NZ,SND1         ; no, jump over
2919: 3E04    	        ld      A,%00000100     ; yes, for ch.3, set 3rd bit only (so A=001, B=010, C=100)
291B: 2F      	SND1:   cpl                     ; complement of A - this is used later to set on the channel into the mixer
291C: CDA429  	        call    WRTSND          ; enable line into mixer of channel stored in A
              	                                ; SET FREQUENCY
              	                                ; we simply get frequency and subtract from 4096. The result
              	                                ; is put into register pair of the corresponding freq tone channel
291F: ED5BF181	        ld      DE,(TMPBFR2)    ; restore frequency from temp buffer
2923: E5      	        push    HL              ; store HL (it will be used by the subroutine)
2924: 210010  	        ld      HL,$1000        ; load 4096 into HL
2927: A7      	        and     A               ; reset C flag
2928: ED52    	        sbc     HL,DE           ; subtract freq from HL - now the frequency is inverted, so we will send the low as high and vice-versa
292A: 3AEF81  	        ld      A,(TMPBFR1)     ; restore channel value
292D: 3D      	        dec     A               ; set A into the range 0~2
292E: 87      	        add     A,A             ; double A to find the register pair that correspond to the channel (A->0,1 / B->2,3, C->4,5)
292F: 0E40    	        ld      C,PSG_REG       ; PSG register port
2931: ED79    	        out     (C),A           ; select first register of the pair
2933: 0E41    	        ld      C,PSG_DAT       ; PSG data port
2935: ED69    	        out     (C),L           ; send high byte
2937: 0E40    	        ld      C,PSG_REG       ; PSG register support
2939: 3C      	        inc     A               ; second register of the pair
293A: ED79    	        out     (C),A           ; select register
293C: 0E41    	        ld      C,PSG_DAT       ; PSG data port
293E: ED61    	        out     (C),H           ; send low byte
2940: ED5BF381	        ld      DE,(TMPBFR3)    ; recover duration
2944: 3AEF81  	        ld      A,(TMPBFR1)     ; recover channel value
2947: 3D      	        dec     A               ; set channel into the range 0~2
2948: 87      	        add     A,A             ; double A to find the correct offset
2949: 212382  	        ld      HL,CHASNDDTN    ; set duration into...
294C: 85      	        add     A,L             ; ...the proper...
294D: 3001    	        jr      NC,SNDOVR       ; (is there a rest? no, jump over
294F: 24      	        inc     H               ; yes, increment H)
2950: 6F      	SNDOVR: ld      L,A             ; ...register pair...
2951: 7323722B	        ld      (HL),DE         ; ...and store the value
2955: E1      	        pop     HL              ; retrieve HL
2956: C9      	        ret                     ; Return to caller
2957: FE07    	NOISUP: cp      $07             ; is channel in range 4 to 6 (for a noise)?
2959: D2351B  	        jp      NC,FCERR        ; no, so ILLEGAL FUNCTION CALL
295C: CD4718  	        call    CHKSYN          ; yes, continue checking by making sure ',' follows
295F: 2C      	        defb    ','
2960: CD6527  	        call    GETINT          ; get integer 0-255 (frequency)
2963: FE20    	        cp      $20             ; make sure it's in range 0~31
2965: D2351B  	        jp      NC,FCERR        ; no, so Illegal function call
2968: 32F181  	        ld      (TMPBFR2),A     ; store freq.
296B: 2B      	        dec     HL              ; dec 'cos GETCHR INCs
296C: CD6A1A  	        call    GETCHR          ; check that nothing follows
296F: C26515  	        jp      NZ,SNERR        ; error if no empty line
2972: 3AF181  	        ld      A,(TMPBFR2)     ; retrieve freq.
2975: 5F      	        ld      E,A             ; store freq into E
2976: 3AEF81  	        ld      A,(TMPBFR1)     ; retrieve channel
2979: D603    	        sub     $03             ; subtract 3 to get channel in range 1~3
297B: FE03    	        cp      $03             ; is it 3?
297D: 2002    	        jr      NZ,NOS1         ; no, jump over
297F: 3E04    	        ld      A,%00000100     ; yes, for ch.3, set 3rd bit only (so A=001, B=010, C=100)
2981: 87      	NOS1:   add     A,A
2982: 87      	        add     A,A
2983: 87      	        add     A,A             ; let's move A 3 bits to left
2984: 47      	        ld      B,A             ; store channel into B
2985: 7B      	        ld      A,E             ; check if
2986: A7      	        and     A               ; freq is 0 (means that noise reproduction must be halted)
2987: F3      	        di                      ; disable INts
2988: 200A    	        jr      NZ,NOS2         ; no, so jump over
298A: 3E07    	        ld      A,$07           ; mixer register
298C: CD190C  	        call    SETSNDREG       ; set mixer register
298F: ED78    	        in      A,(C)           ; load current mixer value
2991: B0      	        or      B               ; disable noise
2992: 1819    	        jr      NOS3            ; continue over
2994: 78      	NOS2:   ld      A,B             ; recover channel
2995: 2F      	        cpl                     ; complement of A - this is used to set on the channel into the mixer
2996: CDA429  	        call    WRTSND          ; enable line into mixer of channel stored in A
2999: 3E06    	        ld      A,$06           ; write into noise register
299B: CD190C  	        call    SETSNDREG       ; set register into PSG
299E: 7B      	        ld      A,E             ; load value for noise frequency
299F: CD1E0C  	        call    WRTSNDREG       ; write data into register $06
29A2: FB      	        ei                      ; re-enable INTs
29A3: C9      	        ret
              	        ; enable line into mixer of channel stored in A
29A4: 47      	WRTSND: ld      B,A             ; move channel into B
29A5: 3E07    	        ld      A,$07           ; mixer register
29A7: CD190C  	        call    SETSNDREG       ; set mixer register
29AA: ED78    	        in      A,(C)           ; load current value
29AC: A0      	        and     B               ; set on the channel into the mixer (remember that 0=ON)
              	                                ; example: if channel is A (1), complement of 1 is 254 (11111110). So, 255 (in case
              	                                ; the register is still unchanged after reset) is 11111111 and
              	                                ; 11111111 AND 11111110 is equal to 11111110
              	                                ; 11111001 AND 11111110 is equal to 11111000 (in case channels B & C are ON)
29AD: 47      	NOS3:   ld      B,A             ; store new mixer value into B
29AE: 3E07    	        ld      A,$07           ; mixer address
29B0: CD190C  	        call    SETSNDREG       ; set register
29B3: 78      	        ld      A,B             ; retrieve new mixer value from B
29B4: CD1E0C  	        call    WRTSNDREG       ; send new value for the mixer
29B7: FB      	        ei                      ; re-enable INTs
29B8: C9      	        ret                     ; return to caller
              	
              	; write a byte into one of the VDP registers
29B9: CD6527  	VREG:   call    GETINT          ; Get register number back into A
29BC: FE08    	        cp      $08             ; check if value is equal or greater than 8 (VDP registers are only 8, from 0 to 7)
29BE: D2351B  	        jp      NC,FCERR        ; If yes, exit and raise an Illegal function call Error
29C1: 32EF81  	        ld      (TMPBFR1),A     ; Store A into a temp. buffer
29C4: CD4718  	        call    CHKSYN          ; Make sure ',' follows
29C7: 2C      	        defb    ','
29C8: CD6527  	        call    GETINT          ; get value (0-255)
29CB: 5F      	        ld      E,A             ; store value into E
29CC: 3AEF81  	        ld      A,(TMPBFR1)     ; recover VDP register and store into A
29CF: F3      	        di                      ; disable INTs
29D0: CD4306  	        call    WRITE_VREG      ; write value into VDP register
29D3: FB      	        ei                      ; re-enable INTs
29D4: C9      	        ret                     ; return to caller
              	
              	; read the VDP status register and return it into A
29D5: CD201B  	VSTAT:  call    DEINT           ; Get integer -32768 to 32767 (Note: we do NOT use it)
29D8: F3      	        di                      ; disable INTs
29D9: CD4E06  	        call    READ_VSTAT      ; read VDP register status
29DC: FB      	        ei                      ; re-enable INTs
29DD: C3D822  	        jp      PASSA           ; Return integer A
              	
              	; read from PSG register and return it into A
29E0: CD201B  	SSTAT:  call    DEINT           ; get integer -32768 to 32767
29E3: 7B      	        ld      A,E             ; consider LSB
29E4: FE10    	        cp      $10             ; check if value >= 16 (PSG registers go from 0 to 15)
29E6: D2351B  	        jp      NC,FCERR        ; If yes, exit and raise an Illegal function call Error
29E9: F3      	        di                      ; disable INts
29EA: 0E40    	        ld      C,PSG_REG       ; output port to set PSG register
29EC: ED79    	        out     (C),A           ; send register to read from
29EE: ED78    	        in      A,(C)           ; read register's contents and store into A
29F0: FB      	        ei                      ; re-enable INTs
29F1: C3D822  	        jp      PASSA           ; return A
              	
              	; read the temp key buffer and return the value of the current key being pressed
              	; can wait for the number of 100thds of second before to return
29F4: CD5223  	INKEY:  call    IDTEST          ; Test for illegal direct
29F7: CD201B  	        call    DEINT           ; get number param (100thds of second to wait) into DE
29FA: C5      	        push    BC              ; store BC
29FB: 3ACE81  	        ld      A,(TMRCNT)      ; Load current value of system timer
29FE: 47      	        ld      B,A             ; move it into B
29FF: 3ACE81  	CMP_A:  ld      A,(TMRCNT)      ; make a little delay of 1/100 sec...
2A02: B8      	        cp      B               ; ...to let the sniffer collect...
2A03: 20FA    	        jr      NZ,CMP_A        ; ...at least 1 char before to continue
2A05: 7A      	        ld      A,D             ; check the param
2A06: B3      	        or      E               ; if DE<>0 then...
2A07: 2005    	        jr      NZ,INKEY2       ; ...jump over...
2A09: 3A2B82  	        ld      A,(TMPKEYBFR)   ; ...else read the buffer and...
2A0C: 182A    	        jr      ENDINK          ; ...return it
2A0E: 7A      	INKEY2: ld      A,D             ; check if param>1023
2A0F: FE04    	        cp      $04             ; to do this we check if MSB>3
2A11: D2351B  	        jp      NC,FCERR        ; if MSB >=4 then error
2A14: E5      	        push    HL              ; store HL
2A15: 210900  	        ld      HL,$0009        ; check if value
2A18: CDC53D  	        call    CMP16           ; is < 10
2A1B: E1      	        pop     HL              ; retrieve HL
2A1C: DA222A  	        jp      C,SRTINK        ; if value >= 10 then jump over
2A1F: 110A00  	        ld      DE,$000A        ; else, use 10 (no intervals shorter than 10/100s)
2A22: 3ACE81  	SRTINK: ld      A,(TMRCNT)      ; Load the first byte of the system timer
2A25: 47      	        ld      B,A             ; move it into B
2A26: 3A2B82  	CHKINK: ld      A,(TMPKEYBFR)   ; load char code from buffer
2A29: A7      	        and     A               ; is it 0?
2A2A: 200C    	        jr      NZ,ENDINK       ; no, so we can return it
2A2C: 3ACE81  	        ld      A,(TMRCNT)      ; load the first byte of the system timer
2A2F: B8      	        cp      B               ; is it the same value?
2A30: 28F4    	        jr      Z,CHKINK        ; yes, so read again
2A32: 47      	        ld      B,A             ; store new value
2A33: 1B      	        dec     DE              ; no, decrement timer
2A34: 7A      	        ld      A,D             ; check if zero reached
2A35: B3      	        or      E               ; by ORing D and E
2A36: 20EE    	        jr      NZ,CHKINK       ; if not 0, repeat
2A38: C1      	ENDINK: pop     BC              ; restore BC
2A39: F5      	        push    AF              ; store A
2A3A: F3      	        di                      ; disable INTs
2A3B: AF      	        xor     A               ; clear the...
2A3C: 322B82  	        ld      (TMPKEYBFR),A   ; ...TMP KEY buffer for the next read
2A3F: FB      	        ei                      ; re-enable INTs
2A40: F1      	        pop     AF              ; retrieve A
2A41: C3D822  	ENDINK2:jp      PASSA           ; return A as ASCII value
              	
2A44: 216B2F  	ROUND:  ld      HL,HALF         ; Add 0.5 to FPREG
2A47: CD3C2D  	ADDPHL: call    LOADFP          ; Load FP at (HL) to BCDE
2A4A: C3562A  	        jp      FPADD           ; Add BCDE to FPREG
              	
2A4D: CD3C2D  	SUBPHL: call    LOADFP          ; FPREG = -FPREG + number at HL
2A50: 21      	        defb    $21             ; Skip "pop BC" and "pop DE"
2A51: C1      	PSUB:   pop     BC              ; Get FP number from stack
2A52: D1      	        pop     DE
2A53: CD162D  	SUBCDE: call    INVSGN          ; Negate FPREG
2A56: 78      	FPADD:  ld      A,B             ; Get FP exponent
2A57: B7      	        or      A               ; Is number zero?
2A58: C8      	        ret     Z               ; Yes - Nothing to add
2A59: 3ACC81  	        ld      A,(FPEXP)       ; Get FPREG exponent
2A5C: B7      	        or      A               ; Is this number zero?
2A5D: CA2E2D  	        jp      Z,FPBCDE        ; Yes - Move BCDE to FPREG
2A60: 90      	        sub     B               ; BCDE number larger?
2A61: D2702A  	        jp      NC,NOSWAP       ; No - Don't swap them
2A64: 2F      	        cpl                     ; Two's complement
2A65: 3C      	        inc     A               ;  FP exponent
2A66: EB      	        ex      DE,HL
2A67: CD1E2D  	        call    STAKFP          ; Put FPREG on stack
2A6A: EB      	        ex      DE,HL
2A6B: CD2E2D  	        call    FPBCDE          ; Move BCDE to FPREG
2A6E: C1      	        pop     BC              ; Restore number from stack
2A6F: D1      	        pop     DE
2A70: FE19    	NOSWAP: cp      24+1            ; Second number insignificant?
2A72: D0      	        ret     NC              ; Yes - First number is result
2A73: F5      	        push    AF              ; Save number of bits to scale
2A74: CD532D  	        call    SIGNS           ; Set MSBs & sign of result
2A77: 67      	        ld      H,A             ; Save sign of result
2A78: F1      	        pop     AF              ; Restore scaling factor
2A79: CD1B2B  	        call    SCALE           ; Scale BCDE to same exponent
2A7C: B4      	        or      H               ; Result to be positive?
2A7D: 21C981  	        ld      HL,FPREG        ; Point to FPREG
2A80: F2962A  	        jp      P,MINCDE        ; No - Subtract FPREG from CDE
2A83: CDFB2A  	        call    PLUCDE          ; Add FPREG to CDE
2A86: D2DC2A  	        jp      NC,RONDUP       ; No overflow - Round it up
2A89: 23      	        inc     HL              ; Point to exponent
2A8A: 34      	        inc     (HL)            ; Increment it
2A8B: CA7415  	        jp      Z,OVERR         ; Number overflowed - Error
2A8E: 2E01    	        ld      L,$01           ; 1 bit to shift right
2A90: CD312B  	        call    SHRT1           ; Shift result right
2A93: C3DC2A  	        jp      RONDUP          ; Round it up
              	
2A96: AF      	MINCDE: xor     A               ; Clear A and carry
2A97: 90      	        sub     B               ; Negate exponent
2A98: 47      	        ld      B,A             ; Re-save exponent
2A99: 7E      	        ld      A,(HL)          ; Get LSB of FPREG
2A9A: 9B      	        sbc     A, E            ; Subtract LSB of BCDE
2A9B: 5F      	        ld      E,A             ; Save LSB of BCDE
2A9C: 23      	        inc     HL
2A9D: 7E      	        ld      A,(HL)          ; Get NMSB of FPREG
2A9E: 9A      	        sbc     A,D             ; Subtract NMSB of BCDE
2A9F: 57      	        ld      D,A             ; Save NMSB of BCDE
2AA0: 23      	        inc     HL
2AA1: 7E      	        ld      A,(HL)          ; Get MSB of FPREG
2AA2: 99      	        sbc     A,C             ; Subtract MSB of BCDE
2AA3: 4F      	        ld      C,A             ; Save MSB of BCDE
2AA4: DC072B  	CONPOS: call    C,COMPL         ; Overflow - Make it positive
              	
2AA7: 68      	BNORM:  ld      L,B             ; L = Exponent
2AA8: 63      	        ld      H,E             ; H = LSB
2AA9: AF      	        xor     A
2AAA: 47      	BNRMLP: ld      B,A             ; Save bit count
2AAB: 79      	        ld      A,C             ; Get MSB
2AAC: B7      	        or      A               ; Is it zero?
2AAD: C2C92A  	        jp      NZ,PNORM        ; No - Do it bit at a time
2AB0: 4A      	        ld      C,D             ; MSB = NMSB
2AB1: 54      	        ld      D,H             ; NMSB= LSB
2AB2: 65      	        ld      H,L             ; LSB = VLSB
2AB3: 6F      	        ld      L,A             ; VLSB= 0
2AB4: 78      	        ld      A,B             ; Get exponent
2AB5: D608    	        sub     $08             ; Count 8 bits
2AB7: FEE0    	        cp      -24-8           ; Was number zero?
2AB9: C2AA2A  	        jp      NZ,BNRMLP       ; No - Keep normalising
2ABC: AF      	RESZER: xor     A               ; Result is zero
2ABD: 32CC81  	SAVEXP: ld      (FPEXP),A       ; Save result as zero
2AC0: C9      	        ret
              	
2AC1: 05      	NORMAL: dec     B               ; Count bits
2AC2: 29      	        add     HL,HL           ; Shift HL left
2AC3: 7A      	        ld      A,D             ; Get NMSB
2AC4: 17      	        rla                     ; Shift left with last bit
2AC5: 57      	        ld      D,A             ; Save NMSB
2AC6: 79      	        ld      A,C             ; Get MSB
2AC7: 8F      	        adc     A,A             ; Shift left with last bit
2AC8: 4F      	        ld      C,A             ; Save MSB
2AC9: F2C12A  	PNORM:  jp      P,NORMAL        ; Not done - Keep going
2ACC: 78      	        ld      A,B             ; Number of bits shifted
2ACD: 5C      	        ld      E,H             ; Save HL in EB
2ACE: 45      	        ld      B,L
2ACF: B7      	        or      A               ; Any shifting done?
2AD0: CADC2A  	        jp      Z,RONDUP        ; No - Round it up
2AD3: 21CC81  	        ld      HL,FPEXP        ; Point to exponent
2AD6: 86      	        add     A,(HL)          ; Add shifted bits
2AD7: 77      	        ld      (HL),A          ; Re-save exponent
2AD8: D2BC2A  	        jp      NC,RESZER       ; Underflow - Result is zero
2ADB: C8      	        ret     Z               ; Result is zero
2ADC: 78      	RONDUP: ld      A,B             ; Get VLSB of number
2ADD: 21CC81  	RONDB:  ld      HL,FPEXP        ; Point to exponent
2AE0: B7      	        or      A               ; Any rounding?
2AE1: FCEE2A  	        call    M,FPROND        ; Yes - Round number up
2AE4: 46      	        ld      B,(HL)          ; B = Exponent
2AE5: 23      	        inc     HL
2AE6: 7E      	        ld      A,(HL)          ; Get sign of result
2AE7: E680    	        and     %10000000       ; Only bit 7 needed
2AE9: A9      	        xor     C               ; Set correct sign
2AEA: 4F      	        ld      C,A             ; Save correct sign in number
2AEB: C32E2D  	        jp      FPBCDE          ; Move BCDE to FPREG
              	
2AEE: 1C      	FPROND: inc     E               ; Round LSB
2AEF: C0      	        ret     NZ              ; Return if ok
2AF0: 14      	        inc     D               ; Round NMSB
2AF1: C0      	        ret     NZ              ; Return if ok
2AF2: 0C      	        inc     C               ; Round MSB
2AF3: C0      	        ret     NZ              ; Return if ok
2AF4: 0E80    	        ld      C,$80           ; Set normal value
2AF6: 34      	        inc     (HL)            ; Increment exponent
2AF7: C0      	        ret     NZ              ; Return if ok
2AF8: C37415  	        jp      OVERR           ; Overflow error
              	
2AFB: 7E      	PLUCDE: ld      A,(HL)          ; Get LSB of FPREG
2AFC: 83      	        add     A,E             ; Add LSB of BCDE
2AFD: 5F      	        ld      E,A             ; Save LSB of BCDE
2AFE: 23      	        inc     HL
2AFF: 7E      	        ld      A,(HL)          ; Get NMSB of FPREG
2B00: 8A      	        adc     A,D             ; Add NMSB of BCDE
2B01: 57      	        ld      D,A             ; Save NMSB of BCDE
2B02: 23      	        inc     HL
2B03: 7E      	        ld      A,(HL)          ; Get MSB of FPREG
2B04: 89      	        adc     A,C             ; Add MSB of BCDE
2B05: 4F      	        ld      C,A             ; Save MSB of BCDE
2B06: C9      	        ret
              	
2B07: 21CD81  	COMPL:  ld      HL,SGNRES       ; Sign of result
2B0A: 7E      	        ld      A,(HL)          ; Get sign of result
2B0B: 2F      	        cpl                     ; Negate it
2B0C: 77      	        ld      (HL),A          ; Put it back
2B0D: AF      	        xor     A
2B0E: 6F      	        ld      L,A             ; Set L to zero
2B0F: 90      	        sub     B               ; Negate exponent,set carry
2B10: 47      	        ld      B,A             ; Re-save exponent
2B11: 7D      	        ld      A,L             ; Load zero
2B12: 9B      	        sbc     A,E             ; Negate LSB
2B13: 5F      	        ld      E,A             ; Re-save LSB
2B14: 7D      	        ld      A,L             ; Load zero
2B15: 9A      	        sbc     A,D             ; Negate NMSB
2B16: 57      	        ld      D,A             ; Re-save NMSB
2B17: 7D      	        ld      A,L             ; Load zero
2B18: 99      	        sbc     A,C             ; Negate MSB
2B19: 4F      	        ld      C,A             ; Re-save MSB
2B1A: C9      	        ret
              	
2B1B: 0600    	SCALE:  ld      B,$00           ; Clear underflow
2B1D: D608    	SCALLP: sub     $08             ; 8 bits (a whole byte)?
2B1F: DA2A2B  	        jp      C,SHRITE        ; No - Shift right A bits
2B22: 43      	        ld      B,E             ; <- Shift
2B23: 5A      	        ld      E,D             ; <- right
2B24: 51      	        ld      D,C             ; <- eight
2B25: 0E00    	        ld      C,$00           ; <- bits
2B27: C31D2B  	        jp      SCALLP          ; More bits to shift
              	
2B2A: C609    	SHRITE: add     A,8+1           ; Adjust count
2B2C: 6F      	        ld      L,A             ; Save bits to shift
2B2D: AF      	SHRLP:  xor     A               ; Flag for all done
2B2E: 2D      	        dec     L               ; All shifting done?
2B2F: C8      	        ret     Z               ; Yes - Return
2B30: 79      	        ld      A,C             ; Get MSB
2B31: 1F      	SHRT1:  rra                     ; Shift it right
2B32: 4F      	        ld      C,A             ; Re-save
2B33: 7A      	        ld      A,D             ; Get NMSB
2B34: 1F      	        rra                     ; Shift right with last bit
2B35: 57      	        ld      D,A             ; Re-save it
2B36: 7B      	        ld      A,E             ; Get LSB
2B37: 1F      	        rra                     ; Shift right with last bit
2B38: 5F      	        ld      E,A             ; Re-save it
2B39: 78      	        ld      A,B             ; Get underflow
2B3A: 1F      	        rra                     ; Shift right with last bit
2B3B: 47      	        ld      B,A             ; Re-save underflow
2B3C: C32D2B  	        jp      SHRLP           ; More bits to do
              	
2B3F: 00000081	UNITY:  defb    $00,$00,$00,$81 ; 1.00000
              	
2B43: 03      	LOGTAB: defb    $03             ; Table used by LOG
2B44: AA561980	        defb    $AA,$56,$19,$80 ; 0.59898
2B48: F1227680	        defb    $F1,$22,$76,$80 ; 0.96147
2B4C: 45AA3882	        defb    $45,$AA,$38,$82 ; 2.88539
              	
2B50: CDED2C  	LOG:    call    TSTSGN          ; Test sign of value
2B53: B7      	        or      A
2B54: EA351B  	        jp      PE,FCERR        ; ?FC Error if <= zero
2B57: 21CC81  	        ld      HL,FPEXP        ; Point to exponent
2B5A: 7E      	        ld      A,(HL)          ; Get exponent
2B5B: 013580  	        ld      BC,$8035        ; BCDE = SQR(1/2)
2B5E: 11F304  	        ld      DE,$04F3
2B61: 90      	        sub     B               ; Scale value to be < 1
2B62: F5      	        push    AF              ; Save scale factor
2B63: 70      	        ld      (HL),B          ; Save new exponent
2B64: D5      	        push    DE              ; Save SQR(1/2)
2B65: C5      	        push    BC
2B66: CD562A  	        call    FPADD           ; Add SQR(1/2) to value
2B69: C1      	        pop     BC              ; Restore SQR(1/2)
2B6A: D1      	        pop     DE
2B6B: 04      	        inc     B               ; Make it SQR(2)
2B6C: CD432C  	        call    DVBCDE          ; Divide by SQR(2)
2B6F: 213F2B  	        ld      HL,UNITY        ; Point to 1.
2B72: CD4D2A  	        call    SUBPHL          ; Subtract FPREG from 1
2B75: 21432B  	        ld      HL,LOGTAB       ; Coefficient table
2B78: CD3530  	        call    SUMSER          ; Evaluate sum of series
2B7B: 018080  	        ld      BC,$8080        ; BCDE = -0.5
2B7E: 110000  	        ld      DE,$0000
2B81: CD562A  	        call    FPADD           ; Subtract 0.5 from FPREG
2B84: F1      	        pop     AF              ; Restore scale factor
2B85: CD682E  	        call    RSCALE          ; Re-scale number
2B88: 013180  	MULLN2: ld      BC,$8031        ; BCDE = Ln(2)
2B8B: 111872  	        ld      DE,$7218
2B8E: 21      	        defb    $21             ; Skip "pop BC" and "pop DE"
              	
2B8F: C1      	MULT:   pop     BC              ; Get number from stack
2B90: D1      	        pop     DE
2B91: CDED2C  	FPMULT: call    TSTSGN          ; Test sign of FPREG
2B94: C8      	        ret     Z               ; Return zero if zero
2B95: 2E00    	        ld      L,$00           ; Flag add exponents
2B97: CDAB2C  	        call    ADDEXP          ; Add exponents
2B9A: 79      	        ld      A,C             ; Get MSB of multiplier
2B9B: 323D82  	        ld      (MULVAL),A      ; Save MSB of multiplier
2B9E: EB      	        ex      DE,HL
2B9F: 223E82  	        ld      (MULVAL+1),HL   ; Save rest of multiplier
2BA2: 010000  	        ld      BC,$0000        ; Partial product (BCDE) = zero
2BA5: 50      	        ld      D,B
2BA6: 58      	        ld      E,B
2BA7: 21A72A  	        ld      HL,BNORM        ; Address of normalise
2BAA: E5      	        push    HL              ; Save for return
2BAB: 21B32B  	        ld      HL,MULT8        ; Address of 8 bit multiply
2BAE: E5      	        push    HL              ; Save for NMSB,MSB
2BAF: E5      	        push    HL              ;
2BB0: 21C981  	        ld      HL,FPREG        ; Point to number
2BB3: 7E      	MULT8:  ld      A,(HL)          ; Get LSB of number
2BB4: 23      	        inc     HL              ; Point to NMSB
2BB5: B7      	        or      A               ; Test LSB
2BB6: CADF2B  	        jp      Z,BYTSFT        ; Zero - shift to next byte
2BB9: E5      	        push    HL              ; Save address of number
2BBA: 2E08    	        ld      L,$08           ; 8 bits to multiply by
2BBC: 1F      	MUL8LP: rra                     ; Shift LSB right
2BBD: 67      	        ld      H,A             ; Save LSB
2BBE: 79      	        ld      A,C             ; Get MSB
2BBF: D2CD2B  	        jp      NC,NOMADD       ; Bit was zero - Don't add
2BC2: E5      	        push    HL              ; Save LSB and count
2BC3: 2A3E82  	        ld      HL,(MULVAL+1)   ; Get LSB and NMSB
2BC6: 19      	        add     HL,DE           ; Add NMSB and LSB
2BC7: EB      	        ex      DE,HL           ; Leave sum in DE
2BC8: E1      	        pop     HL              ; Restore MSB and count
2BC9: 3A3D82  	        ld      A,(MULVAL)      ; Get MSB of multiplier
2BCC: 89      	        adc     A,C             ; Add MSB
2BCD: 1F      	NOMADD: rra                     ; Shift MSB right
2BCE: 4F      	        ld      C,A             ; Re-save MSB
2BCF: 7A      	        ld      A,D             ; Get NMSB
2BD0: 1F      	        rra                     ; Shift NMSB right
2BD1: 57      	        ld      D,A             ; Re-save NMSB
2BD2: 7B      	        ld      A,E             ; Get LSB
2BD3: 1F      	        rra                     ; Shift LSB right
2BD4: 5F      	        ld      E,A             ; Re-save LSB
2BD5: 78      	        ld      A,B             ; Get VLSB
2BD6: 1F      	        rra                     ; Shift VLSB right
2BD7: 47      	        ld      B,A             ; Re-save VLSB
2BD8: 2D      	        dec     L               ; Count bits multiplied
2BD9: 7C      	        ld      A,H             ; Get LSB of multiplier
2BDA: C2BC2B  	        jp      NZ,MUL8LP       ; More - Do it
2BDD: E1      	POPHRT: pop     HL              ; Restore address of number
2BDE: C9      	        ret
              	
2BDF: 43      	BYTSFT: ld      B,E             ; Shift partial product left
2BE0: 5A      	        ld      E,D
2BE1: 51      	        ld      D,C
2BE2: 4F      	        ld      C,A
2BE3: C9      	        ret
              	
              	
              	; WORKING ––
2BE4: C1      	DINT:   pop     BC              ; Get number from stack
2BE5: D1      	        pop     DE
2BE6: CD432C  	        call    DVBCDE          ; get BCDE/FPREG and store result into FPREG
2BE9: C3C02D  	        jp      INT             ; return INT(FPREG)
              	
              	
              	; A MODULO B - return remainder of the integer division A/B where:
              	; A is in stack; B is in FPREG
              	; math is:
              	; A=INT(A); B=INT(B); R=A-(B*INT(A/B))
2BEC: CDC02D  	MOD:    call    INT             ; B=INT(B)
2BEF: CD392D  	        call    BCDEFP          ; copy B (from FPREG) into BCDE
2BF2: ED53F381	        ld      (TMPBFR3),DE    ; store B into...
2BF6: ED43F581	        ld      (TMPBFR4),BC    ; ...a temp buffer
2BFA: C1      	        pop     BC              ; recover A...
2BFB: D1      	        pop     DE              ; ...from stack
2BFC: CD2E2D  	        call    FPBCDE          ; store A into FPREG
2BFF: CDC02D  	        call    INT             ; get integer part: A=INT(A)
2C02: CD392D  	        call    BCDEFP          ; copy A (from FPREG) into BCDE
2C05: ED53EF81	        ld      (TMPBFR1),DE    ; store A into...
2C09: ED43F181	        ld      (TMPBFR2),BC    ; ...a temp buffer
              	                                ; begin calculation
2C0D: 2AF381  	        ld      HL,(TMPBFR3)    ; move B...
2C10: 22C981  	        ld      (FPREG),HL      ; ...from...
2C13: 2AF581  	        ld      HL,(TMPBFR4)    ; ...temp buffer...
2C16: 22CB81  	        ld      (FPREG+2),HL    ; ...into FPREG
2C19: CD432C  	        call    DVBCDE          ; compute A/B and store into FPREG
2C1C: CDC02D  	        call    INT             ; get integer part of result: now FPREG = INT(A/B)
2C1F: ED5BF381	        ld      DE,(TMPBFR3)    ; load B...
2C23: ED4BF581	        ld      BC,(TMPBFR4)    ; ...into BCDE
2C27: CD912B  	        call    FPMULT          ; get B*INT(A/B) and store into FPREG
2C2A: ED5BEF81	        ld      DE,(TMPBFR1)    ; retrieve A from...
2C2E: ED4BF181	        ld      BC,(TMPBFR2)    ; ...temp buffer
2C32: C3532A  	        jp      SUBCDE          ; return result of A-(B*INT(A/B))
              	
              	
2C35: CD1E2D  	DIV10:  call    STAKFP          ; Save FPREG on stack
2C38: 012084  	        ld      BC,$8420        ; BCDE = 10.
2C3B: 110000  	        ld      DE,$0000
2C3E: CD2E2D  	        call    FPBCDE          ; Move 10 to FPREG
              	
2C41: C1      	DIV:    pop     BC              ; Get number from stack
2C42: D1      	        pop     DE
2C43: CDED2C  	DVBCDE: call    TSTSGN          ; Test sign of FPREG
2C46: CA6815  	        jp      Z,DZERR         ; Error if division by zero
2C49: 2EFF    	        ld      L,-1            ; Flag subtract exponents
2C4B: CDAB2C  	        call    ADDEXP          ; Subtract exponents
2C4E: 34      	        inc     (HL)            ; Add 2 to exponent to adjust
2C4F: 34      	        inc     (HL)
2C50: 2B      	        dec     HL              ; Point to MSB
2C51: 7E      	        ld      A,(HL)          ; Get MSB of dividend
2C52: 327380  	        ld      (DIV3),A        ; Save for subtraction
2C55: 2B      	        dec     HL
2C56: 7E      	        ld      A,(HL)          ; Get NMSB of dividend
2C57: 326F80  	        ld      (DIV2),A        ; Save for subtraction
2C5A: 2B      	        dec     HL
2C5B: 7E      	        ld      A,(HL)          ; Get MSB of dividend
2C5C: 326B80  	        ld      (DIV1),A        ; Save for subtraction
2C5F: 41      	        ld      B,C             ; Get MSB
2C60: EB      	        ex      DE,HL           ; NMSB,LSB to HL
2C61: AF      	        xor     A
2C62: 4F      	        ld      C,A             ; Clear MSB of quotient
2C63: 57      	        ld      D,A             ; Clear NMSB of quotient
2C64: 5F      	        ld      E,A             ; Clear LSB of quotient
2C65: 327680  	        ld      (DIV4),A        ; Clear overflow count
2C68: E5      	DIVLP:  push    HL              ; Save divisor
2C69: C5      	        push    BC
2C6A: 7D      	        ld      A,L             ; Get LSB of number
2C6B: CD6A80  	        call    DIVSUP          ; Subt' divisor from dividend
2C6E: DE00    	        sbc     A,$00           ; Count for overflows
2C70: 3F      	        ccf
2C71: D27B2C  	        jp      NC,RESDIV       ; Restore divisor if borrow
2C74: 327680  	        ld      (DIV4),A        ; Re-save overflow count
2C77: F1      	        pop     AF              ; Scrap divisor
2C78: F1      	        pop     AF
2C79: 37      	        scf                     ; Set carry to
2C7A: D2      	        defb    $D2             ; Skip "pop BC" and "pop HL"
              	
2C7B: C1      	RESDIV: pop     BC              ; Restore divisor
2C7C: E1      	        pop     HL
2C7D: 79      	        ld      A,C             ; Get MSB of quotient
2C7E: 3C      	        inc     A
2C7F: 3D      	        dec     A
2C80: 1F      	        rra                     ; Bit 0 to bit 7
2C81: FADD2A  	        jp      M,RONDB         ; Done - Normalise result
2C84: 17      	        rla                     ; Restore carry
2C85: 7B      	        ld      A,E             ; Get LSB of quotient
2C86: 17      	        rla                     ; Double it
2C87: 5F      	        ld      E,A             ; Put it back
2C88: 7A      	        ld      A,D             ; Get NMSB of quotient
2C89: 17      	        rla                     ; Double it
2C8A: 57      	        ld      D,A             ; Put it back
2C8B: 79      	        ld      A,C             ; Get MSB of quotient
2C8C: 17      	        rla                     ; Double it
2C8D: 4F      	        ld      C,A             ; Put it back
2C8E: 29      	        add     HL,HL           ; Double NMSB,LSB of divisor
2C8F: 78      	        ld      A,B             ; Get MSB of divisor
2C90: 17      	        rla                     ; Double it
2C91: 47      	        ld      B,A             ; Put it back
2C92: 3A7680  	        ld      A,(DIV4)        ; Get VLSB of quotient
2C95: 17      	        rla                     ; Double it
2C96: 327680  	        ld      (DIV4),A        ; Put it back
2C99: 79      	        ld      A,C             ; Get MSB of quotient
2C9A: B2      	        or      D               ; Merge NMSB
2C9B: B3      	        or      E               ; Merge LSB
2C9C: C2682C  	        jp      NZ,DIVLP        ; Not done - Keep dividing
2C9F: E5      	        push    HL              ; Save divisor
2CA0: 21CC81  	        ld      HL,FPEXP        ; Point to exponent
2CA3: 35      	        dec     (HL)            ; Divide by 2
2CA4: E1      	        pop     HL              ; Restore divisor
2CA5: C2682C  	        jp      NZ,DIVLP        ; Ok - Keep going
2CA8: C37415  	        jp      OVERR           ; Overflow error
              	
              	
2CAB: 78      	ADDEXP: ld      A,B             ; Get exponent of dividend
2CAC: B7      	        or      A               ; Test it
2CAD: CACF2C  	        jp      Z,OVTST3        ; Zero - Result zero
2CB0: 7D      	        ld      A,L             ; Get add/subtract flag
2CB1: 21CC81  	        ld      HL,FPEXP        ; Point to exponent
2CB4: AE      	        xor     (HL)            ; Add or subtract it
2CB5: 80      	        add     A,B             ; Add the other exponent
2CB6: 47      	        ld      B,A             ; Save new exponent
2CB7: 1F      	        rra                     ; Test exponent for overflow
2CB8: A8      	        xor     B
2CB9: 78      	        ld      A,B             ; Get exponent
2CBA: F2CE2C  	        jp      P,OVTST2        ; Positive - Test for overflow
2CBD: C680    	        add     A,$80           ; Add excess 128
2CBF: 77      	        ld      (HL),A          ; Save new exponent
2CC0: CADD2B  	        jp      Z,POPHRT        ; Zero - Result zero
2CC3: CD532D  	        call    SIGNS           ; Set MSBs and sign of result
2CC6: 77      	        ld      (HL),A          ; Save new exponent
2CC7: 2B      	        dec     HL              ; Point to MSB
2CC8: C9      	        ret
              	
2CC9: CDED2C  	OVTST1: call    TSTSGN          ; Test sign of FPREG
2CCC: 2F      	        cpl                     ; Invert sign
2CCD: E1      	        pop     HL              ; Clean up stack
2CCE: B7      	OVTST2: or      A               ; Test if new exponent zero
2CCF: E1      	OVTST3: pop     HL              ; Clear off return address
2CD0: F2BC2A  	        jp      P,RESZER        ; Result zero
2CD3: C37415  	        jp      OVERR           ; Overflow error
              	
2CD6: CD392D  	MLSP10: call    BCDEFP          ; Move FPREG to BCDE
2CD9: 78      	        ld      A,B             ; Get exponent
2CDA: B7      	        or      A               ; Is it zero?
2CDB: C8      	        ret     Z               ; Yes - Result is zero
2CDC: C602    	        add     A,$02           ; Multiply by 4
2CDE: DA7415  	        jp      C,OVERR         ; Overflow - ?OV Error
2CE1: 47      	        ld      B,A             ; Re-save exponent
2CE2: CD562A  	        call    FPADD           ; Add BCDE to FPREG (Times 5)
2CE5: 21CC81  	        ld      HL,FPEXP        ; Point to exponent
2CE8: 34      	        inc     (HL)            ; Double number (Times 10)
2CE9: C0      	        ret     NZ              ; Ok - Return
2CEA: C37415  	        jp      OVERR           ; Overflow error
              	
2CED: 3ACC81  	TSTSGN: ld      A,(FPEXP)       ; Get sign of FPREG
2CF0: B7      	        or      A
2CF1: C8      	        ret     Z               ; RETurn if number is zero
2CF2: 3ACB81  	        ld      A,(FPREG+2)     ; Get MSB of FPREG
2CF5: FE      	        defb    0FEH            ; Test sign
2CF6: 2F      	RETREL: cpl                     ; Invert sign
2CF7: 17      	        rla                     ; Sign bit to carry
2CF8: 9F      	FLGDIF: sbc     A,A             ; Carry to all bits of A
2CF9: C0      	        ret     NZ              ; Return -1 if negative
2CFA: 3C      	        inc     A               ; Bump to +1
2CFB: C9      	        ret                     ; Positive - Return +1
              	
2CFC: CDED2C  	SGN:    call    TSTSGN          ; Test sign of FPREG
2CFF: 0688    	FLGREL: ld      B,$80+8         ; 8 bit integer in exponent
2D01: 110000  	        ld      DE,0            ; Zero NMSB and LSB
2D04: 21CC81  	RETINT: ld      HL,FPEXP        ; Point to exponent
2D07: 4F      	        ld      C,A             ; CDE = MSB,NMSB and LSB
2D08: 70      	        ld      (HL),B          ; Save exponent
2D09: 0600    	        ld      B,0             ; CDE = integer to normalise
2D0B: 23      	        inc     HL              ; Point to sign of result
2D0C: 3680    	        ld      (HL),$80        ; Set sign of result
2D0E: 17      	        rla                     ; Carry = sign of integer
2D0F: C3A42A  	        jp      CONPOS          ; Set sign of result
              	
2D12: CDED2C  	ABS:    call    TSTSGN          ; Test sign of FPREG
2D15: F0      	        ret     P               ; Return if positive
2D16: 21CB81  	INVSGN: ld      HL,FPREG+2      ; Point to MSB
2D19: 7E      	        ld      A,(HL)          ; Get sign of mantissa
2D1A: EE80    	        xor     $80             ; Invert sign of mantissa
2D1C: 77      	        ld      (HL),A          ; Re-save sign of mantissa
2D1D: C9      	        ret
              	
2D1E: EB      	STAKFP: ex      DE,HL           ; Save code string address
2D1F: 2AC981  	        ld      HL,(FPREG)      ; LSB,NLSB of FPREG
2D22: E3      	        ex      (SP),HL         ; Stack them,get return
2D23: E5      	        push    HL              ; Re-save return
2D24: 2ACB81  	        ld      HL,(FPREG+2)    ; MSB and exponent of FPREG
2D27: E3      	        ex      (SP),HL         ; Stack them,get return
2D28: E5      	        push    HL              ; Re-save return
2D29: EB      	        ex      DE,HL           ; Restore code string address
2D2A: C9      	        ret
              	
              	; store F.P. number from BCDE into FPREG
2D2B: CD3C2D  	PHLTFP: call    LOADFP          ; Number at HL to BCDE
2D2E: EB      	FPBCDE: ex      DE,HL           ; Save code string address
2D2F: 22C981  	        ld      (FPREG),HL      ; Save LSB,NLSB of number
2D32: 60      	        ld      H,B             ; Exponent of number
2D33: 69      	        ld      L,C             ; MSB of number
2D34: 22CB81  	        ld      (FPREG+2),HL    ; Save MSB and exponent
2D37: EB      	        ex      DE,HL           ; Restore code string address
2D38: C9      	        ret
              	
              	; load F.P. number from FPREG into BCDE
2D39: 21C981  	BCDEFP: ld      HL,FPREG        ; Point to FPREG
2D3C: 5E      	LOADFP: ld      E,(HL)          ; Get LSB of number
2D3D: 23      	        inc     HL
2D3E: 56      	        ld      D,(HL)          ; Get NMSB of number
2D3F: 23      	        inc     HL
2D40: 4E      	        ld      C,(HL)          ; Get MSB of number
2D41: 23      	        inc     HL
2D42: 46      	        ld      B,(HL)          ; Get exponent of number
2D43: 23      	INCHL:  inc     HL              ; Used for conditional "inc HL"
2D44: C9      	        ret
              	
2D45: 11C981  	FPTHL:  ld      DE,FPREG        ; Point to FPREG
2D48: 0604    	DETHL4: ld      B,$04           ; 4 bytes to move
2D4A: 1A      	DETHLB: ld      A,(DE)          ; Get source
2D4B: 77      	        ld      (HL),A          ; Save destination
2D4C: 13      	        inc     DE              ; Next source
2D4D: 23      	        inc     HL              ; Next destination
2D4E: 05      	        dec     B               ; Count bytes
2D4F: C24A2D  	        jp      NZ,DETHLB       ; Loop if more
2D52: C9      	        ret
              	
2D53: 21CB81  	SIGNS:  ld      HL,FPREG+2      ; Point to MSB of FPREG
2D56: 7E      	        ld      A,(HL)          ; Get MSB
2D57: 07      	        rlca                    ; Old sign to carry
2D58: 37      	        scf                     ; Set MSBit
2D59: 1F      	        rra                     ; Set MSBit of MSB
2D5A: 77      	        ld      (HL),A          ; Save new MSB
2D5B: 3F      	        ccf                     ; Complement sign
2D5C: 1F      	        rra                     ; Old sign to carry
2D5D: 23      	        inc     HL
2D5E: 23      	        inc     HL
2D5F: 77      	        ld      (HL),A          ; Set sign of result
2D60: 79      	        ld      A,C             ; Get MSB
2D61: 07      	        rlca                    ; Old sign to carry
2D62: 37      	        scf                     ; Set MSBit
2D63: 1F      	        rra                     ; Set MSBit of MSB
2D64: 4F      	        ld      C,A             ; Save MSB
2D65: 1F      	        rra
2D66: AE      	        xor     (HL)            ; New sign of result
2D67: C9      	        ret
              	
2D68: 78      	CMPNUM: ld      A,B             ; Get exponent of number
2D69: B7      	        or      A
2D6A: CAED2C  	        jp      Z,TSTSGN        ; Zero - Test sign of FPREG
2D6D: 21F62C  	        ld      HL,RETREL       ; Return relation routine
2D70: E5      	        push    HL              ; Save for return
2D71: CDED2C  	        call    TSTSGN          ; Test sign of FPREG
2D74: 79      	        ld      A,C             ; Get MSB of number
2D75: C8      	        ret     Z               ; FPREG zero - Number's MSB
2D76: 21CB81  	        ld      HL,FPREG+2      ; MSB of FPREG
2D79: AE      	        xor     (HL)            ; Combine signs
2D7A: 79      	        ld      A,C             ; Get MSB of number
2D7B: F8      	        ret     M               ; Exit if signs different
2D7C: CD822D  	        call    CMPFP           ; Compare FP numbers
2D7F: 1F      	        rra                     ; Get carry to sign
2D80: A9      	        xor     C               ; Combine with MSB of number
2D81: C9      	        ret
              	
2D82: 23      	CMPFP:  inc     HL              ; Point to exponent
2D83: 78      	        ld      A,B             ; Get exponent
2D84: BE      	        cp      (HL)            ; Compare exponents
2D85: C0      	        ret     NZ              ; Different
2D86: 2B      	        dec     HL              ; Point to MBS
2D87: 79      	        ld      A,C             ; Get MSB
2D88: BE      	        cp      (HL)            ; Compare MSBs
2D89: C0      	        ret     NZ              ; Different
2D8A: 2B      	        dec     HL              ; Point to NMSB
2D8B: 7A      	        ld      A,D             ; Get NMSB
2D8C: BE      	        cp      (HL)            ; Compare NMSBs
2D8D: C0      	        ret     NZ              ; Different
2D8E: 2B      	        dec     HL              ; Point to LSB
2D8F: 7B      	        ld      A,E             ; Get LSB
2D90: 96      	        sub     (HL)            ; Compare LSBs
2D91: C0      	        ret     NZ              ; Different
2D92: E1      	        pop     HL              ; Drop RETurn
2D93: E1      	        pop     HL              ; Drop another RETurn
2D94: C9      	        ret
              	
2D95: 47      	FPINT:  ld      B,A             ; <- Move
2D96: 4F      	        ld      C,A             ; <- exponent
2D97: 57      	        ld      D,A             ; <- to all
2D98: 5F      	        ld      E,A             ; <- bits
2D99: B7      	        or      A               ; Test exponent
2D9A: C8      	        ret     Z               ; Zero - Return zero
2D9B: E5      	        push    HL              ; Save pointer to number
2D9C: CD392D  	        call    BCDEFP          ; Move FPREG to BCDE
2D9F: CD532D  	        call    SIGNS           ; Set MSBs & sign of result
2DA2: AE      	        xor     (HL)            ; Combine with sign of FPREG
2DA3: 67      	        ld      H,A             ; Save combined signs
2DA4: FCB92D  	        call    M,DCBCDE        ; Negative - Decrement BCDE
2DA7: 3E98    	        ld      A,$80+24        ; 24 bits
2DA9: 90      	        sub     B               ; Bits to shift
2DAA: CD1B2B  	        call    SCALE           ; Shift BCDE
2DAD: 7C      	        ld      A,H             ; Get combined sign
2DAE: 17      	        rla                     ; Sign to carry
2DAF: DCEE2A  	        call    C,FPROND        ; Negative - Round number up
2DB2: 0600    	        ld      B,$00           ; Zero exponent
2DB4: DC072B  	        call    C,COMPL         ; If negative make positive
2DB7: E1      	        pop     HL              ; Restore pointer to number
2DB8: C9      	        ret
              	
2DB9: 1B      	DCBCDE: dec     DE              ; Decrement BCDE
2DBA: 7A      	        ld      A,D             ; Test LSBs
2DBB: A3      	        and     E
2DBC: 3C      	        inc     A
2DBD: C0      	        ret     NZ              ; Exit if LSBs not FFFF
2DBE: 0B      	        dec     BC              ; Decrement MSBs
2DBF: C9      	        ret
              	
2DC0: 21CC81  	INT:    ld      HL,FPEXP        ; Point to exponent
2DC3: 7E      	        ld      A,(HL)          ; Get exponent
2DC4: FE98    	        cp      $80+24          ; Integer accuracy only?
2DC6: 3AC981  	        ld      A,(FPREG)       ; Get LSB
2DC9: D0      	        ret     NC              ; Yes - Already integer
2DCA: 7E      	        ld      A,(HL)          ; Get exponent
2DCB: CD952D  	        call    FPINT           ; F.P to integer
2DCE: 3698    	        ld      (HL),$80+24     ; Save 24 bit integer
2DD0: 7B      	        ld      A,E             ; Get LSB of number
2DD1: F5      	        push    AF              ; Save LSB
2DD2: 79      	        ld      A,C             ; Get MSB of number
2DD3: 17      	        rla                     ; Sign to carry
2DD4: CDA42A  	        call    CONPOS          ; Set sign of result
2DD7: F1      	        pop     AF              ; Restore LSB of number
2DD8: C9      	        ret
              	
2DD9: 210000  	MLDEBC: ld      HL,$0000        ; Clear partial product
2DDC: 78      	        ld      A,B             ; Test multiplier
2DDD: B1      	        or      C
2DDE: C8      	        ret     Z               ; Return zero if zero
2DDF: 3E10    	        ld      A,$10           ; 16 bits
2DE1: 29      	MLDBLP: add     HL,HL           ; Shift P.P left
2DE2: DA0622  	        jp      C,BSERR         ; ?BS Error if overflow
2DE5: EB      	        ex      DE,HL
2DE6: 29      	        add     HL,HL           ; Shift multiplier left
2DE7: EB      	        ex      DE,HL
2DE8: D2EF2D  	        jp      NC,NOMLAD       ; Bit was zero - No add
2DEB: 09      	        add     HL,BC           ; Add multiplicand
2DEC: DA0622  	        jp      C,BSERR         ; ?BS Error if overflow
2DEF: 3D      	NOMLAD: dec     A               ; Count bits
2DF0: C2E12D  	        jp      NZ,MLDBLP       ; More
2DF3: C9      	        ret
              	
2DF4: FE2D    	ASCTFP: cp      '-'             ; Negative?
2DF6: F5      	        push    AF              ; Save it and flags
2DF7: CA002E  	        jp      Z,CNVNUM        ; Yes - Convert number
2DFA: FE2B    	        cp      '+'             ; Positive?
2DFC: CA002E  	        jp      Z,CNVNUM        ; Yes - Convert number
2DFF: 2B      	        dec     HL              ; dec 'cos GETCHR INCs
2E00: CDBC2A  	CNVNUM: call    RESZER          ; Set result to zero
2E03: 47      	        ld      B,A             ; Digits after point counter
2E04: 57      	        ld      D,A             ; Sign of exponent
2E05: 5F      	        ld      E,A             ; Exponent of ten
2E06: 2F      	        cpl
2E07: 4F      	        ld      C,A             ; Before or after point flag
2E08: CD6A1A  	MANLP:  call    GETCHR          ; Get next character
2E0B: DA512E  	        jp      C,ADDIG         ; Digit - Add to number
2E0E: FE2E    	        cp      '.'
2E10: CA2C2E  	        jp      Z,DPOINT        ; '.' - Flag point
2E13: FE45    	        cp      'E'
2E15: C2302E  	        jp      NZ,CONEXP       ; Not 'E' - Scale number
2E18: CD6A1A  	        call    GETCHR          ; Get next character
2E1B: CD2220  	        call    SGNEXP          ; Get sign of exponent
2E1E: CD6A1A  	EXPLP:  call    GETCHR          ; Get next character
2E21: DA732E  	        jp      C,EDIGIT        ; Digit - Add to exponent
2E24: 14      	        inc     D               ; Is sign negative?
2E25: C2302E  	        jp      NZ,CONEXP       ; No - Scale number
2E28: AF      	        xor     A
2E29: 93      	        sub     E               ; Negate exponent
2E2A: 5F      	        ld      E,A             ; And re-save it
2E2B: 0C      	        inc     C               ; Flag end of number
2E2C: 0C      	DPOINT: inc     C               ; Flag point passed
2E2D: CA082E  	        jp      Z,MANLP         ; Zero - Get another digit
2E30: E5      	CONEXP: push    HL              ; Save code string address
2E31: 7B      	        ld      A,E             ; Get exponent
2E32: 90      	        sub     B               ; Subtract digits after point
2E33: F4492E  	SCALMI: call    P,SCALPL        ; Positive - Multiply number
2E36: F23F2E  	        jp      P,ENDCON        ; Positive - All done
2E39: F5      	        push    AF              ; Save number of times to /10
2E3A: CD352C  	        call    DIV10           ; Divide by 10
2E3D: F1      	        pop     AF              ; Restore count
2E3E: 3C      	        inc     A               ; Count divides
              	
2E3F: C2332E  	ENDCON: jp      NZ,SCALMI       ; More to do
2E42: D1      	        pop     DE              ; Restore code string address
2E43: F1      	        pop     AF              ; Restore sign of number
2E44: CC162D  	        call    Z,INVSGN        ; Negative - Negate number
2E47: EB      	        ex      DE,HL           ; Code string address to HL
2E48: C9      	        ret
              	
2E49: C8      	SCALPL: ret     Z               ; Exit if no scaling needed
2E4A: F5      	MULTEN: push    AF              ; Save count
2E4B: CDD62C  	        call    MLSP10          ; Multiply number by 10
2E4E: F1      	        pop     AF              ; Restore count
2E4F: 3D      	        dec     A               ; Count multiplies
2E50: C9      	        ret
              	
2E51: D5      	ADDIG:  push    DE              ; Save sign of exponent
2E52: 57      	        ld      D,A             ; Save digit
2E53: 78      	        ld      A,B             ; Get digits after point
2E54: 89      	        adc     A,C             ; Add one if after point
2E55: 47      	        ld      B,A             ; Re-save counter
2E56: C5      	        push    BC              ; Save point flags
2E57: E5      	        push    HL              ; Save code string address
2E58: D5      	        push    DE              ; Save digit
2E59: CDD62C  	        call    MLSP10          ; Multiply number by 10
2E5C: F1      	        pop     AF              ; Restore digit
2E5D: D630    	        sub     '0'             ; Make it absolute
2E5F: CD682E  	        call    RSCALE          ; Re-scale number
2E62: E1      	        pop     HL              ; Restore code string address
2E63: C1      	        pop     BC              ; Restore point flags
2E64: D1      	        pop     DE              ; Restore sign of exponent
2E65: C3082E  	        jp      MANLP           ; Get another digit
              	
2E68: CD1E2D  	RSCALE: call    STAKFP          ; Put number on stack
2E6B: CDFF2C  	        call    FLGREL          ; Digit to add to FPREG
2E6E: C1      	PADD:   pop     BC              ; Restore number
2E6F: D1      	        pop     DE
2E70: C3562A  	        jp      FPADD           ; Add BCDE to FPREG and return
              	
2E73: 7B      	EDIGIT: ld      A,E             ; Get digit
2E74: 07      	        rlca                    ; Times 2
2E75: 07      	        rlca                    ; Times 4
2E76: 83      	        add     A,E             ; Times 5
2E77: 07      	        rlca                    ; Times 10
2E78: 86      	        add     A,(HL)          ; Add next digit
2E79: D630    	        sub     '0'             ; Make it absolute
2E7B: 5F      	        ld      E,A             ; Save new digit
2E7C: C31E2E  	        jp      EXPLP           ; Look for another digit
              	
2E7F: E5      	LINEIN: push    HL              ; Save code string address
2E80: 21DE14  	        ld      HL,INMSG        ; Output " in "
2E83: CDE723  	        call    PRS             ; Output string at HL
2E86: E1      	        pop     HL              ; Restore code string address
2E87: EB      	PRNTHL: ex      DE,HL           ; Code string address to DE
2E88: AF      	        xor     A
2E89: 0698    	        ld      B,$80+24        ; 24 bits
2E8B: CD042D  	        call    RETINT          ; Return the integer
2E8E: 21E623  	        ld      HL,PRNUMS       ; Print number string
2E91: E5      	        push    HL              ; Save for return
2E92: 213082  	NUMASC: ld      HL,PBUFF        ; Convert number to ASCII
2E95: E5      	        push    HL              ; Save for return
2E96: CDED2C  	        call    TSTSGN          ; Test sign of FPREG
2E99: 3620    	        ld      (HL),SPC        ; Space at start
2E9B: F2A02E  	        jp      P,SPCFST        ; Positive - Space to start
2E9E: 362D    	        ld      (HL),'-'        ; '-' sign at start
2EA0: 23      	SPCFST: inc     HL              ; First byte of number
2EA1: 3630    	        ld      (HL),'0'        ; '0' if zero
2EA3: CA562F  	        jp      Z,JSTZER        ; Return '0' if zero
2EA6: E5      	        push    HL              ; Save buffer address
2EA7: FC162D  	        call    M,INVSGN        ; Negate FPREG if negative
2EAA: AF      	        xor     A               ; Zero A
2EAB: F5      	        push    AF              ; Save it
2EAC: CD5C2F  	        call    RNGTST          ; Test number is in range
2EAF: 014391  	SIXDIG: ld      BC,$9143        ; BCDE - 99999.9
2EB2: 11F84F  	        ld      DE,$4FF8
2EB5: CD682D  	        call    CMPNUM          ; Compare numbers
2EB8: B7      	        or      A
2EB9: E2CD2E  	        jp      PO,INRNG        ; > 99999.9 - Sort it out
2EBC: F1      	        pop     AF              ; Restore count
2EBD: CD4A2E  	        call    MULTEN          ; Multiply by ten
2EC0: F5      	        push    AF              ; Re-save count
2EC1: C3AF2E  	        jp      SIXDIG          ; Test it again
              	
2EC4: CD352C  	GTSIXD: call    DIV10           ; Divide by 10
2EC7: F1      	        pop     AF              ; Get count
2EC8: 3C      	        inc     A               ; Count divides
2EC9: F5      	        push    AF              ; Re-save count
2ECA: CD5C2F  	        call    RNGTST          ; Test number is in range
2ECD: CD442A  	INRNG:  call    ROUND           ; Add 0.5 to FPREG
2ED0: 3C      	        inc     A
2ED1: CD952D  	        call    FPINT           ; F.P to integer
2ED4: CD2E2D  	        call    FPBCDE          ; Move BCDE to FPREG
2ED7: 010603  	        ld      BC,$0306        ; 1E+06 to 1E-03 range
2EDA: F1      	        pop     AF              ; Restore count
2EDB: 81      	        add     A,C             ; 6 digits before point
2EDC: 3C      	        inc     A               ; Add one
2EDD: FAE92E  	        jp      M,MAKNUM        ; Do it in 'E' form if < 1E-02
2EE0: FE08    	        cp      6+1+1           ; More than 999999 ?
2EE2: D2E92E  	        jp      NC,MAKNUM       ; Yes - Do it in 'E' form
2EE5: 3C      	        inc     A               ; Adjust for exponent
2EE6: 47      	        ld      B,A             ; Exponent of number
2EE7: 3E02    	        ld      A,2             ; Make it zero after
              	
2EE9: 3D      	MAKNUM: dec     A               ; Adjust for digits to do
2EEA: 3D      	        dec     A
2EEB: E1      	        pop     HL              ; Restore buffer address
2EEC: F5      	        push    AF              ; Save count
2EED: 116F2F  	        ld      DE,POWERS       ; Powers of ten
2EF0: 05      	        dec     B               ; Count digits before point
2EF1: C2FA2E  	        jp      NZ,DIGTXT       ; Not zero - Do number
2EF4: 362E    	        ld      (HL),'.'        ; Save point
2EF6: 23      	        inc     HL              ; Move on
2EF7: 3630    	        ld      (HL),'0'        ; Save zero
2EF9: 23      	        inc     HL              ; Move on
2EFA: 05      	DIGTXT: dec     B               ; Count digits before point
2EFB: 362E    	        ld      (HL),'.'        ; Save point in case
2EFD: CC432D  	        call    Z,INCHL         ; Last digit - move on
2F00: C5      	        push    BC              ; Save digits before point
2F01: E5      	        push    HL              ; Save buffer address
2F02: D5      	        push    DE              ; Save powers of ten
2F03: CD392D  	        call    BCDEFP          ; Move FPREG to BCDE
2F06: E1      	        pop     HL              ; Powers of ten table
2F07: 062F    	        ld      B,'0'-1         ; ASCII '0' - 1
2F09: 04      	TRYAGN: inc     B               ; Count subtractions
2F0A: 7B      	        ld      A,E             ; Get LSB
2F0B: 96      	        sub     (HL)            ; Subtract LSB
2F0C: 5F      	        ld      E,A             ; Save LSB
2F0D: 23      	        inc     HL
2F0E: 7A      	        ld      A,D             ; Get NMSB
2F0F: 9E      	        sbc     A,(HL)          ; Subtract NMSB
2F10: 57      	        ld      D,A             ; Save NMSB
2F11: 23      	        inc     HL
2F12: 79      	        ld      A,C             ; Get MSB
2F13: 9E      	        sbc     A,(HL)          ; Subtract MSB
2F14: 4F      	        ld      C,A             ; Save MSB
2F15: 2B      	        dec     HL              ; Point back to start
2F16: 2B      	        dec     HL
2F17: D2092F  	        jp      NC,TRYAGN       ; No overflow - Try again
2F1A: CDFB2A  	        call    PLUCDE          ; Restore number
2F1D: 23      	        inc     HL              ; Start of next number
2F1E: CD2E2D  	        call    FPBCDE          ; Move BCDE to FPREG
2F21: EB      	        ex      DE,HL           ; Save point in table
2F22: E1      	        pop     HL              ; Restore buffer address
2F23: 70      	        ld      (HL),B          ; Save digit in buffer
2F24: 23      	        inc     HL              ; And move on
2F25: C1      	        pop     BC              ; Restore digit count
2F26: 0D      	        dec     C               ; Count digits
2F27: C2FA2E  	        jp      NZ,DIGTXT       ; More - Do them
2F2A: 05      	        dec     B               ; Any decimal part?
2F2B: CA3A2F  	        jp      Z,DOEBIT        ; No - Do 'E' bit
2F2E: 2B      	SUPTLZ: dec     HL              ; Move back through buffer
2F2F: 7E      	        ld      A,(HL)          ; Get character
2F30: FE30    	        cp      '0'             ; '0' character?
2F32: CA2E2F  	        jp      Z,SUPTLZ        ; Yes - Look back for more
2F35: FE2E    	        cp      '.'             ; A decimal point?
2F37: C4432D  	        call    NZ,INCHL        ; Move back over digit
              	
2F3A: F1      	DOEBIT: pop     AF              ; Get 'E' flag
2F3B: CA592F  	        jp      Z,NOENED        ; No 'E' needed - End buffer
2F3E: 3645    	        ld      (HL),'E'        ; Put 'E' in buffer
2F40: 23      	        inc     HL              ; And move on
2F41: 362B    	        ld      (HL),'+'        ; Put '+' in buffer
2F43: F24A2F  	        jp      P,OUTEXP        ; Positive - Output exponent
2F46: 362D    	        ld      (HL),'-'        ; Put '-' in buffer
2F48: 2F      	        cpl                     ; Negate exponent
2F49: 3C      	        inc     A
2F4A: 062F    	OUTEXP: ld      B,'0'-1         ; ASCII '0' - 1
2F4C: 04      	EXPTEN: inc     B               ; Count subtractions
2F4D: D60A    	        sub     $0A             ; Tens digit
2F4F: D24C2F  	        jp      NC,EXPTEN       ; More to do
2F52: C63A    	        add     A,'0'+10        ; Restore and make ASCII
2F54: 23      	        inc     HL              ; Move on
2F55: 70      	        ld      (HL),B          ; Save MSB of exponent
2F56: 23      	JSTZER: inc     HL              ;
2F57: 77      	        ld      (HL),A          ; Save LSB of exponent
2F58: 23      	        inc     HL
2F59: 71      	NOENED: ld      (HL),C          ; Mark end of buffer
2F5A: E1      	        pop     HL              ; Restore code string address
2F5B: C9      	        ret
              	
2F5C: 017494  	RNGTST: ld      BC,$9474        ; BCDE = 999999.
2F5F: 11F723  	        ld      DE,$23F7
2F62: CD682D  	        call    CMPNUM          ; Compare numbers
2F65: B7      	        or      A
2F66: E1      	        pop     HL              ; Return address to HL
2F67: E2C42E  	        jp      PO,GTSIXD       ; Too big - Divide by ten
2F6A: E9      	        jp      (HL)            ; Otherwise return to caller
              	
2F6B: 00000080	HALF:   defb    $00,$00,$00,$80 ; 0.5
              	
2F6F: A08601  	POWERS: defb    $A0,$86,$01  ; 100000
2F72: 102700  	        defb    $10,$27,$00  ;  10000
2F75: E80300  	        defb    $E8,$03,$00  ;   1000
2F78: 640000  	        defb    $64,$00,$00  ;    100
2F7B: 0A0000  	        defb    $0A,$00,$00  ;     10
2F7E: 010000  	        defb    $01,$00,$00  ;      1
              	
2F81: 21162D  	NEGAFT: ld      HL,INVSGN       ; Negate result
2F84: E3      	        ex      (SP),HL         ; To be done after caller
2F85: E9      	        jp      (HL)            ; Return to caller
              	
2F86: CD1E2D  	SQR:    call    STAKFP          ; Put value on stack
2F89: 216B2F  	        ld      HL,HALF         ; Set power to 1/2
2F8C: CD2B2D  	        call    PHLTFP          ; Move 1/2 to FPREG
              	
2F8F: C1      	POWER:  pop     BC              ; Get base
2F90: D1      	        pop     DE
2F91: CDED2C  	        call    TSTSGN          ; Test sign of power
2F94: 78      	        ld      A,B             ; Get exponent of base
2F95: CAD42F  	        jp      Z,EXP           ; Make result 1 if zero
2F98: F29F2F  	        jp      P,POWER1        ; Positive base - Ok
2F9B: B7      	        or      A               ; Zero to negative power?
2F9C: CA6815  	        jp      Z,DZERR         ; Yes - ?/0 Error
2F9F: B7      	POWER1: or      A               ; Base zero?
2FA0: CABD2A  	        jp      Z,SAVEXP        ; Yes - Return zero
2FA3: D5      	        push    DE              ; Save base
2FA4: C5      	        push    BC
2FA5: 79      	        ld      A,C             ; Get MSB of base
2FA6: F67F    	        or      %01111111       ; Get sign status
2FA8: CD392D  	        call    BCDEFP          ; Move power to BCDE
2FAB: F2BC2F  	        jp      P,POWER2        ; Positive base - Ok
2FAE: D5      	        push    DE              ; Save power
2FAF: C5      	        push    BC
2FB0: CDC02D  	        call    INT             ; Get integer of power
2FB3: C1      	        pop     BC              ; Restore power
2FB4: D1      	        pop     DE
2FB5: F5      	        push    AF              ; MSB of base
2FB6: CD682D  	        call    CMPNUM          ; Power an integer?
2FB9: E1      	        pop     HL              ; Restore MSB of base
2FBA: 7C      	        ld      A,H             ; but don't affect flags
2FBB: 1F      	        rra                     ; Exponent odd or even?
2FBC: E1      	POWER2: pop     HL              ; Restore MSB and exponent
2FBD: 22CB81  	        ld      (FPREG+2),HL    ; Save base in FPREG
2FC0: E1      	        pop     HL              ; LSBs of base
2FC1: 22C981  	        ld      (FPREG),HL      ; Save in FPREG
2FC4: DC812F  	        call    C,NEGAFT        ; Odd power - Negate result
2FC7: CC162D  	        call    Z,INVSGN        ; Negative base - Negate it
2FCA: D5      	        push    DE              ; Save power
2FCB: C5      	        push    BC
2FCC: CD502B  	        call    LOG             ; Get LOG of base
2FCF: C1      	        pop     BC              ; Restore power
2FD0: D1      	        pop     DE
2FD1: CD912B  	        call    FPMULT          ; Multiply LOG by power
              	
2FD4: CD1E2D  	EXP:    call    STAKFP          ; Put value on stack
2FD7: 013881  	        ld      BC,$8138        ; BCDE = 1/Ln(2)
2FDA: 113BAA  	        ld      DE,$AA3B
2FDD: CD912B  	        call    FPMULT          ; Multiply value by 1/LN(2)
2FE0: 3ACC81  	        ld      A,(FPEXP)       ; Get exponent
2FE3: FE88    	        cp      $80+8           ; Is it in range?
2FE5: D2C92C  	        jp      NC,OVTST1       ; No - Test for overflow
2FE8: CDC02D  	        call    INT             ; Get INT of FPREG
2FEB: C680    	        add     A,$80           ; For excess 128
2FED: C602    	        add     A,$02           ; Exponent > 126?
2FEF: DAC92C  	        jp      C,OVTST1        ; Yes - Test for overflow
2FF2: F5      	        push    AF              ; Save scaling factor
2FF3: 213F2B  	        ld      HL,UNITY        ; Point to 1.
2FF6: CD472A  	        call    ADDPHL          ; Add 1 to FPREG
2FF9: CD882B  	        call    MULLN2          ; Multiply by LN(2)
2FFC: F1      	        pop     AF              ; Restore scaling factor
2FFD: C1      	        pop     BC              ; Restore exponent
2FFE: D1      	        pop     DE
2FFF: F5      	        push    AF              ; Save scaling factor
3000: CD532A  	        call    SUBCDE          ; Subtract exponent from FPREG
3003: CD162D  	        call    INVSGN          ; Negate result
3006: 211430  	        ld      HL,EXPTAB       ; Coefficient table
3009: CD4430  	        call    SMSER1          ; Sum the series
300C: 110000  	        ld      DE,$0000        ; Zero LSBs
300F: C1      	        pop     BC              ; Scaling factor
3010: 4A      	        ld      C,D             ; Zero MSB
3011: C3912B  	        jp      FPMULT          ; Scale result to correct value
              	
3014: 08      	EXPTAB: defb    $08             ; Table used by EXP
3015: 402E9474	        defb    $40,$2E,$94,$74 ; -1/7! (-1/5040)
3019: 704F2E77	        defb    $70,$4F,$2E,$77 ;  1/6! ( 1/720)
301D: 6E02887A	        defb    $6E,$02,$88,$7A ; -1/5! (-1/120)
3021: E6A02A7C	        defb    $E6,$A0,$2A,$7C ;  1/4! ( 1/24)
3025: 50AAAA7E	        defb    $50,$AA,$AA,$7E ; -1/3! (-1/6)
3029: FFFF7F7F	        defb    $FF,$FF,$7F,$7F ;  1/2! ( 1/2)
302D: 00008081	        defb    $00,$00,$80,$81 ; -1/1! (-1/1)
3031: 00000081	        defb    $00,$00,$00,$81 ;  1/0! ( 1/1)
              	
3035: CD1E2D  	SUMSER: call    STAKFP          ; Put FPREG on stack
3038: 118F2B  	        ld      DE,MULT         ; Multiply by "X"
303B: D5      	        push    DE              ; To be done after
303C: E5      	        push    HL              ; Save address of table
303D: CD392D  	        call    BCDEFP          ; Move FPREG to BCDE
3040: CD912B  	        call    FPMULT          ; Square the value
3043: E1      	        pop     HL              ; Restore address of table
3044: CD1E2D  	SMSER1: call    STAKFP          ; Put value on stack
3047: 7E      	        ld      A,(HL)          ; Get number of coefficients
3048: 23      	        inc     HL              ; Point to start of table
3049: CD2B2D  	        call    PHLTFP          ; Move coefficient to FPREG
304C: 06      	        defb    06H             ; Skip "pop AF"
304D: F1      	SUMLP:  pop     AF              ; Restore count
304E: C1      	        pop     BC              ; Restore number
304F: D1      	        pop     DE
3050: 3D      	        dec     A               ; Cont coefficients
3051: C8      	        ret     Z               ; All done
3052: D5      	        push    DE              ; Save number
3053: C5      	        push    BC
3054: F5      	        push    AF              ; Save count
3055: E5      	        push    HL              ; Save address in table
3056: CD912B  	        call    FPMULT          ; Multiply FPREG by BCDE
3059: E1      	        pop     HL              ; Restore address in table
305A: CD3C2D  	        call    LOADFP          ; Number at HL to BCDE
305D: E5      	        push    HL              ; Save address in table
305E: CD562A  	        call    FPADD           ; Add coefficient to FPREG
3061: E1      	        pop     HL              ; Restore address in table
3062: C34D30  	        jp      SUMLP           ; More coefficients
              	
3065: CDED2C  	RND:    call    TSTSGN          ; Test sign of FPREG
3068: 217A80  	        ld      HL,SEED+2       ; Random number seed
306B: FAC630  	        jp      M,RESEED        ; Negative - Re-seed
306E: 219B80  	        ld      HL,LSTRND       ; Last random number
3071: CD2B2D  	        call    PHLTFP          ; Move last RND to FPREG
3074: 217A80  	        ld      HL,SEED+2       ; Random number seed
3077: C8      	        ret     Z               ; Return if RND(0)
3078: 86      	        add     A,(HL)          ; Add (SEED)+2)
3079: E607    	        and     %00000111       ; 0 to 7
307B: 0600    	        ld      B,$00
307D: 77      	        ld      (HL),A          ; Re-save seed
307E: 23      	        inc     HL              ; Move to coefficient table
307F: 87      	        add     A,A             ; 4 bytes
3080: 87      	        add     A,A             ; per entry
3081: 4F      	        ld      C,A             ; BC = Offset into table
3082: 09      	        add     HL,BC           ; Point to coefficient
3083: CD3C2D  	        call    LOADFP          ; Coefficient to BCDE
3086: CD912B  	        call    FPMULT  ;       ; Multiply FPREG by coefficient
3089: 3A7980  	        ld      A,(SEED+1)      ; Get (SEED+1)
308C: 3C      	        inc     A               ; Add 1
308D: E603    	        and     %00000011       ; 0 to 3
308F: 0600    	        ld      B,$00
3091: FE01    	        cp      $01             ; Is it zero?
3093: 88      	        adc     A,B             ; Yes - Make it 1
3094: 327980  	        ld      (SEED+1),A      ; Re-save seed
3097: 21CA30  	        ld      HL,RNDTAB-4     ; Addition table
309A: 87      	        add     A,A             ; 4 bytes
309B: 87      	        add     A,A             ; per entry
309C: 4F      	        ld      C,A             ; BC = Offset into table
309D: 09      	        add     HL,BC           ; Point to value
309E: CD472A  	        call    ADDPHL          ; Add value to FPREG
30A1: CD392D  	RND1:   call    BCDEFP          ; Move FPREG to BCDE
30A4: 7B      	        ld      A,E             ; Get LSB
30A5: 59      	        ld      E,C             ; LSB = MSB
30A6: EE4F    	        xor     %01001111       ; Fiddle around
30A8: 4F      	        ld      C,A             ; New MSB
30A9: 3680    	        ld      (HL),$80        ; Set exponent
30AB: 2B      	        dec     HL              ; Point to MSB
30AC: 46      	        ld      B,(HL)          ; Get MSB
30AD: 3680    	        ld      (HL),$80        ; Make value -0.5
30AF: 217880  	        ld      HL,SEED         ; Random number seed
30B2: 34      	        inc     (HL)            ; Count seed
30B3: 7E      	        ld      A,(HL)          ; Get seed
30B4: D6AB    	        sub     $AB             ; Do it modulo 171
30B6: C2BD30  	        jp      NZ,RND2         ; Non-zero - Ok
30B9: 77      	        ld      (HL),A          ; Zero seed
30BA: 0C      	        inc     C               ; Fillde about
30BB: 15      	        dec     D               ; with the
30BC: 1C      	        inc     E               ; number
30BD: CDA72A  	RND2:   call    BNORM           ; Normalise number
30C0: 219B80  	        ld      HL,LSTRND       ; Save random number
30C3: C3452D  	        jp      FPTHL           ; Move FPREG to last and return
              	
30C6: 77      	RESEED: ld      (HL),A          ; Re-seed random numbers
30C7: 2B      	        dec     HL
30C8: 77      	        ld      (HL),A
30C9: 2B      	        dec     HL
30CA: 77      	        ld      (HL),A
30CB: C3A130  	        jp      RND1            ; Return RND seed
              	
30CE: 68B14668	RNDTAB: defb    $68,$B1,$46,$68 ; Table used by RND
30D2: 99E99269	        defb    $99,$E9,$92,$69
30D6: 10D17568	        defb    $10,$D1,$75,$68
              	
30DA: 212431  	COS:    ld      HL,HALFPI       ; Point to PI/2
30DD: CD472A  	        call    ADDPHL          ; Add it to PPREG
30E0: CD1E2D  	SIN:    call    STAKFP          ; Put angle on stack
30E3: 014983  	        ld      BC,$8349        ; BCDE = 2 PI
30E6: 11DB0F  	        ld      DE,$0FDB
30E9: CD2E2D  	        call    FPBCDE          ; Move 2 PI to FPREG
30EC: C1      	        pop     BC              ; Restore angle
30ED: D1      	        pop     DE
30EE: CD432C  	        call    DVBCDE          ; Divide angle by 2 PI
30F1: CD1E2D  	        call    STAKFP          ; Put it on stack
30F4: CDC02D  	        call    INT             ; Get INT of result
30F7: C1      	        pop     BC              ; Restore number
30F8: D1      	        pop     DE
30F9: CD532A  	        call    SUBCDE          ; Make it 0 <= value < 1
30FC: 212831  	        ld      HL,QUARTR       ; Point to 0.25
30FF: CD4D2A  	        call    SUBPHL          ; Subtract value from 0.25
3102: CDED2C  	        call    TSTSGN          ; Test sign of value
3105: 37      	        scf                     ; Flag positive
3106: F21031  	        jp      P,SIN1          ; Positive - Ok
3109: CD442A  	        call    ROUND           ; Add 0.5 to value
310C: CDED2C  	        call    TSTSGN          ; Test sign of value
310F: B7      	        or      A               ; Flag negative
3110: F5      	SIN1:   push    AF              ; Save sign
3111: F4162D  	        call    P,INVSGN        ; Negate value if positive
3114: 212831  	        ld      HL,QUARTR       ; Point to 0.25
3117: CD472A  	        call    ADDPHL          ; Add 0.25 to value
311A: F1      	        pop     AF              ; Restore sign
311B: D4162D  	        call    NC,INVSGN       ; Negative - Make positive
311E: 212C31  	        ld      HL,SINTAB       ; Coefficient table
3121: C33530  	        jp      SUMSER          ; Evaluate sum of series
              	
3124: DB0F4981	HALFPI: defb    $DB,$0F,$49,$81 ; 1.5708 (PI/2)
              	
3128: 0000007F	QUARTR: defb    $00,$00,$00,$7F ; 0.25
              	
312C: 05      	SINTAB: defb    $05             ; Table used by SIN
312D: BAD71E86	        defb    $BA,$D7,$1E,$86 ; 39.711
3131: 64269987	        defb    $64,$26,$99,$87 ;-76.575
3135: 58342387	        defb    $58,$34,$23,$87 ; 81.602
3139: E05DA586	        defb    $E0,$5D,$A5,$86 ;-41.342
313D: DA0F4983	        defb    $DA,$0F,$49,$83 ;  6.2832
              	
3141: CD1E2D  	TAN:    call    STAKFP          ; Put angle on stack
3144: CDE030  	        call    SIN             ; Get SIN of angle
3147: C1      	        pop     BC              ; Restore angle
3148: E1      	        pop     HL
3149: CD1E2D  	        call    STAKFP          ; Save SIN of angle
314C: EB      	        ex      DE,HL           ; BCDE = Angle
314D: CD2E2D  	        call    FPBCDE          ; Angle to FPREG
3150: CDDA30  	        call    COS             ; Get COS of angle
3153: C3412C  	        jp      DIV             ; TAN = SIN / COS
              	
3156: CDED2C  	ATN:    call    TSTSGN          ; Test sign of value
3159: FC812F  	        call    M,NEGAFT        ; Negate result after if -ve
315C: FC162D  	        call    M,INVSGN        ; Negate value if -ve
315F: 3ACC81  	        ld      A,(FPEXP)       ; Get exponent
3162: FE81    	        cp      81H             ; Number less than 1?
3164: DA7331  	        jp      C,ATN1          ; Yes - Get arc tangnt
3167: 010081  	        ld      BC,$8100        ; BCDE = 1
316A: 51      	        ld      D,C
316B: 59      	        ld      E,C
316C: CD432C  	        call    DVBCDE          ; Get reciprocal of number
316F: 214D2A  	        ld      HL,SUBPHL       ; Sub angle from PI/2
3172: E5      	        push    HL              ; Save for angle > 1
3173: 217D31  	ATN1:   ld      HL,ATNTAB       ; Coefficient table
3176: CD3530  	        call    SUMSER          ; Evaluate sum of series
3179: 212431  	        ld      HL,HALFPI       ; PI/2 - angle in case > 1
317C: C9      	        ret                     ; Number > 1 - Sub from PI/2
              	
317D: 09      	ATNTAB: defb    $09             ; Table used by ATN
317E: 4AD73B78	        defb    $4A,$D7,$3B,$78 ; 1/17
3182: 026E847B	        defb    $02,$6E,$84,$7B ;-1/15
3186: FEC12F7C	        defb    $FE,$C1,$2F,$7C ; 1/13
318A: 74319A7D	        defb    $74,$31,$9A,$7D ;-1/11
318E: 843D5A7D	        defb    $84,$3D,$5A,$7D ; 1/9
3192: C87F917E	        defb    $C8,$7F,$91,$7E ;-1/7
3196: E4BB4C7E	        defb    $E4,$BB,$4C,$7E ; 1/5
319A: 6CAAAA7F	        defb    $6C,$AA,$AA,$7F ;-1/3
319E: 00000081	        defb    $00,$00,$00,$81 ; 1/1
              	
              	
31A2: C9      	ARET:   ret                     ; A RETurn instruction
              	
31A3: D7      	GETINP: rst     $10             ; input a character
31A4: C9      	        ret
              	
31A5: E5      	CLS:    push    HL
31A6: D5      	        push    DE
31A7: 3AE081  	        ld      A,(SCR_MODE)    ; check screen mode
31AA: FE02    	        cp      $02             ; G2 mode?
31AC: CC6705  	        call    Z,EMPTYVIDBUF   ; yes, reset video buffer
31AF: D1      	        pop     DE
31B0: E1      	        pop     HL
31B1: 3E0C    	        ld      A,CS            ; ASCII Clear screen
31B3: CD8518  	        call    SND2VID         ; send to screen
31B6: C39E3D  	        jp      MONOUT          ; Output character
              	
31B9: CD6527  	WIDTH:  call    GETINT          ; Get integer 0-255
31BC: 7B      	        ld      A,E             ; Width to A
31BD: 32A280  	        ld      (LWIDTH),A      ; Set width
31C0: C9      	        ret
              	
              	
31C1: CD201B  	DEEK:   call    DEINT           ; Get integer -32768 to 32767
31C4: D5      	        push    DE              ; Save number
31C5: E1      	        pop     HL              ; Number to HL
31C6: 46      	RECWRD: ld      B,(HL)          ; Get LSB of contents
31C7: 23      	        inc     HL
31C8: 7E      	        ld      A,(HL)          ; Get MSB of contents
31C9: C3C922  	        jp      ABPASS          ; Return integer AB
              	
31CC: CDDF1E  	DOKE:   call    GETNUM          ; Get a number
31CF: CD201B  	        call    DEINT           ; Get integer -32768 to 32767
31D2: D5      	        push    DE              ; Save address
31D3: CD4718  	        call    CHKSYN          ; Make sure ',' follows
31D6: 2C      	        defb    ','
31D7: CDDF1E  	        call    GETNUM          ; Get a number
31DA: CD201B  	        call    DEINT           ; Get integer -32768 to 32767
31DD: E3      	        ex      (SP),HL         ; Save value,get address
31DE: 73      	        ld      (HL),E          ; Save LSB of value
31DF: 23      	        inc     HL
31E0: 72      	        ld      (HL),D          ; Save MSB of value
31E1: E1      	        pop     HL              ; Restore code string address
31E2: C9      	        ret
              	
              	; stop the execution of code for a certain bit of time. The pause
              	; is between $0000 and $FFFF 100ths of second (0~655.5 secs)
31E3: CDDF1E  	PAUSE:  call    GETNUM          ; Get a number
31E6: CD201B  	        call    DEINT           ; Get integer -32768 to 32767
31E9: 7A      	        ld      A,D             ; load D into A
31EA: B3      	        or      E               ; are D & E equal to $00?
31EB: C8      	        ret     Z               ; if yes, then return
31EC: C5      	DIR_PAU:push    BC              ; store BC
31ED: 3ACE81  	        ld      A,(TMRCNT)      ; Load current value of system timer
31F0: 47      	        ld      B,A             ; move it into B
31F1: CD951A  	RPTPS:  call    TSTBRK          ; Test for break key
31F4: 3ACE81  	        ld      A,(TMRCNT)      ; Load current value of system timer
31F7: B8      	        cp      B               ; is it the same value?
31F8: 28F7    	        jr      Z,RPTPS         ; yes, so read again
31FA: 47      	        ld      B,A             ; no, so store the new value
31FB: 1B      	        dec     DE              ; decrement interval
31FC: 7A      	        ld      A,D             ; load D into A
31FD: B3      	        or      E               ; check if DE is equal to 0 (if D & e are $00 then result is 0)
31FE: 20F1    	        jr      NZ,RPTPS        ; no, repeat
3200: C1      	        pop     BC              ; yes, recover BC and continue
3201: C9      	        ret
              	
              	; change the screen mode. Usage: SCREEN X[,Y][,Z]
              	; where X is: 0=text mode (40x24),
              	; 1=graphic mode 1 (32x24 chars); 2=graphic mode 2 (256x192 pixels);
              	; 3=multicolor mode (64x48 pixels); 4=extended graphic mode 2 (32x24 chars mixed between G1 and G2)
              	; Y is: 0=8x8 sprites, 1=16x16 sprites
              	; Z is: 0=no sprite magnification; 1=sprite magnification x2 (8x8=>16x16, and 16x16=32x32)
              	; (the latters are accepted only in graphic modes G1, G2, G3, and G4)
3202: AF      	SCREEN: xor     A
3203: 32F181  	        ld      (TMPBFR2),A     ; sprite size & magnif. byte set to 0
3206: CD6527  	        call    GETINT          ; Get integer 0-255
3209: FE05    	        cp      $05             ; is it a valid mode (0~4)?
320B: D2351B  	        jp      NC,FCERR        ; No - Illegal function call Error
320E: 32EF81  	        ld      (TMPBFR1),A     ; store graphic mode
3211: A7      	        and     A               ; is it 0 (text mode)?
3212: CA2E32  	        jp      Z,SCVDP         ; yes, ignore other arguments and set mode immediately
3215: CD6D32  	SETVDP: call    CHKSCAR         ; no, check if sprite size follows
3218: DA2032  	        jp      C,CKMAGN        ; no (set to 0 or missing), so jump over
321B: 3E02    	        ld      A,$02           ; no, so set sprite size
321D: 32F181  	        ld      (TMPBFR2),A     ; ...to 16x16
3220: CD6D32  	CKMAGN: call    CHKSCAR         ; check if sprite magnification follows
3223: DA2E32  	        jp      C,SCVDP         ; no (set to 0 or missing), so jump over
3226: 3AF181  	        ld      A,(TMPBFR2)     ; yes, so retrieve sprite attributes...
3229: F601    	        or      $01             ; ...set sprite magnification to 2x...
322B: 32F181  	        ld      (TMPBFR2),A     ; ...and save flags again
322E: F3      	SCVDP:  di                      ; disable INTs
322F: D5      	        push    DE              ; store DE
3230: E5      	        push    HL              ; store HL
3231: 3AEF81  	        ld      A,(TMPBFR1)     ; recover graphic mode
3234: 5F      	        ld      E,A             ; and store it into E
3235: 3AF181  	        ld      A,(TMPBFR2)     ; recover sprite flags
3238: 57      	        ld      D,A             ; and store them into D
3239: D5      	        push    DE              ; store D & E
323A: CD7E03  	        call    initVDP         ; initialize VDP with mode pointed by E
323D: D1      	        pop     DE              ; retrieve D & E
323E: 7B      	        ld      A,E             ; move graphic mode into A
323F: 87      	        add     A,A
3240: 87      	        add     A,A
3241: 87      	        add     A,A             ; multiply A times 8 to get offset of graphic mode
3242: 5F      	        ld      E,A             ; and pass it into E
3243: D5      	        push    DE              ; store sprite flags in E
3244: 1600    	        ld      D,$00           ; reset D
3246: 215A0A  	        ld      HL,VDPMODESET+1 ; load address of VDP settings for reg#1
3249: 19      	        add     HL,DE           ; load correct reg#1 setting
324A: D1      	        pop     DE              ; retrieve sprite flags from E
324B: 7E      	        ld      A,(HL)          ; load reg#1 setting
324C: E6FC    	        and     %11111100       ; reset size & magn. bits
324E: B2      	        or      D               ; set size & magn. bits
324F: 5F      	        ld      E,A             ; value into E
3250: 3E01    	        ld      A,$01           ; reg #1
3252: CD4306  	        call    WRITE_VREG      ; send setting to reg #1
3255: 2AAF80  	        ld      HL,(LINEAT)     ; Get current line number
3258: 23      	        inc     HL              ; -1 means direct statement
3259: 7C      	        ld      A,H
325A: B5      	        or      L
325B: CC5A08  	        call    Z,CURSOR_ON     ; enable cursor if not in program mode
325E: FB      	        ei                      ; re-enable interrupts
325F: E1      	        pop     HL              ; restore HL
3260: D1      	        pop     DE              ; restore DE
3261: 3ADF81  	        ld      A,(SCR_SIZE_H)  ; check the screen mode by looking at the screen height
3264: FE30    	        cp      $30             ; is it 48 chars or 192 pixels (MC and G2 modes)?
3266: D0      	        ret     NC              ; yes, so exit (in graphics 2 and multicolor no print-on-video)
3267: 3E01    	        ld      A,$01           ; no (we are in Text, G1 or ExG2), so activate the...
3269: 32EB81  	        ld      (PRNTVIDEO),A   ; ...video buffer...
326C: C9      	        ret                     ; ...and return to caller
              	
              	; check an additional argument for SCREEN
326D: 2B      	CHKSCAR:dec     HL              ; dec 'cos GETCHR INCs
326E: CD6A1A  	        call    GETCHR          ; Get next character
3271: 37      	        scf                     ; set carry flag
3272: C8      	        ret     Z               ; return if nothing follows with Carry=1
3273: CD4718  	        call    CHKSYN          ; Make sure ',' follows
3276: 2C      	        defb    ','
3277: CD6527  	        call    GETINT          ; get value
327A: 1F      	        rra                     ; Carry=bit #0
327B: 3F      	        ccf                     ; invert Carry, so Carry=0 if arg. is 1, and Carry=1 otherwise (arg<>1)
327C: C9      	        ret                     ; return
              	
              	
              	; change the colors of the screen - Syntax is COLOR a,b,c where:
              	; a=foreground color / b=background color / c=border color
              	; a,b,c must be in a range between 1 and 15 (0 is transparent and it's not supported)
327D: CD6527  	COLOR:  call    GETINT          ; get first value
3280: CD2633  	        call    CHKCLR1         ; check if it's in range 1~15
3283: 32EF81  	        ld      (TMPBFR1),A     ; store it
3286: 3AE081  	        ld      A,(SCR_MODE)    ; check screen mode
3289: FE03    	        cp      $03             ; is it multicolor mode?
328B: 200D    	        jr      NZ,CNTCKCL      ; no, continue
328D: 3E0F    	        ld      A,$0F           ; white for...
328F: 32ED81  	        ld      (FRGNDCLR),A    ; ...foreground (even it's not used in MC)
3292: 3AEF81  	        ld      A,(TMPBFR1)     ; yes, so we stop here because in MC mode we just support border color
3295: 32F381  	        ld      (TMPBFR3),A     ; move color into temp buffer 3
3298: 1831    	        jr      CLRMC           ; jump to set color
329A: CD4718  	CNTCKCL:call    CHKSYN          ; Make sure ',' follows
329D: 2C      	        defb    ','
329E: CD6527  	        call    GETINT          ; get second value
32A1: CD2633  	        call    CHKCLR1         ; check if it's in range 1~15
32A4: 32F181  	        ld      (TMPBFR2),A     ; store it
32A7: 3AE081  	        ld      A,(SCR_MODE)    ; check screen mode
32AA: A7      	        and     A               ; is it text mode?
32AB: 281B    	        jr      Z,CLRTXT        ; yes, stop here because in text mode, background and border colors coincide
32AD: CD4718  	        call    CHKSYN          ; Make sure ',' follows
32B0: 2C      	        defb    ','
32B1: CD6527  	        call    GETINT          ; get third value
32B4: CD2633  	        call    CHKCLR1         ; check if it's in range 1~15
32B7: 32F381  	        ld      (TMPBFR3),A     ; store it
32BA: D5      	        push    DE              ; store DE
32BB: 3AE081  	        ld      A,(SCR_MODE)    ; check screen mode
32BE: FE01    	        cp      $01             ; is it G1 mode?
32C0: 2810    	        jr      Z,CLRG1         ; yes, jump over
32C2: FE02    	        cp      $02             ; is it G2 mode?
32C4: 2815    	        jr      Z,CLRG2         ; yes, jump over
32C6: 181C    	        jr      CLREX2          ; last case can only be ExG2
32C8: CD1933  	CLRTXT: call    MIXCLRS         ; mix foreground and background color nibbles in 1 byte
32CB: 32F381  	CLRMC:  ld      (TMPBFR3),A     ; store color settings (for MC mode, we only set border color)
32CE: D5      	        push    DE              ; store DE
32CF: F3      	        di                      ; disable INTs
32D0: 182E    	        jr      SETBRCL         ; set colors and exit
32D2: CD1933  	CLRG1:  call    MIXCLRS         ; mix foreground and background color nibbles in 1 byte
32D5: 1601    	        ld      D,$01           ; repeat 1 time
32D7: 0620    	        ld      B,$20           ; 32 bytes of colors
32D9: 1810    	        jr      LOADCLR         ; load colors
32DB: CD1933  	CLRG2:  call    MIXCLRS         ; mix foreground and background color nibbles in 1 byte
32DE: 1618    	        ld      D,$18           ; 18 pages of...
32E0: 0600    	        ld      B,$00           ; ...256 bytes each
32E2: 1807    	        jr      LOADCLR         ; load colors
32E4: CD1933  	CLREX2: call    MIXCLRS         ; mix foreground and background color nibbles in 1 byte
32E7: 1608    	        ld      D,$08           ; 8 pages of...
32E9: 0600    	        ld      B,$00           ; ...256 bytes each
32EB: E5      	LOADCLR:push    HL              ; store HL
32EC: 210020  	        ld      HL,$2000        ; color table start: $2000
32EF: F3      	        di                      ; disable INTs
32F0: CDF905  	        call    SETVDPADRS
32F3: 0E30    	        ld      C,VDP_DAT       ; VDP data mode
32F5: ED79    	RPTLDCL:out     (C),A           ; after first byte, the VDP autoincrements VRAM pointer
32F7: 00      	        nop
32F8: 00      	        nop
32F9: 10FA    	        djnz    RPTLDCL         ; repeat for 256 bytes (1 page)
32FB: 15      	        dec     D               ; did we fill up all the pages?
32FC: 20F7    	        jr      NZ,RPTLDCL      ; no, repeat
32FE: FB      	        ei
32FF: E1      	        pop     HL              ; retrieve HL
3300: 3AEF81  	SETBRCL:ld      A,(TMPBFR1)     ; retrieve foreground color
3303: 32ED81  	        ld      (FRGNDCLR),A    ; store it
3306: 3AF181  	        ld      A,(TMPBFR2)     ; retrieve background color
3309: 32EE81  	        ld      (BKGNDCLR),A    ; store it
330C: 3AF381  	        ld      A,(TMPBFR3)     ; recover border color
330F: 5F      	        ld      E,A             ; move it into E
3310: 3E07    	        ld      A,$07           ; set VDP register 7
3312: F3      	        di
3313: CD4306  	        call    WRITE_VREG      ; send value to VDP: set border color
3316: FB      	        ei                      ; re-enable INTs
3317: D1      	        pop     DE              ; retrieve DE
3318: C9      	        ret                     ; return to caller
              	
              	
              	; mix 2 color nibbles in 1 byte
3319: 3AF181  	MIXCLRS:ld      A,(TMPBFR2)     ; retrieve background color
331C: 47      	        ld      B,A             ; move it into B
331D: 3AEF81  	        ld      A,(TMPBFR1)     ; retrieve foreground color
3320: 87      	        add     A,A             ; move foreground color into the high nibble of A
3321: 87      	        add     A,A
3322: 87      	        add     A,A
3323: 87      	        add     A,A
3324: B0      	        or      B               ; put background color into the low nibble of A
3325: C9      	        ret                     ; return to caller
              	
              	
              	; check if the color is not 0 and into the range 1~15
3326: A7      	CHKCLR1:and     A               ; is it 0?
3327: CA6515  	        jp      Z,SNERR         ; yes, raise a SN error
332A: FE10    	CHKCLR0:cp      $10             ; is it in range 0~15?
332C: D26515  	        jp      NC,SNERR        ; no, raise a SN error
332F: C9      	        ret                     ; param is OK, can return
              	
              	
              	; check if in graphics 2 mode
3330: 3AE081  	CHKG2M: ld      A,(SCR_MODE)    ; check screen mode
3333: FE02    	        cp      $02             ; actually, we can paint only in G2
3335: C24539  	        jp      NZ,GMERR        ; no G2, print a No Graphics Mode Error
3338: C9      	        ret                     ; return to caller
              	
              	
              	; print a text in screen 2
              	; GPRINT text,x,y[,fc[,bc]]
              	; where "text" is an expression that can be converted into a sequence of ASCII chars,
              	; x & y are the coordinates (0<=x<=32, 0<=y<=23), fc & bc are foreground and background
              	; colors (1~15), resp.
              	; (portions of code are from nippur72)
81F3:         	GX      equ     TMPBFR3
81F5:         	GY      equ     TMPBFR4
81F1:         	TMPCLR  equ     TMPBFR2
81EF:         	MIXCOL  equ     TMPBFR1
81F7:         	TMPADR  equ     VIDEOBUFF
81F9:         	CHRPNT  equ     VIDEOBUFF+$02
81FB:         	NUMCHR  equ     VIDEOBUFF+$04
81FD:         	TMPHL   equ     VIDEOBUFF+$06
3339: CD3033  	GPRINT: call    CHKG2M          ; check if in graphic mode 2
333C: 2B      	        dec     HL              ; dec 'cos GETCHR INCs
333D: CD6A1A  	        call    GETCHR          ; check if something follows
3340: CA6515  	        jp      Z,SNERR         ; if nothing else, raise a syntax error
3343: 22F781  	        ld      (VIDEOBUFF),HL  ; save current code string pointer
3346: CDF11E  	        call    EVAL            ; Evaluate expression
3349: CDE31E  	        call    TSTSTR          ; Make sure it's a string
334C: 22FD81  	        ld      (TMPHL),HL      ; store code string pointer
334F: CD2A25  	        call    GSTRCU          ; Current string to pool
3352: CD3C2D  	        call    LOADFP          ; Move string block to BCDE (BC=pointer, E=length)
3355: ED43F981	        ld      (CHRPNT),BC     ; store string pointer
3359: ED53FB81	        ld      (NUMCHR),DE     ; store string lenght
335D: 2AFD81  	        ld      HL,(TMPHL)      ; store code string pointer
3360: CD4718  	        call    CHKSYN          ; Make sure ',' follows
3363: 2C      	        defb    ','
3364: CD6527  	        call    GETINT          ; get X coord.
3367: FE20    	        cp      $20             ; is it in rage 0~31?
3369: D2351B  	        jp      NC,FCERR        ; Illegal function call error
336C: 32F381  	        ld      (GX),A          ; store into temp. buffer
336F: CD4718  	        call    CHKSYN          ; Make sure ',' follows
3372: 2C      	        defb    ','
3373: CD6527  	        call    GETINT          ; get Y coord.
3376: FE18    	        cp      $18             ; is it in range 0~23?
3378: D2351B  	        jp      NC,FCERR        ; Illegal function call error
337B: 32F581  	        ld      (GY),A          ; store into temp. buffer
337E: 11F181  	        ld      DE,TMPCLR
3381: 3AEE81  	        ld      A,(BKGNDCLR)    ; load background color
3384: 12      	        ld      (DE),A          ; store into temp buff
3385: 3AED81  	        ld      A,(FRGNDCLR)    ; load foreground color
3388: 1B      	        dec     DE
3389: 1B      	        dec     DE
338A: 12      	        ld      (DE),A          ; store into temp buff
338B: CD1734  	        call    CKCOL           ; check color
338E: CA9633  	        jp      Z,CNTGPT2       ; if anything follows, jump over
3391: 13      	        inc     DE
3392: 13      	        inc     DE
3393: CD1734  	        call    CKCOL           ; check background color
3396: CD1933  	CNTGPT2:call    MIXCLRS         ; mix foreground & background colors
3399: 32EF81  	        ld      (MIXCOL),A      ; store mixed colors
339C: E5      	        push    HL              ; store code string address
339D: ED4BF981	        ld      BC,(CHRPNT)     ; retrieve string pointer
33A1: ED5BFB81	        ld      DE,(NUMCHR)     ; retrieve string lenght
33A5: 1C      	        inc     E               ; Length + 1
33A6: CDAB33  	        call    GPNT            ; print on G2
33A9: E1      	        pop     HL              ; recover HL
33AA: C9      	        ret                     ; return to caller
33AB: D5      	GPNT:   push    DE              ; store string lenght (E)
              	        ; calculate VRAM address of first char
33AC: 3AF381  	        LD      A,(GX)          ; load X
33AF: 6F      	        ld      L,A             ;
33B0: 2600    	        ld      H,0             ; HL = X
33B2: 29      	        add     HL,HL           ;
33B3: 29      	        add     HL,HL           ;
33B4: 29      	        add     HL,HL           ; X=X*8
33B5: 3AF581  	        ld      A,(GY)          ; load Y
33B8: 57      	        ld      D,A             ; move it into D
33B9: 1E00    	        ld      E,0             ; DE =Y*256
33BB: 19      	        add     HL,DE           ; address = X*8 + Y*256
33BC: 22F781  	        ld      (TMPADR),HL     ; store VRAM address of first VRAM cell
33BF: D1      	        pop     DE              ; retrieve # of chars to be printed yet (E)
33C0: 1D      	RPGPNT: dec     E               ; Count characters
33C1: C8      	        ret     Z               ; End of string - return
33C2: D5      	        push    DE              ; store chars counter
              	        ; calculate dest address in color vram
33C3: 2AF781  	        ld      HL,(TMPADR)     ; recover VRAM address 
33C6: 110020  	        ld      DE,$2000        ; color map address
33C9: 19      	        add     HL,DE           ; HL = $2000 + XY address
33CA: F3      	        di                      ; disable INTs
              	        ; send color settings
33CB: CDF905  	GPNTCOL:call    SETVDPADRS      ; set VRAM address for color cell
33CE: 3AEF81  	        ld      A,(MIXCOL)      ; load color settings
33D1: 0608    	        ld      B,$08           ; repeat for 8 rows
33D3: 0E30    	        ld      C,VDP_DAT       ; VDP data mode
33D5: ED79    	GPNTCO1:out     (C),A           ; send data (VRAM pointer auto-increments)
33D7: 00      	        nop                     ; wait...
33D8: 00      	        nop                     ; ...a...
33D9: 00      	        nop                     ; ...while
33DA: 10F9    	        djnz    GPNTCO1         ; repeat for 8 cells
              	        ; calculate source address
33DC: 2AF981  	        ld      HL,(CHRPNT)     ; load char pointer
33DF: 7E      	        ld      A,(HL)          ; get char
33E0: 23      	        inc     HL              ; increment char pointer
33E1: 22F981  	        ld      (CHRPNT),HL     ; store char pointer
33E4: 6F      	        ld      L,A             ;
33E5: 2600    	        ld      H,0             ; char into HL
33E7: 29      	        add     HL,HL           ;
33E8: 29      	        add     HL,HL           ;
33E9: 29      	        add     HL,HL           ; get offset of char into ROM (charcode * 8)
33EA: 111346  	        ld      DE,CHRST88      ; DE = start of 8x8 fonts in ROM
33ED: 19      	        add     HL,DE           ; HL = start of characters in ROM
33EE: EB      	        ex      DE,HL           ; store address into DE
33EF: 2AF781  	GPCPCHR:ld      HL,(TMPADR)     ; load VRAM address
33F2: CDF905  	        call    SETVDPADRS      ; send it to VDP
33F5: EB      	        ex      DE,HL           ; restore address into HL
33F6: 0608    	        ld      B,$08           ; repeat for 8 rows
33F8: 0E30    	        ld      C,VDP_DAT       ; VDP data mode
33FA: EDA3    	GPCPCH1:outi                    ; load a byte from ROM and send to VRAM
33FC: 00      	        nop                     ; wait...
33FD: 00      	        nop                     ; ...a...
33FE: 00      	        nop                     ; ...while
33FF: 20F9    	        jr      NZ,GPCPCH1      ; repeat for 8 chars
3401: FB      	        ei                      ; re-enable INTs
3402: 110800  	        ld      DE,$0008        ; 8 bytes to go to the next video ell
3405: 2AF781  	        ld      HL,(TMPADR)     ; load VRAM address
3408: 19      	        add     HL,DE           ; get address of next VRAM cell
3409: 22F781  	        ld      (TMPADR),HL     ; store new VRAM address
340C: 110018  	        ld      DE,$1800        ; forbidden address
340F: CDC53D  	        call    CMP16           ; check if the printing has gone out of the screen
3412: D1      	        pop     DE              ; retrieve number of chars to be printed
3413: D0      	        ret     NC              ; if HL>=$1800 then leave
3414: C3C033  	        jp      RPGPNT          ; otherwise, check if more chars to output
              	        
3417: 2B      	CKCOL:  dec     HL              ; dec 'cos GETCHR INCs
3418: CD6A1A  	        call    GETCHR          ; Get next character
341B: C8      	        ret     Z               ; return if nothing follows
341C: CD4718  	        call    CHKSYN          ; Make sure ',' follows
341F: 2C      	        defb    ','
3420: D5      	        push    DE              ; store DE
3421: CD6527  	        call    GETINT          ; get value
3424: CD2633  	        call    CHKCLR1         ; check if color is in range 1~15
3427: D1      	        pop     DE              ; retrieve DE
3428: 12      	        ld      (DE),A          ; store color into temp buffer
3429: C9      	        ret                     ; return to caller
              	        
              	
              	; paint X,Y[,C]: in graphics mode, fills an area starting
              	; at point X,Y, using default color or, if used, with
              	; color set by C
              	; TMPBFR1       X
              	; TMPBFR2       Y
              	; TMPBFR3       COLOR
81F7:         	PNT     equ     VIDEOBUFF
81F9:         	SPA     equ     VIDEOBUFF+$02
81FA:         	SPB     equ     VIDEOBUFF+$03
81FB:         	ORGSP   equ     VIDEOBUFF+$04
342A: CD3033  	PAINT:  call    CHKG2M          ; check if in graphic mode 2
342D: CD6527  	        call    GETINT          ; get X
3430: 32EF81  	        ld      (TMPBFR1),A     ; store X
3433: CD4718  	        call    CHKSYN          ; Make sure ',' follows
3436: 2C      	        defb    ','
3437: CD6527  	        call    GETINT          ; get Y coords,
343A: FEC0    	        cp      $C0             ; check if Y is in range 0~191
343C: D2351B  	        jp      NC,FCERR        ; no, raise an FC error
343F: 32F181  	        ld      (TMPBFR2),A     ; store Y
3442: CD2C39  	        call    CLRPRM          ; check if color has been passed
3445: 3AF381  	        ld      A,(TMPBFR3)     ; load color
3448: A7      	        and     A               ; check if 0
3449: CA351B  	        jp      Z,FCERR         ; yes, raise an error
344C: E5      	        push    HL              ; store HL
344D: C5      	        push    BC              ; store BC
344E: D5      	        push    DE              ; store DE
              	        ; start algorithm
344F: CD7135  	        call    PNTRTN          ; check if pixel is already set
3452: C21735  	        jp      NZ,EXITPA2      ; if yes, then leave PAINT
3455: ED73FB81	        ld      (ORGSP),SP      ; no, store current Stack Pointer
3459: 210100  	        ld      HL,$0001        ; HL=1
345C: 22F781  	        ld      (PNT),HL        ; set PNT
345F: 3AEF81  	        ld      A,(TMPBFR1)     ; load starting X...
3462: 47      	        ld      B,A             ; ...into B
3463: 3AF181  	        ld      A,(TMPBFR2)     ; load starting Y...
3466: 4F      	        ld      C,A             ; ...into C
3467: C5      	        push    BC              ; store starting X,Y into stack
              	        ; main loop
              	;130 IF PT<0 THEN END
              	;140 X=ST(PT,0):Y=ST(PT,1):PT=PT-1
              	;150 X1=X
3468: 2AF781  	NXTLOOP:ld      HL,(PNT)        ; retrieve PNT
346B: 7C      	        ld      A,H             ; check if PNT=0
346C: B5      	        or      L
346D: CA1335  	        jp      Z,EXITPAI       ; yes, no more points to process - exit
3470: 2B      	        dec     HL              ; no, so decrement PNT...
3471: 22F781  	        ld      (PNT),HL        ; ...and store it
3474: C1      	        pop     BC              ; retrieve pixel coordinates X,Y into BC
              	;170 IF X1>=0 THEN IF POINT(X1,Y)=0 THEN X1=X1-1:GOTO 170
3475: CD1B35  	PAINT0: call    CHECKPA         ; check if pixel is set/reset
3478: 2007    	        jr      NZ,PAINT11      ; pixel is set, so jump over
347A: 78      	        ld      A,B             ; pixel is reset, check if X1=0
347B: A7      	        and     A               ; (reached the limit of the screen)
347C: 2804    	        jr      Z,PAINT1        ; yes, jump over
347E: 05      	        dec     B               ; no, decrement X1...
347F: 18F4    	        jr      PAINT0          ; ...and repeat
              	;180 X1=X1+1 ??
              	;190 SA=0:SB=0
3481: 04      	PAINT11:inc     B               ; if found a pixel on, the re-increment X1
3482: AF      	PAINT1: xor     A               ; reset A
3483: 32F981  	        ld      (SPA),A         ; set SA=0
3486: 32FA81  	        ld      (SPB),A         ; set SB=0
              	;200 IF POINT(X1,Y)=0 THEN 210
              	;205 GOTO 130
3489: CD1B35  	MNPAINT:call    CHECKPA         ; check if pixel is set/reset
348C: 20DA    	        jr      NZ,NXTLOOP      ; it's set, so goto next loop
              	;210 PLOT X1,Y
348E: 78      	        ld      A,B             ; copy X1
348F: 32EF81  	        ld      (TMPBFR1),A     ; into buffer
3492: 79      	        ld      A,C             ; copy Y
3493: 32F181  	        ld      (TMPBFR2),A     ; into buffer
3496: CD9735  	        call    CNTPLOT         ; plot pixel X1,Y
              	;220 IF SA=0 AND Y>0 THEN IF POINT(X1,Y-1)=0 THEN A=X1:B=Y-1:GOSUB 300:SA=1:GOTO 240
3499: 3AF981  	        ld      A,(SPA)
349C: A7      	        and     A               ; SA=0?
349D: 201D    	        jr      NZ,PAINT2       ; no, jump over
349F: 79      	        ld      A,C             ; load Y
34A0: FE01    	        cp      $01             ; Y>0?
34A2: 3818    	        jr      C,PAINT2        ; no, jump over
34A4: 3D      	        dec     A               ; yes, Y=Y-1
34A5: CD1C35  	        call    CHECKPY         ; check pixel X1,Y-1
34A8: 2012    	        jr      NZ,PAINT2       ; it's set, so jump over
34AA: 0D      	        dec     C               ; Y=Y-1
34AB: C5      	        push    BC              ; insert pixel(X1,Y-1) into stack
34AC: 0C      	        inc     C               ; retrieve original Y
34AD: 2AF781  	        ld      HL,(PNT)        ; load PNT
34B0: 23      	        inc     HL              ; increment PNT
34B1: 22F781  	        ld      (PNT),HL        ; store new PNT
34B4: 3E01    	        ld      A,$01           ; set SA=1...
34B6: 32F981  	        ld      (SPA),A         ; ...into memory
34B9: C3D234  	        jp      PAINT3          ; jump over
              	;230 IF SA=1 AND Y>0 THEN IF POINT(X1,Y-1)<>0 THEN SA=0
34BC: 3AF981  	PAINT2: ld      A,(SPA)
34BF: 1F      	        rra                     ; check if SA=1
34C0: 3010    	        jr      NC,PAINT3       ; no, jump over
34C2: 79      	        ld      A,C             ; load Y
34C3: FE01    	        cp      $01             ; Y>0?
34C5: 380B    	        jr      C,PAINT3        ; no, jump over
34C7: 3D      	        dec     A               ; Y=Y-1
34C8: CD1C35  	        call    CHECKPY         ; check pixel X1,Y-1
34CB: CAD234  	        jp      Z,PAINT3        ; if pixel is off, jump over
34CE: AF      	        xor     A               ; pixel is on, so...
34CF: 32F981  	        ld      (SPA),A         ; ...set SA=0
              	;240 IF SB=0 AND Y<191 THEN IF POINT(X1,Y+1)=0 THEN A=X1:B=Y+1:GOSUB 300:SB=1:GOTO 260
34D2: 3AFA81  	PAINT3: ld      A,(SPB)         ; check if
34D5: A7      	        and     A               ; B=0
34D6: 201D    	        jr      NZ,PAINT4       ; no, jump over
34D8: 79      	        ld      A,C             ; load Y
34D9: FEBF    	        cp      $BF             ; Y<191?
34DB: 3018    	        jr      NC,PAINT4       ; no, jump over
34DD: 3C      	        inc     A               ; Y=Y+1
34DE: CD1C35  	        call    CHECKPY         ; check pixel X1,Y+1
34E1: 2012    	        jr      NZ,PAINT4       ; pixel is on, so jump over
34E3: 0C      	        inc     C               ; Y=Y+1
34E4: C5      	        push    BC              ; insert pixel(X1,Y+1) into stack
34E5: 0D      	        dec     C               ; retrieve original Y
34E6: 2AF781  	        ld      HL,(PNT)        ; PNT
34E9: 23      	        inc     HL              ; PNT=PNT+1
34EA: 22F781  	        ld      (PNT),HL        ; store PNT
34ED: 3E01    	        ld      A,$01           ; SB=1
34EF: 32FA81  	        ld      (SPB),A         ; set SB
34F2: C30C35  	        jp      PAINT5          ; jump over
              	;250 IF SB=1 AND Y<191 THEN IF POINT(X1,Y+1)<>0 THEN SB=0
34F5: 3AFA81  	PAINT4: ld      A,(SPB)         ; load SB
34F8: 1F      	        rra                     ; check if SB=1
34F9: D20C35  	        jp      NC,PAINT5       ; no, jump over
34FC: 79      	        ld      A,C             ; load Y
34FD: FEBF    	        cp      $BF             ; Y<191?
34FF: 300B    	        jr      NC,PAINT5       ; no, jump over
3501: 3C      	        inc     A               ; Y=Y+1
3502: CD1C35  	        call    CHECKPY         ; check pixel X1,Y+1
3505: CA0C35  	        jp      Z,PAINT5        ; if pixel is off, jump over
3508: AF      	        xor     A               ; pixel is on, so...
3509: 32FA81  	        ld      (SPB),A         ; ...set SB=0
              	;260 X1=X1+1
              	;270 GOTO 200
350C: 04      	PAINT5: inc     B               ; X1=X1+1
350D: CA6834  	        jp      Z,NXTLOOP       ; if X1>255 (X1=0) then goto next loop
3510: C38934  	        jp      MNPAINT         ; otherwise, repeat for next X
3513: ED7BFB81	EXITPAI:ld      SP,(ORGSP)      ; retrieve original SP pointer
3517: D1      	EXITPA2:pop     DE              ; retrieve DE
3518: C1      	        pop     BC              ; retrieve BC
3519: E1      	        pop     HL              ; retrieve HL
351A: C9      	        ret                     ; return to caller
351B: 79      	CHECKPA:ld      A,C             ; copy Y into A
351C: 32F181  	CHECKPY:ld      (TMPBFR2),A     ; store Y
351F: 78      	        ld      A,B             ; copy X1 into A
3520: 32EF81  	        ld      (TMPBFR1),A     ; store X1
3523: C5      	        push    BC              ; save X1,Y
3524: CD7135  	        call    PNTRTN          ; check if pixel is set/reset
3527: C1      	        pop     BC              ; retrieve X1,Y
3528: C9      	        ret                     ; return to caller
              	
              	
              	; POINT(x,y): return if a pixel is set (returns color) or if it's reset (0)
3529: CD3033  	POINT:  call    CHKG2M          ; check if in graphic mode 2
352C: CD4718  	        call    CHKSYN          ; make sure "(" follows
352F: 28      	        defb    '('
3530: CD6527  	        call    GETINT          ; get X coords.
3533: 32EF81  	        ld      (TMPBFR1),A     ; store it into a temp buffer
3536: CD4718  	        call    CHKSYN          ; Make sure ',' follows
3539: 2C      	        defb    ','
353A: CD6527  	        call    GETINT          ; get Y coords,
353D: FEC0    	        cp      $C0             ; check if Y is in range 0~191
353F: D2351B  	        jp      NC,FCERR        ; no, raise an FC error
3542: 32F181  	        ld      (TMPBFR2),A     ; store into a temp buffer
3545: CD4718  	        call    CHKSYN          ; make sure ")" follows
3548: 29      	        defb    ')'
3549: E5      	        push    HL              ; store current string address - the point after the ")" - ...
354A: FDE1    	        pop     IY              ; ...into IY
354C: CD7135  	        call    PNTRTN          ; check if pixel is set or reset
354F: 200C    	        jr      NZ,CTPOINT      ; it's ON, jump over
3551: AF      	        xor     A               ; no, it's OFF. make sure to reset A...
3552: 47      	        ld      B,A             ; ...and B
3553: E1      	PNTEND: pop     HL              ; drop original return point
3554: FDE5    	        push    IY              ; load current string address from IY into stack
3556: 11CA1F  	        ld      DE,RETNUM       ; Address of Return number from function...
3559: D5      	        push    DE              ; ...saved on stack
355A: C3C922  	        jp      ABPASS          ; return AB
355D: CBEC    	CTPOINT:set     5,H             ; set to read from color VRAM (it's like adding $2000 to HL)
355F: F3      	        di
3560: CD1906  	        call    READ_VIDEO_LOC  ; load original colors of pixel
3563: FB      	        ei
3564: CB3F    	        srl     A               ; shift A...
3566: CB3F    	        srl     A               ; ...4 times...
3568: CB3F    	        srl     A               ; ...to move foreground color...
356A: CB3F    	        srl     A               ; ...into lowest nibble
356C: 47      	        ld      B,A             ; color into B
356D: AF      	        xor     A               ; reset MSB
356E: C35335  	        jp      PNTEND          ; return AB
3571: CDE435  	PNTRTN: call    XY2HL           ; find HL address of pixel at X,Y
3574: 57      	        ld      D,A             ; store pixel index
3575: F3      	        di                      ; disable INTs
3576: CD1906  	        call    READ_VIDEO_LOC  ; read contents of VRAM cell addressed by HL
3579: FB      	        ei                      ; re-enable INTs
357A: A2      	        and     D               ; is the pixel ON or OFF? (will be checked later)
357B: C9      	        ret                     ; return to caller
              	
              	
              	; PLOT X,Y[,color]
              	; plot a pixel in graphic mode 2
357C: CD3033  	PLOT:   call    CHKG2M          ; check if in G2 mode
357F: CD6527  	        call    GETINT          ; get X coords.
3582: 32EF81  	        ld      (TMPBFR1),A     ; store it into a temp buffer
3585: CD4718  	        call    CHKSYN          ; Make sure ',' follows
3588: 2C      	        defb    ','
3589: CD6527  	        call    GETINT          ; get Y coords,
358C: FEC0    	        cp      $C0             ; check if Y is in range 0~191
358E: D2351B  	        jp      NC,FCERR        ; no, raise an FC error
3591: 32F181  	        ld      (TMPBFR2),A     ; store into a temp buffer
3594: CD2C39  	        call    CLRPRM          ; check if param "color" has been passed
3597: E5      	CNTPLOT:push    HL              ; store HL
3598: C5      	        push    BC              ; store BC
3599: D5      	        push    DE              ; store DE
359A: CDE435  	        call    XY2HL           ; find VRAM address of byte containing pixel at X,Y & return into HL
359D: D2D835  	        jp      NC,NOGD         ; if carry is reset, there was an error -> so leave
35A0: 57      	        ld      D,A             ; move pixel value into D
35A1: 3AF381  	        ld      A,(TMPBFR3)     ; retrieve color
35A4: A7      	        and     A               ; is it 0? (background, or reset pixel)
35A5: 2011    	        jr      NZ,CNTPLT1      ; no, continue
35A7: F3      	        di                      ; yes - so, disable INTs
35A8: CD1906  	        call    READ_VIDEO_LOC  ; load original value of VRAM cell pointed by HL
35AB: FB      	        ei                      ; re-enable INTs
35AC: 5F      	        ld      E,A             ; store value of cell
35AD: 7A      	        ld      A,D             ; retrieve pixel
35AE: 2F      	        cpl                     ; revert bits
35AF: A3      	        and     E               ; set video pixel to off
35B0: F3      	        di                      ; disable INTs
35B1: CD2E06  	        call    WRITE_VIDEO_LOC ; write new value into VRAM cell
35B4: FB      	        ei                      ; re-enable INTs
35B5: C3D835  	        jp      NOGD            ; leave
35B8: 87      	CNTPLT1:add     A,A             ; now we move low nibble
35B9: 87      	        add     A,A             ; in the high nibble
35BA: 87      	        add     A,A             ; by adding A to itself
35BB: 87      	        add     A,A             ; 4 times (this is a shift left 4)
35BC: 5F      	        ld      E,A             ; move it into E
35BD: F3      	        di                      ; disable INTs
35BE: CD1906  	        call    READ_VIDEO_LOC  ; load original value of VRAM cell pointed by HL
35C1: FB      	        ei
35C2: B2      	        or      D               ; plot new pixel preserving original pattern
35C3: F3      	        di
35C4: CD2E06  	        call    WRITE_VIDEO_LOC ; write new value into VRAM cell
35C7: FB      	        ei
35C8: CBEC    	        set     5,H             ; set to read from color VRAM (it's like adding $2000 to HL)
35CA: F3      	        di
35CB: CD1906  	        call    READ_VIDEO_LOC  ; load original colors of pixel
35CE: FB      	        ei
35CF: E60F    	        and     %00001111       ; reset high nibble (the foreground color)
35D1: B3      	        or      E               ; set new foreground color
35D2: F3      	        di
35D3: CD2E06  	        call    WRITE_VIDEO_LOC ; write new color settings
35D6: FB      	        ei                      ; re-enable INTs
35D7: 00      	        nop                     ; wait for INTs to be enabled again
35D8: D1      	NOGD:   pop     DE              ; retrieve DE
35D9: C1      	        pop     BC              ; retrieve BC
35DA: E1      	        pop     HL              ; retrieve HL
35DB: C9      	        ret                     ; return to caller
35DC: 80402010	PXLSET: defb    $80,$40,$20,$10,$08,$04,$02,$01 ; pixel to be set ON
35E0: 08040201	
              	        ; where R(X/8)=> 0=80h, 1=40h, 2=20h, 3=10h, 4=08h, 5=04h, 6=02h, 7=$01
              	
              	
              	; compute the VRAM address of the byte containing the pixel
              	; being pointed by X,Y (TMPBFR1,TMPBFR1)
              	; byte address is returned into HL
              	; pixel is returned into A
35E4:         	XY2HL:  ; formula is: ADDRESS=(INT(X/8))*8 + (INT(Y/8))*256 + R(Y/8)
              	        ; where R(Y/8) is the remainder of (Y/8)
              	        ; the pixel to be set is given by R(X/8), and data is taken from the array
35E4: 3AF181  	        ld      A,(TMPBFR2)     ; retrieve Y
35E7: FEC0    	        cp      $C0             ; Y>=192?
35E9: D0      	        ret     NC              ; yes, so leave
35EA: 1E08    	        ld      E,$08           ; load E with divisor
35EC: 57      	        ld      D,A             ; and store into D (dividend)
35ED: CDF43D  	        call    DIV_8_8         ; get Y/8, D is quotient=INT(Y/8), and A is remainder
35F0: 4F      	        ld      C,A             ; store remainder into C
35F1: 42      	        ld      B,D             ; B=(INT(Y/8))*256 (we simply copy quotient into B)
35F2: 6069    	        ld      HL,BC           ; copy BC into HL: now HL has the VRAM address of the byte being set
35F4: 3AEF81  	        ld      A,(TMPBFR1)     ; retrieve X
35F7: 57      	        ld      D,A             ; and move it into D (dividend)
35F8: CDF43D  	        call    DIV_8_8         ; get X/8, D is quotient=INT(X/8), and A is remainder
35FB: 4F      	        ld      C,A             ; store remainder into C
35FC: 7A      	        ld      A,D             ; move quotient into A
35FD: 87      	        add     A,A
35FE: 87      	        add     A,A
35FF: 87      	        add     A,A             ; multiply quotient by 8
3600: 5F      	        ld      E,A             ; store result into E
3601: 1600    	        ld      D,$00           ; reset D
3603: 19      	        add     HL,DE           ; add DE to HL, getting the final VRAM address
3604: EB      	        ex      DE,HL           ; move VRAM address into DE
3605: 21DC35  	        ld      HL,PXLSET       ; starting address of table for pixel to draw
3608: 0600    	        ld      B,$00           ; reset B
360A: 09      	        add     HL,BC           ; add C (remainder of X/8) to get address of pixel to turn on
360B: 7E      	        ld      A,(HL)          ; load pixel data
360C: EB      	        ex      DE,HL           ; retrieve VRAM pattern address into HL
360D: 37      	        scf                     ; set Carry for normal exit
360E: C9      	        ret                     ; return to caller
              	
              	
              	; DRAW X1,Y1,X2,Y2[,color]
              	; Draw a line using Bresenham's line algorithm from X1,Y1 to X2,Y2
              	; X1,Y1 can be either less than or greater than X2,Y2 (meaning that)
              	; the drawing will be ever done from X1,Y2 to X2,Y2, regardless of
              	; the values. If color is not specified, the foreground color set
              	; with COLOR will be used 
81EF:         	X1      equ     TMPBFR1
81F1:         	Y1      equ     TMPBFR2
81F7:         	X2      equ     VIDEOBUFF
81F9:         	Y2      equ     VIDEOBUFF+$02
81FB:         	ER      equ     VIDEOBUFF+$04
81FD:         	E2      equ     VIDEOBUFF+$06
81FF:         	SX      equ     VIDEOBUFF+$08
8201:         	SY      equ     VIDEOBUFF+$0A
8203:         	DX      equ     VIDEOBUFF+$0C
8205:         	DY      equ     VIDEOBUFF+$0E
360F: CD3033  	DRAW:   call    CHKG2M          ; check if in G2 mode
3612: CD1439  	        call    CLRVDBF         ; clear VIDEOBUFF
3615: CD6527  	        call    GETINT          ; get X1 coords.
3618: 32EF81  	        ld      (X1),A          ; store it into a temp buffer
361B: CD4718  	        call    CHKSYN          ; Make sure ',' follows
361E: 2C      	        defb    ','
361F: CD6527  	        call    GETINT          ; get Y1 coords.
3622: FEC0    	        cp      $C0             ; check if Y1 is in range 0~191
3624: D2351B  	        jp      NC,FCERR        ; no, raise an FC error
3627: 32F181  	        ld      (Y1),A          ; store into a temp buffer
362A: CD4718  	        call    CHKSYN          ; Make sure ',' follows
362D: 2C      	        defb    ','
362E: CD6527  	        call    GETINT          ; get X2 coords.
3631: 32F781  	        ld      (X2),A          ; store it into a temp buffer
3634: CD4718  	        call    CHKSYN          ; Make sure ',' follows
3637: 2C      	        defb    ','
3638: CD6527  	        call    GETINT          ; get Y2 coords
363B: FEC0    	        cp      $C0             ; check if Y2 is in range 0~191
363D: D2351B  	        jp      NC,FCERR        ; no, raise an FC error
3640: 32F981  	        ld      (Y2),A          ; store it into a temp buffer
3643: CD2C39  	        call    CLRPRM          ; check for arg. "color" and store it into TMPBFR3
3646: E5      	        push    HL              ; store register we'll use
3647: D5      	        push    DE              
3648: C5      	        push    BC
3649: ED5BEF81	        ld      DE,(X1)         ; load X1 and
364D: 2AF781  	        ld      HL,(X2)         ; X2
3650: B7      	        or      A               ; clear CARRY
3651: ED52    	        sbc     HL,DE           ; DX=X2-X1
3653: CDEA3D  	        call    absHL           ; DX=ABS(DX)
3656: 220382  	        ld      (DX),HL         ; store DX
3659: 01FFFF  	        ld      BC,$FFFF        ; SX=-1
365C: 2AEF81  	        ld      HL,(X1)
365F: ED5BF781	        ld      DE,(X2)
3663: CDC53D  	        call    CMP16           ; X1<X2?
3666: CA6F36  	        jp      Z,X1GR          ; no, X1=X2
3669: F26F36  	        jp      P,X1GR          ; no, X1>X2
366C: 010100  	        ld      BC,$0001        ; yes, so set SX=1
366F: ED43FF81	X1GR:   ld      (SX),BC         ; store SX
3673: ED5BF181	        ld      DE,(Y1)
3677: 2AF981  	        ld      HL,(Y2)
367A: B7      	        or      A               ; clear Carry
367B: ED52    	        sbc     HL,DE           ; DY=Y2-Y1
367D: CDEA3D  	        call    absHL           ; DY=ABS(DY)
3680: 220582  	        ld      (DY),HL         ; store DY
3683: 01FFFF  	        ld      BC,$FFFF        ; SY=-1
3686: 2AF181  	        ld      HL,(Y1)
3689: ED5BF981	        ld      DE,(Y2)
368D: CDC53D  	        call    CMP16           ; is Y1<Y2?
3690: CA9936  	        jp      Z,Y1GR          ; no, Y1=Y2
3693: F29936  	        jp      P,Y1GR          ; no, Y1>Y2 - jump over
3696: 010100  	        ld      BC,$0001        ; yes, so set SY=1
3699: ED430182	Y1GR:   ld      (SY),BC         ; store SY
369D: 2A0582  	        ld      HL,(DY)         ; ER=DY
36A0: CDED3D  	        call    negHL           ; ER=-DY
36A3: 22FB81  	        ld      (ER),HL         ; store ER
36A6: 2A0382  	        ld      HL,(DX)
36A9: ED5B0582	        ld      DE,(DY)
36AD: CDC53D  	        call    CMP16           ; DX>DY?
36B0: CABC36  	        jp      Z,ER2           ; no, DX=DY
36B3: FABC36  	        jp      M,ER2           ; no, DX<DY
36B6: 2A0382  	        ld      HL,(DX)         ; reload DX
36B9: 22FB81  	        ld      (ER),HL         ; yes: DX>DY, so ER=DX
36BC: 2AFB81  	ER2:    ld      HL,(ER)         ; load ER
36BF: CB2C    	        sra     H               ; right shift (and preserve sign)...
36C1: CB1D    	        rr      L               ; ...of HL, so ER=INT(ER/2)
36C3: CB7C    	        bit     7,H             ; is the number negative?
36C5: CAC936  	        jp      Z,STRE2         ; no, jump over
36C8: 23      	        inc     HL              ; yes, add 1 'cos INT of a negative number needs to be incremented
36C9: 22FB81  	STRE2:  ld      (ER),HL         ; store ER
36CC: CD9735  	RPTDRW: call    CNTPLOT         ; plot first pixel
36CF: 2AEF81  	        ld      HL,(X1)
36D2: ED5BF781	        ld      DE,(X2)
36D6: CDC53D  	        call    CMP16           ; X1=X2?
36D9: 200D    	        jr      NZ,CNTDRW       ; no, continue drawing
36DB: 2AF181  	        ld      HL,(Y1)         ; yes, so check
36DE: ED5BF981	        ld      DE,(Y2)         ; also Y
36E2: CDC53D  	        call    CMP16           ; Y1=Y2?
36E5: CA4137  	        jp      Z,ENDDRAW       ; yes, finished drawing: exit
36E8: ED5BFB81	CNTDRW: ld      DE,(ER)
36EC: ED53FD81	        ld      (E2),DE         ; E2=ER
36F0: 2A0382  	        ld      HL,(DX)
36F3: CDED3D  	        call    negHL           ; DX=-DX
36F6: EB      	        ex      DE,HL           ; invert DE and HL => HL=E2, DE=-DX
36F7: CDC53D  	        call    CMP16           ; E2>-DX?
36FA: CA1837  	        jp      Z,DXGR          ; no, E2=-DX: jump
36FD: FA1837  	        jp      M,DXGR          ; no, E2<-DX: jump
3700: 2AFB81  	        ld      HL,(ER)         ; yes
3703: ED5B0582	        ld      DE,(DY)
3707: B7      	        or      A               ; clear CARRY
3708: ED52    	        sbc     HL,DE           ; ER=ER-DY
370A: 22FB81  	        ld      (ER),HL
370D: 2AEF81  	        ld      HL,(X1)
3710: ED5BFF81	        ld      DE,(SX)
3714: 19      	        add     HL,DE           ; X1=X1+SX (increment X1)
3715: 22EF81  	        ld      (X1),HL
3718: 2AFD81  	DXGR:   ld      HL,(E2)
371B: ED5B0582	        ld      DE,(DY)
371F: CDC53D  	        call    CMP16           ; E2<DY?
3722: CACC36  	        jp      Z,RPTDRW        ; no, E2=DY: jump
3725: F2CC36  	        jp      P,RPTDRW        ; no, E2>DY: jump
3728: 2AFB81  	        ld      HL,(ER)         ; yes
372B: ED5B0382	        ld      DE,(DX)
372F: 19      	        add     HL,DE           ; ER=ER+DX
3730: 22FB81  	        ld      (ER),HL
3733: 2AF181  	        ld      HL,(Y1)
3736: ED5B0182	        ld      DE,(SY)
373A: 19      	        add     HL,DE           ; Y1=Y1+SY (increment Y1)
373B: 22F181  	        ld      (Y1),HL
373E: C3CC36  	        jp      RPTDRW          ; repeat
3741: C1      	ENDDRAW:pop     BC              ; retrieve BC
3742: D1      	        pop     DE              ; retrieve DE
3743: E1      	        pop     HL              ; retrieve HL
3744: C9      	        ret                     ; return to caller
              	
              	
              	; CIRCLE X,Y,R[,C]
              	; Draw a circle using Bresenham's circle algorithm with center in X,Y
              	; and radius R, with optional color C. If color is not specified, the
              	; foreground color set with COLOR will be used 
81F7:         	XC      equ     VIDEOBUFF
81F9:         	YC      equ     VIDEOBUFF+$02
81FB:         	RADIUS  equ     VIDEOBUFF+$04
81FD:         	XI      equ     VIDEOBUFF+$06
81FF:         	YI      equ     VIDEOBUFF+$08
8201:         	DC      equ     VIDEOBUFF+$0A
3745: CD3033  	CIRCLE: call    CHKG2M          ; check if in G2 mode
3748: CD1439  	        call    CLRVDBF         ; clear VIDEOBUFF
374B: CD6527  	        call    GETINT          ; get X coords.
374E: 32F781  	        ld      (XC),A          ; store it into a temp buffer
3751: CD4718  	        call    CHKSYN          ; Make sure ',' follows
3754: 2C      	        defb    ','
3755: CD6527  	        call    GETINT          ; get Y coords,
3758: 32F981  	        ld      (YC),A          ; store it into a temp buffer
375B: CD4718  	        call    CHKSYN          ; Make sure ',' follows
375E: 2C      	        defb    ','
375F: CD6527  	        call    GETINT          ; get radius
3762: 32FB81  	        ld      (RADIUS),A      ; store it into a temp buffer
3765: CD2C39  	        call    CLRPRM          ; check if param "color" has been passed
3768: C5      	        push    BC              ; store BC
3769: D5      	        push    DE              ; store DE
376A: E5      	        push    HL              ; store HL
376B: AF      	        xor     A               ; clear A,
376C: 47      	        ld      B,A             ; B,
376D: 4F      	        ld      C,A             ; C,
376E: 57      	        ld      D,A             ; D,
376F: 67      	        ld      H,A             ; and H
3770: ED43FD81	        ld      (XI),BC         ; clear XI
3774: 3AFB81  	        ld      A,(RADIUS)      ; load RADIUS into A
3777: 6F      	        ld      L,A             ; HL now contains R
3778: 22FF81  	        ld      (YI),HL         ; YI=RADIUS
377B: 29      	        add     HL,HL           ; R*2
377C: EB      	        ex      DE,HL           ; put HL into DE
377D: 210300  	        ld      HL,$0003        ; now HL is 3
3780: AF      	        xor     A               ; clear Carry
3781: ED52    	        sbc     HL,DE           ; HL=>D=3-(2*R)
3783: 220182  	        ld      (DC),HL         ; store D
3786: CDE537  	        call    DRWCRL          ; draw initial point
3789: ED5BFD81	RPTCRL: ld      DE,(XI)         ; load XI
378D: 2AFF81  	        ld      HL,(YI)         ; load YI
3790: CDC53D  	        call    CMP16           ; is YI<DI?
3793: CA9C37  	        jp      Z,RPTCL1        ; no, YI=XI
3796: F29C37  	        jp      P,RPTCL1        ; no, YI>XI
3799: C3E137  	        jp      ENDCRL          ; yes, so we've finished
379C: 21FD81  	RPTCL1: ld      HL,XI
379F: 34      	        inc     (HL)            ; XI=XI+1
37A0: 2A0182  	        ld      HL,(DC)         ; load D
37A3: 7C      	        ld      A,H
37A4: B5      	        or      L               ; is D=0? Yes, jump over
37A5: CAC937  	        jp      Z,DLSZ
37A8: CB7C    	        bit     7,H             ; is D<0?
37AA: 201D    	        jr      NZ,DLSZ         ; yes, jump over
37AC: ED5BFF81	        ld      DE,(YI)         ; D>0
37B0: 1B      	        dec     DE              ; so, YI=YI-1
37B1: ED53FF81	        ld      (YI),DE         ; store YI
37B5: AF      	        xor     A               ; clear Carry
37B6: 2AFD81  	        ld      HL,(XI)
37B9: ED52    	        sbc     HL,DE           ; HL=XI-YI
37BB: 29      	        add     HL,HL
37BC: 29      	        add     HL,HL           ; HL=HL*4
37BD: 110A00  	        ld      DE,10
37C0: 19      	        add     HL,DE           ; HL=HL+10
37C1: ED5B0182	        ld      DE,(DC)         ; load D
37C5: EB      	        ex      DE,HL           ; invert DE and HL, so that HL=4*(XI-YI)+10 and DE=D
37C6: 19      	        add     HL,DE           ; D=D+4*(XI-YI)+10
37C7: 180F    	        jr      PLTCRL          ; plot next pixel
37C9: 2AFD81  	DLSZ:   ld      HL,(XI)         ; load XI
37CC: 29      	        add     HL,HL
37CD: 29      	        add     HL,HL           ; XI=XI*4
37CE: 110600  	        ld      DE,$0006
37D1: 19      	        add     HL,DE
37D2: ED5B0182	        ld      DE,(DC)
37D6: EB      	        ex      DE,HL           ; HL=D and DE=4*XI+6
37D7: 19      	        add     HL,DE           ; D=D+4*XI+6
37D8: 220182  	PLTCRL: ld      (DC),HL         ; store new D
37DB: CDE537  	        call    DRWCRL          ; plot pixel
37DE: C38937  	        jp      RPTCRL          ; repeat
37E1: E1      	ENDCRL: pop     HL
37E2: D1      	        pop     DE
37E3: C1      	        pop     BC
37E4: C9      	        ret                     ; return to caller
37E5: 2AF781  	DRWCRL: ld      HL,(XC)
37E8: ED5BFD81	        ld      DE,(XI)
37EC: 19      	        add     HL,DE           ; X=XC+XI
37ED: 22EF81  	        ld      (X1),HL         ; store X
37F0: CD0439  	        call    VALIDX          ; check if X is valid (0~255)
37F3: DA0738  	        jp      C,CNTCL1        ; if Carry is set, X is not valid
37F6: 2AF981  	        ld      HL,(YC)
37F9: ED5BFF81	        ld      DE,(YI)
37FD: 19      	        add     HL,DE           ; Y=YC+YI
37FE: 22F181  	        ld      (Y1),HL         ; store Y
3801: CD0939  	        call    VALIDY          ; check if Y is valid (0~191)
3804: D49735  	        call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
3807: AF      	CNTCL1: xor     A               ; clear Carry
3808: 2AF781  	        ld      HL,(XC)
380B: ED5BFD81	        ld      DE,(XI)
380F: ED52    	        sbc     HL,DE           ; X=XC-XI
3811: 22EF81  	        ld      (X1),HL         ; store X
3814: CD0439  	        call    VALIDX          ; check if X is valid (0~255)
3817: DA2B38  	        jp      C,CNTCL2        ; if Carry is set, X is not valid
381A: 2AF981  	        ld      HL,(YC)
381D: ED5BFF81	        ld      DE,(YI)
3821: 19      	        add     HL,DE           ; Y=YC+YI
3822: 22F181  	        ld      (Y1),HL         ; store Y
3825: CD0939  	        call    VALIDY          ; check if Y is valid (0~191)
3828: D49735  	        call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
382B: 2AF781  	CNTCL2: ld      HL,(XC)
382E: ED5BFD81	        ld      DE,(XI)
3832: 19      	        add     HL,DE           ; X=XC+XI
3833: 22EF81  	        ld      (X1),HL         ; store X
3836: CD0439  	        call    VALIDX          ; check if X is valid (0~255)
3839: DA4F38  	        jp      C,CNTCL3        ; if Carry is set, X is not valid
383C: AF      	        xor     A               ; clear Carry
383D: 2AF981  	        ld      HL,(YC)
3840: ED5BFF81	        ld      DE,(YI)
3844: ED52    	        sbc     HL,DE           ; Y=YC-YI
3846: 22F181  	        ld      (Y1),HL         ; store Y
3849: CD0939  	        call    VALIDY          ; check if Y is valid (0~191)
384C: D49735  	        call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
384F: AF      	CNTCL3: xor     A               ; clear Carry
3850: 2AF781  	        ld      HL,(XC)
3853: ED5BFD81	        ld      DE,(XI)
3857: ED52    	        sbc     HL,DE           ; X=XC-XI
3859: 22EF81  	        ld      (X1),HL         ; store X
385C: CD0439  	        call    VALIDX          ; check if X is valid (0~255)
385F: DA7538  	        jp      C,CNTCL4        ; if Carry is set, X is not valid
3862: AF      	        xor     A               ; clear Carry
3863: 2AF981  	        ld      HL,(YC)
3866: ED5BFF81	        ld      DE,(YI)
386A: ED52    	        sbc     HL,DE           ; Y=YC-YI
386C: 22F181  	        ld      (Y1),HL         ; store Y
386F: CD0939  	        call    VALIDY          ; check if Y is valid (0~191)
3872: D49735  	        call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
3875: 2AF781  	CNTCL4: ld      HL,(XC)
3878: ED5BFF81	        ld      DE,(YI)
387C: 19      	        add     HL,DE           ; X=XC+YI
387D: 22EF81  	        ld      (X1),HL         ; store X
3880: CD0439  	        call    VALIDX          ; check if X is valid (0~255)
3883: DA9738  	        jp      C,CNTCL5        ; if Carry is set, X is not valid
3886: 2AF981  	        ld      HL,(YC)
3889: ED5BFD81	        ld      DE,(XI)
388D: 19      	        add     HL,DE           ; Y=YC+XI
388E: 22F181  	        ld      (Y1),HL         ; store Y
3891: CD0939  	        call    VALIDY          ; check if Y is valid (0~191)
3894: D49735  	        call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
3897: AF      	CNTCL5: xor     A               ; clear Carry
3898: 2AF781  	        ld      HL,(XC)
389B: ED5BFF81	        ld      DE,(YI)
389F: ED52    	        sbc     HL,DE           ; X=XC-YI
38A1: 22EF81  	        ld      (X1),HL         ; store X
38A4: CD0439  	        call    VALIDX          ; check if X is valid (0~255)
38A7: DABB38  	        jp      C,CNTCL6        ; if Carry is set, X is not valid
38AA: 2AF981  	        ld      HL,(YC)
38AD: ED5BFD81	        ld      DE,(XI)
38B1: 19      	        add     HL,DE           ; Y=YC+XI
38B2: 22F181  	        ld      (Y1),HL         ; store Y
38B5: CD0939  	        call    VALIDY          ; check if Y is valid (0~191)
38B8: D49735  	        call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
38BB: 2AF781  	CNTCL6: ld      HL,(XC)
38BE: ED5BFF81	        ld      DE,(YI)
38C2: 19      	        add     HL,DE           ; X=XC+YI
38C3: 22EF81  	        ld      (X1),HL         ; store X
38C6: CD0439  	        call    VALIDX          ; check if X is valid (0~255)
38C9: DADF38  	        jp      C,CNTCL7        ; if Carry is set, X is not valid
38CC: AF      	        xor     A               ; clear Carry
38CD: 2AF981  	        ld      HL,(YC)
38D0: ED5BFD81	        ld      DE,(XI)
38D4: ED52    	        sbc     HL,DE           ; Y=YC-XI
38D6: 22F181  	        ld      (Y1),HL         ; store Y
38D9: CD0939  	        call    VALIDY          ; check if Y is valid (0~191)
38DC: D49735  	        call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
38DF: AF      	CNTCL7: xor     A               ; clear Carry
38E0: 2AF781  	        ld      HL,(XC)
38E3: ED5BFF81	        ld      DE,(YI)
38E7: ED52    	        sbc     HL,DE           ; X=XC-YI
38E9: 22EF81  	        ld      (X1),HL         ; store X
38EC: CD0439  	        call    VALIDX          ; check if X is valid (0~255)
38EF: D8      	        ret     C               ; if Carry is set, X is not valid
38F0: AF      	        xor     A               ; clear Carry
38F1: 2AF981  	        ld      HL,(YC)
38F4: ED5BFD81	        ld      DE,(XI)
38F8: ED52    	        sbc     HL,DE           ; Y=YC-XI
38FA: 22F181  	        ld      (Y1),HL         ; store Y
38FD: CD0939  	        call    VALIDY          ; check if Y is valid (0~191)
3900: D49735  	        call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
3903: C9      	        ret                     ; return to caller
              	
              	; check if X,Y coordinates are valid: 0<=X<=255 and 0<=Y<=191
              	; input: HL (value to check), can be negative
              	; output: CARRY flag: reset => VALID  //  set => NOT VALID
              	; destroys: A
3904: AF      	VALIDX: xor     A               ; reset A
3905: B4      	        or      H               ; check if H is 0 (this means that X is in range 0~255 and not negative)
3906: C8      	        ret     Z               ; yes, we can return (C is clear)
3907: 37      	        scf                     ; set Carry flag to raise error
3908: C9      	        ret                     ; return to caller
              	
3909: AF      	VALIDY: xor     A               ; reset A
390A: B4      	        or      H               ; check if H is 0 (this means that Y is in range 0~255 and not negative)
390B: 2802    	        jr      Z,CNTVALY       ; yes, continue checking
390D: 37      	        scf                     ; no, raise error by setting Carry flag
390E: C9      	        ret                     ; return to caller
390F: 7D      	CNTVALY:ld      A,L
3910: FEC0    	        cp      $C0             ; is Y<192? Carry is set if Y<192
3912: 3F      	        ccf                     ; invert Carry, so Carry=0 means OK, Carry=1 means ERROR
3913: C9      	        ret                     ; return to caller
              	
              	
              	; clear VIDEOBUFF before using it as temp buffer
3914: AF      	CLRVDBF:xor     A               ; clear A
3915: C5      	        push    BC              ; store BC
3916: E5      	        push    HL              ; store HL
3917: 21EF81  	        ld      HL,TMPBFR1      ; address of 1st cell
391A: 0606    	        ld      B,$06           ; 6 cells
391C: 77      	RPTCVB1:ld      (HL),A          ; clear cell
391D: 23      	        inc     HL              ; next cell
391E: 10FC    	        djnz    RPTCVB1         ; repeat
3920: 0628    	        ld      B,$28           ; 40 cells
3922: 21F781  	        ld      HL,VIDEOBUFF    ; address of 1st cell
3925: 77      	RPTCVB2:ld      (HL),A          ; clear cell
3926: 23      	        inc     HL              ; next cell
3927: 10FC    	        djnz    RPTCVB2         ; repeat
3929: E1      	        pop     HL              ; retrieve HL
392A: C1      	        pop     BC              ; retrieve BC
392B: C9      	        ret                     ; return to caller
              	
              	
              	; check if a color is passed as argument with PLOT, DRAW, and CIRCLE
              	; commands. If not present, the default foreground color will be used
392C: 3AED81  	CLRPRM: ld      A,(FRGNDCLR)    ; load foreground color
392F: 32F381  	        ld      (TMPBFR3),A     ; store into temp buffer
3932: 2B      	        dec     HL              ; dec 'cos GETCHR INCs
3933: CD6A1A  	        call    GETCHR          ; Get next character
3936: C8      	        ret     Z               ; return foreground color if nothing follows
3937: CD4718  	        call    CHKSYN          ; Make sure ',' follows
393A: 2C      	        defb    ','
393B: CD6527  	        call    GETINT          ; get value
393E: CD2A33  	        call    CHKCLR0         ; check if color is in range 0~15
3941: 32F381  	        ld      (TMPBFR3),A     ; store color into temp buffer
3944: C9      	        ret                     ; return to caller
              	
              	
              	; no graphics mode error: raised when a graphics command is invoked
              	; out of graphic 2 mode.
3945: 1E2A    	GMERR:  ld      E,GM            ; load Graphics Mode Error flag
3947: C37915  	        jp      ERROR           ; print error
              	
              	
              	; set a serial port: params are PORT,BPS,DATA,PARITY,STOP
              	; PORT=1/2; BPS=1,200~57,600 (see below), DATA=5/6/7/8
              	; PARITY: 0=no parity; 1=ODD parity; 2=EVEN parity;
              	; STOP=0/1/2/3: 0=0 bit; 1=1 bit; 2=1.5 bits; 3=2 bits
              	; PORT 1 acts as a char device; PORT 2 acts as a block device
              	; DATA,PARITY, and STOP are optional: if nothing follows BPS,
              	; they are assumed to be 8,0,1 resp.
81F7:         	PRTNUM  equ     VIDEOBUFF
81F8:         	BPS     equ     VIDEOBUFF+$01
81FA:         	DATABT  equ     BPS+$02
81FB:         	PARBT   equ     DATABT+$01
81FC:         	STPBT   equ     PARBT+$01
81FD:         	SIOBFR  equ     STPBT+$01
394A: CD6527  	SERIAL: call    GETINT          ; get port #
394D: A7      	        and     A               ; is it zero?
394E: CA351B  	        jp      Z,FCERR         ; yes, error
3951: FE03    	        cp      $03             ; is it 1 or 2?
3953: D2343B  	        jp      NC,SCERR        ; no, error
3956: 32F781  	        ld      (PRTNUM),A      ; store port number into a temp buffer
3959: CD4718  	        call    CHKSYN          ; Make sure ',' follows
395C: 2C      	        defb    ','
395D: CD3A1B  	        call    ATOH            ; get bps (returned into DE)
3960: 7A      	        ld      A,D             ; move MSB into A
3961: B3      	        or      E               ; LSB OR MSB, to check if bps=0
3962: 203A    	        jr      NZ,CNTSER       ; no, continue checking
              	        ; if baud rate is 0, then close the serial comm.
3964: 3AF781  	RSTSER1:ld      A,(PRTNUM)      ; yes, so reset the channel. First, load port number
3967: 3D      	        dec     A               ; subtract 1, so that serial channel is 0=>A and 1=>B
3968: C622    	        add     SIO_CA          ; find correct channel
396A: 4F      	        ld      C,A             ; store serial channel
396B: F3      	        di                      ; disable INTs
396C: AF      	        xor     A               ; reset A
396D: 1601    	        ld      D,$01           ; start from WR1
396F: 0605    	        ld      B,$05           ; 5 registers
3971: ED51    	RPTRSSR:out     (C),D           ; select register
3973: ED79    	        out     (C),A           ; reset register
3975: 14      	        inc     D               ; next register
3976: 10F9    	        djnz    RPTRSSR         ; repeat
3978: 3E30    	        ld      A,%00110000     ; write into WR0: error reset, select WR0
397A: ED79    	        out     (C),A           ; send command to serial channel
397C: 3E18    	        ld      A,%00011000     ; write into WR0: channel reset
397E: ED79    	        out     (C),A           ; send command to serial channel
3980: FB      	        ei                      ; re-enable INTs
3981: E5      	        push    HL              ; store HL
3982: 212E82  	        ld      HL,SERIALS_EN   ; serials enabled status byte
3985: DB01    	        in      A,(PIO_DB)      ; read status LEDs
3987: CB41    	        bit     0,C             ; check serial port
3989: 2009    	        jr      NZ,SRPT2        ; if bit is set, jump to port 2
398B: CBB7    	        res     6,A             ; it's port 1
398D: CBA7    	        res     4,A             ; remove possible error LED
398F: CB86    	        res     0,(HL)          ; disable port 1
3991: C39A39  	        jp      SERLED          ; jump over
3994: CBBF    	SRPT2:  res     7,A             ; it's port 2
3996: CBAF    	        res     5,A             ; remove possible error LED
3998: CB8E    	        res     1,(HL)          ; disable port 2
399A: D301    	SERLED: out     (PIO_DB),A      ; send new configuration
399C: E1      	        pop     HL              ; retrieve HL
399D: C9      	        ret                     ; return to caller
              	        ; check if bps=1, meaning reactivate RX on serial
399E: 7A      	CNTSER: ld      A,D
399F: B2      	        or      D               ; check if bps<>1 by first checking D=0
39A0: 203B    	        jr      NZ,CNTSER2      ; if not, jump over
39A2: 7B      	        ld      A,E             ; then by checking that
39A3: FE01    	        cp      $01             ; E=1
39A5: 2036    	        jr      NZ,CNTSER2      ; if not, jump over
39A7: 3AF781  	        ld      A,(PRTNUM)      ; load port number
39AA: FE01    	        cp      $01             ; is it port 1? (currently do NOT support on port 2)
39AC: C2343B  	        jp      NZ,SCERR        ; no, raise error and exit 
39AF: 57      	        ld      D,A             ; store port on D
39B0: 3A2E82  	        ld      A,(SERIALS_EN)  ; load address of serial status cell
39B3: A2      	        and     D               ; check status
39B4: CA343B  	        jp      Z,SCERR         ; port not open, raise error
39B7: F3      	        di                      ; disable INTs
39B8: 7A      	        ld      A,D             ; move port # into A
39B9: 5F      	        ld      E,A             ; store original A into E
39BA: 87      	        add     A
39BB: 87      	        add     A               ; move A to left times 2
39BC: 57      	        ld      D,A             ; move value into D
39BD: 3A2E82  	        ld      A,(SERIALS_EN)  ; load serial status byte
39C0: B2      	        or      D               ; re-enable RX
39C1: 322E82  	        ld      (SERIALS_EN),A  ; store new serial status
39C4: 7B      	        ld      A,E             ; recover port #
39C5: 3D      	        dec     A               ; check port
39C6: 200A    	        jr      NZ,CNTRX2       ; port is #2
39C8: CD8D01  	        call    SIO_A_EI        ; re-enable RX on port 1
39CB: DB01    	        in      A,(PIO_DB)      ; load status LEDs
39CD: CBA7    	        res     4,A             ; remove error LED
39CF: C3D939  	        jp      RXEND           ; terminate setting
39D2: CD8D01  	CNTRX2: call    SIO_A_EI        ; re-enable RX on port 2 -> CURRENTLY only port 1 is supported
39D5: DB01    	        in      A,(PIO_DB)      ; load status LEDs
39D7: CBAF    	        res     5,A             ; remove error LED
39D9: D301    	RXEND:  out     (PIO_DB),A      ; set new status for LEDs
39DB: FB      	        ei                      ; re-enable INTs
39DC: C9      	        ret                     ; return to caller
              	        ; set serial port comm.
39DD: D5      	CNTSER2:push    DE              ; store BPS
39DE: 3AF781  	        ld      A,(PRTNUM)      ; load port number
39E1: 57      	        ld      D,A             ; move port # into D
39E2: 3A2E82  	        ld      A,(SERIALS_EN)  ; check if serial port is already open
39E5: A2      	        and     D               ; by ANDing A with D
39E6: D1      	        pop     DE              ; retrieve BPS
39E7: CAEF39  	        jp      Z,CNTSER3       ; not open, continue
39EA: 1E2E    	        ld      E,SA            ; already open, so raise a "Serial Port Already Error"
39EC: C37915  	        jp      ERROR           ; and leave
39EF: E5      	CNTSER3:push    HL              ; store HL   
39F0: 2100E1  	        ld      HL,$E100        ; check bps. start with HL=57,600
39F3: CDC53D  	        call    CMP16           ; is bps<=57,600?
39F6: E1      	        pop     HL              ; but first, recover HL
39F7: DA343B  	        jp      C,SCERR         ; no (bps>57,600) then error
39FA: ED53F881	        ld      (BPS),DE        ; store bps
39FE: 2B      	        dec     HL              ; dec 'cos GETCHR INCs
39FF: CD6A1A  	        call    GETCHR          ; Get next character
3A02: CA393A  	        jp      Z,DEFSER        ; defaults if nothing follows
3A05: CD4718  	        call    CHKSYN          ; Make sure ',' follows
3A08: 2C      	        defb    ','
3A09: CD6527  	        call    GETINT          ; get data bits
3A0C: FE05    	        cp      $05             ; is it <5?
3A0E: DA343B  	        jp      C,SCERR         ; yes, error
3A11: FE09    	        cp      $09             ; is it >=9?
3A13: D2351B  	        jp      NC,FCERR        ; no, error
3A16: 32FA81  	        ld      (DATABT),A      ; store data bits
3A19: CD4718  	        call    CHKSYN          ; Make sure ',' follows
3A1C: 2C      	        defb    ','
3A1D: CD6527  	        call    GETINT          ; get parity bits
3A20: FE03    	        cp      A,$03           ; check if parity is in range 0~2
3A22: D2343B  	        jp      NC,SCERR        ; no, error
3A25: 32FB81  	        ld      (PARBT),A       ; store parity
3A28: CD4718  	        call    CHKSYN          ; Make sure ',' follows
3A2B: 2C      	        defb    ','
3A2C: CD6527  	        call    GETINT          ; get stop bits
3A2F: FE03    	        cp      $03             ; is it >=3?
3A31: D2343B  	        jp      NC,SCERR        ; yes, error
3A34: 32FC81  	        ld      (STPBT),A       ; store stop bits
3A37: 180D    	        jr      SETSER          ; jump to set serial
3A39: 3E08    	DEFSER: ld      A,$08           ; 8 bits for data
3A3B: 32FA81  	        ld      (DATABT),A
3A3E: AF      	        xor     A               ; no parity bit
3A3F: 32FB81  	        ld      (PARBT),A
3A42: 3C      	        inc     A               ; 1 bit for stop
3A43: 32FC81  	        ld      (STPBT),A
              	        ; check if bps are legal
3A46: E5      	SETSER: push    HL              ; store HL 
3A47: D5      	        push    DE              ; store DE
3A48: DDE5    	        push    IX              ; store IX
3A4A: DD210F3B	        ld      IX,SUP_BPS      ; allowed BPSs
3A4E: 060B    	        ld      B,$0B           ; 11 items
3A50: 0E00    	        ld      C,$00           ; reset pointer
3A52: 2AF881  	CKBPS:  ld      HL,(BPS)        ; load BPS
3A55: DD5E00  	        ld      E,(IX+0)        ; load LSB of item
3A58: DD5601  	        ld      D,(IX+1)        ; load MSB of item
3A5B: CDC53D  	        call    CMP16           ; is it equal?
3A5E: CA6B3A  	        jp      Z,FNDBPS        ; yes, found correspondance
3A61: DD23    	        inc     IX
3A63: DD23    	        inc     IX              ; no, go to next entry
3A65: 0C      	        inc     C               ; increment pointer
3A66: 10EA    	        djnz    CKBPS           ; repeat for 10 entries
3A68: C3303B  	        jp      SCERR1          ; if nothing found, raise an error
3A6B: 3AF781  	FNDBPS: ld      A,(PRTNUM)      ; check serial port
3A6E: 3D      	        dec     A               ; is it port 1?
3A6F: CA753A  	        jp      Z,SET_P1        ; yes, set port 1
3A72: C3303B  	        jp      SCERR1          ; at the moment, only port 1 can be configured
3A75:         	SET_P1: ;init CTC CH0: CH0 provides RX/TX clock to SIO port A
              	        ; TO0 output frequency=INPUT CLK/time constant. Time constant is set to get 16 times
              	        ; the requested baud rate. I.e., if bps is 19,200 then time constast is set to 6 because
              	        ; 1,843,200/6 = 307,200 Hz (that is 19,200 x 16)
3A75: F3      	        di                      ; disable INTs
3A76: 0600    	        ld      B,$00           ; reset B
3A78: 21253B  	        ld      HL,CTC_CFG      ; address of first CTC divider
3A7B: 09      	        add     HL,BC           ; adjust for correct CTC divider
3A7C: 3E47    	        ld      A,%01000111     ; interrupt off, counter mode, prsc=16 (doesn't matter), ext. start,
              	                                ; start upon loading time constant, time constant follows, sw reset, command word
3A7E: D310    	        out     (CTC_CH0),A     ; configure CTC channel 0
3A80: 7E      	        ld      A,(HL)          ; load CTC divider
3A81: D310    	        out     (CTC_CH0),A     ; send divider
              	        ; configure SIO
3A83: 21FA02  	        ld      HL,SIO_A_SETS   ; load default settings for SIO
3A86: 11FD81  	        ld      DE,SIOBFR       ; into a temp buffer
3A89: 010A00  	        ld      BC,$000A        ; 10 items to copy
3A8C: EDB0    	        ldir                    ; copy SIO settings into TEMP buffer
3A8E: 3A0282  	        ld      A,(SIOBFR+5)    ; load WR5 setting
3A91: 47      	        ld      B,A             ; move it into B
3A92: 3AFA81  	        ld      A,(DATABT)      ; load DATA bits
3A95: FE05    	        cp      $05             ; is it 5 bits?
3A97: 2006    	        jr      NZ,BITS6        ; no, jump over
3A99: CBB0    	        res     6,B
3A9B: CBA8    	        res     5,B             ; set D6 & D5 to 0
3A9D: 1819    	        jr      SETPAR          ; jump to set parity
3A9F: FE06    	BITS6:  cp      $06             ; is it 6 bits?
3AA1: 2006    	        jr      NZ,BITS7        ; no, jump over
3AA3: CBF0    	        set     6,B
3AA5: CBA8    	        res     5,B             ; set D6 & D5 to 1,0
3AA7: 180F    	        jr      SETPAR          ; jump to set parity
3AA9: FE07    	BITS7:  cp      $07             ; is it 7 bits?
3AAB: 2007    	        jr      NZ,BITS8        ; no, jump over
3AAD: CBB0    	        res     6,B
3AAF: CBE8    	        set     5,B             ; set D6 & D5 to 0,1
3AB1: C3B83A  	        jp      SETPAR          ; jump to set parity
3AB4: CBF0    	BITS8:  set     6,B
3AB6: CBE8    	        set     5,B             ; set D6 & D5 to 1,1
3AB8: 78      	SETPAR: ld      A,B
3AB9: 320282  	        ld      (SIOBFR+5),A    ; save DATA bits
3ABC: E660    	        and     %01100000       ; filter only D5&D6 bits
3ABE: 87      	        add     A,A             ; shift left times 1
3ABF: 322F82  	        ld      (SERABITS),A    ; store for SIO_A_EI & SIO_A_DI functions
3AC2: 3AFC81  	        ld      A,(STPBT)       ; load STOP bits
3AC5: 87      	        add     A,A
3AC6: 87      	        add     A,A             ; 2 left shifts
3AC7: 47      	        ld      B,A             ; move forming byte into B
3AC8: 3AFB81  	        ld      A,(PARBT)       ; load PARITY setting
3ACB: A7      	        and     A               ; is it 0?
3ACC: CAD73A  	        jp      Z,STRPAR        ; yes, jump over
3ACF: CBC0    	        set     0,B             ; set PARITY on
3AD1: 3D      	        dec     A               ; is parity ODD?
3AD2: CAD73A  	        jp      Z,STRPAR        ; yes, so jump over
3AD5: CBC8    	        set     1,B             ; no, it's EVEN so set the corresponding bit
3AD7: 3A0082  	STRPAR: ld      A,(SIOBFR+3)    ; load WR4 setting
3ADA: E6F0    	        and     %11110000       ; reset STOP & PARITY bits
3ADC: B0      	        or      B               ; set new STOP & PARITY bits
3ADD: 320082  	        ld      (SIOBFR+3),A    ; store new value
              	        ;set up TX and RX:
              	        ; the followings are settings for channel A
3AE0: 21FD81  	        ld      HL,SIOBFR       ; settings for SIO ch. A
3AE3: 0606    	        ld      B,$06           ; 6 bytes to send
3AE5: 0E22    	        ld      C,SIO_CA        ; I/O address of SIO ch.A
3AE7: EDB3    	        otir                    ; send bytes to SIO
              	        ; the following are settings for channel B (don't need to load HL since settings are contigous)
3AE9: 0604    	        ld      B,$04           ; other 4 bytes to send
3AEB: 0E23    	        ld      C,SIO_CB        ; I/O address of SIO ch.B
3AED: EDB3    	        otir                    ; send bytes to SIO
              	        ; the following are settings for channel A
3AEF: 3E01    	        ld      A,$01           ; write into WR0: select WR1
3AF1: D322    	        out     (SIO_CA),A
3AF3: 3E18    	        ld      A,%00011000     ; interrupts on every RX char; parity is no special condition;
              	                                ; buffer overrun is special condition
3AF5: D322    	        out     (SIO_CA),A
3AF7: CD8D01  	        call    SIO_A_EI        ; enable RX on SIO channel A
3AFA: 212E82  	EXITSER:ld      HL,SERIALS_EN
3AFD: CBC6    	        set     0,(HL)          ; set serial port 1 status ON
3AFF: CBD6    	        set     2,(HL)          ; set serial port 1 RX ON
              	        ; back to normal running
3B01: FB      	        ei                      ; re-enable INTs
3B02: DB01    	        in      A,(PIO_DB)      ; load status LEDs
3B04: CBF7    	        set     6,A             ; set status LED on
3B06: CBA7    	        res     4,A             ; set error LED off
3B08: D301    	        out     (PIO_DB),A      ; send new configuration
3B0A: DDE1    	        pop     IX              ; retrieve IX
3B0C: D1      	        pop     DE              ; retrieve DE
3B0D: E1      	        pop     HL              ; retrieve HL
3B0E: C9      	        ret                     ; return to caller
              	
              	; allowed bps (Bauds per second)
3B0F: 00E10096	SUP_BPS:defw    57600,38400,28800,19200,14400,9600,4800,3600,2400,1200,600
3B13: 8070004B	
3B17: 40388025	
3B1B: C012100E	
3B1F: 6009B004	
3B23: 5802    	
              	; corresponding CTC divider
3B25: 02030406	CTC_CFG:defb    2,3,4,6,8,12,24,32,48,96,192
3B29: 080C1820	
3B2D: 3060C0  	
              	
              	; serial configuration error
3B30: DDE1    	SCERR1: pop     IX              ; retrieve IX
3B32: D1      	        pop     DE              ; retrieve DE
3B33: E1      	        pop     HL              ; retrieve HL
3B34: 1E2C    	SCERR:  ld      E,SC            ; Serial Configuration Error
3B36: C37915  	        jp      ERROR           ; print error
              	
              	; check for direct mode
3B39: E5      	DIRMOD: push    HL              ; Save code string address
3B3A: 2AAF80  	        ld      HL,(LINEAT)     ; Get current line number
3B3D: 23      	        inc     HL              ; -1 means direct statement
3B3E: 7C      	        ld      A,H
3B3F: B5      	        or      L
3B40: E1      	        pop     HL              ; Restore code string address
3B41: C25B3B  	        jp      NZ,HLPERR       ; raise error if in indirect mode
3B44: C9      	        ret
              	
              	
              	; HELP lists the line program where an error was found
3B45: CD393B  	HELP:   call    DIRMOD          ; check if in direct mode
3B48: E5      	        push    HL              ; store HL
3B49: 2AB180  	        ld      HL,(HLPLN)      ; load HELP line
3B4C: 23      	        inc     HL              ; increment HL
3B4D: 7C      	        ld      A,H
3B4E: B5      	        or      L               ; check if there is a line into the HELP reg.
3B4F: E1      	        pop     HL
3B50: CA5B3B  	        jp      Z,HLPERR        ; no line found, raise error
3B53: ED5BB180	        ld      DE,(HLPLN)      ; recover line
3B57: C1      	        pop     BC              ; remove BC from stack since it's not needed anymore for LIST
3B58: C3D518  	        jp      LST01H          ; jump to list line
3B5B: 1E30    	HLPERR: ld      E,HP            ; HELP call error
3B5D: C37915  	        jp      ERROR           ; raise error
              	
              	
              	; KEY command to list/modify function keys
3B60: 2B      	KEY:    dec     HL              ; dec 'cos GETCHR INCs
3B61: CD6A1A  	        call    GETCHR          ; Get next character
3B64: CAE43B  	        jp      Z,LSTKEYS       ; jump if nothing follows
              	                                ; change FN keys
3B67: CD6527  	        call    GETINT          ; get a number
3B6A: A7      	        and     A               ; is it 0?
3B6B: 2010    	        jr      NZ,KEYCH        ; no, jump over         
3B6D: E5      	        push    HL              ; yes - reset FN keys to defaults
3B6E: D5      	        push    DE              ; store HL & DE
3B6F: 215514  	        ld      HL,DEFFNKS      ; pointer to default FN keys texts
3B72: 11B380  	        ld      DE,FNKEYS       ; pointer to destination
3B75: 018000  	        ld      BC,$0080        ; 128 chars to be copied
3B78: EDB0    	        ldir                    ; restore default texts
3B7A: D1      	        pop     DE              ; retrieve DE
3B7B: E1      	        pop     HL              ; retrieve HL
3B7C: C9      	        ret                     ; return to caller
3B7D: FE09    	KEYCH:  cp      $09             ; is it >= 9?
3B7F: D26515  	        jp      NC,SNERR        ; yes - syntax error
3B82: 3D      	        dec     A               ; FN key in range 0~7
3B83: 87      	        add     A,A             ; multiply A...
3B84: 87      	        add     A,A             ; ... times 4...
3B85: 87      	        add     A,A             ; ... to get the correct...
3B86: 87      	        add     A,A             ; ... offset fo FN key text
3B87: 32EF81  	        ld      (TMPBFR1),A     ; store FN key offset...
3B8A: AF      	        xor     A               ; ...in a...
3B8B: 32F081  	        ld      (TMPBFR1+1),A   ; ...16-bit register
3B8E: CD4718  	        call    CHKSYN          ; Make sure ',' follows
3B91: 2C      	        defb    ','
3B92: 444D    	        ld      BC,HL           ; copy address into BC
3B94: CDF11E  	        call    EVAL            ; Evaluate expression (in E there is the length)
3B97: E5      	        push    HL              ; store string pointer
3B98: 3A9281  	        ld      A,(TYPE)        ; Get variable type
3B9B: B7      	        or      A               ; Is it a string variable?
3B9C: CA6515  	        jp      Z,SNERR         ; no - syntax error
3B9F: CD2A25  	        call    GSTRCU          ; Current string to pool
3BA2: CD3C2D  	        call    LOADFP          ; Move string block data to (BC=pointer, DE=length)
3BA5: 7B      	        ld      A,E             ; copy length into A
3BA6: FE11    	        cp      $11             ; is length > 16?
3BA8: DAAD3B  	        jp      C,DECLN1        ; no, jump over
3BAB: 1E10    	        ld      E,$10           ; yes, so set length to 16
3BAD: 3E10    	DECLN1: ld      A,$10           ; calculate how many...
3BAF: 93      	        sub     E               ; ...null chars needed to fill up...
3BB0: 57      	        ld      D,A             ; ...the FN key text
3BB1: C5      	        push    BC              ; store address of string 
3BB2: ED4BEF81	        ld      BC,(TMPBFR1)    ; load FN key offset
3BB6: 21B380  	        ld      HL,FNKEYS       ; load address of FN keys texts
3BB9: 09      	        add     HL,BC           ; get corrected address
3BBA: C1      	        pop     BC              ; retrieve address of string chars
3BBB: 0A      	CPKEY:  ld      A,(BC)          ; load char from string
3BBC: FE0D    	        cp      CR              ; return?
3BBE: CACB3B  	        jp      Z,CPKEY2        ; yes, store char
3BC1: FE7B    	        cp      $7B             ; if char > "z" ?
3BC3: D26515  	        jp      NC,SNERR        ; yes - syntax error
3BC6: FE20    	        cp      $20             ; is char < space?
3BC8: DA6515  	        jp      C,SNERR         ; yes - syntax error
3BCB: FE61    	CPKEY2: cp      $61             ; is it >= 'a'?
3BCD: DAD23B  	        jp      C,CPKEY3        ; no, continue
3BD0: E65F    	        and     %01011111       ; set letters to uppercase
3BD2: 77      	CPKEY3: ld      (HL),A          ; store char
3BD3: 23      	        inc     HL              ; next string char
3BD4: 03      	        inc     BC              ; next free cell
3BD5: 1D      	        dec     E               ; decrement E
3BD6: 20E3    	        jr      NZ,CPKEY        ; repeat until 0
3BD8: AF      	        xor     A               ; null char
3BD9: 14      	        inc     D               ; +1 to decrement below
3BDA: 15      	CPKEY1: dec     D               ; how many null chars to insert?
3BDB: CAE23B  	        jp      Z,CPKYEND       ; no more nulls, so exit
3BDE: 77      	        ld      (HL),A          ; store it
3BDF: 23      	        inc     HL              ; next cell
3BE0: 18F8    	        jr      CPKEY1          ; repeat
3BE2: E1      	CPKYEND:pop     HL              ; retrieve pointer to string
3BE3: C9      	        ret                     ; return to caller
              	                                ; list FN keys
3BE4: E5      	LSTKEYS:push    HL              ; Save code string address
3BE5: 2AAF80  	        ld      HL,(LINEAT)     ; Get current line number
3BE8: 23      	        inc     HL              ; -1 means direct statement
3BE9: 7C      	        ld      A,H
3BEA: B5      	        or      L
3BEB: E1      	        pop     HL              ; Restore code string address
3BEC: C26515  	        jp      NZ,SNERR        ; raise error if in indirect mode
3BEF: E5      	        push    HL              ; store HL
3BF0: D5      	        push    DE              ; store DE
3BF1: 21B380  	        ld      HL,FNKEYS       ; load starting address of FN keys text
3BF4: 0E01    	        ld      C,$01           ; 8 function keys
3BF6: 0610    	PRTK4:  ld      B,$10           ; 16 chars each
3BF8: 11973C  	PRTK2:  ld      DE,CHKEY1       ; message "KEY "
3BFB: CD883C  	        call    PRTCKEY         ; print it
3BFE: 79      	        ld      A,C             ; load FN key
3BFF: C630    	        add     $30             ; get number in ASCI code
3C01: CD5218  	        call    OUTC            ; print it
3C04: 119C3C  	        ld      DE,CHKEY2       ; message ": ""
3C07: CD883C  	        call    PRTCKEY         ; print it
3C0A: 3E01    	        ld      A,$01           ; " opened
3C0C: 32EF81  	        ld      (TMPBFR1),A
3C0F: 7E      	LDKEY:  ld      A,(HL)          ; retrieve char
3C10: A7      	        and     A               ; is it zero?
3C11: CA243C  	        jp      Z,CNTLTK        ; yes, go next char
3C14: CD703C  	        call    OPNQT           ; check if quotes are opened
3C17: FE22    	        cp      $22             ; check if char is "?
3C19: CA393C  	        jp      Z,PRTCHR        ; yes, print "chr$("
3C1C: FE0D    	        cp      CR              ; is it a CR?
3C1E: CA393C  	        jp      Z,PRTCHR        ; yes, print "chr$("
3C21: CD5218  	PRTK3:  call    OUTC            ; no, just print it
3C24: 23      	CNTLTK: inc     HL              ; next char
3C25: 10E8    	        djnz    LDKEY           ; continue until finished
3C27: CD5E3C  	        call    CLSQT           ; check if quotes are still open
3C2A: 3E0D    	        ld      A,CR            ; go next line
3C2C: CD5218  	        call    OUTC            ; print it
3C2F: 0C      	        inc     C               ; next FN key
3C30: 79      	        ld      A,C             ; check if...
3C31: FE09    	        cp      $09             ; finished keys?
3C33: DAF63B  	        jp      C,PRTK4         ; no, repeat 1 more time
3C36: D1      	        pop     DE              ; retrieve DE
3C37: E1      	        pop     HL              ; retrieve HL
3C38: C9      	        ret                     ; return to caller
              	
3C39: E5      	PRTCHR: push    HL              ; store HL
3C3A: CD5E3C  	        call    CLSQT           ; check if quotes are closed
3C3D: 3E2B    	        ld      A,'+'           ; '+' char
3C3F: CD5218  	        call    OUTC            ; print it
3C42: 119F3C  	        ld      DE,CHKEY3       ; address of "CHR$("
3C45: CD883C  	        call    PRTCKEY         ; print it
3C48: E1      	        pop     HL              ; recover HL
3C49: 23      	        inc     HL              ; next char
3C4A: 05      	        dec     B               ; increment char counter
3C4B: 11A53C  	        ld      DE,CHKEY4       ; load address of RETURN
3C4E: 7E      	        ld      A,(HL)          ; load char
3C4F: FE0D    	        cp      CR              ; is it a RETURN?
3C51: 2003    	        jr      NZ,PTCHR1       ; no, jump over
3C53: 11A83C  	        ld      DE,CHKEY5       ; yes, load address of "
3C56: CD883C  	PTCHR1: call    PRTCKEY         ; print it
3C59: 3E29    	        ld      A,')'           ; char )
3C5B: C3213C  	        jp      PRTK3           ; continue
              	
3C5E: F5      	CLSQT:  push    AF              ; store A
3C5F: 3AEF81  	        ld      A,(TMPBFR1)     ; quote status
3C62: A7      	        and     A               ; are they closed?
3C63: 2809    	        jr      Z,CLSQT1        ; if yes, return
3C65: 3E22    	        ld      A,$22           ; no, so close them
3C67: CD5218  	        call    OUTC            ; print "
3C6A: AF      	        xor     A               ; set quotes
3C6B: 32EF81  	        ld      (TMPBFR1),A     ; as closed
3C6E: F1      	CLSQT1: pop     AF              ; retrieve A
3C6F: C9      	        ret                     ; return to caller
              	
3C70: F5      	OPNQT:  push    AF              ; store A
3C71: 3AEF81  	        ld      A,(TMPBFR1)     ; quote status
3C74: A7      	        and     A               ; are they open?
3C75: 200F    	        jr      NZ,OPNQT1       ; if yes, return
3C77: 3E2B    	        ld      A,'+'           ; no, so add '+
3C79: CD5218  	        call    OUTC            ; print it
3C7C: 3E22    	        ld      A,$22           ; and then open quotes
3C7E: CD5218  	        call    OUTC            ; print them
3C81: 3E01    	        ld      A,$01           ; set quotes
3C83: 32EF81  	        ld      (TMPBFR1),A     ; as opened
3C86: F1      	OPNQT1: pop     AF              ; retrieve A
3C87: C9      	        ret                     ; return to caller
              	
3C88: F5      	PRTCKEY:push    AF              ; store original char
3C89: 1A      	PRTK1:  ld      A,(DE)          ; load char
3C8A: A7      	        and     A               ; is it 0?
3C8B: CA953C  	        jp      Z,PRTEND        ; yes, finished printing
3C8E: CD5218  	        call    OUTC            ; no, print char
3C91: 13      	        inc     DE              ; next char
3C92: C3893C  	        jp      PRTK1           ; repeat
3C95: F1      	PRTEND: pop     AF              ; retrieve AF
3C96: C9      	        ret                     ; return to caller
              	
3C97: 4B455920	CHKEY1: defb    "KEY ",0
3C9B: 00      	
3C9C: 3A2200  	CHKEY2: defb    ":",34,0
3C9F: 63687224	CHKEY3: defb    "chr$(",0
3CA3: 2800    	
3CA5: 313300  	CHKEY4: defb    "13",0
3CA8: 333400  	CHKEY5: defb    "34",0
              	
              	
              	; HEX$(nn) Convert 16 bit number to Hexadecimal string
3CAB: CDE21E  	HEX: 	call	TSTNUM          ; Verify it's a number
3CAE: CD201B  	        call	DEINT           ; Get integer -32768 to 32767
3CB1: C5      	        push	BC              ; Save contents of BC
3CB2: 213082  	        ld      HL,PBUFF        ; load address of PBUFF into HL
3CB5: 7A      	        ld      A,D             ; Get MSB into A
3CB6: B7      	        or      A               ; OR with LSB to see if param=0
3CB7: 280C    	        jr      Z,HEX2          ; Skip output if both high digits are zero
3CB9: CDE13C  	        call    BYT2ASC         ; Convert D to ASCII
3CBC: 78      	        ld      A,B             ; cechk if B
3CBD: FE30    	        cp      '0'             ; is 0
3CBF: 2802    	        jr      Z,HEX1          ; Don't store high digit if zero
3CC1: 70      	        ld      (HL),B          ; Store it to PBUFF
3CC2: 23      	        inc     HL              ; Next location
3CC3: 71      	HEX1:   ld      (HL),C          ; Store C to PBUFF+1
3CC4: 23      	        inc     HL              ; Next location
3CC5: 7B      	HEX2:   ld      A,E             ; Get lower byte
3CC6: CDE13C  	        call    BYT2ASC         ; Convert E to ASCII
3CC9: 7A      	        ld      A,D
3CCA: B7      	        or      A
3CCB: 2005    	        jr      NZ,HEX3         ; If upper byte was not zero then always print lower byte
3CCD: 78      	        ld      A,B
3CCE: FE30    	        cp      '0'             ; If high digit of lower byte is zero then don't print
3CD0: 2802    	        jr      Z,HEX4
3CD2: 70      	HEX3:   ld      (HL),B          ; to PBUFF+2
3CD3: 23      	        inc     HL              ; Next location
3CD4: 71      	HEX4:   ld      (HL),C          ; to PBUFF+3
3CD5: 23      	        inc     HL              ; PBUFF+4 to zero
3CD6: AF      	        xor     A               ; Terminating character
3CD7: 77      	        ld      (HL),A          ; Store zero to terminate
3CD8: 23      	        inc     HL              ; Make sure PBUFF is terminated
3CD9: 77      	        ld      (HL),A          ; Store the double zero there
3CDA: C1      	        pop     BC              ; Get BC back
3CDB: 213082  	        ld      HL,PBUFF        ; Reset to start of PBUFF
3CDE: C37723  	        jp      STR1            ; Convert the PBUFF to a string and return it
3CE1: 47      	BYT2ASC	ld      B,A             ; Save original value
3CE2: E60F    	        and     $0F             ; Strip off upper nybble
3CE4: FE0A    	        cp      $0A             ; 0-9?
3CE6: 3802    	        jr      C,ADD30         ; If A-F, add 7 more
3CE8: C607    	        add     A,$07           ; Bring value up to ASCII A-F
3CEA: C630    	ADD30	add     A,$30           ; And make ASCII
3CEC: 4F      	        ld      C,A             ; Save converted char to C
3CED: 78      	        ld      A,B             ; Retrieve original value
3CEE: 0F      	        rrca                    ; and Rotate it right
3CEF: 0F      	        rrca
3CF0: 0F      	        rrca
3CF1: 0F      	        rrca
3CF2: E60F    	        and     $0F             ; Mask off upper nybble
3CF4: FE0A    	        cp      $0A             ; 0-9? < A hex?
3CF6: 3802    	        jr      C,ADD301        ; Skip Add 7
3CF8: C607    	        add     A,$07           ; Bring it up to ASCII A-F
3CFA: C630    	ADD301	add     A,$30           ; And make it full ASCII
3CFC: 47      	        ld      B,A             ; Store high order byte
3CFD: C9      	        ret
              	
              	; Convert "&Hnnnn" to FPREG
              	; Gets a character from (HL) checks for Hexadecimal ASCII numbers "&Hnnnn"
              	; Char is in A, NC if char is ;<=>?@ A-z, CY is set if 0-9
3CFE: EB      	HEXTFP  ex      DE,HL           ; Move code string pointer to DE
3CFF: 210000  	        ld      HL,$0000        ; Zero out the value
3D02: CD173D  	        call    GETHEX          ; Check the number for valid hex
3D05: DA373D  	        jp      C,HXERR         ; First value wasn't hex, HX error
3D08: 1805    	        jr      HEXLP1          ; Convert first character
3D0A: CD173D  	HEXLP   call    GETHEX          ; Get second and addtional characters
3D0D: 381F    	        jr      C,HEXIT         ; Exit if not a hex character
3D0F: 29      	HEXLP1  add     HL,HL           ; Rotate 4 bits to the left
3D10: 29      	        add     HL,HL
3D11: 29      	        add     HL,HL
3D12: 29      	        add     HL,HL
3D13: B5      	        or      L               ; Add in D0-D3 into L
3D14: 6F      	        ld      L,A             ; Save new value
3D15: 18F3    	        jr      HEXLP           ; And continue until all hex characters are in
              	
3D17: 13      	GETHEX  inc     DE              ; Next location
3D18: 1A      	        ld      A,(DE)          ; Load character at pointer
3D19: FE20    	        cp      SPC
3D1B: CA173D  	        jp      Z,GETHEX        ; Skip spaces
3D1E: D630    	        sub     $30             ; Get absolute value
3D20: D8      	        ret     C               ; < "0", error
3D21: FE0A    	        cp      $0A
3D23: 3805    	        jr      C,NOSUB7        ; Is already in the range 0-9
3D25: D607    	        sub     $07             ; Reduce to A-F
3D27: FE0A    	        cp      $0A             ; Value should be $0A-$0F at this point
3D29: D8      	        ret     C               ; CY set if was :            ; < = > ? @
3D2A: FE10    	NOSUB7  cp      $10             ; > Greater than "F"?
3D2C: 3F      	        ccf
3D2D: C9      	        ret                     ; CY set if it wasn't valid hex
              	
3D2E: EB      	HEXIT   ex      DE,HL           ; Value into DE, Code string into HL
3D2F: 7A      	        ld      A,D             ; Load DE into AC
3D30: 4B      	        ld      C,E             ; For prep to
3D31: E5      	        push    HL
3D32: CDC822  	        call    ACPASS          ; ACPASS to set AC as integer into FPREG
3D35: E1      	        pop     HL
3D36: C9      	        ret
              	
3D37: 1E26    	HXERR:  ld      E,HX            ; ?HEX Error
3D39: C37915  	        jp      ERROR
              	
              	; BIN$(NN) Convert integer to a 1-16 char binary string
3D3C: CDE21E  	BIN:    call    TSTNUM          ; Verify it's a number
3D3F: CD201B  	        call    DEINT           ; Get integer -32768 to 32767
3D42: C5      	BIN2:   push    BC              ; Save contents of BC
3D43: 213082  	        ld      HL,PBUFF
3D46: 0611    	        ld      B,$11           ; One higher than max char count (16+1)
3D48:         	ZEROSUP:                        ; Suppress leading zeros
3D48: 05      	        dec     B               ; Max 16 chars
3D49: 78      	        ld      A,B
3D4A: FE01    	        cp      $01
3D4C: 2808    	        jr      Z,BITOUT        ; Always output at least one character
3D4E: CB13    	        rl      E
3D50: CB12    	        rl      D
3D52: 30F4    	        jr      NC,ZEROSUP
3D54: 1804    	        jr      BITOUT2
3D56: CB13    	BITOUT: rl      E
3D58: CB12    	        rl      D               ; Top bit now in carry
3D5A: 3E30    	BITOUT2:ld      A,'0'           ; Char for '0'
3D5C: CE00    	        adc     A,$00           ; If carry set then '0' --> '1'
3D5E: 77      	        ld      (HL),A
3D5F: 23      	        inc     HL
3D60: 05      	        dec     B
3D61: 20F3    	        jr      NZ,BITOUT
3D63: AF      	        xor     A               ; Terminating character
3D64: 77      	        ld      (HL),A          ; Store zero to terminate
3D65: 23      	        inc     HL              ; Make sure PBUFF is terminated
3D66: 77      	        ld      (HL),A          ; Store the double zero there
3D67: C1      	        pop     BC
3D68: 213082  	        ld      HL,PBUFF
3D6B: C37723  	        jp      STR1
              	
              	; Convert "&Bnnnn" to FPREG
              	; Gets a character from (HL) checks for Binary ASCII numbers "&Bnnnn"
3D6E: EB      	BINTFP: ex      DE,HL           ; Move code string pointer to DE
3D6F: 210000  	        ld      HL,$0000        ; Zero out the value
3D72: CD8B3D  	        call    CHKBIN          ; Check the number for valid bin
3D75: DA993D  	        jp      C,BINERR        ; First value wasn't bin, HX error
3D78: D630    	BINIT:  sub     '0'
3D7A: 29      	        add     HL,HL           ; Rotate HL left
3D7B: B5      	        or      L
3D7C: 6F      	        ld      L,A
3D7D: CD8B3D  	        call    CHKBIN          ; Get second and addtional characters
3D80: 30F6    	        jr      NC,BINIT        ; Process if a bin character
3D82: EB      	        ex      DE,HL           ; Value into DE, Code string into HL
3D83: 7A      	        ld      A,D             ; Load DE into AC
3D84: 4B      	        ld      C,E             ; For prep to
3D85: E5      	        push    HL
3D86: CDC822  	        call    ACPASS          ; ACPASS to set AC as integer into FPREG
3D89: E1      	        pop     HL
3D8A: C9      	        ret
              	
              	; Char is in A, NC if char is 0 or 1
3D8B: 13      	CHKBIN: inc     DE
3D8C: 1A      	        ld      A,(DE)
3D8D: FE20    	        cp      SPC
3D8F: CA8B3D  	        jp      Z,CHKBIN        ; Skip spaces
3D92: FE30    	        cp      '0'             ; Set C if < '0'
3D94: D8      	        ret     C
3D95: FE32    	        cp      '2'
3D97: 3F      	        ccf                     ; Set C if > '1'
3D98: C9      	        ret
              	
3D99: 1E28    	BINERR: ld      E,BN            ; ?BIN Error
3D9B: C37915  	        jp      ERROR
              	
              	
3D9E: C30800  	MONOUT: jp      $0008           ; output a char
              	
              	
3DA1: 3A2E82  	RESET:  ld      A,(SERIALS_EN)
3DA4: E601    	        and     $01             ; is serial port #1 open?
3DA6: C46439  	        call    NZ,RSTSER1      ; yes, reset serial 1
3DA9: CD8027  	        call    DISNMI          ; disable NMI vector
3DAC: F3      	        di                      ; disable INTs
3DAD: C30000  	        jp      $0000           ; Restart
              	
              	
3DB0: 3E00    	INITST: ld      A,$00           ; Clear break flag
3DB2: 32A980  	        ld      (BRKFLG),A
3DB5: C3060F  	        jp      INIT
              	
              	
3DB8: F5      	TSTBIT: push    AF              ; Save bit mask
3DB9: A0      	        and     B               ; Get common bits
3DBA: C1      	        pop     BC              ; Restore bit mask
3DBB: B8      	        cp      B               ; Same bit set?
3DBC: 3E00    	        ld      A,$00           ; Return 0 in A
3DBE: C9      	        ret
              	
3DBF: CD5218  	OUTNCR: call    OUTC            ; Output character in A
3DC2: C3231D  	        jp      PRNTCRLF        ; Output CRLF
              	; ------------------------------------------------------------------------------
              	; LM80C - UTILITY ROUTINES - R1.1
              	; ------------------------------------------------------------------------------
              	; The following code is intended to be used with LM80C Z80-based computer
              	; designed by Leonardo Miliani. More info at
              	; www DOT leonardomiliani DOT com
              	;
              	; *ALS are routines from "Z80 Assembly Language Subroutines" by Lance
              	; A. Leventhal and Winthrop Saville - Ed. Osborne/McGraw-Hill (1983)
              	;
              	; * WKT are routines from WikiTI:
              	; http://wikiti.brandonw.net/index.php?title=WikiTI_Home
              	;
              	; * LAC are routines from Learn@Cemetch
              	; https://learn.cemetech.net/index.php/Main_Page
              	;
              	; ------------------------------------------------------------------------------
              	; Code Revision:
              	; R1.0 - 20200110 - First release: 16-bit comparision/multiplication/negation
              	; R1.1 - 20200413 - Second release: added ABS(HL) 
              	;
              	; ------------------------------------------------------------------------------
              	
              	; compare two 16-bit registers, HL (minuend) and DE (subtrahend)
              	; values can be both signed or unsigned words
              	; inputs: HL, DE
              	; destroys: A,F,HL
              	; returns: if both registers are 2's complement, use Z and S flags;
              	; otherwise:
              	; if HL=DE: Z,P,NC  - Z=1, S=0; C=0
              	; if HL>DE: NZ,P,NC - Z=0, S=0; C=0
              	; if HL<DE: NZ,M,C  - Z=0, S=1; C=1
              	; Source: ALS
              	
3DC5: B7      	CMP16:  or      A           ; clear CARRY
3DC6: ED52    	        sbc     HL,DE       ; subtract DE from HL
3DC8: E0      	        ret     PO          ; return if no overflow
3DC9: 7C      	        ld      A,H         ; overflow - invert SIGN flag
3DCA: 1F      	        rra                 ; save CARRY flag in bit 7
3DCB: EE40    	        xor     %01000000   ; complement bit 6 (SIGN bit)
3DCD: 37      	        scf                 ; ensure a Non-Zero result
3DCE: 8F      	        adc     A,A         ; restore CARRY, complemented SIGN
              	                            ; ZERO flag = 0 for sure
3DCF: C9      	        ret                 ; return
              	
              	; ----------------------------------------------------------------------
              	
              	; multiply 2 signed/unsigned 16-bit words and return a 16-bit
              	; signed/unsigned product
              	; inputs: HL (multiplicand); DE (multiplier)
              	; destroys: A,F
              	; returns: HL (product)
              	; Source: ALS
              	
              	; initialize partial product, bit count
3DD0: C5      	MUL16:  push    BC
3DD1: 4D      	        ld      C,L         ; BC = multiplier
3DD2: 44      	        ld      B,H
3DD3: 210000  	        ld      HL,0        ; product = 0
3DD6: 3E0F    	        ld      A,$0F       ; count = bit lenght - 1 (16-1)
              	        ; shift-and-add algorithm
              	        ; if MSB of multiplier is 1, add multiplicand to partial product
              	        ; shift partial product, multiplier left 1 bit
3DD8: CB23    	MLP:    sla     E           ; shift multiplier left 1 bit
3DDA: CB12    	        rl      D
3DDC: 3001    	        jr      NC,MLP1     ; jump if MSB of multiplier = 0
3DDE: 09      	        add     HL,BC       ; add multiplicand to partial product
3DDF: 29      	MLP1:   add     HL,HL       ; shift partial product left
3DE0: 3D      	        dec     A
3DE1: 20F5    	        jr      NZ,MLP      ; continue until count = 0
              	        ; add multiplicand one last time if MSB of multiplier is 1
3DE3: B2      	        or      D           ; sign flag = MSB of multiplier
3DE4: F2E83D  	        jp      P,EXMUL16   ; exit if MSB of multiplier is 0
3DE7: 09      	        add     HL,BC       ; add multiplicand to product
3DE8: C1      	EXMUL16:pop     BC
3DE9: C9      	        ret
              	
              	; ----------------------------------------------------------------------
              	; absolute value of HL (same applies to other 16-bit register pairs)
              	; also, invert value of HL (or any other 16-bit register, just adjust the code)
              	;
              	; inputs: HL
              	; destroys: A
              	; operation: ABS(HL)
              	; returns: HL with no sign or negated
              	; Source: WKT
              	
3DEA: CB7C    	absHL:  bit     7,H
3DEC: C8      	        ret     Z
3DED: AF      	negHL:  xor     A
3DEE: 95      	        sub     L
3DEF: 6F      	        ld      L,A
3DF0: 9F      	        sbc     A,A
3DF1: 94      	        sub     H
3DF2: 67      	        ld      H,A
3DF3: C9      	        ret
              	
              	; ------------------------------------------------------------------------------
              	
              	; 8/8 division
              	; INPUT: D (dividend), E (divisor)
              	; OPERATION: D/E
              	; OUTPUT: D (quotient), A (remainder)
3DF4: AF      	DIV_8_8:    xor     A
3DF5: C5      	            push    BC
3DF6: 0608    	            ld      B,08h
3DF8: CB22    	DIV_8_8LOOP:sla     D
3DFA: 17      	            rla
3DFB: BB      	            cp      E
3DFC: 3802    	            jr      C,$+4
3DFE: 93      	            sub     E
3DFF: 14      	            inc     D
3E00: 10F6    	            djnz    DIV_8_8LOOP
3E02: C1      	            pop     BC
3E03: C9      	            ret
              	
              	; ----------------------------------------------------------------------
              	; divide a 16-bit number by an 8-bit number
              	; (16/8 division)
              	;
              	; inputs: HL (Dividend), C (divisor)
              	; destroys: A
              	; OPERATION: HL/C
              	; returns: HL (quotient), A (remainder)
              	; source: WKT
              	
3E04: AF      	DIV_16_8:   xor     A
3E05: 0610    	            ld      B,16
3E07: 29      	DIV_16_8LP: add     HL,HL
3E08: 17      	            rla
3E09: 3803    	            jr      C,$+5
3E0B: B9      	            cp      C
3E0C: 3802    	            jr      C,$+4
3E0E: 91      	            sub     C
3E0F: 2C      	            inc     L
3E10: 10F5    	            djnz    DIV_16_8LP
3E12: C9      	            ret; ------------------------------------------------------------------------------
              	; LM80C - 6x8 CHARSET - R1.5
              	; ------------------------------------------------------------------------------
              	; The following code is intended to be used with LM80C Z80-based computer
              	; designed by Leonardo Miliani. More info at
              	; www DOT leonardomiliani DOT com
              	; ------------------------------------------------------------------------------
              	; Code Revision:
              	; R1.0 - 20190511 - First revision: ASCII chars (from 0 to 127)
              	; R1.1 - 20190521 - Expanded to 255 chars
              	; R1.2 - 20191209 - Start adding graphic chars to be coherent with 8x8 fonts
              	; R1.3 - 20191226 - Added extended char codes (128-255)
              	; R1.4 - 20200228 - adopted more usual hexadecimal & binary prefixes
              	; R1.5 - 20200524 - New style for char #252
              	; ------------------------------------------------------------------------------
              	;
              	;-------------------------------------------------------------------------------
              	;
              	;               6 x 8    C  H  A  R  S  E  T
              	;
              	;-------------------------------------------------------------------------------
              	;
              	;       6X8 CHARS, DESIGNED FOR TEXT BUT USABLE IN GRAPHICS 1 MODE TOO
              	;       UPDATE: NOW GRAPHICS 1 MODE HAS ITS OWN CHAR SET
              	
3E13:         	CHRST68 equ $
3E13: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 0 (null char)
3E17: 00000000	
3E1B: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 1 F1
3E1F: 00000000	
3E23: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 2 F2
3E27: 00000000	
3E2B: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 3 CTRL-C
3E2F: 00000000	
3E33: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 4 F3
3E37: 00000000	
3E3B: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 5 F4
3E3F: 00000000	
3E43: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 6 F5
3E47: 00000000	
3E4B: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 7 (bell)
3E4F: 00000000	
3E53: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 8 (backspace)
3E57: 00000000	
3E5B: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 9 (H. tab)
3E5F: 00000000	
3E63: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 10 (line feed)
3E67: 00000000	
3E6B: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 11 
3E6F: 00000000	
3E73: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 12 Form feed (clear screen)
3E77: 00000000	
3E7B: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 13 (carriage return)
3E7F: 00000000	
3E83: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 14 CTRL
3E87: 00000000	
3E8B: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 15 CTRL-O
3E8F: 00000000	
3E93: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 16 C=/Graphic key
3E97: 00000000	
3E9B: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 17 CTRL-Q
3E9F: 00000000	
3EA3: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 18 CTRL-R
3EA7: 00000000	
3EAB: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 19 CTRL-S
3EAF: 00000000	
3EB3: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 20 SHIFT
3EB7: 00000000	
3EBB: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 21 CTRL-U
3EBF: 00000000	
3EC3: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 22 F6
3EC7: 00000000	
3ECB: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 23 F7
3ECF: 00000000	
3ED3: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 24 HELP
3ED7: 00000000	
3EDB: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 25 (home)
3EDF: 00000000	
3EE3: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 26
3EE7: 00000000	
3EEB: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 27 (escape)
3EEF: 00000000	
3EF3: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 28 (cursor left)
3EF7: 00000000	
3EFB: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 29 (cursor right)
3EFF: 00000000	
3F03: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 30 (cursor up)
3F07: 00000000	
3F0B: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 31 (cursor down)
3F0F: 00000000	
3F13: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 32: space
3F17: 00000000	
3F1B: 20202020	        defb $20,$20,$20,$20,$20,$00,$20,$00 ; char 33: !
3F1F: 20002000	
3F23: 50500000	        defb $50,$50,$00,$00,$00,$00,$00,$00 ; char 34: "
3F27: 00000000	
3F2B: 5050F850	        defb $50,$50,$f8,$50,$f8,$50,$50,$00 ; char 35: #
3F2F: F8505000	
3F33: 2078A070	        defb $20,$78,$a0,$70,$28,$f0,$20,$00 ; char 36: $
3F37: 28F02000	
3F3B: C0C81020	        defb $c0,$c8,$10,$20,$40,$98,$18,$00 ; char 37: %
3F3F: 40981800	
3F43: 6090A040	        defb $60,$90,$a0,$40,$a8,$90,$68,$00 ; char 38: &
3F47: A8906800	
3F4B: 60204000	        defb $60,$20,$40,$00,$00,$00,$00,$00 ; char 39: '
3F4F: 00000000	
3F53: 10204040	        defb $10,$20,$40,$40,$40,$20,$10,$00 ; char 40: (
3F57: 40201000	
3F5B: 40201010	        defb $40,$20,$10,$10,$10,$20,$40,$00 ; char 41: )
3F5F: 10204000	
3F63: 0020A870	        defb $00,$20,$a8,$70,$a8,$20,$00,$00 ; char 42: *
3F67: A8200000	
3F6B: 002020F8	        defb $00,$20,$20,$f8,$20,$20,$00,$00 ; char 43: +
3F6F: 20200000	
3F73: 00000000	        defb $00,$00,$00,$00,$60,$20,$40,$00 ; char 44: ,
3F77: 60204000	
3F7B: 000000F8	        defb $00,$00,$00,$f8,$00,$00,$00,$00 ; char 45: -
3F7F: 00000000	
3F83: 00000000	        defb $00,$00,$00,$00,$00,$60,$60,$00 ; char 46: .
3F87: 00606000	
3F8B: 00081020	        defb $00,$08,$10,$20,$40,$80,$00,$00 ; char 47: /
3F8F: 40800000	
3F93: 708898A8	        defb $70,$88,$98,$a8,$c8,$88,$70,$00 ; char 48: 0
3F97: C8887000	
3F9B: 20602020	        defb $20,$60,$20,$20,$20,$20,$70,$00 ; char 49: 1
3F9F: 20207000	
3FA3: 70880810	        defb $70,$88,$08,$10,$20,$40,$f8,$00 ; char 50: 2
3FA7: 2040F800	
3FAB: F8102010	        defb $f8,$10,$20,$10,$08,$88,$70,$00 ; char 51: 3
3FAF: 08887000	
3FB3: 10305090	        defb $10,$30,$50,$90,$f8,$10,$10,$00 ; char 52: 4
3FB7: F8101000	
3FBB: F880F008	        defb $f8,$80,$f0,$08,$08,$88,$70,$00 ; char 53: 5
3FBF: 08887000	
3FC3: 304080F0	        defb $30,$40,$80,$f0,$88,$88,$70,$00 ; char 54: 6
3FC7: 88887000	
3FCB: F8081020	        defb $f8,$08,$10,$20,$40,$40,$40,$00 ; char 55: 7
3FCF: 40404000	
3FD3: 70888870	        defb $70,$88,$88,$70,$88,$88,$70,$00 ; char 56: 8
3FD7: 88887000	
3FDB: 70888878	        defb $70,$88,$88,$78,$08,$10,$60,$00 ; char 57: 9
3FDF: 08106000	
3FE3: 00303000	        defb $00,$30,$30,$00,$30,$30,$00,$00 ; char 58: :
3FE7: 30300000	
3FEB: 00303000	        defb $00,$30,$30,$00,$30,$10,$20,$00 ; char 59: ;
3FEF: 30102000	
3FF3: 10204080	        defb $10,$20,$40,$80,$40,$20,$10,$00 ; char 60: <
3FF7: 40201000	
3FFB: 0000F800	        defb $00,$00,$f8,$00,$f8,$00,$00,$00 ; char 61: =
3FFF: F8000000	
4003: 40201008	        defb $40,$20,$10,$08,$10,$20,$40,$00 ; char 62: >
4007: 10204000	
400B: 70880810	        defb $70,$88,$08,$10,$20,$00,$20,$00 ; char 63: ?
400F: 20002000	
4013: 70880868	        defb $70,$88,$08,$68,$a8,$a8,$70,$00 ; char 64: @
4017: A8A87000	
401B: 70888888	        defb $70,$88,$88,$88,$f8,$88,$88,$00 ; char 65: A
401F: F8888800	
4023: F08888F0	        defb $f0,$88,$88,$f0,$88,$88,$f0,$00 ; char 66: B
4027: 8888F000	
402B: 70888080	        defb $70,$88,$80,$80,$80,$88,$70,$00 ; char 67: C
402F: 80887000	
4033: E0908888	        defb $e0,$90,$88,$88,$88,$90,$e0,$00 ; char 68: D
4037: 8890E000	
403B: F88080F0	        defb $f8,$80,$80,$f0,$80,$80,$f8,$00 ; char 69: E
403F: 8080F800	
4043: F88080F0	        defb $f8,$80,$80,$f0,$80,$80,$80,$00 ; char 70: F
4047: 80808000	
404B: 708880B8	        defb $70,$88,$80,$b8,$88,$88,$78,$00 ; char 71: G
404F: 88887800	
4053: 888888F8	        defb $88,$88,$88,$f8,$88,$88,$88,$00 ; char 72: H
4057: 88888800	
405B: 70202020	        defb $70,$20,$20,$20,$20,$20,$70,$00 ; char 73: I
405F: 20207000	
4063: 38101010	        defb $38,$10,$10,$10,$10,$90,$60,$00 ; char 74: J
4067: 10906000	
406B: 8890A0C0	        defb $88,$90,$a0,$c0,$a0,$90,$88,$00 ; char 75: K
406F: A0908800	
4073: 80808080	        defb $80,$80,$80,$80,$80,$80,$f8,$00 ; char 76: L
4077: 8080F800	
407B: 88D8A8A8	        defb $88,$d8,$a8,$a8,$88,$88,$88,$00 ; char 77: M
407F: 88888800	
4083: 88C8A898	        defb $88,$c8,$a8,$98,$88,$88,$88,$00 ; char 78: N
4087: 88888800	
408B: 70888888	        defb $70,$88,$88,$88,$88,$88,$70,$00 ; char 79: O
408F: 88887000	
4093: F08888F0	        defb $f0,$88,$88,$f0,$80,$80,$80,$00 ; char 80: P
4097: 80808000	
409B: 70888888	        defb $70,$88,$88,$88,$a8,$90,$68,$00 ; char 81: Q
409F: A8906800	
40A3: F08888F0	        defb $f0,$88,$88,$f0,$a0,$90,$88,$00 ; char 82: R
40A7: A0908800	
40AB: 78808070	        defb $78,$80,$80,$70,$08,$08,$f0,$00 ; char 83: S
40AF: 0808F000	
40B3: F8202020	        defb $f8,$20,$20,$20,$20,$20,$20,$00 ; char 84: T
40B7: 20202000	
40BB: 88888888	        defb $88,$88,$88,$88,$88,$88,$70,$00 ; char 85: U
40BF: 88887000	
40C3: 88888888	        defb $88,$88,$88,$88,$88,$50,$20,$00 ; char 86: V
40C7: 88502000	
40CB: 88888888	        defb $88,$88,$88,$88,$a8,$a8,$50,$00 ; char 87: W
40CF: A8A85000	
40D3: 88885020	        defb $88,$88,$50,$20,$50,$88,$88,$00 ; char 88: X
40D7: 50888800	
40DB: 88888850	        defb $88,$88,$88,$50,$20,$20,$20,$00 ; char 89: Y
40DF: 20202000	
40E3: F8081020	        defb $f8,$08,$10,$20,$40,$80,$f8,$00 ; char 90: Z
40E7: 4080F800	
40EB: 70404040	        defb $70,$40,$40,$40,$40,$40,$70,$00 ; char 91: [
40EF: 40407000	
40F3: 00804020	        defb $00,$80,$40,$20,$10,$08,$00,$00 ; char 92: \
40F7: 10080000	
40FB: 70101010	        defb $70,$10,$10,$10,$10,$10,$70,$00 ; char 93: ]
40FF: 10107000	
4103: 20508800	        defb $20,$50,$88,$00,$00,$00,$00,$00 ; char 94: ^
4107: 00000000	
410B: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$FC ; char 95: _ (underscore)
410F: 000000FC	
4113: 40201000	        defb $40,$20,$10,$00,$00,$00,$00,$00 ; char 96: `
4117: 00000000	
411B: 00007008	        defb $00,$00,$70,$08,$78,$88,$78,$00 ; char 97: a
411F: 78887800	
4123: 808080B0	        defb $80,$80,$80,$b0,$c8,$88,$f0,$00 ; char 98: b
4127: C888F000	
412B: 00007080	        defb $00,$00,$70,$80,$80,$88,$70,$00 ; char 99: c
412F: 80887000	
4133: 08080868	        defb $08,$08,$08,$68,$98,$88,$78,$00 ; char 100: d
4137: 98887800	
413B: 00007088	        defb $00,$00,$70,$88,$f8,$80,$70,$00 ; char 101: e
413F: F8807000	
4143: 304840E0	        defb $30,$48,$40,$e0,$40,$40,$40,$00 ; char 102: f
4147: 40404000	
414B: 00007888	        defb $00,$00,$78,$88,$78,$08,$70,$00 ; char 103: g
414F: 78087000	
4153: 8080B0C8	        defb $80,$80,$b0,$c8,$88,$88,$88,$00 ; char 104: h
4157: 88888800	
415B: 20002020	        defb $20,$00,$20,$20,$20,$20,$20,$00 ; char 105: i
415F: 20202000	
4163: 08000808	        defb %00001000,%00000000,%00001000,%00001000,%00001000,%10001000,%01110000,%00000000 ; char 106: j
4167: 08887000	
416B: 808090A0	        defb $80,$80,$90,$a0,$c0,$a0,$90,$00 ; char 107: k
416F: C0A09000	
4173: 60202020	        defb $60,$20,$20,$20,$20,$20,$70,$00 ; char 108: l
4177: 20207000	
417B: 0000D0A8	        defb $00,$00,$d0,$a8,$a8,$88,$88,$00 ; char 109: m
417F: A8888800	
4183: 0000B0C8	        defb $00,$00,$b0,$c8,$88,$88,$88,$00 ; char 110: n
4187: 88888800	
418B: 00007088	        defb $00,$00,$70,$88,$88,$88,$70,$00 ; char 111: o
418F: 88887000	
4193: 0000F088	        defb $00,$00,$f0,$88,$f0,$80,$80,$00 ; char 112: p
4197: F0808000	
419B: 00007888	        defb $00,$00,$78,$88,$78,$08,$08,$00 ; char 113: q
419F: 78080800	
41A3: 0000B0C8	        defb $00,$00,$b0,$c8,$80,$80,$80,$00 ; char 114: r
41A7: 80808000	
41AB: 00007080	        defb $00,$00,$70,$80,$70,$08,$f0,$00 ; char 115: s
41AF: 7008F000	
41B3: 4040E040	        defb $40,$40,$e0,$40,$40,$48,$30,$00 ; char 116: t
41B7: 40483000	
41BB: 00008888	        defb $00,$00,$88,$88,$88,$98,$68,$00 ; char 117: u
41BF: 88986800	
41C3: 00008888	        defb $00,$00,$88,$88,$88,$50,$20,$00 ; char 118: v
41C7: 88502000	
41CB: 00008888	        defb $00,$00,$88,$88,$a8,$a8,$50,$00 ; char 119: w
41CF: A8A85000	
41D3: 00008850	        defb $00,$00,$88,$50,$20,$50,$88,$00 ; char 120: x
41D7: 20508800	
41DB: 00008898	        defb $00,$00,$88,$98,$68,$08,$70,$00 ; char 121: y
41DF: 68087000	
41E3: 0000F810	        defb $00,$00,$f8,$10,$20,$40,$f8,$00 ; char 122: z
41E7: 2040F800	
41EB: 10202040	        defb $10,$20,$20,$40,$20,$20,$10,$00 ; char 123: {
41EF: 20201000	
41F3: 20202020	        defb $20,$20,$20,$20,$20,$20,$20,$00 ; char 124: |
41F7: 20202000	
41FB: 20101008	        defb $20,$10,$10,$08,$10,$10,$20,$00 ; char 125: }
41FF: 10102000	
4203: 00285000	        defb $00,$28,$50,$00,$00,$00,$00,$00 ; char 126: ~
4207: 00000000	
420B: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 127: (delete) - here end the standard ASCII (0-127)
420F: 00000000	
4213: 7884CC84	        defb %01111000,%10000100,%11001100,%10000100,%10110100,%10000100,%01111000,%00000000 ; char 128 (open face)
4217: B4847800	
421B: 78FCB4FC	        defb %01111000,%11111100,%10110100,%11111100,%10110100,%11001100,%01111000,%00000000 ; char 129 (full face)
421F: B4CC7800	
4223: 48FCFCFC	        defb %01001000,%11111100,%11111100,%11111100,%11111100,%01111000,%00110000,%00000000 ; char 130 (hearts)
4227: FC783000	
422B: 002070F8	        defb %00000000,%00100000,%01110000,%11111000,%11111000,%01110000,%00100000,%00000000 ; char 131 (diamonds)
422F: F8702000	
4233: 7020A8F8	        defb %01110000,%00100000,%10101000,%11111000,%10101000,%00100000,%01110000,%00000000 ; char 132 (clubs)
4237: A8207000	
423B: 2070F8F8	        defb %00100000,%01110000,%11111000,%11111000,%10101000,%00100000,%01110000,%00000000 ; char 133 (spades)
423F: A8207000	
4243: 303030FC	        defb %00110000,%00110000,%00110000,%11111100,%11111100,%00110000,%00110000,%00110000 ; char 134 
4247: FC303030	
424B: 0000003C	        defb %00000000,%00000000,%00000000,%00111100,%00111100,%00110000,%00110000,%00110000 ; char 135 
424F: 3C303030	
4253: 000000F0	        defb %00000000,%00000000,%00000000,%11110000,%11110000,%00110000,%00110000,%00110000 ; char 136 
4257: F0303030	
425B: 303030F0	        defb %00110000,%00110000,%00110000,%11110000,%11110000,%00000000,%00000000,%00000000 ; char 137 
425F: F0000000	
4263: 3030303C	        defb %00110000,%00110000,%00110000,%00111100,%00111100,%00000000,%00000000,%00000000 ; char 138 
4267: 3C000000	
426B: 303030FC	        defb %00110000,%00110000,%00110000,%11111100,%11111100,%00000000,%00000000,%00000000 ; char 139 
426F: FC000000	
4273: 3030303C	        defb %00110000,%00110000,%00110000,%00111100,%00111100,%00110000,%00110000,%00110000 ; char 140 
4277: 3C303030	
427B: 000000FC	        defb %00000000,%00000000,%00000000,%11111100,%11111100,%00110000,%00110000,%00110000 ; char 141 
427F: FC303030	
4283: 303030F0	        defb %00110000,%00110000,%00110000,%11110000,%11110000,%00110000,%00110000,%00110000 ; char 142 
4287: F0303030	
428B: 000000FC	        defb %00000000,%00000000,%00000000,%11111100,%11111100,%00000000,%00000000,%00000000 ; char 143 
428F: FC000000	
4293: 30303030	        defb %00110000,%00110000,%00110000,%00110000,%00110000,%00110000,%00110000,%00110000 ; char 144 
4297: 30303030	
429B: 0C1C1838	        defb %00001100,%00011100,%00011000,%00111000,%01110000,%01100000,%11100000,%11000000 ; char 145 
429F: 7060E0C0	
42A3: C0E06070	        defb %11000000,%11100000,%01100000,%01110000,%00111000,%00011000,%00011100,%00001100 ; char 146 
42A7: 38181C0C	
42AB: CCCC7830	        defb %11001100,%11001100,%01111000,%00110000,%00110000,%01111000,%11001100,%11001100 ; char 147 
42AF: 3078CCCC	
42B3: 202020FC	        defb %00100000,%00100000,%00100000,%11111100,%00100000,%00100000,%00100000,%00100000 ; char 148 
42B7: 20202020	
42BB: 0000003C	        defb %00000000,%00000000,%00000000,%00111100,%00100000,%00100000,%00100000,%00100000 ; char 149 
42BF: 20202020	
42C3: 000000E0	        defb %00000000,%00000000,%00000000,%11100000,%00100000,%00100000,%00100000,%00100000 ; char 150 
42C7: 20202020	
42CB: 202020E0	        defb %00100000,%00100000,%00100000,%11100000,%00000000,%00000000,%00000000,%00000000 ; char 151 
42CF: 00000000	
42D3: 2020203C	        defb %00100000,%00100000,%00100000,%00111100,%00000000,%00000000,%00000000,%00000000 ; char 152 
42D7: 00000000	
42DB: 202020FC	        defb %00100000,%00100000,%00100000,%11111100,%00000000,%00000000,%00000000,%00000000 ; char 153 
42DF: 00000000	
42E3: 2020203C	        defb %00100000,%00100000,%00100000,%00111100,%00100000,%00100000,%00100000,%00100000 ; char 154 
42E7: 20202020	
42EB: 000000FC	        defb %00000000,%00000000,%00000000,%11111100,%00100000,%00100000,%00100000,%00100000 ; char 155 
42EF: 20202020	
42F3: 202020E0	        defb %00100000,%00100000,%00100000,%11100000,%00100000,%00100000,%00100000,%00100000 ; char 156 
42F7: 20202020	
42FB: 000000FC	        defb %00000000,%00000000,%00000000,%11111100,%00000000,%00000000,%00000000,%00000000 ; char 157 
42FF: 00000000	
4303: 20202020	        defb %00100000,%00100000,%00100000,%00100000,%00100000,%00100000,%00100000,%00100000 ; char 158 
4307: 20202020	
430B: 04080810	        defb %00000100,%00001000,%00001000,%00010000,%00100000,%01000000,%01000000,%10000000 ; char 159 
430F: 20404080	
4313: 80404020	        defb %10000000,%01000000,%01000000,%00100000,%00010000,%00001000,%00001000,%00000100 ; char 160 
4317: 10080804	
431B: 84484830	        defb %10000100,%01001000,%01001000,%00110000,%00110000,%01001000,%01001000,%10000100 ; char 161 
431F: 30484884	
4323: 00000000	        defb %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%11111100,%11111100 ; char 162 
4327: 0000FCFC	
432B: 00000000	        defb %00000000,%00000000,%00000000,%00000000,%11111100,%11111100,%11111100,%11111100 ; char 163 
432F: FCFCFCFC	
4333: 0000FCFC	        defb %00000000,%00000000,%11111100,%11111100,%11111100,%11111100,%11111100,%11111100 ; char 164 
4337: FCFCFCFC	
433B: FCFC0000	        defb %11111100,%11111100,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 165 
433F: 00000000	
4343: FCFCFCFC	        defb %11111100,%11111100,%11111100,%11111100,%00000000,%00000000,%00000000,%00000000 ; char 166 
4347: 00000000	
434B: FCFCFCFC	        defb %11111100,%11111100,%11111100,%11111100,%11111100,%11111100,%00000000,%00000000 ; char 167 
434F: FCFC0000	
4353: 80808080	        defb %10000000,%10000000,%10000000,%10000000,%10000000,%10000000,%10000000,%10000000 ; char 168 
4357: 80808080	
435B: E0E0E0E0	        defb %11100000,%11100000,%11100000,%11100000,%11100000,%11100000,%11100000,%11100000 ; char 169 
435F: E0E0E0E0	
4363: F8F8F8F8	        defb %11111000,%11111000,%11111000,%11111000,%11111000,%11111000,%11111000,%11111000 ; char 170 
4367: F8F8F8F8	
436B: 04040404	        defb %00000100,%00000100,%00000100,%00000100,%00000100,%00000100,%00000100,%00000100 ; char 171 
436F: 04040404	
4373: 1C1C1C1C	        defb %00011100,%00011100,%00011100,%00011100,%00011100,%00011100,%00011100,%00011100 ; char 172 
4377: 1C1C1C1C	
437B: 7C7C7C7C	        defb %01111100,%01111100,%01111100,%01111100,%01111100,%01111100,%01111100,%01111100 ; char 173 
437F: 7C7C7C7C	
4383: FC848484	        defb %11111100,%10000100,%10000100,%10000100,%10000100,%10000100,%10000100,%11111100 ; char 174 
4387: 848484FC	
438B: 00000000	        defb %00000000,%00000000,%00000000,%00000000,%11100000,%11100000,%11100000,%11100000 ; char 175 
438F: E0E0E0E0	
4393: 00000000	        defb %00000000,%00000000,%00000000,%00000000,%00011100,%00011100,%00011100,%00011100 ; char 176 
4397: 1C1C1C1C	
439B: 1C1C1C1C	        defb %00011100,%00011100,%00011100,%00011100,%00000000,%00000000,%00000000,%00000000 ; char 177 
439F: 00000000	
43A3: E0E0E0E0	        defb %11100000,%11100000,%11100000,%11100000,%00000000,%00000000,%00000000,%00000000 ; char 178 
43A7: 00000000	
43AB: E0E0E0E0	        defb %11100000,%11100000,%11100000,%11100000,%00011100,%00011100,%00011100,%00011100 ; char 179 
43AF: 1C1C1C1C	
43B3: 1C1C1C1C	        defb %00011100,%00011100,%00011100,%00011100,%11100000,%11100000,%11100000,%11100000 ; char 180 
43B7: E0E0E0E0	
43BB: 78787878	        defb %01111000,%01111000,%01111000,%01111000,%01111000,%01111000,%01111000,%01111000 ; char 181 
43BF: 78787878	
43C3: CCCCCCCC	        defb %11001100,%11001100,%11001100,%11001100,%11001100,%11001100,%11001100,%11001100 ; char 182 
43C7: CCCCCCCC	
43CB: FCFC0000	        defb %11111100,%11111100,%00000000,%00000000,%00000000,%00000000,%11111100,%11111100 ; char 183 
43CF: 0000FCFC	
43D3: 0000FCFC	        defb %00000000,%00000000,%11111100,%11111100,%11111100,%11111100,%00000000,%00000000 ; char 184 
43D7: FCFC0000	
43DB: 3030CCCC	        defb %00110000,%00110000,%11001100,%11001100,%00110000,%00110000,%11001100,%11001100 ; char 185 
43DF: 3030CCCC	
43E3: 54A854A8	        defb %01010100,%10101000,%01010100,%10101000,%01010100,%10101000,%01010100,%10101000 ; char 186 
43E7: 54A854A8	
43EB: 643098CC	        defb %01100100,%00110000,%10011000,%11001100,%01100100,%00110000,%10011000,%11001100 ; char 187 
43EF: 643098CC	
43F3: CC643098	        defb %11001100,%01100100,%00110000,%10011000,%11001100,%01100100,%00110000,%10011000 ; char 188 
43F7: CC643098	
43FB: 3098CC64	        defb %00110000,%10011000,%11001100,%01100100,%00110000,%10011000,%11001100,%01100100 ; char 189 
43FF: 3098CC64	
4403: 64CC9830	        defb %01100100,%11001100,%10011000,%00110000,%01100100,%11001100,%10011000,%00110000 ; char 190 
4407: 64CC9830	
440B: 2020F820	        defb %00100000,%00100000,%11111000,%00100000,%00100000,%00000000,%11111000,%00000000 ; char 191 (±)
440F: 2000F800	
4413: C0300830	        defb %11000000,%00110000,%00001000,%00110000,%11000000,%00000000,%11111000,%00000000 ; char 192 (≥)
4417: C000F800	
441B: 18608060	        defb %00011000,%01100000,%10000000,%01100000,%00011000,%00000000,%11111000,%00000000 ; char 193 (≤)
441F: 1800F800	
4423: 3C202020	        defb %00111100,%00100000,%00100000,%00100000,%10100000,%01100000,%00100000,%00000000 ; char 194 (square root)
4427: A0602000	
442B: 30484830	        defb %00110000,%01001000,%01001000,%00110000,%00000000,%00000000,%00000000,%00000000 ; char 195 (°)
442F: 00000000	
4433: 60103040	        defb %01100000,%00010000,%00110000,%01000000,%01110000,%00000000,%00000000,%00000000 ; char 196 (²)
4437: 70000000	
443B: 000054A8	        defb %00000000,%00000000,%01010100,%10101000,%00000000,%11111100,%00000000,%00000000 ; char 197
443F: 00FC0000	
4443: 0054A800	        defb %00000000,%01010100,%10101000,%00000000,%01010100,%10101000,%00000000,%00000000 ; char 198 (≈)
4447: 54A80000	
444B: 0080C0E0	        defb %00000000,%10000000,%11000000,%11100000,%11100000,%11000000,%10000000,%00000000 ; char 199
444F: E0C08000	
4453: FC783000	        defb %11111100,%01111000,%00110000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 200
4457: 00000000	
445B: 00040C1C	        defb %00000000,%00000100,%00001100,%00011100,%00011100,%00001100,%00000100,%00000000 ; char 201
445F: 1C0C0400	
4463: 00000000	        defb %00000000,%00000000,%00000000,%00000000,%00000000,%00110000,%01111000,%11111100 ; char 202 
4467: 003078FC	
446B: 2070F820	        defb %00100000,%01110000,%11111000,%00100000,%00100000,%00100000,%00100000,%00000000 ; char 203 (up arrow)
446F: 20202000	
4473: 3C1C1C24	        defb %00111100,%00011100,%00011100,%00100100,%01000000,%10000000,%00000000,%00000000 ; char 204 (up right arrow)
4477: 40800000	
447B: 001018FC	        defb %00000000,%00010000,%00011000,%11111100,%00011000,%00010000,%00000000,%00000000 ; char 205 (right arrow)
447F: 18100000	
4483: 00008040	        defb %00000000,%00000000,%10000000,%01000000,%00100100,%00011100,%00011100,%00111100 ; char 206 (down right arrow)
4487: 241C1C3C	
448B: 00202020	        defb %00000000,%00100000,%00100000,%00100000,%00100000,%11111000,%01110000,%00100000 ; char 207 (down arrow)
448F: 20F87020	
4493: 00000408	        defb %00000000,%00000000,%00000100,%00001000,%10010000,%11100000,%11100000,%11110000 ; char 208 (down left arrow)
4497: 90E0E0F0	
449B: 002060FC	        defb %00000000,%00100000,%01100000,%11111100,%01100000,%00100000,%00000000,%00000000 ; char 209 (left arrow)
449F: 60200000	
44A3: F0E0E090	        defb %11110000,%11100000,%11100000,%10010000,%00001000,%00000100,%00000000,%00000000 ; char 210 (up left arrow)
44A7: 08040000	
44AB: 3844F040	        defb %00111000,%01000100,%11110000,%01000000,%11110000,%01000100,%00111000,%00000000 ; char 211 (euro)
44AF: F0443800	
44B3: 000478A8	        defb %00000000,%00000100,%01111000,%10101000,%00101000,%00101000,%00101000,%00000000 ; char 212 (greek pi)
44B7: 28282800	
44BB: 00000000	        defb %00000000,%00000000,%00000000,%00000000,%00011100,%00100000,%00100000,%00100000 ; char 213
44BF: 1C202020	
44C3: 00000000	        defb %00000000,%00000000,%00000000,%00000000,%11100000,%00010000,%00010000,%00010000 ; char 214
44C7: E0101010	
44CB: 101010E0	        defb %00010000,%00010000,%00010000,%11100000,%00000000,%00000000,%00000000,%00000000 ; char 215
44CF: 00000000	
44D3: 2020201C	        defb %00100000,%00100000,%00100000,%00011100,%00000000,%00000000,%00000000,%00000000 ; char 216
44D7: 00000000	
44DB: 0000001C	        defb %00000000,%00000000,%00000000,%00011100,%00111100,%00110000,%00110000,%00110000 ; char 217
44DF: 3C303030	
44E3: 000000E0	        defb %00000000,%00000000,%00000000,%11100000,%11110000,%00110000,%00110000,%00110000 ; char 218
44E7: F0303030	
44EB: 303030F0	        defb %00110000,%00110000,%00110000,%11110000,%11100000,%00000000,%00000000,%00000000 ; char 219
44EF: E0000000	
44F3: 3030303C	        defb %00110000,%00110000,%00110000,%00111100,%00011100,%00000000,%00000000,%00000000 ; char 220
44F7: 1C000000	
44FB: 00304848	        defb %00000000,%00110000,%01001000,%01001000,%01001000,%00110000,%00000000,%00000000 ; char 221
44FF: 48300000	
4503: 00307878	        defb %00000000,%00110000,%01111000,%01111000,%01111000,%00110000,%00000000,%00000000 ; char 222
4507: 78300000	
450B: 003078FC	        defb %00000000,%00110000,%01111000,%11111100,%11111100,%01111000,%00110000,%00000000 ; char 223
450F: FC783000	
4513: FCF8F0E0	        defb %11111100,%11111000,%11110000,%11100000,%11100000,%11000000,%10000000,%10000000 ; char 224
4517: E0C08080	
451B: FC7C3C1C	        defb %11111100,%01111100,%00111100,%00011100,%00011100,%00001100,%00000100,%00000100 ; char 225
451F: 1C0C0404	
4523: 04040C1C	        defb %00000100,%00000100,%00001100,%00011100,%00011100,%00111100,%01111100,%11111100 ; char 226
4527: 1C3C7CFC	
452B: 8080C0E0	        defb %10000000,%10000000,%11000000,%11100000,%11100000,%11110000,%11111000,%11111100 ; char 227
452F: E0F0F8FC	
4533: 00040CD8	        defb %00000000,%00000100,%00001100,%11011000,%11110000,%11100000,%11000000,%00000000 ; char 228 (checkmark)
4537: F0E0C000	
453B: 00CC7830	        defb %00000000,%11001100,%01111000,%00110000,%01111000,%11001100,%00000000,%00000000 ; char 229 (x)
453F: 78CC0000	
4543: 70888888	        defb %01110000,%10001000,%10001000,%10001000,%01110000,%00100000,%01110000,%00100000 ; char 230 (female)
4547: 70207020	
454B: 001C0C74	        defb %00000000,%00011100,%00001100,%01110100,%10010000,%10010000,%01100000,%00000000 ; char 231 (male)
454F: 90906000	
4553: F8848484	        defb %11111000,%10000100,%10000100,%10000100,%10000100,%10000100,%10000100,%11111100 ; char 232 (new doc)
4557: 848484FC	
455B: 00F0FC84	        defb %00000000,%11110000,%11111100,%10000100,%10000100,%10000100,%10000100,%11111100 ; char 233 (folder)
455F: 848484FC	
4563: 3078FC48	        defb %00110000,%01111000,%11111100,%01001000,%01001000,%01001000,%01001000,%01111000 ; char 234 (trash bin)
4567: 48484878	
456B: FC848484	        defb %11111100,%10000100,%10000100,%10000100,%11111100,%10110100,%10110100,%11111100 ; char 235 (floppy disk)
456F: FCB4B4FC	
4573: 0000D4D8	        defb %00000000,%00000000,%11010100,%11011000,%11010100,%11010100,%00000000,%00000000 ; char 236 (OK)
4577: D4D40000	
457B: 3078FC78	        defb %00110000,%01111000,%11111100,%01111000,%01111000,%01001000,%01001000,%01001000 ; char 237 (home)
457F: 78484848	
4583: 7884A4A4	        defb %01111000,%10000100,%10100100,%10100100,%10110100,%10000100,%01111000,%00000000 ; char 238 (clock)
4587: B4847800	
458B: 000008F4	        defb %00000000,%00000000,%00001000,%11110100,%10101000,%10000000,%00000000,%00000000 ; char 239 (key)
458F: A8800000	
4593: 203078B0	        defb %00100000,%00110000,%01111000,%10110000,%10100000,%10001000,%01110000,%00000000 ; char 240 (undo)
4597: A0887000	
459B: 00FCCCB4	        defb %00000000,%11111100,%11001100,%10110100,%10000100,%10000100,%11111100,%00000000 ; char 241 (letter)
459F: 8484FC00	
45A3: 609090F0	        defb %01100000,%10010000,%10010000,%11110000,%11110000,%11110000,%11110000,%00000000 ; char 242 (lock)
45A7: F0F0F000	
45AB: 081414F0	        defb %00001000,%00010100,%00010100,%11110000,%11110000,%11110000,%11110000,%00000000 ; char 243 (unlock)
45AF: F0F0F000	
45B3: FCFC84B4	        defb %11111100,%11111100,%10000100,%10110100,%10010100,%10010100,%10000100,%11111100 ; char 244 (calendar)
45B7: 949484FC	
45BB: 00043858	        defb %00000000,%00000100,%00111000,%01011000,%01101000,%01110000,%10000000,%00000000 ; char 245 (diameter)
45BF: 68708000	
45C3: 78848484	        defb %01111000,%10000100,%10000100,%10000100,%01101100,%00011000,%00001000,%00000000 ; char 246 (baloon)
45C7: 6C180800	
45CB: 30282828	        defb %00110000,%00101000,%00101000,%00101000,%00100000,%01100000,%11100000,%01000000 ; char 247 (note)
45CF: 2060E040	
45D3: 2068E4E4	        defb %00100000,%01101000,%11100100,%11100100,%11100100,%01101000,%00100000,%00000000 ; char 248 (audio on)
45D7: E4682000	
45DB: 2060E0E0	        defb %00100000,%01100000,%11100000,%11100000,%11100000,%01100000,%00100000,%00000000 ; char 249 (audio off)
45DF: E0602000	
45E3: 80C0E0F0	        defb %10000000,%11000000,%11100000,%11110000,%11111000,%11111100,%11110000,%10010000 ; char 250 (pointer)
45E7: F8FCF090	
45EB: 7884B4A4	        defb %01111000,%10000100,%10110100,%10100100,%10110100,%10000100,%01111000,%00000000 ; char 251 (©)
45EF: B4847800	
45F3: 304840E0	        defb %00110000,%01001000,%01000000,%11100000,%01000000,%01001000,%10110000,%00000000 ; char 252 (£)
45F7: 4048B000	
45FB: 7884F048	        defb %01111000,%10000100,%11110000,%01001000,%01001000,%00111100,%10000100,%01111000 ; char 253 (§)
45FF: 483C8478	
4603: 00002000	        defb %00000000,%00000000,%00100000,%00000000,%11111000,%00000000,%00100000,%00000000 ; char 254 (÷)
4607: F8002000	
460B: FCFCFCFC	        defb %11111100,%11111100,%11111100,%11111100,%11111100,%11111100,%11111100,%11111100 ; char 255 (cursor)
460F: FCFCFCFC	
              	        ; here ends the ASCII table
              	; ------------------------------------------------------------------------------
              	; LM80C - 8x8 CHARSET - R1.8
              	; ------------------------------------------------------------------------------
              	; The following code is intended to be used with LM80C Z80-based computer
              	; designed by Leonardo Miliani. More info at
              	; www DOT leonardomiliani DOT com
              	; ------------------------------------------------------------------------------
              	; Code Revision:
              	; R1.0 - 20190615 - First revision: ASCII chars (from 0 to 255) - actually, they are 6x8 pixels
              	; R1.1 - 20190616 - Converted to 8x8 pixels
              	; R1.2 - 20191013 - Added new graphic chars and reorganized previous ones
              	; R1.3 - 20191015 - More graphic chars
              	; R1.4 - 20191202 - Fixed char 11/12, added new special chars
              	; R1.5 - 20191210 - Changed several graphic chars
              	; R1.6 - 20200125 - Removed double chars, changed with new ones
              	; R1.7 - 20200228 - adopted more usual hexadecimal & binary prefixes
              	; R1.8 - 20200524 - New style for char #252
              	; ------------------------------------------------------------------------------
              	;
              	;-------------------------------------------------------------------------------
              	;
              	;               8 x 8    C  H  A  R  S  E  T
              	;
              	;-------------------------------------------------------------------------------
              	;
              	;       8X8 CHARS, DESIGNED FOR GRAPHICS 1 MODE
              	
4613:         	CHRST88 equ $
4613: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 0 (null char)
4617: 00000000	
461B: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 1 F1
461F: 00000000	
4623: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 2 F2
4627: 00000000	
462B: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 3 CTRL-C
462F: 00000000	
4633: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 4 F3
4637: 00000000	
463B: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 5 F4
463F: 00000000	
4643: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 6 F5
4647: 00000000	
464B: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 7 (bell)
464F: 00000000	
4653: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 8 (backspace)
4657: 00000000	
465B: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 9 (H. tab)
465F: 00000000	
4663: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 10 (line feed)
4667: 00000000	
466B: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 11 
466F: 00000000	
4673: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 12 Form feed (clear screen)
4677: 00000000	
467B: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 13 (carriage return)
467F: 00000000	
4683: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 14 CTRL
4687: 00000000	
468B: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 15 CTRL-O
468F: 00000000	
4693: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 16 C=/Graphic key
4697: 00000000	
469B: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 17 CTRL-Q
469F: 00000000	
46A3: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 18 CTRL-R
46A7: 00000000	
46AB: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 19 CTRL-S
46AF: 00000000	
46B3: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 20 SHIFT
46B7: 00000000	
46BB: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 21 CTRL-U
46BF: 00000000	
46C3: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 22 F6
46C7: 00000000	
46CB: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 23 F7
46CF: 00000000	
46D3: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 24 HELP
46D7: 00000000	
46DB: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 25 (home)
46DF: 00000000	
46E3: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 26
46E7: 00000000	
46EB: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 27 (escape)
46EF: 00000000	
46F3: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 28 (cursor left)
46F7: 00000000	
46FB: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 29 (cursor right)
46FF: 00000000	
4703: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 30 (cursor up)
4707: 00000000	
470B: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 31 (cursor down)
470F: 00000000	
4713: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 32 - space
4717: 00000000	
471B: 10101010	        defb %00010000,%00010000,%00010000,%00010000,%00010000,%00000000,%00010000,%00000000 ; char 33 - !
471F: 10001000	
4723: 28282800	        defb %00101000,%00101000,%00101000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 34 - "
4727: 00000000	
472B: 2828FE28	        defb %00101000,%00101000,%11111110,%00101000,%11111110,%00101000,%00101000,%00000000 ; char 35 - #
472F: FE282800	
4733: 103C5038	        defb %00010000,%00111100,%01010000,%00111000,%00010100,%01111000,%00010000,%00000000 ; char 36 - $
4737: 14781000	
473B: 00626408	        defb %00000000,%01100010,%01100100,%00001000,%00010000,%00100110,%01000110,%00000000 ; char 37 - %
473F: 10264600	
4743: 00304830	        defb %00000000,%00110000,%01001000,%00110000,%01001010,%01000100,%00111010,%00000000 ; char 38 - &
4747: 4A443A00	
474B: 08102000	        defb %00001000,%00010000,%00100000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 39 - '
474F: 00000000	
4753: 08102020	        defb %00001000,%00010000,%00100000,%00100000,%00100000,%00010000,%00001000,%00000000 ; char 40 - (
4757: 20100800	
475B: 20100808	        defb %00100000,%00010000,%00001000,%00001000,%00001000,%00010000,%00100000,%00000000 ; char 41 - )
475F: 08102000	
4763: 00105438	        defb %00000000,%00010000,%01010100,%00111000,%00111000,%01010100,%00010000,%00000000 ; char 42 - *
4767: 38541000	
476B: 0010107C	        defb %00000000,%00010000,%00010000,%01111100,%00010000,%00010000,%00000000,%00000000 ; char 43 - +
476F: 10100000	
4773: 00000000	        defb %00000000,%00000000,%00000000,%00000000,%00000000,%00011000,%00001000,%00010000 ; char 44 - ,
4777: 00180810	
477B: 0000007C	        defb %00000000,%00000000,%00000000,%01111100,%00000000,%00000000,%00000000,%00000000 ; char 45 - -
477F: 00000000	
4783: 00000000	        defb %00000000,%00000000,%00000000,%00000000,%00000000,%00011000,%00011000,%00000000 ; char 46 - .
4787: 00181800	
478B: 00020408	        defb %00000000,%00000010,%00000100,%00001000,%00010000,%00100000,%01000000,%00000000 ; char 47 - /
478F: 10204000	
4793: 38444C54	        defb %00111000,%01000100,%01001100,%01010100,%01100100,%01000100,%00111000,%00000000 ; char 48 - 0
4797: 64443800	
479B: 10305010	        defb %00010000,%00110000,%01010000,%00010000,%00010000,%00010000,%01111100,%00000000 ; char 49 - 1
479F: 10107C00	
47A3: 38440408	        defb %00111000,%01000100,%00000100,%00001000,%00010000,%00100000,%01111100,%00000000 ; char 50 - 2
47A7: 10207C00	
47AB: 7C081008	        defb %01111100,%00001000,%00010000,%00001000,%00000100,%01000100,%00111000,%00000000 ; char 51 - 3
47AF: 04443800	
47B3: 08182848	        defb %00001000,%00011000,%00101000,%01001000,%01111100,%00001000,%00001000,%00000000 ; char 52 - 4
47B7: 7C080800	
47BB: 7C407804	        defb %01111100,%01000000,%01111000,%00000100,%00000100,%01000100,%00111000,%00000000 ; char 53 - 5
47BF: 04443800	
47C3: 38444078	        defb %00111000,%01000100,%01000000,%01111000,%01000100,%01000100,%00111000,%00000000 ; char 54 - 6
47C7: 44443800	
47CB: 7C040810	        defb %01111100,%00000100,%00001000,%00010000,%00100000,%00100000,%00100000,%00000000 ; char 55 - 7
47CF: 20202000	
47D3: 38444438	        defb %00111000,%01000100,%01000100,%00111000,%01000100,%01000100,%00111000,%00000000 ; char 56 - 8
47D7: 44443800	
47DB: 3844443C	        defb %00111000,%01000100,%01000100,%00111100,%00000100,%01000100,%00111000,%00000000 ; char 57 - 9
47DF: 04443800	
47E3: 00181800	        defb %00000000,%00011000,%00011000,%00000000,%00011000,%00011000,%00000000,%00000000 ; char 58 - :
47E7: 18180000	
47EB: 00181800	        defb %00000000,%00011000,%00011000,%00000000,%00011000,%00001000,%00010000,%00000000 ; char 59 - ;
47EF: 18081000	
47F3: 04081020	        defb %00000100,%00001000,%00010000,%00100000,%00010000,%00001000,%00000100,%00000000 ; char 60 - <
47F7: 10080400	
47FB: 00007E00	        defb %00000000,%00000000,%01111110,%00000000,%01111110,%00000000,%00000000,%00000000 ; char 61 - =
47FF: 7E000000	
4803: 20100804	        defb %00100000,%00010000,%00001000,%00000100,%00001000,%00010000,%00100000,%00000000 ; char 62 - >
4807: 08102000	
480B: 38440408	        defb %00111000,%01000100,%00000100,%00001000,%00010000,%00000000,%00010000,%00000000 ; char 63 - ?
480F: 10001000	
4813: 7884BCAC	        defb %01111000,%10000100,%10111100,%10101100,%10111000,%10000000,%10000100,%01111000 ; char 64 - @
4817: B8808478	
481B: 38444444	        defb %00111000,%01000100,%01000100,%01000100,%01111100,%01000100,%01000100,%00000000 ; char 65 - A
481F: 7C444400	
4823: 78444478	        defb %01111000,%01000100,%01000100,%01111000,%01000100,%01000100,%01111000,%00000000 ; char 66 - B
4827: 44447800	
482B: 38444040	        defb %00111000,%01000100,%01000000,%01000000,%01000000,%01000100,%00111000,%00000000 ; char 67 - C
482F: 40443800	
4833: 78444444	        defb %01111000,%01000100,%01000100,%01000100,%01000100,%01000100,%01111000,%00000000 ; char 68 - D
4837: 44447800	
483B: 7C404070	        defb %01111100,%01000000,%01000000,%01110000,%01000000,%01000000,%01111100,%00000000 ; char 69 - E
483F: 40407C00	
4843: 7C404070	        defb %01111100,%01000000,%01000000,%01110000,%01000000,%01000000,%01000000,%00000000 ; char 70 - F
4847: 40404000	
484B: 38444040	        defb %00111000,%01000100,%01000000,%01000000,%01011100,%01000100,%00111000,%00000000 ; char 71 - G
484F: 5C443800	
4853: 4444447C	        defb %01000100,%01000100,%01000100,%01111100,%01000100,%01000100,%01000100,%00000000 ; char 72 - H
4857: 44444400	
485B: 38101010	        defb %00111000,%00010000,%00010000,%00010000,%00010000,%00010000,%00111000,%00000000 ; char 73 - I
485F: 10103800	
4863: 3C040404	        defb %00111100,%00000100,%00000100,%00000100,%00000100,%01000100,%00111000,%00000000 ; char 74 - J
4867: 04443800	
486B: 44444870	        defb %01000100,%01000100,%01001000,%01110000,%01001000,%01000100,%01000100,%00000000 ; char 75 - K
486F: 48444400	
4873: 40404040	        defb %01000000,%01000000,%01000000,%01000000,%01000000,%01000000,%01111100,%00000000 ; char 76 - L
4877: 40407C00	
487B: 42665A42	        defb %01000010,%01100110,%01011010,%01000010,%01000010,%01000010,%01000010,%00000000 ; char 77 - M
487F: 42424200	
4883: 4464544C	        defb %01000100,%01100100,%01010100,%01001100,%01000100,%01000100,%01000100,%00000000 ; char 78 - N
4887: 44444400	
488B: 38444444	        defb %00111000,%01000100,%01000100,%01000100,%01000100,%01000100,%00111000,%00000000 ; char 79 - O
488F: 44443800	
4893: 78444444	        defb %01111000,%01000100,%01000100,%01000100,%01111000,%01000000,%01000000,%00000000 ; char 80 - P
4897: 78404000	
489B: 38444444	        defb %00111000,%01000100,%01000100,%01000100,%01010100,%01001000,%00110100,%00000000 ; char 81 - Q
489F: 54483400	
48A3: 78444444	        defb %01111000,%01000100,%01000100,%01000100,%01111000,%01001000,%01000100,%00000000 ; char 82 - R
48A7: 78484400	
48AB: 3C404038	        defb %00111100,%01000000,%01000000,%00111000,%00000100,%00000100,%01111000,%00000000 ; char 83 - S
48AF: 04047800	
48B3: 7C101010	        defb %01111100,%00010000,%00010000,%00010000,%00010000,%00010000,%00010000,%00000000 ; char 84 - T
48B7: 10101000	
48BB: 44444444	        defb %01000100,%01000100,%01000100,%01000100,%01000100,%01000100,%00111000,%00000000 ; char 85 - U
48BF: 44443800	
48C3: 44444444	        defb %01000100,%01000100,%01000100,%01000100,%01000100,%00101000,%00010000,%00000000 ; char 86 - V
48C7: 44281000	
48CB: 42424242	        defb %01000010,%01000010,%01000010,%01000010,%01011010,%01011010,%00100100,%00000000 ; char 87 - W
48CF: 5A5A2400	
48D3: 44442810	        defb %01000100,%01000100,%00101000,%00010000,%00101000,%01000100,%01000100,%00000000 ; char 88 - X
48D7: 28444400	
48DB: 44444428	        defb %01000100,%01000100,%01000100,%00101000,%00010000,%00010000,%00010000,%00000000 ; char 89 - Y
48DF: 10101000	
48E3: 7C040810	        defb %01111100,%00000100,%00001000,%00010000,%00100000,%01000000,%01111100,%00000000 ; char 90 - Z
48E7: 20407C00	
48EB: 38202020	        defb %00111000,%00100000,%00100000,%00100000,%00100000,%00100000,%00111000,%00000000 ; char 91 - [
48EF: 20203800	
48F3: 00402010	        defb %00000000,%01000000,%00100000,%00010000,%00001000,%00000100,%00000010,%00000000 ; char 92 - \
48F7: 08040200	
48FB: 38080808	        defb %00111000,%00001000,%00001000,%00001000,%00001000,%00001000,%00111000,%00000000 ; char 93 - ]
48FF: 08083800	
4903: 10284400	        defb %00010000,%00101000,%01000100,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 94 - ^
4907: 00000000	
490B: 00000000	        defb %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%01111110,%00000000 ; char 95 _ (underscore)
490F: 00007E00	
4913: 20100800	        defb %00100000,%00010000,%00001000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 96 - `
4917: 00000000	
491B: 00003804	        defb %00000000,%00000000,%00111000,%00000100,%00111100,%01000100,%00111100,%00000000 ; char 97 - a
491F: 3C443C00	
4923: 40404078	        defb %01000000,%01000000,%01000000,%01111000,%01000100,%01000100,%01111000,%00000000 ; char 98 - b
4927: 44447800	
492B: 00003840	        defb %00000000,%00000000,%00111000,%01000000,%01000000,%01000100,%00111000,%00000000 ; char 99 - c
492F: 40443800	
4933: 0404043C	        defb %00000100,%00000100,%00000100,%00111100,%01000100,%01000100,%00111100,%00000000 ; char 100 - d
4937: 44443C00	
493B: 00003844	        defb %00000000,%00000000,%00111000,%01000100,%01111100,%01000000,%00111000,%00000000 ; char 101 - e
493F: 7C403800	
4943: 18242070	        defb %00011000,%00100100,%00100000,%01110000,%00100000,%00100000,%00100000,%00000000 ; char 102 - f
4947: 20202000	
494B: 00003C44	        defb %00000000,%00000000,%00111100,%01000100,%01000100,%00111100,%00000100,%00111000 ; char 103 - g
494F: 443C0438	
4953: 40405864	        defb %01000000,%01000000,%01011000,%01100100,%01000100,%01000100,%01000100,%00000000 ; char 104 - h
4957: 44444400	
495B: 00100010	        defb %00000000,%00010000,%00000000,%00010000,%00010000,%00010000,%00010000,%00000000 ; char 105 - i
495F: 10101000	
4963: 08001808	        defb %00001000,%00000000,%00011000,%00001000,%00001000,%00001000,%01001000,%00110000 ; char 106 - j
4967: 08084830	
496B: 40404850	        defb %01000000,%01000000,%01001000,%01010000,%01100000,%01010000,%01001000,%00000000 ; char 107 - k
496F: 60504800	
4973: 30101010	        defb %00110000,%00010000,%00010000,%00010000,%00010000,%00010000,%00111000,%00000000 ; char 108 - l
4977: 10103800	
497B: 0000546A	        defb %00000000,%00000000,%01010100,%01101010,%01001010,%01000010,%01000010,%00000000 ; char 109 - m
497F: 4A424200	
4983: 00005864	        defb %00000000,%00000000,%01011000,%01100100,%01000100,%01000100,%01000100,%00000000 ; char 110 - n
4987: 44444400	
498B: 00003844	        defb %00000000,%00000000,%00111000,%01000100,%01000100,%01000100,%00111000,%00000000 ; char 111: o
498F: 44443800	
4993: 00007844	        defb %00000000,%00000000,%01111000,%01000100,%01000100,%01111000,%01000000,%01000000 ; char 112: p
4997: 44784040	
499B: 00003C44	        defb %00000000,%00000000,%00111100,%01000100,%01000100,%00111100,%00000100,%00000100 ; char 113: q
499F: 443C0404	
49A3: 00005864	        defb %00000000,%00000000,%01011000,%01100100,%01000000,%01000000,%01000000,%00000000 ; char 114: r
49A7: 40404000	
49AB: 00003840	        defb %00000000,%00000000,%00111000,%01000000,%00111000,%00000100,%01111000,%00000000 ; char 115: s
49AF: 38047800	
49B3: 20207020	        defb %00100000,%00100000,%01110000,%00100000,%00100000,%00100100,%00011000,%00000000 ; char 116: t
49B7: 20241800	
49BB: 00004444	        defb %00000000,%00000000,%01000100,%01000100,%01000100,%01001100,%00110100,%00000000 ; char 117: u
49BF: 444C3400	
49C3: 00004444	        defb %00000000,%00000000,%01000100,%01000100,%01000100,%00101000,%00010000,%00000000 ; char 118: v
49C7: 44281000	
49CB: 00004444	        defb %00000000,%00000000,%01000100,%01000100,%01010100,%01010100,%00101000,%00000000 ; char 119: w
49CF: 54542800	
49D3: 00004428	        defb %00000000,%00000000,%01000100,%00101000,%00010000,%00101000,%01000100,%00000000 ; char 120: x
49D7: 10284400	
49DB: 00004444	        defb %00000000,%00000000,%01000100,%01000100,%01001100,%00110100,%00000100,%00111000 ; char 121: y
49DF: 4C340438	
49E3: 00007C08	        defb %00000000,%00000000,%01111100,%00001000,%00010000,%00100000,%01111100,%00000000 ; char 122: z
49E7: 10207C00	
49EB: 18202040	        defb %00011000,%00100000,%00100000,%01000000,%00100000,%00100000,%00011000,%00000000 ; char 123: {
49EF: 20201800	
49F3: 10101010	        defb %00010000,%00010000,%00010000,%00010000,%00010000,%00010000,%00010000,%00000000 ; char 124: |
49F7: 10101000	
49FB: 30080804	        defb %00110000,%00001000,%00001000,%00000100,%00001000,%00001000,%00110000,%00000000 ; char 125: }
49FF: 08083000	
4A03: 20540800	        defb %00100000,%01010100,%00001000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 126: ~
4A07: 00000000	
4A0B: 00000000	        defb %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 127 (delete) - end the standard ASCII (0-127)
4A0F: 00000000	
4A13: 3C42A581	        defb %00111100,%01000010,%10100101,%10000001,%10100101,%10011001,%01000010,%00111100 ; char 128 (open face)
4A17: A599423C	
4A1B: 3C7EDBFF	        defb %00111100,%01111110,%11011011,%11111111,%11011011,%11100111,%01111110,%00111100 ; char 129 (full face)
4A1F: DBE77E3C	
4A23: 6CFEFEFE	        defb %01101100,%11111110,%11111110,%11111110,%01111100,%00111000,%00010000,%00000000 ; char 130 (hearts)
4A27: 7C381000	
4A2B: 10387CFE	        defb %00010000,%00111000,%01111100,%11111110,%01111100,%00111000,%00010000,%00000000 ; char 131 (diamonds)
4A2F: 7C381000	
4A33: 103854FE	        defb %00010000,%00111000,%01010100,%11111110,%01010100,%00010000,%01111100,%00000000 ; char 132 (clus)
4A37: 54107C00	
4A3B: 10387CFE	        defb %00010000,%00111000,%01111100,%11111110,%11010110,%00010000,%01111100,%00000000 ; char 133 (spades)
4A3F: D6107C00	
4A43: 181818FF	        defb %00011000,%00011000,%00011000,%11111111,%11111111,%00011000,%00011000,%00011000 ; char 134
4A47: FF181818	
4A4B: 0000001F	        defb %00000000,%00000000,%00000000,%00011111,%00011111,%00011000,%00011000,%00011000 ; char 135
4A4F: 1F181818	
4A53: 000000F8	        defb %00000000,%00000000,%00000000,%11111000,%11111000,%00011000,%00011000,%00011000 ; char 136
4A57: F8181818	
4A5B: 181818F8	        defb %00011000,%00011000,%00011000,%11111000,%11111000,%00000000,%00000000,%00000000 ; char 137
4A5F: F8000000	
4A63: 1818181F	        defb %00011000,%00011000,%00011000,%00011111,%00011111,%00000000,%00000000,%00000000 ; char 138
4A67: 1F000000	
4A6B: 181818FF	        defb %00011000,%00011000,%00011000,%11111111,%11111111,%00000000,%00000000,%00000000 ; char 139
4A6F: FF000000	
4A73: 1818181F	        defb %00011000,%00011000,%00011000,%00011111,%00011111,%00011000,%00011000,%00011000 ; char 140
4A77: 1F181818	
4A7B: 000000FF	        defb %00000000,%00000000,%00000000,%11111111,%11111111,%00011000,%00011000,%00011000 ; char 141
4A7F: FF181818	
4A83: 181818F8	        defb %00011000,%00011000,%00011000,%11111000,%11111000,%00011000,%00011000,%00011000 ; char 142
4A87: F8181818	
4A8B: 000000FF	        defb %00000000,%00000000,%00000000,%11111111,%11111111,%00000000,%00000000,%00000000 ; char 143
4A8F: FF000000	
4A93: 18181818	        defb %00011000,%00011000,%00011000,%00011000,%00011000,%00011000,%00011000,%00011000 ; char 144
4A97: 18181818	
4A9B: 03070E1C	        defb %00000011,%00000111,%00001110,%00011100,%00111000,%01110000,%11100000,%11000000 ; char 145
4A9F: 3870E0C0	
4AA3: C0E07038	        defb %11000000,%11100000,%01110000,%00111000,%00011100,%00001110,%00000111,%00000011 ; char 146
4AA7: 1C0E0703	
4AAB: C3E77E3C	        defb %11000011,%11100111,%01111110,%00111100,%00111100,%01111110,%11100111,%11000011 ; char 147
4AAF: 3C7EE7C3	
4AB3: 101010FF	        defb %00010000,%00010000,%00010000,%11111111,%00010000,%00010000,%00010000,%00010000 ; char 148
4AB7: 10101010	
4ABB: 0000001F	        defb %00000000,%00000000,%00000000,%00011111,%00010000,%00010000,%00010000,%00010000 ; char 149
4ABF: 10101010	
4AC3: 000000F0	        defb %00000000,%00000000,%00000000,%11110000,%00010000,%00010000,%00010000,%00010000 ; char 150
4AC7: 10101010	
4ACB: 101010F0	        defb %00010000,%00010000,%00010000,%11110000,%00000000,%00000000,%00000000,%00000000 ; char 151
4ACF: 00000000	
4AD3: 1010101F	        defb %00010000,%00010000,%00010000,%00011111,%00000000,%00000000,%00000000,%00000000 ; char 152
4AD7: 00000000	
4ADB: 101010FF	        defb %00010000,%00010000,%00010000,%11111111,%00000000,%00000000,%00000000,%00000000 ; char 153
4ADF: 00000000	
4AE3: 1010101F	        defb %00010000,%00010000,%00010000,%00011111,%00010000,%00010000,%00010000,%00010000 ; char 154
4AE7: 10101010	
4AEB: 000000FF	        defb %00000000,%00000000,%00000000,%11111111,%00010000,%00010000,%00010000,%00010000 ; char 155
4AEF: 10101010	
4AF3: 101010F0	        defb %00010000,%00010000,%00010000,%11110000,%00010000,%00010000,%00010000,%00010000 ; char 156
4AF7: 10101010	
4AFB: 000000FF	        defb %00000000,%00000000,%00000000,%11111111,%00000000,%00000000,%00000000,%00000000 ; char 157
4AFF: 00000000	
4B03: 10101010	        defb %00010000,%00010000,%00010000,%00010000,%00010000,%00010000,%00010000,%00010000 ; char 158
4B07: 10101010	
4B0B: 01020408	        defb %00000001,%00000010,%00000100,%00001000,%00010000,%00100000,%01000000,%10000000 ; char 159
4B0F: 10204080	
4B13: 80402010	        defb %10000000,%01000000,%00100000,%00010000,%00001000,%00000100,%00000010,%00000001 ; char 160
4B17: 08040201	
4B1B: 81422418	        defb %10000001,%01000010,%00100100,%00011000,%00011000,%00100100,%01000010,%10000001 ; char 161
4B1F: 18244281	
4B23: 00000000	        defb %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%11111111,%11111111 ; char 162
4B27: 0000FFFF	
4B2B: 00000000	        defb %00000000,%00000000,%00000000,%00000000,%11111111,%11111111,%11111111,%11111111 ; char 163
4B2F: FFFFFFFF	
4B33: 0000FFFF	        defb %00000000,%00000000,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111 ; char 164
4B37: FFFFFFFF	
4B3B: FFFF0000	        defb %11111111,%11111111,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 165
4B3F: 00000000	
4B43: FFFFFFFF	        defb %11111111,%11111111,%11111111,%11111111,%00000000,%00000000,%00000000,%00000000 ; char 166
4B47: 00000000	
4B4B: FFFFFFFF	        defb %11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%00000000,%00000000 ; char 167
4B4F: FFFF0000	
4B53: C0C0C0C0	        defb %11000000,%11000000,%11000000,%11000000,%11000000,%11000000,%11000000,%11000000 ; char 168
4B57: C0C0C0C0	
4B5B: F0F0F0F0	        defb %11110000,%11110000,%11110000,%11110000,%11110000,%11110000,%11110000,%11110000 ; char 169
4B5F: F0F0F0F0	
4B63: FCFCFCFC	        defb %11111100,%11111100,%11111100,%11111100,%11111100,%11111100,%11111100,%11111100 ; char 170
4B67: FCFCFCFC	
4B6B: 03030303	        defb %00000011,%00000011,%00000011,%00000011,%00000011,%00000011,%00000011,%00000011 ; char 171
4B6F: 03030303	
4B73: 0F0F0F0F	        defb %00001111,%00001111,%00001111,%00001111,%00001111,%00001111,%00001111,%00001111 ; char 172
4B77: 0F0F0F0F	
4B7B: 3F3F3F3F	        defb %00111111,%00111111,%00111111,%00111111,%00111111,%00111111,%00111111,%00111111 ; char 173
4B7F: 3F3F3F3F	
4B83: FF818181	        defb %11111111,%10000001,%10000001,%10000001,%10000001,%10000001,%10000001,%11111111 ; char 174
4B87: 818181FF	
4B8B: 00000000	        defb %00000000,%00000000,%00000000,%00000000,%11110000,%11110000,%11110000,%11110000 ; char 175
4B8F: F0F0F0F0	
4B93: 00000000	        defb %00000000,%00000000,%00000000,%00000000,%00001111,%00001111,%00001111,%00001111 ; char 176
4B97: 0F0F0F0F	
4B9B: 0F0F0F0F	        defb %00001111,%00001111,%00001111,%00001111,%00000000,%00000000,%00000000,%00000000 ; char 177
4B9F: 00000000	
4BA3: F0F0F0F0	        defb %11110000,%11110000,%11110000,%11110000,%00000000,%00000000,%00000000,%00000000 ; char 178
4BA7: 00000000	
4BAB: F0F0F0F0	        defb %11110000,%11110000,%11110000,%11110000,%00001111,%00001111,%00001111,%00001111 ; char 179
4BAF: 0F0F0F0F	
4BB3: 0F0F0F0F	        defb %00001111,%00001111,%00001111,%00001111,%11110000,%11110000,%11110000,%11110000 ; char 180
4BB7: F0F0F0F0	
4BBB: 3C3C3C3C	        defb %00111100,%00111100,%00111100,%00111100,%00111100,%00111100,%00111100,%00111100 ; char 181
4BBF: 3C3C3C3C	
4BC3: C3C3C3C3	        defb %11000011,%11000011,%11000011,%11000011,%11000011,%11000011,%11000011,%11000011 ; char 182
4BC7: C3C3C3C3	
4BCB: FFFF0000	        defb %11111111,%11111111,%00000000,%00000000,%00000000,%00000000,%11111111,%11111111 ; char 183
4BCF: 0000FFFF	
4BD3: 0000FFFF	        defb %00000000,%00000000,%11111111,%11111111,%11111111,%11111111,%00000000,%00000000 ; char 184
4BD7: FFFF0000	
4BDB: 3333CCCC	        defb %00110011,%00110011,%11001100,%11001100,%00110011,%00110011,%11001100,%11001100 ; char 185
4BDF: 3333CCCC	
4BE3: 55AA55AA	        defb %01010101,%10101010,%01010101,%10101010,%01010101,%10101010,%01010101,%10101010 ; char 186
4BE7: 55AA55AA	
4BEB: 663399CC	        defb %01100110,%00110011,%10011001,%11001100,%01100110,%00110011,%10011001,%11001100 ; char 187
4BEF: 663399CC	
4BF3: CC993366	        defb %11001100,%10011001,%00110011,%01100110,%11001100,%10011001,%00110011,%01100110 ; char 188
4BF7: CC993366	
4BFB: 3399CC66	        defb %00110011,%10011001,%11001100,%01100110,%00110011,%10011001,%11001100,%01100110 ; char 189
4BFF: 3399CC66	
4C03: 66CC9933	        defb %01100110,%11001100,%10011001,%00110011,%01100110,%11001100,%10011001,%00110011 ; char 190
4C07: 66CC9933	
4C0B: 10107C10	        defb %00010000,%00010000,%01111100,%00010000,%00010000,%00000000,%01111100,%00000000 ; char 191 (±)
4C0F: 10007C00	
4C13: 60180618	        defb %01100000,%00011000,%00000110,%00011000,%01100000,%00000000,%01111110,%00000000 ; char 192 (≥)
4C17: 60007E00	
4C1B: 06186018	        defb %00000110,%00011000,%01100000,%00011000,%00000110,%00000000,%01111110,%00000000 ; char 193 (≤)
4C1F: 06007E00	
4C23: 3E202020	        defb %00111110,%00100000,%00100000,%00100000,%10100000,%01100000,%00100000,%00000000 ; char 194 (square root)
4C27: A0602000	
4C2B: 30484830	        defb %00110000,%01001000,%01001000,%00110000,%00000000,%00000000,%00000000,%00000000 ; char 195 (°)
4C2F: 00000000	
4C33: 60103040	        defb %01100000,%00010000,%00110000,%01000000,%01110000,%00000000,%00000000,%00000000 ; char 196 (²)
4C37: 70000000	
4C3B: 00002A54	        defb %00000000,%00000000,%00101010,%01010100,%00000000,%01111110,%00000000,%00000000 ; char 197 
4C3F: 007E0000	
4C43: 0054A800	        defb %00000000,%01010100,%10101000,%00000000,%01010100,%10101000,%00000000,%00000000 ; char 198 (≈)
4C47: 54A80000	
4C4B: 80C0E0F0	        defb %10000000,%11000000,%11100000,%11110000,%11100000,%11000000,%10000000,%00000000 ; char 199
4C4F: E0C08000	
4C53: FE7C3810	        defb %11111110,%01111100,%00111000,%00010000,%00000000,%00000000,%00000000,%00000000 ; char 200
4C57: 00000000	
4C5B: 0103070F	        defb %00000001,%00000011,%00000111,%00001111,%00000111,%00000011,%00000001,%00000000 ; char 201
4C5F: 07030100	
4C63: 00000000	        defb %00000000,%00000000,%00000000,%00000000,%00010000,%00111000,%01111100,%11111110 ; char 202
4C67: 10387CFE	
4C6B: 10387C10	        defb %00010000,%00111000,%01111100,%00010000,%00010000,%00010000,%00010000,%00000000 ; char 203 (up arrow)
4C6F: 10101000	
4C73: 1E0E0E12	        defb %00011110,%00001110,%00001110,%00010010,%00100000,%01000000,%00000000,%00000000 ; char 204 (up right arrow)
4C77: 20400000	
4C7B: 00080CFE	        defb %00000000,%00001000,%00001100,%11111110,%00001100,%00001000,%00000000,%00000000 ; char 205 (right arrow)
4C7F: 0C080000	
4C83: 00402012	        defb %00000000,%01000000,%00100000,%00010010,%00001110,%00001110,%00011110,%00000000 ; char 206 (down right arrow)
4C87: 0E0E1E00	
4C8B: 10101010	        defb %00010000,%00010000,%00010000,%00010000,%01111100,%00111000,%00010000,%00000000 ; char 207 (down arrow)
4C8F: 7C381000	
4C93: 00040890	        defb %00000000,%00000100,%00001000,%10010000,%11100000,%11100000,%11110000,%00000000 ; char 208 (down left arrow)
4C97: E0E0F000	
4C9B: 002060FE	        defb %00000000,%00100000,%01100000,%11111110,%01100000,%00100000,%00000000,%00000000 ; char 209 (left arrow)
4C9F: 60200000	
4CA3: F0E0E090	        defb %11110000,%11100000,%11100000,%10010000,%00001000,%00000100,%00000000,%00000000 ; char 210 (up left arrow)
4CA7: 08040000	
4CAB: 3844F040	        defb %00111000,%01000100,%11110000,%01000000,%11110000,%01000100,%00111000,%00000000 ; char 211 (euro)
4CAF: F0443800	
4CB3: 00027CA8	        defb %00000000,%00000010,%01111100,%10101000,%00101000,%00101000,%00101000,%00000000 ; char 212 (greek pi)
4CB7: 28282800	
4CBB: 00000007	        defb %00000000,%00000000,%00000000,%00000111,%00001000,%00010000,%00010000,%00010000 ; char 213
4CBF: 08101010	
4CC3: 000000C0	        defb %00000000,%00000000,%00000000,%11000000,%00100000,%00010000,%00010000,%00010000 ; char 214
4CC7: 20101010	
4CCB: 101020C0	        defb %00010000,%00010000,%00100000,%11000000,%00000000,%00000000,%00000000,%00000000 ; char 215
4CCF: 00000000	
4CD3: 10100807	        defb %00010000,%00010000,%00001000,%00000111,%00000000,%00000000,%00000000,%00000000 ; char 216
4CD7: 00000000	
4CDB: 00000007	        defb %00000000,%00000000,%00000000,%00000111,%00001111,%00011100,%00011000,%00011000 ; char 217
4CDF: 0F1C1818	
4CE3: 000000E0	        defb %00000000,%00000000,%00000000,%11100000,%11110000,%00111000,%00011000,%00011000 ; char 218
4CE7: F0381818	
4CEB: 181838F0	        defb %00011000,%00011000,%00111000,%11110000,%11100000,%00000000,%00000000,%00000000 ; char 219
4CEF: E0000000	
4CF3: 18181C0F	        defb %00011000,%00011000,%00011100,%00001111,%00000111,%00000000,%00000000,%00000000 ; char 220
4CF7: 07000000	
4CFB: 003C4242	        defb %00000000,%00111100,%01000010,%01000010,%01000010,%01000010,%00111100,%00000000 ; char 221
4CFF: 42423C00	
4D03: 003C7E7E	        defb %00000000,%00111100,%01111110,%01111110,%01111110,%01111110,%00111100,%00000000 ; char 222
4D07: 7E7E3C00	
4D0B: 00183C7E	        defb %00000000,%00011000,%00111100,%01111110,%01111110,%00111100,%00011000,%00000000 ; char 223
4D0F: 7E3C1800	
4D13: FFFEFCF8	        defb %11111111,%11111110,%11111100,%11111000,%11110000,%11100000,%11000000,%10000000 ; char 224
4D17: F0E0C080	
4D1B: FF7F3F1F	        defb %11111111,%01111111,%00111111,%00011111,%00001111,%00000111,%00000011,%00000001 ; char 225
4D1F: 0F070301	
4D23: 0103070F	        defb %00000001,%00000011,%00000111,%00001111,%00011111,%00111111,%01111111,%11111111 ; char 226
4D27: 1F3F7FFF	
4D2B: 80C0E0F0	        defb %10000000,%11000000,%11100000,%11110000,%11111000,%11111100,%11111110,%11111111 ; char 227
4D2F: F8FCFEFF	
4D33: 0002066C	        defb %00000000,%00000010,%00000110,%01101100,%01111000,%01110000,%01100000,%00000000 ; char 228 (checkmark)
4D37: 78706000	
4D3B: 00663C18	        defb %00000000,%01100110,%00111100,%00011000,%00111100,%01100110,%00000000,%00000000 ; char 229 (x)
4D3F: 3C660000	
4D43: 38444444	        defb %00111000,%01000100,%01000100,%01000100,%00111000,%00010000,%00111000,%00010000 ; char 230 (female)
4D47: 38103810	
4D4B: 07033D44	        defb %00000111,%00000011,%00111101,%01000100,%01000100,%01000100,%00111000,%00000000 ; char 231 (male)
4D4F: 44443800	
4D53: 78444242	        defb %01111000,%01000100,%01000010,%01000010,%01000010,%01000010,%01000010,%01111110 ; char 232 (new doc)
4D57: 4242427E	
4D5B: 00F8FF81	        defb %00000000,%11111000,%11111111,%10000001,%10000001,%10000001,%10000001,%11111111 ; char 233 (folder)
4D5F: 818181FF	
4D63: 107CFE54	        defb %00010000,%01111100,%11111110,%01010100,%01010100,%01010100,%01010100,%01111100 ; char 234 (trash bin)
4D67: 5454547C	
4D6B: FF818181	        defb %11111111,%10000001,%10000001,%10000001,%10111101,%10101101,%10101101,%11111111 ; char 235 (floppy disk)
4D6F: BDADADFF	
4D73: 00EAAAAC	        defb %00000000,%11101010,%10101010,%10101100,%10101100,%10101010,%11101010,%00000000 ; char 236 (OK)
4D77: ACAAEA00	
4D7B: 187EFF7E	        defb %00011000,%01111110,%11111111,%01111110,%01111110,%01100110,%01100110,%01100110 ; char 237 (home)
4D7F: 7E666666	
4D83: 3C429191	        defb %00111100,%01000010,%10010001,%10010001,%10011101,%10000001,%01000010,%00111100 ; char 238 (clock)
4D87: 9D81423C	
4D8B: 000205FD	        defb %00000000,%00000010,%00000101,%11111101,%10100101,%10100010,%00000000,%00000000 ; char 239 (key)
4D8F: A5A20000	
4D93: 080C3E4C	        defb %00001000,%00001100,%00111110,%01001100,%01001000,%01000010,%01000010,%00111100 ; char 240 (undo)
4D97: 4842423C	
4D9B: 00FFC3A5	        defb %00000000,%11111111,%11000011,%10100101,%10011001,%10000001,%11111111,%00000000 ; char 241 (letter)
4D9F: 9981FF00	
4DA3: 3844447C	        defb %00111000,%01000100,%01000100,%01111100,%01111100,%01111100,%01111100,%00000000 ; char 242 (lock)
4DA7: 7C7C7C00	
4DAB: 060909F8	        defb %00000110,%00001001,%00001001,%11111000,%11111000,%11111000,%11111000,%00000000 ; char 243 (unlock)
4DAF: F8F8F800	
4DB3: FFFF81AD	        defb %11111111,%11111111,%10000001,%10101101,%10100101,%10100101,%10000001,%11111111 ; char 244 (calendar)
4DB7: A5A581FF	
4DBB: 011A244A	        defb %00000001,%00011010,%00100100,%01001010,%01010010,%00100100,%01011000,%10000000 ; char 245 (diameter)
4DBF: 52245880	
4DC3: 7E818181	        defb %01111110,%10000001,%10000001,%10000001,%10000001,%01110110,%00001100,%00000100 ; char 246 (baloon)
4DC7: 81760C04	
4DCB: 0C0A0A0A	        defb %00001100,%00001010,%00001010,%00001010,%00001000,%00011000,%00111000,%00010000 ; char 247 (note)
4DCF: 08183810	
4DD3: 1231F5F5	        defb %00010010,%00110001,%11110101,%11110101,%11110101,%11110101,%00110001,%00010010 ; char 248 (audio on)
4DD7: F5F53112	
4DDB: 1030F0F0	        defb %00010000,%00110000,%11110000,%11110000,%11110000,%11110000,%00110000,%00010000 ; char 249 (audio off)
4DDF: F0F03010	
4DE3: 40607078	        defb %01000000,%01100000,%01110000,%01111000,%01111100,%01111110,%01111000,%01001000 ; char 250 (pointer)
4DE7: 7C7E7848	
4DEB: 3C4299A1	        defb %00111100,%01000010,%10011001,%10100001,%10100001,%10011001,%01000010,%00111100 ; char 251 (©)
4DEF: A199423C	
4DF3: 18242078	        defb %00011000,%00100100,%00100000,%01111000,%00100000,%00100010,%01011100,%00000000 ; char 252 (£)
4DF7: 20225C00	
4DFB: 3C427824	        defb %00111100,%01000010,%01111000,%00100100,%00100100,%00011110,%01000010,%00111100 ; char 253 (§)
4DFF: 241E423C	
4E03: 00001000	        defb %00000000,%00000000,%00010000,%00000000,%01111100,%00000000,%00010000,%00000000 ; char 254 (÷)
4E07: 7C001000	
4E0B: FFFFFFFF	        defb %11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111 ; char 255 (cursor)
4E0F: FFFFFFFF	
              	
              	; ------------------------------------------------------------------------------
              	; LM80C - LOGO CHARSET - R1.1
              	; ------------------------------------------------------------------------------
              	; The following code is intended to be used with LM80C Z80-based computer
              	; designed by Leonardo Miliani. More info at
              	; www DOT leonardomiliani DOT com
              	; ------------------------------------------------------------------------------
              	; Code Revision:
              	; R1.0 - 20200124 - First revision: logo chars
              	; R1.1 - 20200229 - Adopted usual hexadecimal & binary prefixes
              	; ------------------------------------------------------------------------------
              	
4E13:         	LOGOFONT:   equ $
4E13: 00000000	            defb %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000 ; 0
4E17: 00000000	
4E1B: FFFFFFFF	            defb %11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111 ; 1
4E1F: FFFFFFFF	
4E23: FFFFFFFF	            defb %11111111,%11111111,%11111111,%11111111,%00000000,%00000000,%00000000,%00000000 ; 2
4E27: 00000000	
4E2B: 0F0F0F0F	            defb %00001111,%00001111,%00001111,%00001111,%00001111,%00001111,%00001111,%00001111 ; 3
4E2F: 0F0F0F0F	
4E33: 00000000	            defb %00000000,%00000000,%00000000,%00000000,%11111111,%11111111,%11111111,%11111111 ; 4
4E37: FFFFFFFF	
4E3B: F0F0F0F0	            defb %11110000,%11110000,%11110000,%11110000,%11110000,%11110000,%11110000,%11110000 ; 5
4E3F: F0F0F0F0	
4E43: 00000000	            defb %00000000,%00000000,%00000000,%00000000,%00001111,%00001111,%00001111,%00001111 ; 6
4E47: 0F0F0F0F	
4E4B: 00000000	            defb %00000000,%00000000,%00000000,%00000000,%11110000,%11110000,%11110000,%11110000 ; 7
4E4F: F0F0F0F0	
4E53: F0F0F0F0	            defb %11110000,%11110000,%11110000,%11110000,%00000000,%00000000,%00000000,%00000000 ; 8
4E57: 00000000	
4E5B: 0F0F0F0F	            defb %00001111,%00001111,%00001111,%00001111,%00000000,%00000000,%00000000,%00000000 ; 9
4E5F: 00000000	
4E63: 000000FC	            defb %00000000,%00000000,%00000000,%11111100,%11111111,%00000111,%00000011,%00000000 ; 10
4E67: FF070300	
4E6B: 0000003F	            defb %00000000,%00000000,%00000000,%00111111,%11111111,%11100000,%11000000,%00000000 ; 11
4E6F: FFE0C000	
4E73: 18181F19	            defb %00011000,%00011000,%00011111,%00011001,%00011001,%00011111,%00011000,%00011000 ; 12
4E77: 191F1818	
4E7B: 1818F898	            defb %00011000,%00011000,%11111000,%10011000,%10011000,%11111000,%00011000,%00011000 ; 13
4E7F: 98F81818	
4E83: 18181C1F	            defb %00011000,%00011000,%00011100,%00011111,%00001111,%00000000,%00000000,%00000000 ; 14
4E87: 0F000000	
4E8B: 0000000F	            defb %00000000,%00000000,%00000000,%00001111,%00011111,%00011100,%00011000,%00011000 ; 15
4E8F: 1F1C1818	
4E93: 000000F0	            defb %00000000,%00000000,%00000000,%11110000,%11111000,%00111000,%00011000,%00011000 ; 16
4E97: F8381818	
4E9B: 181838F8	            defb %00011000,%00011000,%00111000,%11111000,%11110000,%00000000,%00000000,%00000000 ; 17
4E9F: F0000000	
4EA3: 000000FF	            defb %00000000,%00000000,%00000000,%11111111,%11111111,%00000000,%00000000,%00000000 ; 18
4EA7: FF000000	
4EAB: 0F0F0F0F	            defb %00001111,%00001111,%00001111,%00001111,%11111111,%11111111,%11111111,%11111111 ; 19
4EAF: FFFFFFFF	
4EB3: F0F0F0F0	            defb %11110000,%11110000,%11110000,%11110000,%11111111,%11111111,%11111111,%11111111 ; 20
4EB7: FFFFFFFF	
4EBB: FFFFFFFF	            defb %11111111,%11111111,%11111111,%11111111,%11110000,%11110000,%11110000,%11110000 ; 21
4EBF: F0F0F0F0	
4EC3: FFFFFFFF	            defb %11111111,%11111111,%11111111,%11111111,%00001111,%00001111,%00001111,%00001111 ; 22
4EC7: 0F0F0F0F	
4ECB: 00307878	            defb %00000000,%00110000,%01111000,%01111000,%00110000,%00000000,%00000000,%00000000 ; 23
4ECF: 30000000	
              	            ; ------------------------------------------------------------------------------
              	; LM80C - FIRMWARE - R3.14
              	; ------------------------------------------------------------------------------
              	; The following code is intended to be used with LM80C Z80-based computer
              	; designed by Leonardo Miliani. More info at
              	; www DOT leonardomiliani DOT com
              	; ------------------------------------------------------------------------------
              	; Coding/Editing/Compiling:
              	; Original init code for MC68B05 by Grant Searle
              	; Original SIO/CTC/PIO init code by Mario Blunk
              	; NASCOM BASIC originally modified by Gran Searle
              	; Code modified and adapted for LM80C by Leonardo Miliani
              	;
              	; Edited with Atom Editor
              	;
              	; Compiled with ZASM assembler 4.2.4
              	; https://k1.spdns.de/Develop/Projects/zasm-4.0/Distributions/
              	; ------------------------------------------------------------------------------
              	; Copyright notes:
              	; Parts of the code (c) Grant Searle - free for non commercial use
              	; Please include this advice and the note to the attribution of the original
              	; version to Grant Searle if you intend to redistribuite it
              	; http://searle.hostei.com/grant/index.html
              	; eMail: home.micros01@btinternet.com
              	;
              	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
              	; Parts of the code (c) Mario Blunk
              	; http://www.train­z.de
              	;
              	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
              	; NASCOM ROM BASIC Ver 4.7, (C) 1978 Microsoft
              	; Scanned from source published in 80-BUS NEWS from Vol 2, Issue 3
              	; (May-June 1983) to Vol 3, Issue 3 (May-June 1984)
              	; Adapted for the freeware Zilog Macro Assembler 2.10 to produce
              	; the original ROM code (checksum A934H). PA
              	;
              	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
              	; The following code is intended to be used with LM80C Z80-based computer
              	; designed by Leonardo Miliani. Code and computer schematics are released under
              	; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
              	; kind of warranty: you can use them at your own risk.
              	; You are free to use them for any non-commercial use: you are only asked to
              	; maintain the copyright notices, include this advice and the note to the 
              	; attribution of the original version to Leonardo Miliani, if you intend to
              	; redistribuite them.
              	; https://www.leonardomiliani.com
              	; 
              	; Please support me by visiting the following links:
              	; Main project page: https://www.leonardomiliani.com
              	; Schematics and code: https://github.com/leomil72/LM80C
              	; Videos about the computer: https://www.youtube.com/user/leomil72/videos
              	; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
              	; ------------------------------------------------------------------------------
              	
              	
              	; ------------------------------------------------------------------------------
              	; this line instructs the assembler to prepare a file for a ROM target
              	; meaning that blank cells will be filled up with $FF
              	#target rom
              	
              	; this line instructs the assembler to compile taking account that code
              	; starts at $0000 (the address reached by Z80 upon reset)
0000:         	#code BOOT, $0000
              	
              	; ------------------------------------------------------------------------------
              	; include the latest version of the bootloader: this sets up the address aliases
              	; configu
              	
              	; END OF ASSEMBLY SOURCE
              	#end
              	
              	;-------------------------------------------------------------------------------


; +++ segments +++

#CODE          = $0000 =     0,  size = $4ED3 = 20179
#CODE BOOT     = $0000 =     0,  size = $0000 =     0

; +++ global symbols +++

ABPASS           = $22C9 =  8905          :4663
ABS              = $2D12 = 11538          :6264
ACCSUM           = $1AFF =  6911          :3531 (unused)
ACPASS           = $22C8 =  8904          :4662
ADD30            = $3CEA = 15594          :8502
ADD301           = $3CFA = 15610          :8513
ADDEXP           = $2CAB = 11435          :6199
ADDIG            = $2E51 = 11857          :6489
ADDNEWLINE       = $0990 =  2448          :1424
ADDPHL           = $2A47 = 10823          :5807
ADRS1            = $81F1 = 33265          :5155
ADRS2            = $81F5 = 33269          :5157
ALLFOL           = $2597 =  9623          :5111
ANTVLU           = $1E04 =  7684          :3941
ARET             = $31A2 = 12706          :6929 (unused)
ARLDSV           = $21D3 =  8659          :4502
ARREND           = $81BF = 33215          :2049
ARRLP            = $2462 =  9314          :4902
ASC              = $2568 =  9576          :5081
ASCTFP           = $2DF4 = 11764          :6435
ASPCS            = $1D65 =  7525          :3863
ATHOME           = $060F =  1551          :906
ATN              = $3156 = 12630          :6900
ATN1             = $3173 = 12659          :6912
ATNTAB           = $317D = 12669          :6917
ATOH             = $1B3A =  6970          :3564
A_RTS_OFF        = $0165 =   357          :198
A_RTS_ON         = $0173 =   371          :209
BACKSPACE        = $078D =  1933          :1135
BADINP           = $1D88 =  7560          :3875
BAKSTK           = $14EE =  5358          :2636
BAKTMP           = $2548 =  9544          :5059
BASTXT           = $8133 = 33075          :2025
BCDEFP           = $2D39 = 11577          :6293
BEEPOFF          = $0539 =  1337          :773
BFREE            = $0F9C =  3996          :2218
BIN              = $3D3C = 15676          :8562
BIN2             = $3D42 = 15682          :8564 (unused)
BINERR           = $3D99 = 15769          :8623
BINIT            = $3D78 = 15736          :8598
BINTFP           = $3D6E = 15726          :8594
BITOUT           = $3D56 = 15702          :8576
BITOUT2          = $3D5A = 15706          :8578
BITS6            = $3A9F = 15007          :8184
BITS7            = $3AA9 = 15017          :8189
BITS8            = $3AB4 = 15028          :8194
BKGNDCLR         = $81EE = 33262          :2076
BKSP             = $0008 =     8          :1974
BN               = $0028 =    40          :2127
BNMSG            = $137A =  4986          :2544
BNORM            = $2AA7 = 10919          :5866
BNPTR            = $13F6 =  5110          :2571 (unused)
BNRMLP           = $2AAA = 10922          :5869
BOOT             = $0000 =     0  BOOT    :9455 (unused)
BOOT_end         = $0000 =     0  BOOT    :9455 (unused)
BOOT_size        = $0000 =     0  BOOT    :9455 (unused)
BPS              = $81F8 = 33272          :8005
BRK              = $1AAD =  6829          :3488
BRKFLG           = $80A9 = 32937          :2019
BRKLIN           = $81B3 = 33203          :2043
BRKMSG           = $14E8 =  5352          :2634
BRKRET           = $0F93 =  3987          :2214
BS               = $0010 =    16          :2115
BSERR            = $2206 =  8710          :4533
BSMSG            = $12A9 =  4777          :2532
BSPTR            = $13DE =  5086          :2559 (unused)
BUFFER           = $8136 = 33078          :2026
BYT2ASC          = $3CE1 = 15585          :8497
BYTSFT           = $2BDF = 11231          :6077
CFEVAL           = $2169 =  8553          :4433
CH3_TIMER        = $0237 =   567          :349
CHABFREMPTY      = $01C8 =   456          :263
CHAR2VID         = $06C8 =  1736          :1030
CHARINTOBFR      = $0136 =   310          :167
CHARTY           = $2117 =  8471          :4389
CHASNDDTN        = $8223 = 33315          :2087
CHBSNDDTN        = $8225 = 33317          :2088
CHCKYPOS         = $07B3 =  1971          :1154
CHCKYPOS2        = $081E =  2078          :1214
CHCSNDDTN        = $8227 = 33319          :2089
CHECKALT         = $0CA8 =  3240          :1734
CHECKCTRL        = $0CB6 =  3254          :1740
CHECKKBD         = $0CC4 =  3268          :1746
CHECKPA          = $351B = 13595          :7460
CHECKPY          = $351C = 13596          :7461
CHECKWARM        = $02BB =   699          :417
CHEKFN           = $2360 =  9056          :4755
CHKALT           = $0D3C =  3388          :1806
CHKBIN           = $3D8B = 15755          :8613
CHKBKSP          = $06F2 =  1778          :1050
CHKCLR0          = $332A = 13098          :7165
CHKCLR1          = $3326 = 13094          :7163
CHKCR            = $06E9 =  1769          :1046
CHKCRSDWN        = $0716 =  1814          :1066
CHKCRSLFT        = $06FB =  1787          :1054
CHKCRSR          = $0246 =   582          :359
CHKCRSRGT        = $070D =  1805          :1062
CHKCRSUP         = $0704 =  1796          :1058
CHKCS            = $06E0 =  1760          :1042
CHKCTRL          = $0D33 =  3379          :1802
CHKEY1           = $3C97 = 15511          :8455
CHKEY2           = $3C9C = 15516          :8456
CHKEY3           = $3C9F = 15519          :8457
CHKEY4           = $3CA5 = 15525          :8458
CHKEY5           = $3CA8 = 15528          :8459
CHKFNK           = $0D6F =  3439          :1831
CHKG2M           = $3330 = 13104          :7171
CHKINK           = $2A26 = 10790          :5786
CHKLF            = $071F =  1823          :1070
CHKLN            = $0D1F =  3359          :1793
CHKLTR           = $1B0C =  6924          :3540
CHKSCAR          = $326D = 12909          :7061
CHKSNDCH         = $0C2D =  3117          :1660
CHKSTK           = $1522 =  5410          :2673
CHKSUM           = $80A6 = 32934          :2017
CHKSYN           = $1847 =  6215          :3143
CHKTYP           = $1EE4 =  7908          :4056
CHKYPOS          = $07DA =  2010          :1175
CHR              = $2579 =  9593          :5093
CHR4VID          = $81EC = 33260          :2074
CHRPNT           = $81F9 = 33273          :7188
CHRST68          = $3E13 = 15891          :8813
CHRST88          = $4613 = 17939          :9098
CIRCLE           = $3745 = 14149          :7755
CKBPS            = $3A52 = 14930          :8144
CKCOL            = $3417 = 13335          :7303
CKINCHAR         = $0224 =   548          :330
CKMAGN           = $3220 = 12832          :7014
CLEAR            = $1B5F =  7007          :3588
CLEARVIDBUF      = $0602 =  1538          :899
CLOTST           = $1893 =  6291          :3190
CLREG            = $16B1 =  5809          :2916
CLREX2           = $32E4 = 13028          :7120
CLRG1            = $32D2 = 13010          :7112
CLRG2            = $32DB = 13019          :7116
CLRG2PTNTBL      = $05A2 =  1442          :837
CLRMC            = $32CB = 13003          :7108
CLRPRM           = $392C = 14636          :7978
CLRPSGREGS       = $0BCB =  3019          :1605
CLRPTR           = $168C =  5772          :2896
CLRTABLE         = $0562 =  1378          :804
CLRTXT           = $32C8 = 13000          :7107
CLRVDBF          = $3914 = 14612          :7958
CLR_RAM_REG      = $0A11 =  2577          :1461
CLS              = $31A5 = 12709          :6934
CLSQT            = $3C5E = 15454          :8421
CLSQT1           = $3C6E = 15470          :8429
CMP16            = $3DC5 = 15813          :8686
CMPFP            = $2D82 = 11650          :6351
CMPLG1           = $207D =  8317          :4295
CMPLOG           = $207B =  8315          :4294
CMPNUM           = $2D68 = 11624          :6334
CMPRES           = $20BF =  8383          :4343
CMPSTR           = $20A7 =  8359          :4323
CMP_A            = $29FF = 10751          :5767
CN               = $0020 =    32          :2123
CNMSG            = $133A =  4922          :2540
CNPTR            = $13EE =  5102          :2567 (unused)
CNT1INS          = $2671 =  9841          :5238
CNTCHKSND        = $0C68 =  3176          :1695
CNTCKCL          = $329A = 12954          :7087
CNTCL1           = $3807 = 14343          :7842
CNTCL2           = $382B = 14379          :7855
CNTCL3           = $384F = 14415          :7868
CNTCL4           = $3875 = 14453          :7882
CNTCL5           = $3897 = 14487          :7894
CNTCL6           = $38BB = 14523          :7907
CNTCL7           = $38DF = 14559          :7920
CNTDRW           = $36E8 = 14056          :7708
CNTEND           = $1D2D =  7469          :3833
CNTFNK           = $0DCA =  3530          :1881
CNTGPT2          = $3396 = 13206          :7228
CNTKBCK          = $0D69 =  3433          :1829
CNTLGC           = $203C =  8252          :4249
CNTLTK           = $3C24 = 15396          :8390
CNTNULL          = $0920 =  2336          :1367
CNTNULL2         = $094A =  2378          :1389
CNTPLOT          = $3597 = 13719          :7527
CNTPLT1          = $35B8 = 13752          :7547
CNTRX2           = $39D2 = 14802          :8085
CNTRXCHA         = $0120 =   288          :151
CNTSER           = $399E = 14750          :8056
CNTSER2          = $39DD = 14813          :8092
CNTSER3          = $39EF = 14831          :8101
CNTTXA           = $0201 =   513          :302
CNTVALY          = $390F = 14607          :7951
CNTWTSP          = $19AA =  6570          :3324
CNTZIN           = $26A8 =  9896          :5261
CNVNUM           = $2E00 = 11776          :6441
COLD             = $0EF2 =  3826          :2133
COLDSTART        = $02B3 =   691          :414
COLOR            = $327D = 12925          :7076
COMMAN           = $80A3 = 32931          :2014
COMPL            = $2B07 = 11015          :5940
CONCAT           = $24DD =  9437          :4992
CONEXP           = $2E30 = 11824          :6465
CONPOS           = $2AA4 = 10916          :5864
CONT             = $1AE6 =  6886          :3518
CONTAD           = $81B9 = 33209          :2046
CONTCRSLFT       = $07C4 =  1988          :1162
CONTCRSRGT       = $0831 =  2097          :1224
CONTROLKEYS      = $822D = 33325          :2094
CONT_POS_CURS    = $06A8 =  1704          :1007
CONVAR           = $1FCF =  8143          :4180
CORW             = $02A7 =   679          :409
COS              = $30DA = 12506          :6848
COUNTER          = $02EF =   751          :447
CPDEHL           = $1841 =  6209          :3136
CPKEY            = $3BBB = 15291          :8335
CPKEY1           = $3BDA = 15322          :8352
CPKEY2           = $3BCB = 15307          :8342
CPKEY3           = $3BD2 = 15314          :8345
CPKYEND          = $3BE2 = 15330          :8357
CPYLIT           = $1786 =  6022          :3035
CR               = $000D =    13          :1977
CRARLP           = $2226 =  8742          :4553
CREARY           = $220B =  8715          :4536
CRESTR           = $1C66 =  7270          :3731
CRGRETURN        = $08F2 =  2290          :1343
CRNCLP           = $16E7 =  5863          :2943
CRSDN            = $001F =    31          :1991
CRSLFT           = $001C =    28          :1988
CRSRGT           = $001D =    29          :1989
CRSR_STATE       = $81E9 = 33257          :2071
CRSUP            = $001E =    30          :1990
CRTMST           = $2399 =  9113          :4788
CRTST            = $23A5 =  9125          :4799
CRTSTE           = $23BB =  9147          :4813
CRUNCH           = $16DE =  5854          :2939
CS               = $000C =    12          :1976
CSTART           = $0EFF =  3839          :2139
CTC0IV           = $81D2 = 33234          :2057
CTC1IV           = $81D5 = 33237          :2058
CTC2IV           = $81D8 = 33240          :2059
CTC3IV           = $81DB = 33243          :2060
CTCCONF          = $032E =   814          :505
CTC_CFG          = $3B25 = 15141          :8250
CTC_CH0          = $0010 =    16          :36
CTC_CH1          = $0011 =    17          :37
CTC_CH2          = $0012 =    18          :38
CTC_CH3          = $0013 =    19          :39
CTLOFG           = $80A5 = 32933          :2016
CTPOINT          = $355D = 13661          :7495
CTRLC            = $0003 =     3          :1972
CTRLG            = $0007 =     7          :1973
CTRLO            = $000F =    15          :1978
CTRLQ            = $0011 =    17          :1979
CTRLR            = $0012 =    18          :1980
CTRLS            = $0013 =    19          :1981
CTRLU            = $0015 =    21          :1982
CTSNDC           = $28D2 = 10450          :5600
CUROPR           = $81AA = 33194          :2037
CURPOS           = $8190 = 33168          :2028
CURSORDOWN       = $083A =  2106          :1232
CURSORLEFT       = $07A0 =  1952          :1145
CURSORRIGHT      = $0805 =  2053          :1201
CURSORUP         = $07EC =  2028          :1186
CURSOR_OFF       = $0870 =  2160          :1265
CURSOR_ON        = $085A =  2138          :1252
CUR_POS          = $81EF = 33263          :1340
DATA             = $1C0D =  7181          :3683
DATABT           = $81FA = 33274          :8006
DATFLG           = $8193 = 33171          :2031
DATLIN           = $81AE = 33198          :2039
DATSNR           = $155F =  5471          :2715
DC               = $8201 = 33281          :7754
DCBCDE           = $2DB9 = 11705          :6394
DD               = $0012 =    18          :2116
DDERR            = $156E =  5486          :2723
DDMSG            = $12B7 =  4791          :2533
DDPTR            = $13E0 =  5088          :2560 (unused)
DECLN1           = $3BAD = 15277          :8327
DEC_D            = $04F9 =  1273          :732
DEC_E            = $02ED =   749          :446
DEEK             = $31C1 = 12737          :6951
DEF              = $22DD =  8925          :4676
DEFFNKS          = $1455 =  5205          :2617
DEFSER           = $3A39 = 14905          :8131
DEFSIZ           = $222E =  8750          :4557
DEINT            = $1B20 =  6944          :3551
DEL              = $007F =   127          :1986
DELCHR           = $17B6 =  6070          :3065
DEPINT           = $1B1A =  6938          :3549
DETHL4           = $2D48 = 11592          :6305
DETHLB           = $2D4A = 11594          :6306
DIGTXT           = $2EFA = 12026          :6587
DIM              = $20E9 =  8425          :4369
DIMRET           = $20E0 =  8416          :4364
DINPOS           = $1876 =  6262          :3170
DINT             = $2BE4 = 11236          :6085
DIRMOD           = $3B39 = 15161          :8260
DIR_PAU          = $31EC = 12780          :6980 (unused)
DISNMI           = $2780 = 10112          :5393
DIV              = $2C41 = 11329          :6126
DIV1             = $806B = 32875          :2005
DIV10            = $2C35 = 11317          :6121
DIV2             = $806F = 32879          :2006
DIV3             = $8073 = 32883          :2007
DIV4             = $8076 = 32886          :2008
DIVLP            = $2C68 = 11368          :6150
DIVSUP           = $806A = 32874          :2004
DIV_16_8         = $3E04 = 15876          :8778
DIV_16_8LP       = $3E07 = 15879          :8780
DIV_8_8          = $3DF4 = 15860          :8755
DIV_8_8LOOP      = $3DF8 = 15864          :8758
DLSZ             = $37C9 = 14281          :7815
DOAGN            = $16CA =  5834          :2929
DOCOM            = $1D32 =  7474          :3837
DODEL            = $1796 =  6038          :3049
DOEBIT           = $2F3A = 12090          :6630
DOFN             = $230A =  8970          :4704
DOKE             = $31CC = 12748          :6959
DOSPC            = $1D60 =  7520          :3860
DOTAB            = $1D4B =  7499          :3849
DPOINT           = $2E2C = 11820          :6463
DRAW             = $360F = 13839          :7630
DRWCRL           = $37E5 = 14309          :7830
DTSTR            = $23A9 =  9129          :4802
DVBCDE           = $2C43 = 11331          :6128
DX               = $8203 = 33283          :7628
DXGR             = $3718 = 14104          :7725
DY               = $8205 = 33285          :7629
DZ               = $0014 =    20          :2117
DZERR            = $1568 =  5480          :2719
DZMSG            = $12CC =  4812          :2534
DZPTR            = $13E2 =  5090          :2561 (unused)
E2               = $81FD = 33277          :7625
ECHDEL           = $17AA =  6058          :3058
ECHO_CHAR        = $02C5 =   709          :423
EDIGIT           = $2E73 = 11891          :6512
EMPTINS          = $2610 =  9744          :5196
EMPTSNDBFR       = $0BC7 =  3015          :1602
EMPTVRM          = $0A08 =  2568          :1453
EMPTYCHABFR      = $01BA =   442          :256
EMPTYG2          = $0590 =  1424          :829
EMPTYMC          = $05C1 =  1473          :855
EMPTYVIDBUF      = $0567 =  1383          :808
EMPTY_VRAM       = $09FD =  2557          :1446
ENDBUF           = $178D =  6029          :3041
ENDCON           = $2E3F = 11839          :6475
ENDCRL           = $37E1 = 14305          :7826
ENDCTRLCK        = $0D0A =  3338          :1782
ENDDIM           = $228D =  8845          :4626
ENDDRAW          = $3741 = 14145          :7739
ENDINK           = $2A38 = 10808          :5797
ENDINK2          = $2A41 = 10817          :5804 (unused)
ENDINP           = $1D19 =  7449          :3824
ENDNAM           = $210B =  8459          :4385
ENDPRG           = $1ABC =  6844          :3498
ENDTMR           = $22A2 =  8866          :4639
ENDTXT           = $81F3 = 33267          :1342
ENDVDPSET        = $0496 =  1174          :677
ENFMEM           = $152B =  5419          :2679
ER               = $81FB = 33275          :7624
ER2              = $36BC = 14012          :7692
ERASECLRTBL      = $0515 =  1301          :749
ERRIN            = $159D =  5533          :2747
ERRINT           = $1AE0 =  6880          :3514
ERRLIN           = $81B7 = 33207          :2045
ERRMSG           = $14D7 =  5335          :2630
ERROR            = $1579 =  5497          :2731
ERRORS           = $1234 =  4660          :2523 (unused)
ERRTBL           = $13CE =  5070          :2550
ESC              = $001B =    27          :1984
EVAL             = $1EF1 =  7921          :4064
EVAL1            = $1EF4 =  7924          :4066
EVAL2            = $1EFD =  7933          :4070
EVAL3            = $1F00 =  7936          :4071
EVLPAR           = $1FB6 =  8118          :4166
EVNOT            = $20C9 =  8393          :4351
EXCUTE           = $1A4A =  6730          :3418
EXG2MD           = $0453 =  1107          :643
EXITCHAR2VID     = $075B =  1883          :1099
EXITCURSORDOWN   = $0857 =  2135          :1246
EXITCURSORLEFT   = $07C7 =  1991          :1163
EXITCURSORRGHT   = $0837 =  2103          :1226
EXITCURSORUP     = $0803 =  2051          :1196
EXITCURSOR_ON    = $086E =  2158          :1261
EXITGM           = $153F =  5439          :2695
EXITPA2          = $3517 = 13591          :7456
EXITPAI          = $3513 = 13587          :7455
EXITSER          = $3AFA = 15098          :8233 (unused)
EXMUL16          = $3DE8 = 15848          :8726
EXP              = $2FD4 = 12244          :6717
EXPLP            = $2E1E = 11806          :6455
EXPTAB           = $3014 = 12308          :6745
EXPTEN           = $2F4C = 12108          :6640
EXTIG            = $1E60 =  7776          :3989
EXTXA            = $0215 =   533          :313
FANDT            = $1E89 =  7817          :4007
FC               = $0008 =     8          :2111
FCERR            = $1B35 =  6965          :3561
FCMSG            = $126D =  4717          :2528
FCPTR            = $13D6 =  5078          :2555 (unused)
FDTLP            = $1E70 =  7792          :3991
FINDEL           = $2269 =  8809          :4598
FINDKEY          = $0D1D =  3357          :1792
FLASHCURSOR      = $0769 =  1897          :1112
FLGDIF           = $2CF8 = 11512          :6247
FLGREL           = $2CFF = 11519          :6253
FNARG            = $81C5 = 33221          :2052
FNCTAB           = $0FE5 =  4069          :2235
FNDARY           = $21D9 =  8665          :4506
FNDBPS           = $3A6B = 14955          :8154
FNDELP           = $226E =  8814          :4603
FNDEND           = $165F =  5727          :2859
FNDNUM           = $2762 = 10082          :5375
FNDTOK           = $196C =  6508          :3289
FNDVAR           = $2150 =  8528          :4417
FNDWRD           = $1711 =  5905          :2963
FNKEYS           = $80B3 = 32947          :2024
FNKEYSORD        = $0DEA =  3562          :1900
FNOFST           = $1FE0 =  8160          :4190
FNRGNM           = $81C3 = 33219          :2051
FNTHR            = $215E =  8542          :4425
FNVAL            = $2011 =  8209          :4216
FOPRND           = $1F29 =  7977          :4092
FOR              = $19B1 =  6577          :3329
FORFLG           = $81B0 = 33200          :2040
FORFND           = $19E1 =  6625          :3357
FORSLP           = $19C5 =  6597          :3338
FPADD            = $2A56 = 10838          :5815
FPBCDE           = $2D2E = 11566          :6284
FPEXP            = $81CC = 33228          :2054
FPINT            = $2D95 = 11669          :6371
FPMULT           = $2B91 = 11153          :6026
FPREG            = $81C9 = 33225          :2053
FPROND           = $2AEE = 10990          :5916
FPSINT           = $1B14 =  6932          :3547
FPTHL            = $2D45 = 11589          :6304
FRE              = $22A7 =  8871          :4645
FRENUM           = $22C3 =  8899          :4657
FRGNDCLR         = $81ED = 33261          :2075
FRMEVL           = $1FD2 =  8146          :4181
FWVER            = $00D0 =   208          :134 (unused)
G1MD             = $03CD =   973          :580
G2MD             = $040E =  1038          :613
GARBGE           = $242A =  9258          :4875
GARBLP           = $242D =  9261          :4876
GETCHR           = $1A6A =  6762          :3441
GETCMD           = $15CC =  5580          :2771
GETHEX           = $3D17 = 15639          :8535
GETINP           = $31A3 = 12707          :6931
GETINT           = $2765 = 10085          :5376
GETLEN           = $255D =  9565          :5073
GETLIN           = $17C7 =  6087          :3073
GETLN            = $1B3B =  6971          :3565
GETNUM           = $1EDF =  7903          :4053
GETNXT           = $172C =  5932          :2978
GETSTR           = $2527 =  9511          :5039
GETVAR           = $20EE =  8430          :4372
GM               = $002A =    42          :2128
GMERR            = $3945 = 14661          :7993
GMMSG            = $1385 =  4997          :2545
GMNCR            = $181E =  6174          :3115
GMPRT            = $13F8 =  5112          :2572 (unused)
GNXARY           = $2461 =  9313          :4901
GOFUNC           = $2019 =  8217          :4220
GOSUB            = $1BB9 =  7097          :3634
GOTO             = $1BCA =  7114          :3646
GPCPCH1          = $33FA = 13306          :7287
GPCPCHR          = $33EF = 13295          :7282 (unused)
GPNT             = $33AB = 13227          :7237
GPNTCO1          = $33D5 = 13269          :7264
GPNTCOL          = $33CB = 13259          :7260 (unused)
GPRINT           = $3339 = 13113          :7191
GRBARY           = $2481 =  9345          :4920
GRBDON           = $2402 =  9218          :4850
GRBLP            = $243B =  9275          :4882
GSTRCU           = $252A =  9514          :5040
GSTRDE           = $252E =  9518          :5042
GSTRHL           = $252D =  9517          :5041
GTFLNM           = $256C =  9580          :5083 (unused)
GTFNAM           = $20F3 =  8435          :4375
GTLNLP           = $1B3E =  6974          :3566
GTSIXD           = $2EC4 = 11972          :6556
GTVLUS           = $1DDC =  7644          :3919
GX               = $81F3 = 33267          :7183
GY               = $81F5 = 33269          :7184
HALF             = $2F6B = 12139          :6661
HALFPI           = $3124 = 12580          :6879
HELLOWRLD        = $02DF =   735          :438
HELP             = $3B45 = 15173          :8271
HEX              = $3CAB = 15531          :8463
HEX1             = $3CC3 = 15555          :8476
HEX2             = $3CC5 = 15557          :8478
HEX3             = $3CD2 = 15570          :8486
HEX4             = $3CD4 = 15572          :8488
HEXIT            = $3D2E = 15662          :8550
HEXLP            = $3D0A = 15626          :8525
HEXLP1           = $3D0F = 15631          :8527
HEXTFP           = $3CFE = 15614          :8520
HL2XY            = $06B7 =  1719          :1018
HLPERR           = $3B5B = 15195          :8282
HLPLN            = $80B1 = 32945          :2023
HOME             = $0019 =    25          :1983
HP               = $0030 =    48          :2131
HPMSG            = $13C4 =  5060          :2548
HPPTR            = $13FE =  5118          :2575 (unused)
HX               = $0026 =    38          :2126
HXERR            = $3D37 = 15671          :8558
HXMSG            = $136F =  4975          :2543
HXPTR            = $13F4 =  5108          :2570 (unused)
ID               = $0016 =    22          :2118
IDMSG            = $12DD =  4829          :2535
IDPTR            = $13E4 =  5092          :2562 (unused)
IDTEST           = $2352 =  9042          :4745
IF               = $1C9C =  7324          :3764
IFGO             = $1CAA =  7338          :3771
IFJMP            = $1A51 =  6737          :3421
INCHL            = $2D43 = 11587          :6301
INCLEN           = $1872 =  6258          :3168
INCTMR3          = $0240 =   576          :355
INDFND           = $1508 =  5384          :2655
INEWLN           = $1627 =  5671          :2819
INIT             = $0F06 =  3846          :2143
INITAB           = $1400 =  5120          :2579
INITBE           = $14D7 =  5335          :2626
INITST           = $3DB0 = 15792          :8638
INIT_HW          = $025A =   602          :376
INKEY            = $29F4 = 10740          :5762
INKEY2           = $2A0E = 10766          :5775
INMSG            = $14DE =  5342          :2631
INP              = $2722 = 10018          :5344
INPBIN           = $1E2E =  7726          :3963
INPBRK           = $1AB9 =  6841          :3496
INPORT           = $80A0 = 32928          :2012
INPSUB           = $809F = 32927          :2011
INPUT            = $1D99 =  7577          :3883
INRNG            = $2ECD = 11981          :6561
INSTR            = $25B9 =  9657          :5163
INT              = $2DC0 = 11712          :6402
INTVAR           = $169B =  5787          :2907
INVSGN           = $2D16 = 11542          :6266
ITMSEP           = $1E1F =  7711          :3954
JSTZER           = $2F56 = 12118          :6646
KBDNPT           = $8229 = 33321          :2090
KBMAP            = $0DF2 =  3570          :1903
KBMAP_ALT        = $0E72 =  3698          :1923
KBMAP_CTRL       = $0EB2 =  3762          :1933
KBMAP_SFT        = $0E32 =  3634          :1913
KBTMP            = $822A = 33322          :2091
KEY              = $3B60 = 15200          :8287
KEYBOARD         = $0C88 =  3208          :1718
KEYCH            = $3B7D = 15229          :8303
KILFOR           = $1ECF =  7887          :4044
KILIN            = $17C1 =  6081          :3070
LASTKEYPRSD      = $822C = 33324          :2093
LCRFLG           = $8191 = 33169          :2029
LDCLRTBEX2       = $048D =  1165          :670
LDCLRTBMD1       = $0405 =  1029          :606
LDCOLSTOEMPTY    = $0581 =  1409          :819
LDFNKEYCHR       = $0DB6 =  3510          :1871
LDG1             = $154C =  5452          :2701
LDG1ND           = $155D =  5469          :2711
LDKEY            = $3C0F = 15375          :8381
LDREGVLS         = $0A2E =  2606          :1480
LEDLIGHT         = $02E9 =   745          :444
LEFT             = $2589 =  9609          :5101
LEN              = $2559 =  9561          :5071
LET              = $1C24 =  7204          :3699
LETNUM           = $1C77 =  7287          :3741
LETSTR           = $1C3F =  7231          :3712
LF               = $000A =    10          :1975
LFRGNM           = $2718 = 10008          :5335
LINEAT           = $80AF = 32943          :2022
LINEIN           = $2E7F = 11903          :6522
LINFND           = $1610 =  5648          :2805
LIST             = $18A6 =  6310          :3202
LISTLP           = $1929 =  6441          :3251
LM80CLOGO        = $0A81 =  2689          :1565
LNS1             = $81EF = 33263          :5154
LNS2             = $81F3 = 33267          :5156
LOADCHARSET      = $0A38 =  2616          :1489
LOADCLR          = $32EB = 13035          :7123
LOADFP           = $2D3C = 11580          :6294
LOADLOGOCHRS     = $0541 =  1345          :779
LOADMAP          = $0D43 =  3395          :1809
LOADNEXTCOL      = $08A2 =  2210          :1292
LOAD_CRSR_POS    = $0693 =  1683          :996
LOCATE           = $2838 = 10296          :5510
LOG              = $2B50 = 11088          :5994
LOGOFONT         = $4E13 = 19987          :9368
LOGTAB           = $2B43 = 11075          :5989
LOKFOR           = $14F2 =  5362          :2638
LOOPST           = $81AC = 33196          :2038
LS               = $001C =    28          :2121
LSMSG            = $130F =  4879          :2538
LSPTR            = $13EA =  5098          :2565 (unused)
LST01            = $18D2 =  6354          :3219
LST01H           = $18D5 =  6357          :3220
LST03            = $190F =  6415          :3240
LST04            = $18EC =  6380          :3228 (unused)
LST05            = $191D =  6429          :3247
LST06            = $18F3 =  6387          :3230
LST07            = $194E =  6478          :3271
LST08            = $194B =  6475          :3270
LSTALL           = $18F7 =  6391          :3232
LSTBIN           = $81B1 = 33201          :2041
LSTCSRSTA        = $81EA = 33258          :2072
LSTKEYS          = $3BE4 = 15332          :8360
LSTLP2           = $195A =  6490          :3280
LSTLP3           = $195D =  6493          :3281
LSTRAM           = $8194 = 33172          :2032
LSTRND           = $809B = 32923          :2010
LTSTND           = $1E39 =  7737          :3968
LVINSTR          = $269E =  9886          :5256
LVKBRDCHK        = $0D9D =  3485          :1852
LVKBRDCHK2       = $0D99 =  3481          :1850
LVRXCHA          = $0131 =   305          :159
LWIDTH           = $80A2 = 32930          :2013
MAKINT           = $2768 = 10088          :5377
MAKNUM           = $2EE9 = 12009          :6576
MANLP            = $2E08 = 11784          :6447
MATCH            = $175E =  5982          :3010
MCMD             = $0430 =  1072          :628
MEMMSG           = $0FDA =  4058          :2224
MID              = $26B9 =  9913          :5273
MID1             = $258F =  9615          :5105
MIDNUM           = $271D = 10013          :5338
MINCDE           = $2A96 = 10902          :5850
MINUS            = $1FBE =  8126          :4171
MIXCLRS          = $3319 = 13081          :7151
MIXCOL           = $81EF = 33263          :7186
MKTMST           = $2396 =  9110          :4787
MLDBLP           = $2DE1 = 11745          :6423
MLDEBC           = $2DD9 = 11737          :6418
MLOOP            = $0F34 =  3892          :2161
MLP              = $3DD8 = 15832          :8715
MLP1             = $3DDF = 15839          :8719
MLSP10           = $2CD6 = 11478          :6227
MNGSNDS          = $0C23 =  3107          :1656
MNOASK           = $0F31 =  3889          :2160
MNPAINT          = $3489 = 13449          :7380
MO               = $0024 =    36          :2125
MOD              = $2BEC = 11244          :6095
MOMSG            = $135F =  4959          :2542
MONOUT           = $3D9E = 15774          :8627
MOPTR            = $13F2 =  5106          :2569 (unused)
MORDT            = $1E45 =  7749          :3973
MORINP           = $17D0 =  6096          :3078
MOVBUF           = $1646 =  5702          :2840
MOVCRS           = $065F =  1631          :969
MOVDIR           = $1766 =  5990          :3018
MOVLP            = $1517 =  5399          :2665
MOVSHOWCRS       = $0665 =  1637          :971
MOVSTR           = $1514 =  5396          :2662
MOVUP            = $1511 =  5393          :2661
MRPRNT           = $1CBC =  7356          :3778
MSGTXT1          = $033A =   826          :510
MSGTXT2          = $0364 =   868          :512
MSIZE            = $0F21 =  3873          :2154
MUL16            = $3DD0 = 15824          :8707
MUL8LP           = $2BBC = 11196          :6049
MULLN2           = $2B88 = 11144          :6020
MULT             = $2B8F = 11151          :6024
MULT8            = $2BB3 = 11187          :6043
MULTEN           = $2E4A = 11850          :6483
MULVAL           = $823D = 33341          :2100
MVCRS2LFT        = $07C9 =  1993          :1167
MVSTPT           = $1C6E =  7278          :3735
NEDMOR           = $1DD8 =  7640          :3917
NEGAFT           = $2F81 = 12161          :6670
NEW              = $168B =  5771          :2895
NEWCRSRCOORD     = $0675 =  1653          :980
NEXITM           = $1D6F =  7535          :3869
NEXT             = $1E94 =  7828          :4012
NEXT1            = $1E97 =  7831          :4013
NF               = $0000 =     0          :2107
NFERR            = $156B =  5483          :2721
NFMSG            = $1234 =  4660          :2524
NFPTR            = $13CE =  5070          :2551 (unused)
NLLCR            = $0000 =     0          :1971
NM1              = $2791 = 10129          :5401
NMI              = $2776 = 10102          :5388
NMI2             = $27A2 = 10146          :5409
NMIDINT          = $27AD = 10157          :5418
NMIEINT          = $27A6 = 10150          :5414
NMIFLG           = $80A8 = 32936          :2018
NMIINT           = $27B0 = 10160          :5419
NMIUSR           = $8061 = 32865          :2000
NMIVR1           = $27BC = 10172          :5430
NOBEEP           = $0BF5 =  3061          :1625
NOBPDAT          = $0C11 =  3089          :1639
NOCHNG           = $1756 =  5974          :3005
NOENED           = $2F59 = 12121          :6649
NOGD             = $35D8 = 13784          :7569
NOISUP           = $2957 = 10583          :5668
NOKEYPRSD        = $0D0E =  3342          :1784
NOLIN            = $1ACF =  6863          :3507
NOMADD           = $2BCD = 11213          :6060
NOMLAD           = $2DEF = 11759          :6431
NOPMPT           = $1DB3 =  7603          :3895
NORMAL           = $2AC1 = 10945          :5885
NOS1             = $2981 = 10625          :5686
NOS2             = $2994 = 10644          :5699
NOS3             = $29AD = 10669          :5718
NOSPC            = $174D =  5965          :3000
NOSUB7           = $3D2A = 15658          :8546
NOSWAP           = $2A70 = 10864          :5831
NOSYSPR          = $27EE = 10222          :5459
NOTAMP           = $1F93 =  8083          :4152
NOTFULL          = $0141 =   321          :173
NOTRDWRAP        = $01E2 =   482          :281
NOTSTR           = $2126 =  8486          :4397
NOTWRAP          = $014D =   333          :179
NOXOR            = $2748 = 10056          :5361
NSCFOR           = $2136 =  8502          :4405
NULFLG           = $80A4 = 32932          :2015
NUMASC           = $2E92 = 11922          :6532
NUMCHR           = $81FB = 33275          :7189
NXTARY           = $21ED =  8685          :4518
NXTBYT           = $173C =  5948          :2990
NXTCHAR          = $0A4B =  2635          :1500
NXTCHR           = $177D =  6013          :3030
NXTDAT           = $81C1 = 33217          :2050
NXTDTA           = $1C0C =  7180          :3681
NXTITM           = $1DD0 =  7632          :3912
NXTLN            = $1984 =  6532          :3302
NXTLOOP          = $3468 = 13416          :7357
NXTOPR           = $81B5 = 33205          :2044
NXTSTL           = $1C13 =  7187          :3686
NXTSTT           = $1C16 =  7190          :3689
OD               = $0006 =     6          :2110
ODMSG            = $1261 =  4705          :2527
ODPTR            = $13D4 =  5076          :2554 (unused)
OKMSG            = $14E3 =  5347          :2633
OM               = $000C =    12          :2113
OMERR            = $153A =  5434          :2690
OMMSG            = $128C =  4748          :2530
OMPTR            = $13DA =  5082          :2557 (unused)
ON               = $1C7E =  7294          :3747
ONGO             = $1C8D =  7309          :3755
ONGOLP           = $1C8E =  7310          :3756
ONJMP            = $1A52 =  6738          :3423
OPNPAR           = $1EED =  7917          :4062
OPNQT            = $3C70 = 15472          :8432
OPNQT1           = $3C86 = 15494          :8442
OPRND            = $1F68 =  8040          :4135
ORGSP            = $81FB = 33275          :7325
OS               = $001A =    26          :2120
OSMSG            = $12FB =  4859          :2537
OSPTR            = $13E8 =  5096          :2564 (unused)
OTKLN            = $17BE =  6078          :3069
OTPORT           = $8068 = 32872          :2003
OUTC             = $1852 =  6226          :3151
OUTEXP           = $2F4A = 12106          :6639
OUTIT            = $1838 =  6200          :3129
OUTNBS           = $183B =  6203          :3131
OUTNCR           = $3DBF = 15807          :8650
OUTSUB           = $8067 = 32871          :2002
OUTWRD           = $1976 =  6518          :3295
OV               = $000A =    10          :2112
OVERR            = $1574 =  5492          :2727
OVMSG            = $1283 =  4739          :2529
OVPTR            = $13D8 =  5080          :2556 (unused)
OVTST1           = $2CC9 = 11465          :6219
OVTST2           = $2CCE = 11470          :6222
OVTST3           = $2CCF = 11471          :6223
PADD             = $2E6E = 11886          :6508
PAINT            = $342A = 13354          :7326
PAINT0           = $3475 = 13429          :7365
PAINT1           = $3482 = 13442          :7375
PAINT11          = $3481 = 13441          :7374
PAINT2           = $34BC = 13500          :7408
PAINT3           = $34D2 = 13522          :7420
PAINT4           = $34F5 = 13557          :7439
PAINT5           = $350C = 13580          :7452
PAND             = $2032 =  8242          :4242
PAND1            = $2057 =  8279          :4265 (unused)
PARBT            = $81FB = 33275          :8007
PASSA            = $22D8 =  8920          :4672
PAUSE            = $31E3 = 12771          :6975
PBUFF            = $8230 = 33328          :2099
PEEK             = $27FE = 10238          :5471
PEND             = $1AB4 =  6836          :3493
PHLTFP           = $2D2B = 11563          :6283
PIO_CA           = $0002 =     2          :32 (unused)
PIO_CB           = $0003 =     3          :33
PIO_DA           = $0000 =     0          :30 (unused)
PIO_DB           = $0001 =     1          :31
PKEPRMS          = $2812 = 10258          :5486
PLOT             = $357C = 13692          :7517
PLTCRL           = $37D8 = 14296          :7823
PLUCDE           = $2AFB = 11003          :5927
PNORM            = $2AC9 = 10953          :5893
PNT              = $81F7 = 33271          :7322
PNT2VD           = $0D96 =  3478          :1849
PNTEND           = $3553 = 13651          :7490
PNTRTN           = $3571 = 13681          :7506
POINT            = $3529 = 13609          :7471
POKE             = $2828 = 10280          :5496
POPAF            = $241C =  9244          :4865
POPHL            = $2546 =  9542          :5056
POPHRT           = $2BDD = 11229          :6074
POPNOK           = $15BE =  5566          :2763
POR              = $2035 =  8245          :4244
POR1             = $205C =  8284          :4270
POS              = $22D5 =  8917          :4671
POSINT           = $1B17 =  6935          :3548
POS_CURSOR       = $0655 =  1621          :963
POS_TB_CRS_32    = $099D =  2461          :1436
POS_TB_CRS_40    = $09CD =  2509          :1440
POUT             = $272E = 10030          :5349
POWER            = $2F8F = 12175          :6678
POWER1           = $2F9F = 12191          :6686
POWER2           = $2FBC = 12220          :6704
POWERS           = $2F6F = 12143          :6663
PRINT            = $1CC0 =  7360          :3780
PRITAB           = $1216 =  4630          :2491
PRNTCRLF         = $1D23 =  7459          :3829
PRNTFNK          = $0DDD =  3549          :1891
PRNTFNKEY        = $0D9E =  3486          :1854
PRNTHL           = $2E87 = 11911          :6526
PRNTLP           = $1CC3 =  7363          :3781
PRNTNB           = $1D06 =  7430          :3813
PRNTOK           = $15BF =  5567          :2766
PRNTRETURN       = $097C =  2428          :1413
PRNTST           = $1D0A =  7434          :3815
PRNTVIDEO        = $81EB = 33259          :2073
PRNUMS           = $23E6 =  9190          :4834
PROCES           = $17E9 =  6121          :3089
PROGND           = $81BB = 33211          :2047
PROGST           = $8240 = 33344          :2101
PROMPT           = $16CE =  5838          :2932
PRS              = $23E7 =  9191          :4835
PRS1             = $23EA =  9194          :4836
PRSLP            = $23F1 =  9201          :4839
PRTCHR           = $3C39 = 15417          :8403
PRTCKEY          = $3C88 = 15496          :8445
PRTEND           = $3C95 = 15509          :8452
PRTK1            = $3C89 = 15497          :8446
PRTK2            = $3BF8 = 15352          :8372 (unused)
PRTK3            = $3C21 = 15393          :8389
PRTK4            = $3BF6 = 15350          :8371
PRTNUM           = $81F7 = 33271          :8004
PSG_DAT          = $0041 =    65          :53
PSG_REG          = $0040 =    64          :52
PSUB             = $2A51 = 10833          :5812
PT               = $81F7 = 33271          :5158
PT1              = $81F9 = 33273          :5159
PT2              = $81FB = 33275          :5160
PTCHR1           = $3C56 = 15446          :8417
PTLN             = $15BA =  5562          :2760
PTRLP            = $1653 =  5715          :2849
PUTBUF           = $1824 =  6180          :3118
PUTCHRBUF        = $0D89 =  3465          :1844
PUTCHRBUF1       = $0DD0 =  3536          :1884
PUTCRSCHR        = $0789 =  1929          :1130
PUTCTL           = $1829 =  6185          :3120
PUTFID           = $1A26 =  6694          :3395
PXLSET           = $35DC = 13788          :7573
PXOR             = $203A =  8250          :4247
PXOR1            = $2064 =  8292          :4276
QTSTLP           = $23AC =  9132          :4804
QTSTR            = $23A6 =  9126          :4800
QUARTR           = $3128 = 12584          :6881
RADIUS           = $81FB = 33275          :7751
RAWPRINT         = $0229 =   553          :336
READ             = $1DCB =  7627          :3909
READFG           = $81B2 = 33202          :2042
READKBLN         = $0C73 =  3187          :1704
READ_VIDEO_LOC   = $0619 =  1561          :913
READ_VSTAT       = $064E =  1614          :956
RECWRD           = $31C6 = 12742          :6954 (unused)
REDO             = $1D76 =  7542          :3873
REM              = $1C0F =  7183          :3684
RESDIV           = $2C7B = 11387          :6163
RESEED           = $30C6 = 12486          :6837
RESET            = $3DA1 = 15777          :8630
RESTMR           = $0329 =   809          :500
RESTNL           = $1A8F =  6799          :3464
RESTOR           = $1A7A =  6778          :3453
RESZER           = $2ABC = 10940          :5881
RETADR           = $219D =  8605          :4465
RETINT           = $2D04 = 11524          :6255
RETLIN           = $1C07 =  7175          :3678
RETNAD           = $1762 =  5986          :3014
RETNUL           = $21A0 =  8608          :4469
RETNUM           = $1FCA =  8138          :4176
RETREL           = $2CF6 = 11510          :6245
RETURN           = $1BE8 =  7144          :3662
RG               = $0004 =     4          :2109
RGMSG            = $124C =  4684          :2526
RGPTR            = $13D2 =  5074          :2553 (unused)
RIGHT            = $26AF =  9903          :5266
RIGHT1           = $258D =  9613          :5103
RINPUT           = $80AA = 32938          :2020
RLTLP            = $1F0D =  7949          :4078
RND              = $3065 = 12389          :6784
RND1             = $30A1 = 12449          :6815
RND2             = $30BD = 12477          :6833
RNDTAB           = $30CE = 12494          :6844
RNGTST           = $2F5C = 12124          :6653
RONDB            = $2ADD = 10973          :5905
RONDUP           = $2ADC = 10972          :5904
ROUND            = $2A44 = 10820          :5806
RP2INST          = $2648 =  9800          :5220
RPGPNT           = $33C0 = 13248          :7251
RPT100           = $0523 =  1315          :756
RPT101           = $04CA =  1226          :704
RPT102           = $04CD =  1229          :706
RPT103           = $04E3 =  1251          :719
RPT104           = $04EB =  1259          :723
RPTCL1           = $379C = 14236          :7793
RPTCRL           = $3789 = 14217          :7787
RPTCVB1          = $391C = 14620          :7963
RPTCVB2          = $3925 = 14629          :7968
RPTDRW           = $36CC = 14028          :7699
RPTEMPTYBUF      = $0587 =  1415          :823
RPTEMPTYROW      = $08E6 =  2278          :1328
RPTFLL1          = $05EF =  1519          :883
RPTINST          = $2621 =  9761          :5203
RPTKBDRD         = $0CC8 =  3272          :1748
RPTLDCL          = $32F5 = 13045          :7128
RPTNLLSRC        = $0910 =  2320          :1357
RPTNLLSRC2       = $093B =  2363          :1381
RPTPS            = $31F1 = 12785          :6983
RPTRSSR          = $3971 = 14705          :8031
RPTWLCMBP        = $0BFB =  3067          :1628
RPVOLCG          = $28AD = 10413          :5573
RSCALE           = $2E68 = 11880          :6506
RST00            = $0000 =     0          :75 (unused)
RST08            = $0008 =     8          :81 (unused)
RST10            = $0010 =    16          :96 (unused)
RST18            = $0018 =    24          :102 (unused)
RSTCHRCRS        = $068A =  1674          :990
RSTPSG           = $0BD2 =  3026          :1608
RSTSER1          = $3964 = 14692          :8023
RSTSTR           = $26D2 =  9938          :5286
RSTVDPRAMREG     = $0A17 =  2583          :1464
RUN              = $1BA5 =  7077          :3625
RUNCNT           = $1A2A =  6698          :3399
RUNFST           = $1697 =  5783          :2904
RUNLIN           = $1BC9 =  7113          :3645
RXA              = $01CD =   461          :270
RXA_EXIT         = $01F3 =   499          :288
RXEND            = $39D9 = 14809          :8088
RX_CHA_AVAIL     = $0100 =   256          :138
RZINSTR          = $2693 =  9875          :5251
SA               = $002E =    46          :2130
SAMSG            = $13AB =  5035          :2547
SAPTR            = $13FC =  5116          :2574 (unused)
SAVEXP           = $2ABD = 10941          :5882
SAVSTP           = $1A1D =  6685          :3388
SAVSTR           = $2381 =  9089          :4771
SBSCPT           = $21AB =  8619          :4475
SC               = $002C =    44          :2129
SCALE            = $2B1B = 11035          :5959
SCALLP           = $2B1D = 11037          :5960
SCALMI           = $2E33 = 11827          :6468
SCALPL           = $2E49 = 11849          :6482
SCERR            = $3B34 = 15156          :8256
SCERR1           = $3B30 = 15152          :8253
SCMSG            = $1396 =  5014          :2546
SCNEND           = $24B8 =  9400          :4961
SCPTLP           = $21B1 =  8625          :4479
SCPTR            = $13FA =  5114          :2573 (unused)
SCREEN           = $3202 = 12802          :7002
SCROLLNXTRW      = $0890 =  2192          :1284
SCROLLUP         = $0877 =  2167          :1272
SCR_CURS_X       = $81E4 = 33252          :2066
SCR_CURS_Y       = $81E5 = 33253          :2067
SCR_CUR_NX       = $81E6 = 33254          :2068
SCR_CUR_NY       = $81E7 = 33255          :2069
SCR_MODE         = $81E0 = 33248          :2064
SCR_NAM_TB       = $81E2 = 33250          :2065
SCR_ORG_CHR      = $81E8 = 33256          :2070
SCR_SIZE_H       = $81DF = 33247          :2063
SCR_SIZE_W       = $81DE = 33246          :2062
SCVDP            = $322E = 12846          :7019
SEARCH           = $172A =  5930          :2976
SEED             = $8078 = 32888          :2009
SENDCHRPTRNS     = $0A4F =  2639          :1502
SENDSND          = $0BF8 =  3064          :1626
SERABITS         = $822F = 33327          :2098
SERBUF_START     = $8000 = 32768          :63
SERIAL           = $394A = 14666          :8010
SERIALS_EN       = $822E = 33326          :2097
SERLED           = $399A = 14746          :8052
SER_BUFSIZE      = $0058 =    88          :59
SER_EMPTYSIZE    = $0005 =     5          :61
SER_FULLSIZE     = $0050 =    80          :60
SETBEEP          = $052D =  1325          :765
SETBRCL          = $3300 = 13056          :7136
SETCRSRY         = $0748 =  1864          :1091
SETCSRCOORDS     = $0749 =  1865          :1092
SETIO            = $2752 = 10066          :5368
SETLIT           = $1774 =  6004          :3026
SETNAMETABLE     = $05E6 =  1510          :878
SETPAR           = $3AB8 = 15032          :8196
SETPTR           = $164E =  5710          :2846
SETSER           = $3A46 = 14918          :8138
SETSNDREG        = $0C19 =  3097          :1643
SETTOP           = $0F58 =  3928          :2186
SETVDP           = $3215 = 12821          :7010 (unused)
SETVDPADRS       = $05F9 =  1529          :892
SET_GFX_MODE     = $0A1C =  2588          :1471
SET_GFX_MODE2    = $0A24 =  2596          :1475
SET_P1           = $3A75 = 14965          :8158
SFTPRG           = $1618 =  5656          :2809
SGN              = $2CFC = 11516          :6252
SGNEXP           = $2022 =  8226          :4228
SGNRES           = $81CD = 33229          :2055
SHOW_LOGO        = $04A1 =  1185          :685
SHRITE           = $2B2A = 11050          :5968
SHRLP            = $2B2D = 11053          :5970
SHRT1            = $2B31 = 11057          :5974
SIGNON           = $0FA9 =  4009          :2220
SIGNS            = $2D53 = 11603          :6314
SIN              = $30E0 = 12512          :6850
SIN1             = $3110 = 12560          :6870
SINTAB           = $312C = 12588          :6883
SIOBFR           = $81FD = 33277          :8009
SIO_A_DI         = $0181 =   385          :219
SIO_A_EI         = $018D =   397          :228
SIO_A_SETS       = $02FA =   762          :457
SIO_B_SETS       = $0300 =   768          :463 (unused)
SIO_CA           = $0022 =    34          :42
SIO_CB           = $0023 =    35          :43
SIO_DA           = $0020 =    32          :44
SIO_DB           = $0021 =    33          :45 (unused)
SIXDIG           = $2EAF = 11951          :6546
SMPVAR           = $244C =  9292          :4889
SMSER1           = $3044 = 12356          :6762
SN               = $0002 =     2          :2108
SND1             = $291B = 10523          :5634
SND2VID          = $1885 =  6277          :3181
SNDCHRTOBFR      = $095D =  2397          :1397
SNDCLRSET        = $05DC =  1500          :869
SNDKEYTOBFR      = $0D77 =  3447          :1836
SNDLOGPT         = $0558 =  1368          :795
SNDOVR           = $2950 = 10576          :5664
SNDREGCFG        = $0BDF =  3039          :1617
SNERR            = $1565 =  5477          :2717
SNMSG            = $1245 =  4677          :2525
SNPTR            = $13D0 =  5072          :2552 (unused)
SOUND            = $28C4 = 10436          :5591
SPA              = $81F9 = 33273          :7323
SPB              = $81FA = 33274          :7324
SPC              = $0020 =    32          :1985
SPCFST           = $2EA0 = 11936          :6538
SPCLP            = $1D67 =  7527          :3865
SPEC_RX_CONDITON = $019B =   411          :241
SQR              = $2F86 = 12166          :6674
SRCHLIN          = $1992 =  6546          :3308
SRCHLN           = $166B =  5739          :2868
SRCHLP           = $166E =  5742          :2869
SREG             = $286A = 10346          :5538
SRPT2            = $3994 = 14740          :8049
SRTINK           = $2A22 = 10786          :5784
SRTTXT           = $81F1 = 33265          :1341
SSTAT            = $29E0 = 10720          :5749
SSTSA            = $2514 =  9492          :5021
ST               = $001E =    30          :2122
STACK            = $813B = 33083          :2027
STAKFP           = $2D1E = 11550          :6272
STALL            = $1AA3 =  6819          :3481
STARTB           = $0EF8 =  3832          :2136
STARTEMPTY       = $05D8 =  1496          :867
STKTHS           = $1F51 =  8017          :4119
STLOOK           = $82A4 = 33444          :2102
STMSG            = $131F =  4895          :2539
STOP             = $1AB2 =  6834          :3491
STORED           = $1B82 =  7042          :3605
STPBT            = $81FC = 33276          :8008
STPOOL           = $248F =  9359          :4926
STPTR            = $13EC =  5100          :2566 (unused)
STR              = $2371 =  9073          :4764
STR1             = $2377 =  9079          :4766
STRADD           = $2492 =  9362          :4928
STRBOT           = $81A8 = 33192          :2036
STRE2            = $36C9 = 14025          :7698
STRENT           = $1E22 =  7714          :3956
STRPAR           = $3AD7 = 15063          :8212
STRSPC           = $80AD = 32941          :2021
STTLIN           = $1D11 =  7441          :3819
SUBCDE           = $2A53 = 10835          :5814
SUBPHL           = $2A4D = 10829          :5810
SUMLP            = $304D = 12365          :6767
SUMSER           = $3035 = 12341          :6755
SUPTLZ           = $2F2E = 12078          :6623
SUP_BPS          = $3B0F = 15119          :8248
SVNAM2           = $210A =  8458          :4384
SVSTAD           = $239F =  9119          :4792
SX               = $81FF = 33279          :7626
SY               = $8201 = 33281          :7627
SYS              = $27D0 = 10192          :5447
SYSRET           = $27FC = 10236          :5466
TAN              = $3141 = 12609          :6890
TEMPSTACK        = $818D = 33165          :69
TESTALT          = $0CF7 =  3319          :1773
TESTCTRL         = $0D04 =  3332          :1779
TESTOS           = $241E =  9246          :4868
TESTR            = $2400 =  9216          :4848
TF               = $81FF = 33279          :5162
TM               = $0018 =    24          :2119
TMERR            = $1577 =  5495          :2729
TMMSG            = $12EC =  4844          :2536
TMPADR           = $81F7 = 33271          :7187
TMPBFR1          = $81EF = 33263          :2077
TMPBFR2          = $81F1 = 33265          :2078
TMPBFR3          = $81F3 = 33267          :2079
TMPBFR4          = $81F5 = 33269          :2080
TMPCLR           = $81F1 = 33265          :7185
TMPHL            = $81FD = 33277          :7190
TMPKEYBFR        = $822B = 33323          :2092
TMPSTR           = $81A4 = 33188          :2035
TMPTR            = $13E6 =  5094          :2563 (unused)
TMR              = $2291 =  8849          :4632
TMRCNT           = $81CE = 33230          :2056
TMSTPL           = $8198 = 33176          :2034
TMSTPT           = $8196 = 33174          :2033
TOPOOL           = $2585 =  9605          :5098
TOSTRA           = $251D =  9501          :5030
TP               = $81FD = 33277          :5161
TRYAGN           = $2F09 = 12041          :6596
TSALP            = $251E =  9502          :5031
TSTBIT           = $3DB8 = 15800          :8643 (unused)
TSTBRK           = $1A95 =  6805          :3470
TSTMEM           = $0F46 =  3910          :2174
TSTNUM           = $1EE2 =  7906          :4054
TSTOPL           = $23C7 =  9159          :4820
TSTRED           = $2069 =  8297          :4282
TSTREM           = $1777 =  6007          :3027
TSTSGN           = $2CED = 11501          :6240
TSTSPC           = $1998 =  6552          :3315
TSTSTR           = $1EE3 =  7907          :4055
TTYLIN           = $17C7 =  6087          :3074
TXA              = $01F7 =   503          :296
TXA_EXIT         = $0210 =   528          :310
TXTMD            = $03A3 =   931          :559 (unused)
TX_EMP           = $0218 =   536          :319
TYPE             = $8192 = 33170          :2030
UF               = $0022 =    34          :2124
UFERR            = $1571 =  5489          :2725
UFMSG            = $1349 =  4937          :2541
UFPTR            = $13F0 =  5104          :2568 (unused)
UL               = $000E =    14          :2114
ULERR            = $1BE3 =  7139          :3659
ULMSG            = $129A =  4762          :2531
ULPTR            = $13DC =  5084          :2558 (unused)
UNITY            = $2B3F = 11071          :5987
UPDATA           = $1A90 =  6800          :3465
USR              = $8064 = 32868          :2001
VAL              = $26E9 =  9961          :5305
VAL1             = $2707 =  9991          :5325
VAL2             = $2711 = 10001          :5329
VAL3             = $2714 = 10004          :5330
VALIDX           = $3904 = 14596          :7940
VALIDY           = $3909 = 14601          :7946
VAREND           = $81BD = 33213          :2048
VDPMODESET       = $0A59 =  2649          :1516
VDPMODESET1      = $0A61 =  2657          :1525 (unused)
VDPMODESET2      = $0A69 =  2665          :1535 (unused)
VDPMODESETEX2    = $0A79 =  2681          :1555 (unused)
VDPMODESETMC     = $0A71 =  2673          :1545 (unused)
VDP_DAT          = $0030 =    48          :48
VDP_SET          = $0032 =    50          :49
VIDEOBUFF        = $81F7 = 33271          :2081
VIDTMP1          = $821F = 33311          :2082
VIDTMP2          = $8221 = 33313          :2083
VOLCH            = $28B9 = 10425          :5580
VOLUME           = $288B = 10379          :5558
VPEEK            = $2805 = 10245          :5476
VPOKE            = $282D = 10285          :5501
VREG             = $29B9 = 10681          :5727
VSTAT            = $29D5 = 10709          :5742
WAIT             = $2734 = 10036          :5352
WAITLP           = $2749 = 10057          :5362
WARM             = $0EF5 =  3829          :2134
WARMST           = $0F90 =  3984          :2213
WIDTH            = $31B9 = 12729          :6945
WLCBPDAT         = $0C09 =  3081          :1638
WLCMBEEP         = $0BEF =  3055          :1623
WORDS            = $1029 =  4137          :2274
WORDTB           = $11AE =  4526          :2389
WRITEBUF         = $08CB =  2251          :1313
WRITE_VIDEO_LOC  = $062E =  1582          :930
WRITE_VREG       = $0643 =  1603          :947
WRKSPC           = $805E = 32862          :1999
WRTSND           = $29A4 = 10660          :5709
WRTSNDREG        = $0C1E =  3102          :1648
WTSPC            = $199E =  6558          :3318
X1               = $81EF = 33263          :7620
X1GR             = $366F = 13935          :7667
X2               = $81F7 = 33271          :7622
XC               = $81F7 = 33271          :7749
XI               = $81FD = 33277          :7752
XY2HL            = $35E4 = 13796          :7581
Y1               = $81F1 = 33265          :7621
Y1GR             = $3699 = 13977          :7681
Y2               = $81F9 = 33273          :7623
YC               = $81F9 = 33273          :7750
YI               = $81FF = 33279          :7753
ZDATA            = $0083 =   131          :2455
ZDINT            = $00C0 =   192          :2475 (unused)
ZDIV             = $00BE =   190          :2473 (unused)
ZEND             = $0080 =   128          :2453
ZEQUAL           = $00C6 =   198          :2478
ZERARY           = $224C =  8780          :4578
ZERBYT           = $14E2 =  5346          :2632
ZEROLP           = $218F =  8591          :4456
ZEROSUP          = $3D48 = 15688          :8567
ZFN              = $00B6 =   182          :2464
ZFOR             = $0081 =   129          :2454
ZGOSUB           = $008C =   140          :2457
ZGOTO            = $0088 =   136          :2456
ZGTR             = $00C5 =   197          :2477
ZINSTR           = $00DF =   223          :2484
ZLEFT            = $00E7 =   231          :2485
ZLTH             = $00C7 =   199          :2479
ZMINUS           = $00BC =   188          :2471
ZMOD             = $00BF =   191          :2474 (unused)
ZNEW             = $00B3 =   179          :2460
ZNOT             = $00B9 =   185          :2467
ZONELP           = $1D40 =  7488          :3843
ZOR              = $00C4 =   196          :2476
ZPLUS            = $00BB =   187          :2470
ZPOINT           = $00DE =   222          :2482
ZPRINT           = $00AD =   173          :2459
ZREM             = $008E =   142          :2458
ZSGN             = $00C8 =   200          :2481
ZSPC             = $00B7 =   183          :2465
ZSTEP            = $00BA =   186          :2468
ZTAB             = $00B4 =   180          :2462
ZTHEN            = $00B8 =   184          :2466
ZTIMES           = $00BD =   189          :2472 (unused)
ZTO              = $00B5 =   181          :2463
_end             = $4ED3 = 20179          :74 (unused)
_size            = $4ED3 = 20179          :74 (unused)
_z80_            = $0001 =     1          :1 (unused)
absHL            = $3DEA = 15850          :8739
basicStarted     = $805D = 32861          :67
bufWrap          = $0058 =    88          :68
initCTC          = $0304 =   772          :472
initPSG          = $0BC1 =  3009          :1599
initVDP          = $037E =   894          :539
negHL            = $3DED = 15853          :8741
serBufUsed       = $805C = 32860          :66
serInPtr         = $8058 = 32856          :64
serRdPtr         = $805A = 32858          :65


total time: 0.0354 sec.
no errors
