              	; --------------------------------------
              	; zasm: assemble "rom.asm"
              	; date: 2020-06-14 12:00:42
              	; --------------------------------------


              	; 
              	; ------------------------------------------------------------------------------
              	; LM80C - BOOTLOADER - R3.13.3
              	; ------------------------------------------------------------------------------
              	; The following code is intended to be used with LM80C Z80-based computer
              	; designed by Leonardo Miliani. Code and computer schematics are released under
              	; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
              	; kind of warranty: you can use them at your own risk.
              	; You are free to use them for any non-commercial use: you are only asked to
              	; maintain the copyright notices, include this advice and the note to the 
              	; attribution of the original version to Leonardo Miliani, if you intend to
              	; redistribuite them.
              	; https://www.leonardomiliani.com
              	; 
              	; Please support me by visiting the following links:
              	; Main project page: https://www.leonardomiliani.com
              	; Schematics and code: https://github.com/leomil72/LM80C
              	; Videos about the computer: https://www.youtube.com/user/leomil72/videos
              	; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
              	; ------------------------------------------------------------------------------
              	
              	; ADDRESS DECODING (bits A6/A5/A4)
              	; 0000xxxx : PIO
              	; 0001xxxx : CTC
              	; 0010xxxx : SIO
              	; 0011xxxx : VDP
              	; 0100xxxx : PSG
              	
              	; label defining for PIO (Parallel Input/Output)
0000:         	PIO_DA          equ %00000000
0001:         	PIO_DB          equ %00000001
0002:         	PIO_CA          equ %00000010
0003:         	PIO_CB          equ %00000011
              	
              	; label defining for CTC (Counter Timer Circuit)
0010:         	CTC_CH0         equ %00010000
0011:         	CTC_CH1         equ %00010001
0012:         	CTC_CH2         equ %00010010
0013:         	CTC_CH3         equ %00010011
              	
              	;label defining for SIO (Serial Input/Output)
0022:         	SIO_CA          equ %00100010
0023:         	SIO_CB          equ %00100011
0020:         	SIO_DA          equ %00100000
0021:         	SIO_DB          equ %00100001
              	
              	;label defining for VDP (Video Display Processor)
0030:         	VDP_DAT         equ %00110000
0032:         	VDP_SET         equ %00110010
              	
              	; label defining for PSG (Programmable Sound Generator)
0040:         	PSG_REG         equ %01000000
0041:         	PSG_DAT         equ %01000001
              	
              	; Interrupt-driven serial I/O interface lead by the Z80 SIO to run modified
              	; NASCOM Basic 4.7 - Full input buffering with incoming data hardware handshaking
              	; Handshake shows full before the buffer is totally filled to allow run-on from the sender
              	
0058:         	SER_BUFSIZE     equ     $58
0050:         	SER_FULLSIZE    equ     $50
0005:         	SER_EMPTYSIZE   equ     $05
              	
8000:         	SERBUF_START    equ     $8000           ; RAM starts here
8058:         	serInPtr        equ     SERBUF_START + SER_BUFSIZE
805A:         	serRdPtr        equ     serInPtr+2
805C:         	serBufUsed      equ     serRdPtr+2
805D:         	basicStarted    equ     serBufUsed+1
0058:         	bufWrap         equ     (SERBUF_START + SER_BUFSIZE) & $FF
818D:         	TEMPSTACK       equ     CURPOS - 3      ; top of BASIC line input buffer so is "free ram" when BASIC resets
              	
              	;------------------------------------------------------------------------------
              	; BASE MEMORY - RESET LOCATION - $0000
              	; the CPU jumps to 0000h after a reset
0000:         	                org     $0000
0000: F3      	RST00:          di                      ; be sure that INTs are disabled
0001: C35A02  	                jp      INIT_HW         ; jump to system initialization
              	
              	;------------------------------------------------------------------------------
              	; send a character over serial
0004: FFFFFFFF	                org     $0008
0008: C3F701  	RST08:          jp      TXA
              	
              	;------------------------------------------------------------------------------
              	; interrupt vector when SIO has a char available in its buffer
000B: FF      	                org     $000C
000C: 0001    	                defw    RX_CHA_AVAIL
              	
              	;------------------------------------------------------------------------------
              	; interrupt vector for SIO special conditions (i.e. buf overrun)
              	                org     $000E
000E: 9B01    	                defw    SPEC_RX_CONDITON
              	
              	;------------------------------------------------------------------------------
              	; receive a character over serial
              	                org     $0010
0010: C3CD01  	RST10:          jp      RXA
              	
              	;------------------------------------------------------------------------------
              	; check serial status
              	
0013: FFFFFFFF	                org     $0018
0017: FF      	
0018: C32402  	RST18:          jp      CKINCHAR
              	
              	;------------------------------------------------------------------------------
              	; interrupt vectors for CTC 
001B: FFFFFFFF	                org     $0040               ; for CH0 Timer - unused
001F: FF...   	
0040: D281    	                defw    CTC0IV
              	                
              	                org     $0042               ; for CH1 Timer - unused
0042: D581    	                defw    CTC1IV
              	                
              	                org     $0044               ; for CH2 timer - unused
0044: D881    	                defw    CTC2IV
              	                
              	                org     $0046               ; for CH3 Timer - used for 100ths/s counter
0046: DB81    	                defw    CTC3IV
              	
              	;------------------------------------------------------------------------------
              	; interrupt routine for NMI
0048: FFFFFFFF	                org     $0066
004C: FF...   	
0066: C36180  	                jp      NMIUSR              ; jump to execute NMI service routine
              	
              	;------------------------------------------------------------------------------
              	
0069: FFFFFFFF	                org     $0090
006D: FF...   	
0090: 4C4D3830	                defb    $4C,$4D,$38,$30,$43,$20,$43,$4F
0094: 4320434F	
0098: 4C4F5200	                defb    $4C,$4F,$52,$00,$00,$00,$00,$00
009C: 00000000	
00A0: 434F4D50	                defb    $43,$4F,$4D,$50,$55,$54,$45,$52
00A4: 55544552	
00A8: 20283230	                defb    $20,$28,$32,$30,$32,$30,$29,$00
00AC: 32302900	
00B0: 44657369	                defb    $44,$65,$73,$69,$67,$6E,$65,$64
00B4: 676E6564	
00B8: 20627900	                defb    $20,$62,$79,$00,$00,$00,$00,$00
00BC: 00000000	
00C0: 4C656F6E	                defb    $4C,$65,$6F,$6E,$61,$72,$64,$6F
00C4: 6172646F	
00C8: 204D696C	                defb    $20,$4D,$69,$6C,$69,$61,$6E,$69
00CC: 69616E69	
00D0: 46572033	FWVER:          defm    'FW 3.13.3',$20,__date__,$20,__time__,$00
00D4: 2E31332E	
00D8: 33203230	
00DC: 32302D30	
00E0: 362D3134	
00E4: 2031323A	
00E8: 30303A34	
00EC: 3200    	
              	;------------------------------------------------------------------------------
              	; interrupt driven routine to get chars from Z80 SIO
00EE: FFFFFFFF	                org     $0100
00F2: FF...   	
0100: F5      	RX_CHA_AVAIL:   push    AF              ; store A
0101: E5      	                push    HL              ; and HL
0102: CD6501  	                call    A_RTS_OFF       ; disable RTS line
0105: DB20    	                in      A,(SIO_DA)      ; read char from RX buffer into A
0107: 322B82  	                ld      (TMPKEYBFR),A   ; store it into the temp key buffer
010A: CD3601  	                call    CHARINTOBFR     ; sub-routine to put the char into the input buffer
010D: D23101  	                jp      NC,LVRXCHA      ; if buffer is full, then leave without doing anything else
0110: 3A2B82  	                ld      A,(TMPKEYBFR)   ; retrieve char
0113: 32EC81  	                ld      (CHR4VID),A     ; write into buffer for video printing
0116: FE0D    	                cp      CR              ; is it RETURN?
0118: CA2001  	                jp      Z,CNTRXCHA      ; yes, continue
011B: FE20    	                cp      $20             ; is it another control char (code < 32)?
011D: DA3101  	                jp      C,LVRXCHA       ; yes, leave w/o printing it on video nor sending back to serial
0120: F5      	CNTRXCHA:       push    AF              ; store char
0121: AF      	                xor     A
0122: 322982  	                ld      (KBDNPT),A      ; a char from serial is like a char printed by BASIC
0125: 3AEB81  	                ld      A,(PRNTVIDEO)   ; load status of print-on-video
0128: FE01    	                cp      $01             ; is the print on video on?
012A: CCAE06  	                call    Z,CHAR2VID      ; yes, print on screen
012D: F1      	                pop     AF              ; retrieve char
012E: CDF701  	                call    TXA             ; send back to serial
0131: E1      	LVRXCHA:        pop     HL              ; retrieve HL
0132: F1      	                pop     AF              ; and A
0133: FB      	                ei                      ; re-enable interrupts
0134: ED4D    	                reti                    ; and exit
              	
              	; put a char into the input buffer, char is into A
              	; this sub is called both from the ISR "RX_CHA_AVAIL" and when
              	; the RETURN key is pressed on the keyboard
0136: F5      	CHARINTOBFR:    push    AF              ; store it
0137: 3A5C80  	                ld      A,(serBufUsed)  ; load buffer size
013A: FE58    	                cp      SER_BUFSIZE     ; if buffer is not full
013C: DA4101  	                jp      C,NOTFULL       ; then store the char
013F: F1      	                pop     AF              ; else drop it
0140: C9      	                ret                     ; and exit
0141: 2A5880  	NOTFULL:        ld      HL,(serInPtr)   ; buffer is not full, can store the char
0144: 23      	                inc     HL              ; load pointer to find first free cell
0145: 7D      	                ld      A,L             ; only check low byte because buffer<256
0146: FE58    	                cp      bufWrap         ; check if the pointer is at the last cell
0148: 2003    	                jr      NZ,NOTWRAP      ; if not then continue
014A: 210080  	                ld      HL,SERBUF_START ; else load the address of the first cell
014D: 225880  	NOTWRAP:        ld      (serInPtr),HL   ; store the new pointer
0150: F1      	                pop     AF              ; then recover the char
0151: 77      	                ld      (HL),A          ; and store it in the appropriate cell
0152: 3A5C80  	                ld      A,(serBufUsed)  ; load the size of the input buffer
0155: 3C      	                inc     A               ; increment it
0156: 325C80  	                ld      (serBufUsed),A  ; and store the new size
0159: FE50    	                cp      SER_FULLSIZE    ; check if input buffer is full
015B: D8      	                ret     C               ; exit if buffer is not full
015C: 3A2E82  	                ld      A,(SERIALS_EN)  ; check if serial 1 is open
015F: 1F      	                rra                     ; bit 0 into Carry: if Carry is 1 then serial 0 is open and...
0160: DC6501  	                call    C,A_RTS_OFF     ; ...stop receiving further chars
0163: AF      	                xor     A               ; clear Carry to set a buffer full condition
0164: C9      	                ret
              	
              	;-------------------------------------------------------------------------------
              	; Z80 SIO MANAGEMENT
              	;-------------------------------------------------------------------------------
              	; disable RTS:
              	; by resetting RTS bit (set to 0), the RTS line is disabled (HIGH)
0165: F5      	A_RTS_OFF:      push    AF              ; store A
0166: 3E05    	                ld      A,%00000101     ; write into WR0: select WR5
0168: D322    	                out     (SIO_CA),A
016A: 3A2F82  	                ld      A,(SERABITS)    ; load data bits
016D: F628    	                or      %00101000       ; TX enable; RTS disable
016F: D322    	                out     (SIO_CA),A      ; send setting
0171: F1      	                pop     AF              ; retrieve A
0172: C9      	                ret                     ; exit
              	
              	; enable RTS
              	; by setting RTS bit (set to 1), the RTS line is enabled (LOW)
0173: F5      	A_RTS_ON:       push    AF              ; store A
0174: 3E05    	                ld      A,%00000101     ; write into WR0: select WR5
0176: D322    	                out     (SIO_CA),A
0178: 3A2F82  	                ld      A,(SERABITS)    ; load data bits
017B: F62A    	                or      %00101010       ; TX enable; RTS enable
017D: D322    	                out     (SIO_CA),A      ; send setting
017F: F1      	                pop     AF              ; retrieve A
0180: C9      	                ret                     ; return
              	
              	; disable SIO RX channel A
0181: F5      	SIO_A_DI:       push    AF              ; store A
0182: 3E03    	                ld      A,%00000011     ; write into WR0: select WR3
0184: D322    	                out     (SIO_CA),A
0186: 3A2F82  	                ld      A,(SERABITS)    ; load the serial bits; RX disabled; auto enable is OFF
0189: D322    	                out     (SIO_CA),A
018B: F1      	                pop     AF              ; retrieve A
018C: C9      	                ret                     ; return
              	
              	; enable SIO RX channel A
018D: F5      	SIO_A_EI:       push    AF              ; store A
018E: 3E03    	                ld      A,%00000011     ; write into WR0: select WR3
0190: D322    	                out     (SIO_CA),A      ; select register
0192: 3A2F82  	                ld      A,(SERABITS)    ; load the serial data bits
0195: CBC7    	                set     0,A             ; set RX enabled; auto enable is OFF
0197: D322    	                out     (SIO_CA),A      ; send setting to SIO
0199: F1      	                pop     AF              ; retrieve A
019A: C9      	                ret
              	
              	
              	; special SIO condition (i.e., buffer overrun)
              	; if buffer overruns then show an error, empty the RX buffer and send
              	; a break char
019B:         	SPEC_RX_CONDITON:
019B: F5      	                push    AF
019C: E5      	                push    HL
019D: CD6501  	                call    A_RTS_OFF       ; disable RTS
01A0: CD8101  	                call    SIO_A_DI        ; disable RX on ch. A
01A3: 3A2E82  	                ld      A,(SERIALS_EN)  ; load serial status
01A6: CB97    	                res     2,A             ; disable RX on port 1
01A8: 322E82  	                ld      (SERIALS_EN),A  ; store new serial status 
01AB: DB01    	                in      A,(PIO_DB)      ; read status LEDs
01AD: CBE7    	                set     4,A             ; set 5th pin ON
01AF: D301    	                out     (PIO_DB),A      ; send new setting
01B1: 3E30    	                ld      A,%00110000     ; write into WR0: error reset, select WR0
01B3: D322    	                out     (SIO_CA),A      ; send command to SIO
01B5: 3E03    	                ld      A,CTRLC
01B7: CD3601  	                call    CHARINTOBFR     ; send CTRL-C to BASIC
01BA: AF      	EMPTYCHABFR:    xor     A
01BB: D322    	                out     (SIO_CA),A      ; write to WR0, select RR0
01BD: DB22    	                in      A,(SIO_CA)      ; read RR0 register
01BF: E601    	                and     $01             ; check if input buffer if empty
01C1: CAC801  	                jp      Z,CHABFREMPTY   ; if yes (bit 0 = 0) then leave
01C4: DB20    	                in      A,(SIO_DA)      ; read chars
01C6: 18F2    	                jr      EMPTYCHABFR     ; repeat
01C8: E1      	CHABFREMPTY:    pop     HL
01C9: F1      	                pop     AF
01CA: FB      	                ei                      ; re-enable interrupts
01CB: ED4D    	                reti                    ; return from interrupt
              	
              	;------------------------------------------------------------------------------
              	; retrieve a char from the input buffer
01CD: 3A5C80  	RXA:            ld      A,(serBufUsed)  ; load the buffer size
01D0: A7      	                and     A               ; check if it's 0 (empty)
01D1: CACD01  	                jp      Z,RXA           ; if it's empty, wait for a char
01D4: F3      	                di                      ; disable interrupts
01D5: E5      	                push    HL              ; store HL
01D6: 2A5A80  	                ld      HL,(serRdPtr)   ; load pointer to first available char
01D9: 23      	                inc     HL              ; increment it (go to the next char)
01DA: 7D      	                ld      A,L             ; check if the end of the buffer has been reached
01DB: FE58    	                cp      bufWrap         ; (only check low byte because buffer<256)
01DD: 2003    	                jr      NZ,NOTRDWRAP    ; if not, jump straight
01DF: 210080  	                ld      HL,SERBUF_START ; else reload the starting address of the buffer
01E2: 225A80  	NOTRDWRAP:      ld      (serRdPtr),HL   ; store new pointer to the next char to read
01E5: 3A5C80  	                ld      A,(serBufUsed)  ; load buffer size
01E8: 3D      	                dec     A               ; decrement it
01E9: 325C80  	                ld      (serBufUsed),A  ; and store the new size
01EC: FE05    	                cp      SER_EMPTYSIZE   ; check if input buffer can be considered empty
01EE: 3003    	                jr      NC,RXA_EXIT     ; if not empty yet, then exit
01F0: CD7301  	                call    A_RTS_ON        ; else re-enable receiving chars
01F3: 7E      	RXA_EXIT:       ld      A,(HL)          ; recover the char and return it into A
01F4: E1      	                pop     HL              ; retrieve HL
01F5: FB      	                ei                      ; re-enable interrupts
01F6: C9      	                ret                     ; return
              	
              	;------------------------------------------------------------------------------
              	; sends a char over the serial (trick for INTs from WikiTI)
              	; char is into A
01F7: F5      	TXA:            push    AF              ; store AF
01F8: C5      	                push    BC              ; store BC
01F9: 47      	                ld      B,A             ; store char
01FA: ED57    	                ld      A,I             ; when loading I into A, P/V is set to the value of IFF (P/V is set if INTs enabled)
01FC: EA0102  	                jp      PE,CNTTXA       ; if set, jump over
01FF: ED57    	                ld      A,I             ; if not set, test again to fix "false negative" from interrupt occurring at first test
0201: F5      	CNTTXA:         push    AF              ; store current P/V flag
0202: F3      	                di                      ; disable INTs
0203: 3A2E82  	                ld      A,(SERIALS_EN)  ; load serial status
0206: FE05    	                cp      %00000101       ; check if serial 1 is open and RX/TX is enabled 
0208: 2006    	                jr      NZ,TXA_EXIT     ; no, jump over
020A: 78      	                ld      A,B             ; retrieve char
020B: D320    	                out     (SIO_DA),A      ; send char to the SIO
020D: CD1802  	                call    TX_EMP          ; wait for outgoing char to be sent
0210: F1      	TXA_EXIT:       pop     AF              ; retrieve P/V flag
0211: E21502  	                jp      PO,EXTXA        ; if P is reset, INTs were disabled so we can leave right now
0214: FB      	                ei                      ; INTs were enabled, so re-enable interrupts
0215: C1      	EXTXA:          pop     BC              ; retrieve BC
0216: F1      	                pop     AF              ; retrieve AF
0217: C9      	                ret                     ; return
              	
              	;------------------------------------------------------------------------------
              	; wait until outgoing serial has been sent
0218: 97      	TX_EMP:         sub     A               ; set A to 0
0219: 3C      	                inc     A               ; set A to 1
021A: D322    	                out     (SIO_CA),A      ; write to WR0, select RR1
021C: DB22    	                in      A,(SIO_CA)      ; read RR1 register
021E: CB47    	                bit     0,A             ; check if all chars have been sent
0220: CA1802  	                jp      Z,TX_EMP        ; if not (bit 0 = 0) then retrieve
0223: C9      	                ret                     ; else exit
              	
              	
              	;------------------------------------------------------------------------------
              	; check if there is some chars into the buffer
0224: 3A5C80  	CKINCHAR        ld      A,(serBufUsed)  ; load char in buffer
0227: A7      	                and     A               ; compare to 0
0228: C9      	                ret                     ; return
              	
              	;------------------------------------------------------------------------------
              	; print a text from memory, and terminate when $00 is found
0229: 7E      	RAWPRINT:       ld      A,(HL)          ; load character from memory cell pointed by HL
022A: B7      	                or      A               ; is it $00 (end string)?
022B: C8      	                ret     Z               ; Yes, then return
022C: 32EC81  	                ld      (CHR4VID),A     ; store char
022F: F3      	                di
0230: CDAE06  	                call    CHAR2VID        ; and send it to screen
0233: FB      	                ei
0234: 23      	                inc     HL              ; and select the next one
0235: 18F2    	                jr      RAWPRINT        ; repeat
              	
              	;-------------------------------------------------
              	; Interrupt service routine (ISR) for CH3 timer
              	; this is used to increment the 100ths of a second counter and for cursor flashing
0237: F5      	CH3_TIMER:      push    AF              ; save regs. A,
0238: C5      	                push    BC              ; BC,
0239: D5      	                push    DE              ; DE,
023A: E5      	                push    HL              ; HL
023B: 21CE81  	                ld      HL,TMRCNT       ; load starting address of the timer
023E: 0604    	                ld      B,$04           ; 4 bytes to check
0240: 34      	INCTMR3:        inc     (HL)            ; increment timer
0241: 2003    	                jr      NZ,CHKCRSR      ; if not zero then exit (finished increment)
0243: 23      	                inc     HL              ; if yes, there was an overflow, so increment next byte
0244: 10FA    	                djnz    INCTMR3         ; repeat for 4 bytes
0246: CD4707  	CHKCRSR:        call    FLASHCURSOR     ; call the flashing cursor routine
0249: CD010C  	                call    MNGSNDS         ; call the tone managemenet
024C: 3ACE81  	                ld      A,(TMRCNT)      ; check for keyboard management
024F: 1F      	                rra                     ; bit 0 = 1 ?
0250: D4660C  	                call    NC,KEYBOARD     ; no, so read the keyboard inputs
0253: E1      	                pop     HL              ; retrieve HL,
0254: D1      	                pop     DE              ; DE,
0255: C1      	                pop     BC              ; BC,
0256: F1      	                pop     AF              ; and A
0257: FB      	                ei                      ; re-enable interrupts
0258: ED4D    	                reti                    ; exit from ISR
              	
              	;------------------------------------------------------------------------------
              	;------------------------------------------------------------------------------
              	; HARDWARE INITIALISATION
              	; first run - setup HW & SW
              	;
025A: 218D81  	INIT_HW:        ld      HL,TEMPSTACK    ; load temp stack pointer
025D: F9      	                ld      SP,HL           ; set stack to temp stack pointer
025E: 210080  	                ld      HL,SERBUF_START ; set beginning of input buffer
0261: 225880  	                ld      (serInPtr),HL   ; for incoming chars to store into buffer
0264: 225A80  	                ld      (serRdPtr),HL   ; and for chars to be read from buffer
0267: AF      	                xor     A               ; reset A
0268: 325C80  	                ld      (serBufUsed),A  ; actual buffer size is 0
026B: 322E82  	                ld      (SERIALS_EN),A  ; set serial ports status to OFF
026E: CDDF02  	                call    HELLOWRLD       ; little serial blink with LEDs
0271: CD0403  	                call    initCTC         ; configure CTC, then...
0274: CD9F0B  	                call    initPSG         ; ...configure PSG
0277: CD9404  	                call    SHOW_LOGO       ; show computer logo
027A: 1E01    	                ld      E,$01           ; E chooses the video mode: 1:graphics 1
027C: CD8003  	                call    initVDP         ; set video display
027F: AF      	                xor     A
0280: ED47    	                ld      I,A             ; set high byte of interrupt vectors to point to page 0
0282: ED5E    	                im      2               ; interrupt mode 2
0284: FB      	                ei                      ; enable interrupts
              	                ; print system messages
0285: AF      	                xor     A               ; A=0 so...
0286: 322982  	                ld      (KBDNPT),A      ; ...inputs don't come from keyboard
0289: 3C      	                inc     A               ; A=1...
028A: 32EB81  	                ld      (PRNTVIDEO),A   ; ...to activate the print-on-video
028D: 213A03  	                ld      HL,MSGTXT1      ; sign-on message
0290: CD2902  	                call    RAWPRINT        ; print message
0293: CD3808  	                call    CURSOR_ON       ; enable cursor
0296: 3A5D80  	                ld      A,(basicStarted); check if BASIC is already started
0299: FE59    	                cp      'Y'             ; to see if this is a power-up
029B: 2016    	                jr      NZ,COLDSTART    ; if not, then do a COLD start
029D: 216603  	                ld      HL,MSGTXT2      ; message to choose kind of start
02A0: CD2902  	                call    RAWPRINT        ; print message
02A3: AF      	                xor     A
02A4: 32EB81  	                ld      (PRNTVIDEO),A   ; disable print-on-video
02A7: CDCD01  	CORW:           call    RXA             ; look for a pressed key
02AA: E6DF    	                and     %11011111       ; only UPPERCASE char
02AC: FE43    	                cp      'C'             ; cold start?
02AE: 200B    	                jr      NZ,CHECKWARM    ; no, let's check for warm start
02B0: CDC502  	                call    ECHO_CHAR       ; echoes the char
02B3: 3E59    	COLDSTART:      ld      A,'Y'           ; yes, set the "BASIC started" flag
02B5: 325D80  	                ld      (basicStarted),A
02B8: C3D00E  	                jp      COLD            ; start BASIC COLD
02BB: FE57    	CHECKWARM:      cp      'W'
02BD: 20E8    	                jr      NZ,CORW         ; char not recognized, wait again
02BF: CDC502  	                call    ECHO_CHAR       ; echoes the char
02C2: C3D30E  	                jp      WARM            ; start BASIC WARM
              	
              	;-------------------------------------------------------------------------------
02C5: 32EC81  	ECHO_CHAR:      ld      (CHR4VID),A     ; set char for video printing
02C8: AF      	                xor     A
02C9: 322982  	                ld      (KBDNPT),A      ; input is not from keyboard
02CC: F3      	                di                      ; disable INTs
02CD: CDAE06  	                call    CHAR2VID        ; echoes back the pressed key,
02D0: 3E0D    	                ld      A,CR            ; then set a CR
02D2: 32EC81  	                ld      (CHR4VID),A     ; set char for video printing
02D5: CDAE06  	                call    CHAR2VID        ; and send it to screen
02D8: FB      	                ei                      ; re-enable INTs
02D9: 3E01    	                ld      A,$01
02DB: 32EB81  	                ld      (PRNTVIDEO),A   ; re-enable video printing
02DE: C9      	                ret                     ; return to caller
              	                
              	;-------------------------------------------------------------------------------
              	; little serial blink with LEDs
02DF: 0E09    	HELLOWRLD:      ld      C,$09           ; 8 LEDs to be turned off + 1 more step to turn off the last LED
02E1: 3ECF    	                ld      A,%11001111     ; set mode 3 (mode control)
02E3: D303    	                out     (PIO_CB),A      ; for PIO port B
02E5: AF      	                xor     A               ; set pins to OUTPUT
02E6: D303    	                out     (PIO_CB),A      ; for port B
02E8: 3C      	                inc     A               ; LSB on
02E9: D301    	LEDLIGHT:       out     (PIO_DB),A      ; turn LEDs on/off for a "Supercar" sequence
02EB: 1E20    	                ld      E,$20           ; little delay
02ED: 0600    	DEC_E:          ld      B,$00           ; count to 256
02EF: 10FE    	COUNTER:        djnz    COUNTER         ; decrement inner counter
02F1: 1D      	                dec     E               ; decrement outer counter
02F2: 20F9    	                jr      NZ,DEC_E        ; finish delay
02F4: CB27    	                sla     A               ; shift reg.A to left 1 bit
02F6: 0D      	                dec     C               ; next LED
02F7: 20F0    	                jr      NZ,LEDLIGHT     ; all LEDs done? no, repeat
02F9: C9      	                ret                     ; return to caller
              	
              	;-------------------------------------------------------------------------------
              	; Z80 SIO default settings for channel A
02FA: 30      	SIO_A_SETS:     defb    %00110000       ; write into WR0: error reset, select WR0
02FB: 18      	                defb    %00011000       ; write into WR0: channel reset
02FC: 04      	                defb    %00000100       ; write into WR0: select WR4
02FD: 44      	                defb    %01000100       ; write into WR4: presc. 16x, 1 stop bit, no parity
02FE: 05      	                defb    %00000101       ; write into WR0: select WR5
02FF: E8      	                defb    %11101000       ; write into WR5: DTR on, TX 8 bits, BREAK off, TX on, RTS off
0300: 01      	SIO_B_SETS:     defb    %00000001       ; write into WR0: select WR1
0301: 04      	                defb    %00000100       ; write into WR1: status affects interrupt vectors
0302: 02      	                defb    %00000010       ; write into WR0: select WR2
0303: 00      	                defb    %00000000       ; write into WR2: set interrupt vector, but bits D3/D2/D1 of this vector
              	                                        ; will be affected by the channel & condition that raised the interrupt
              	                                        ; (see datasheet): in our example, 0x0C for Ch.A receiving A char, 0x0E
              	                                        ; for special conditions
              	;------------------------------------------------------------------------------
              	; Z80 CTC setting up
0304:         	initCTC:
0304: 212E03  	                ld      HL,CTCCONF      ; CTC configuration
0307: 11D281  	                ld      DE,CTC0IV       ; CTC interrupt vector table
030A: 010C00  	                ld      BC,$000C        ; 12 bytes
030D: EDB0    	                ldir                    ; copy data
              	;CH0, CH1, & CH2 disabled
030F: 3E03    	                ld      A,%00000011     ; interrupt off, timer mode, prescaler=16, don't care ext. TRG edge,
              	                                        ; start timer on loading constant, no time constant follows, software reset, command word
0311: D310    	                out     (CTC_CH0),A     ; set CH0
0313: D311    	                out     (CTC_CH1),A     ; set CH1
0315: D312    	                out     (CTC_CH2),A     ; set CH2
              	
              	;init CH3
              	;CH3 divides CPU CLK by 144*256 providing an interrupt signal at 100 Hz (1/100 sec).
              	;f = CPU_CLK/(144*256) => 3,686,400 / ( 36,864 ) => 100Hz
0317: 3EA7    	                ld      A,%10100111     ; interrupt on; timer mode; prescaler=256; don't care ext; automatic trigger;
              	                                        ; time constant follows; cont. operation; command word
0319: D313    	                out     (CTC_CH3),A     ; send to CH3
031B: 3E90    	                ld      A,$90           ; time constant - 90$ (144d)
031D: D313    	                out     (CTC_CH3),A     ; send to CH3
031F: 3E40    	                ld      A,%01000000     ; D7..D3 provide the first part of the int vector (in our case, $0100), followed by
              	                                        ; D2..D1, provided by the CTC (they point to the channel), D0=interrupt word
              	                                        ; so int vector is 01000xx00
0321: D310    	                out     (CTC_CH0),A     ; send to CTC
              	                ; reset cells of 100ths of a second counter
0323: AF      	                xor     A               ; reset A
0324: 21CE81  	                ld      HL,TMRCNT       ; load TMR pointer
0327: 0604    	                ld      B,$04           ; 4 memory cells
0329: 77      	RESTMR:         ld      (HL),A          ; reset n-cell of TMR
032A: 23      	                inc     HL              ; next cell
032B: 10FC    	                djnz    RESTMR          ; repeat for 4 cells
032D: C9      	                ret
              	
032E: FBED4D  	CTCCONF:        defb    $FB,$ED,$4D     ; CTC0 interrupt vector (ei; reti)
0331: FBED4D  	                defb    $FB,$ED,$4D     ; CTC1 interrupt vector (ei; reti)
0334: FBED4D  	                defb    $FB,$ED,$4D     ; CTC2 interrupt vector (ei; reti)
0337: C33702  	                jp      CH3_TIMER       ; CTC3 interrupt vector (sys tick timer)
              	;------------------------------------------------------------------------------
033A: 4C4D3830	MSGTXT1:        defm    "LM80C by Leonardo Miliani",CR
033E: 43206279	
0342: 204C656F	
0346: 6E617264	
034A: 6F204D69	
034E: 6C69616E	
0352: 690D    	
0354: 4669726D	                defm    "Firmware R3.13.3",CR,0
0358: 77617265	
035C: 2052332E	
0360: 31332E33	
0364: 0D00    	
0366: 0D      	MSGTXT2:        defb    CR
0367: 3C433E6F	                defm    "<C>old or <W>arm start? ",0
036B: 6C64206F	
036F: 72203C57	
0373: 3E61726D	
0377: 20737461	
037B: 72743F20	
037F: 00      	
              	; ------------------------------------------------------------------------------
              	; LM80C - VDP ROUTINES - R3.13.3
              	; ------------------------------------------------------------------------------
              	; The following code is intended to be used with LM80C Z80-based computer
              	; designed by Leonardo Miliani. Code and computer schematics are released under
              	; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
              	; kind of warranty: you can use them at your own risk.
              	; You are free to use them for any non-commercial use: you are only asked to
              	; maintain the copyright notices, include this advice and the note to the 
              	; attribution of the original version to Leonardo Miliani, if you intend to
              	; redistribuite them.
              	; https://www.leonardomiliani.com
              	; 
              	; Please support me by visiting the following links:
              	; Main project page: https://www.leonardomiliani.com
              	; Schematics and code: https://github.com/leomil72/LM80C
              	; Videos about the computer: https://www.youtube.com/user/leomil72/videos
              	; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
              	; ------------------------------------------------------------------------------
              	;
              	;------------------------------------------------------------------------------
              	; VDP INITIALISATION
              	; initialize VDP for a specific graphics mode
              	; INPUT: E -> contains the graphics mode:
              	; 0=text; 1=graphics 1; 2=graphics 2; 3=multicolor; 4=extended graphics 2
0380: D5      	initVDP:        push    DE              ; store E
0381: CDDB09  	                call    EMPTY_VRAM      ; reset VRAM
0384: CDFA09  	                call    SET_GFX_MODE    ; load register settings
0387: CDEF09  	                call    CLR_RAM_REG     ; reset RAM registers
038A: D1      	                pop     DE              ; restore reg. E
038B: AF      	                xor     A               ; reset A
038C: 47      	                ld      B,A             ; reset B (will be used later)
038D: 7B      	                ld      A,E             ; move E into A
038E: 32E081  	                ld      (SCR_MODE),A    ; store screen mode
0391: FE01    	                cp      $01             ; is it graphics 1 (A=1)?
0393: CACA03  	                jp      Z,G1MD          ; yes, jump over
0396: FE02    	                cp      $02             ; is it graphics 2 (A=2)?
0398: CA0604  	                jp      Z,G2MD          ; yes, jump over
039B: FE03    	                cp      $03             ; is it multicolor (A=3)?
039D: CA2804  	                jp      Z,MCMD          ; yes, jump over
03A0: FE04    	                cp      $04             ; is it extended graphics 2 (A=4)?
03A2: CA4B04  	                jp      Z,EXG2MD        ; yes, jump over; otherwise, it must be $00 so we assume that it's text mode
              	
              	                ; LOAD VDP SETTINGS FOR SELECTED VIDEO MODE:
              	                ; TEXT MODE (G0)
03A5:         	TXTMD:          ; load charset
03A5: 60      	                ld      H,B
03A6: 68      	                ld      L,B             ; HL=first pattern cell $0000
03A7: CD160A  	                call    LOADCHARSET     ; load patterns into VRAM
              	                ; set cursor & video overlay
03AA: AF      	                xor     A               ; reset A
03AB: 32E481  	                ld      (SCR_CURS_X),A  ; set cursor position at X=0
03AE: 32E581  	                ld      (SCR_CURS_Y),A  ; and Y=0
03B1: 3E05    	                ld      A,$05           ; light blue
03B3: 32EE81  	                ld      (BKGNDCLR),A    ; set background/border color
03B6: 3E28    	                ld      A,$28
03B8: 32DE81  	                ld      (SCR_SIZE_W),A  ; screen width = 40 cols
03BB: 3E18    	                ld      A,$18
03BD: 32DF81  	                ld      (SCR_SIZE_H),A  ; screen height = 24 rows
03C0: 110008  	                ld      DE,$0800
03C3: ED53E281	                ld      (SCR_NAM_TB),DE ; set name table address
03C7: C38904  	                jp      ENDVDPSET       ; execute the rest of the video setting
              	
              	                ; GRAPHICS 1 MODE (G1)
03CA:         	G1MD:           ; load pattern table
03CA: 68      	                ld      L,B
03CB: 60      	                ld      H,B             ; HL=first pattern cell $0000
03CC: CD160A  	                call    LOADCHARSET     ; load patterns into VRAM
              	                ; set cursor & video overlay
03CF: AF      	                xor     A               ; position cursor
03D0: 32E481  	                ld      (SCR_CURS_X),A  ; at X=0
03D3: 32E581  	                ld      (SCR_CURS_Y),A  ; and Y=0
03D6: 3E20    	                ld      A,$20
03D8: 32DE81  	                ld      (SCR_SIZE_W),A  ; screen width = 32 cols
03DB: 3E18    	                ld      A,$18
03DD: 32DF81  	                ld      (SCR_SIZE_H),A  ; screen height = 24 rows
03E0: 110018  	                ld      DE,$1800
03E3: ED53E281	                ld      (SCR_NAM_TB),DE ; set name table address
              	                ; load color table
03E7: 210020  	                ld      HL,$2000        ; color table start: $2000
03EA: CDEC05  	                call    SETVDPADRS
03ED: 3E01    	                ld      A,$01           ; foreground color...
03EF: 32ED81  	                ld      (FRGNDCLR),A    ; ...set to black
03F2: 3E0F    	                ld      A,$0F           ; background color...
03F4: 32EE81  	                ld      (BKGNDCLR),A    ; ...set to white
03F7: 3E1F    	                ld      A,$1F           ; reg.A loaded with colors for chars: bloack pixels on white background
03F9: 0620    	                ld      B,$20           ; 32 bytes of colors
03FB: 0E30    	                ld      C,VDP_DAT       ; VDP data mode
03FD: ED79    	LDCLRTBMD1:     out     (C),A           ; after first byte, the VDP autoincrements VRAM pointer
03FF: 00      	                nop
0400: 00      	                nop
0401: 10FA    	                djnz    LDCLRTBMD1      ; repeat for 32 bytes
0403: C38904  	                jp      ENDVDPSET       ; execute the rest of the video setting
              	
              	                ; GRAPHICS 2 MODE (G2)
0406: AF      	G2MD:           xor     A               ; position cursor
0407: 32E481  	                ld      (SCR_CURS_X),A  ; at X=0
040A: 32E581  	                ld      (SCR_CURS_Y),A  ; and Y=0
040D: 32DE81  	                ld      (SCR_SIZE_W),A  ; screen width = 256 pixels (0=256)
0410: 3C      	                inc     A               ; black on...
0411: 32ED81  	                ld      (FRGNDCLR),A    ; ...foreground
0414: 3E0F    	                ld      A,$0F           ; white on...
0416: 32EE81  	                ld      (BKGNDCLR),A    ; ...background
0419: 3EC0    	                ld      A,$C0
041B: 32DF81  	                ld      (SCR_SIZE_H),A  ; screen height = 192 pixels
041E: 110018  	                ld      DE,$1800
0421: ED53E281	                ld      (SCR_NAM_TB),DE ; set name table address
0425: C38904  	                jp      ENDVDPSET       ; execute the rest of the video setting
              	
              	                ; MULTICOLOR MODE (G3)
0428: AF      	MCMD:           xor     A               ; position cursor
0429: 32E481  	                ld      (SCR_CURS_X),A  ; at X=0
042C: 32E581  	                ld      (SCR_CURS_Y),A  ; and Y=0
042F: 3E0F    	                ld      A,$0F           ; white color for...
0431: 32EE81  	                ld      (BKGNDCLR),A    ; ...background and...
0434: 32ED81  	                ld      (FRGNDCLR),A    ; ...foreground (even this is not used in MC)
0437: 3E40    	                ld      A,$40
0439: 32DE81  	                ld      (SCR_SIZE_W),A  ; screen width = 64 blocks
043C: 3E30    	                ld      A,$30
043E: 32DF81  	                ld      (SCR_SIZE_H),A  ; screen height = 48 blocks
0441: 110008  	                ld      DE,$0800
0444: ED53E281	                ld      (SCR_NAM_TB),DE ; set name table address
0448: C38904  	                jp      ENDVDPSET       ; execute the rest of the video setting
              	
              	                ; EXTENDED GRAPHICS 2 (G4)
044B:         	EXG2MD:         ; load pattern table
044B: 60      	                ld      H,B
044C: 68      	                ld      L,B             ; HL=first pattern cell $0000
044D: CD160A  	                call    LOADCHARSET     ; load patterns into VRAM
              	                ; set cursor & video overlay
0450: AF      	                xor     A               ; position cursor
0451: 32E481  	                ld      (SCR_CURS_X),A  ; at X=0
0454: 32E581  	                ld      (SCR_CURS_Y),A  ; and Y=0
0457: 3E20    	                ld      A,$20
0459: 32DE81  	                ld      (SCR_SIZE_W),A  ; screen width = 32 cols
045C: 3E18    	                ld      A,$18
045E: 32DF81  	                ld      (SCR_SIZE_H),A  ; screen height = 24 rows
0461: 110038  	                ld      DE,$3800
0464: ED53E281	                ld      (SCR_NAM_TB),DE ; set name table address
              	                 ; load color table
0468: 210020  	                ld      HL,$2000        ; color table start: $2000
046B: CDEC05  	                call    SETVDPADRS
046E: 3E01    	                ld      A,$01           ; foreground color is...
0470: 32ED81  	                ld      (FRGNDCLR),A    ; ...set to black
0473: 3E0F    	                ld      A,$0F           ; whitefor...
0475: 32EE81  	                ld      (BKGNDCLR),A    ; ...background
0478: 3E1F    	                ld      A,$1F           ; reg.A loaded with colors for chars: bloack pixels on white background
047A: 1608    	                ld      D,$08           ; 8 pages of 
047C: 0600    	                ld      B,$00           ; 256 bytes of colors (total of 2,048 cells)
047E: 0E30    	                ld      C,VDP_DAT       ; VDP data mode
0480: ED79    	LDCLRTBEX2:     out     (C),A           ; after first byte, the VDP autoincrements VRAM pointer
0482: 00      	                nop
0483: 00      	                nop
0484: 10FA    	                djnz    LDCLRTBEX2      ; repeat for 256 bytes
0486: 15      	                dec     D               ; did we fill up all the cells?
0487: 20F7    	                jr      NZ,LDCLRTBEX2   ; no, repeat
              	                ; LAST VDP SETTINGS
0489: CD4E08  	ENDVDPSET:      call    CURSOR_OFF      ; disable cursor
048C: CD5A05  	                call    EMPTYVIDBUF     ; empty video buffer
048F: AF      	                xor     A
0490: 32E881  	                ld      (SCR_ORG_CHR),A ; store byte used tochar used to empty the video buffer
0493: C9      	                ret                     ; return to caller
              	
              	
              	; show initial logo
0494: CDDB09  	SHOW_LOGO:      call    EMPTY_VRAM      ; reset VRAM
              	                ; set VDP for G2 mode
0497: 0607    	                ld      B,$07           ; set only the first 7 registers
0499: 111000  	                ld      DE,$0010        ; load settings for G2 mode
049C: CD020A  	                call    SET_GFX_MODE2   ; load register settings
049F: 1601    	                ld      D,$01           ; backdrop color set to black
04A1: ED51    	                out     (C),D           ; send data to VDP
04A3: ED79    	                out     (C),A           ; indicate the register to send data to
              	                ; set name table 
04A5: 210018  	                ld      HL,$1800        ; name table address
04A8: CDD905  	                call    SETNAMETABLE    ; set name table (load names into table)
04AB: CD0805  	                call    ERASECLRTBL     ; erase color table (set foreground & background to black)
              	                ; set colors for logo
04AE: 210028  	                ld      HL,$2800        ; 2nd page of color table
04B1: CDEC05  	                call    SETVDPADRS
04B4: 0605    	                ld      B,5             ; 5 bands
04B6: 215505  	                ld      HL,CLRTABLE
04B9: 0E30    	                ld      C,VDP_DAT
04BB: 1E08    	                ld      E,$08           ; 8 pixels each pattern        
04BD: 1640    	RPT101:         ld      D,$40           ; 64 chars each band
04BF: 7E      	                ld      A,(HL)
04C0: ED79    	RPT102:         out     (C),A
04C2: 00      	                nop
04C3: 1D      	                dec     E
04C4: 20FA    	                jr      NZ,RPT102
04C6: 1E08    	                ld      E,$08
04C8: 15      	                dec     D
04C9: 20F5    	                jr      NZ,RPT102
04CB: 23      	                inc     HL
04CC: 10EF    	                djnz    RPT101
              	                ; set pattern table
04CE: 210008  	                ld      HL,$0800        ; address of first cell of 2nd area of pattern table
04D1: 115F0A  	                ld      DE,LM80CLOGO    ; pointer to logo pattern
04D4: 0600    	                ld      B,$00           ; 256 bytes, 8 rows
04D6: CD3405  	RPT103:         call    LOADLOGOCHRS
04D9: 13      	                inc     DE              ; next logo pattern
04DA: 10FA    	                djnz    RPT103
04DC: 0620    	                ld      B,$20           ; repeat for another 2 rows
04DE: CD3405  	RPT104:         call    LOADLOGOCHRS
04E1: 13      	                inc     DE              ; next logo pattern
04E2: 10FA    	                djnz    RPT104
              	                ; show logo/message, play a beep and wait a while
04E4: 0602    	                ld      B,$02
04E6: AF      	                xor     A
04E7: 57      	                ld      D,A             ; 256 times
04E8: 5F      	                ld      E,A             ; x 256 times
04E9: 32EF81  	                ld      (TMPBFR1),A     ; sound flag set to 0
04EC: 00      	DEC_D:          nop                     ; does nothing...
04ED: 00      	                nop
04EE: 00      	                nop
04EF: 00      	                nop
04F0: 00      	                nop
04F1: 00      	                nop
04F2: 1D      	                dec     E               ; decrement E
04F3: 20F7    	                jr      NZ,DEC_D        ; repeat until $00
04F5: 7A      	                ld      A,D
04F6: FE40    	                cp      $40             ; ...equal to 64
04F8: CC2005  	                call    Z,SETBEEP       ; if yes, start sound
04FB: 15      	                dec     D
04FC: 20EE    	                jr      NZ,DEC_D        ; repeat
04FE: 3AEF81  	                ld      A,(TMPBFR1)
0501: FE02    	                cp      $02
0503: C42C05  	                call    NZ,BEEPOFF
0506: 10E4    	                djnz    DEC_D
0508:         	ERASECLRTBL:    ; erase color table
0508: 3E11    	                ld      A,$11           ; foreground and background set to black
050A: 160A    	                ld      D,$0A           ; 10 pages
050C: 0600    	                ld      B,$00           ; 256 color cells per page
050E: 210028  	                ld      HL,$2800        ; first cell of 2nd color table
0511: CDEC05  	                call    SETVDPADRS      ; send address
0514: 0E30    	                ld      C,VDP_DAT       ; VDP address for passing data
0516: ED79    	RPT100:         out     (C),A           ; send data
0518: 00      	                nop
0519: 00      	                nop                     ; little delay
051A: 10FA    	                djnz    RPT100          ; repeat for entire page
051C: 15      	                dec     D
051D: 20F7    	                jr      NZ,RPT100       ; repeat for all the pages ($0A00 cells)
051F: C9      	                ret                     ; return to caller
              	
              	; play a beep
0520: 3AEF81  	SETBEEP:        ld      A,(TMPBFR1)     ; check the already-beeped flag?
0523: B7      	                or      A               ; is it 0?
0524: C0      	                ret     NZ              ; no, exit
0525: 3C      	                inc     A               ; flag to 1
0526: 32EF81  	                ld      (TMPBFR1),A     ; set sound
0529: C3CD0B  	                jp      WLCMBEEP        ; play a beep & return
              	
              	; beep off
052C: 3E02    	BEEPOFF:        ld      A,$02           ; flag for sound off
052E: 32EF81  	                ld      (TMPBFR1),A     ; set flag
0531: C3D30B  	                jp      NOBEEP          ; stop beep and return
              	
              	
              	; used to load the chars that will compose the logo of the splash screen
0534: 1A      	LOADLOGOCHRS:   ld      A,(DE)          ; load a pattern char of the logo
0535: 87      	                add     A,A
0536: 87      	                add     A,A
0537: 87      	                add     A,A             ; multiply times 8 to get the offset
0538: C5      	                push    BC
0539: D5      	                push    DE              ; store BC and DE
053A: E5      	                push    HL              ; store VRAM address to write to
053B: 21AD4C  	                ld      HL,LOGOFONT     ; start of logo font data
053E: 5F      	                ld      E,A
053F: 1600    	                ld      D,$00           ; put offset (A) into DE
0541: 19      	                add     HL,DE           ; get address of pattern data
0542: EB      	                ex      DE,HL           ; move address into DE
0543: E1      	                pop     HL              ; retrieve VRAM address
0544: 0608    	                ld      B,$08           ; 8 bytes per pattern
0546: CDEC05  	                call    SETVDPADRS      ; set VDP address
0549: 0E30    	                ld      C,VDP_DAT
054B: 1A      	SNDLOGPT:       ld      A,(DE)          ; load data from RAM
054C: ED79    	                out     (C),A           ; and send to VRAM
054E: 13      	                inc     DE              ; next byte into RAM
054F: 23      	                inc     HL              ; next byte into VRAM (used in future iterations)
0550: 10F9    	                djnz    SNDLOGPT        ; repeat 8 times
0552: D1      	                pop     DE
0553: C1      	                pop     BC              ; retrieve BC & DE
0554: C9      	                ret                     ; return to caller
              	
0555:         	CLRTABLE:       equ $
0555: 181B1314	                defb    $18,$1B,$13,$14,$1D ; colors of background bands of the logo
0559: 1D      	
              	                
              	; empty video buffer
055A: 3AE081  	EMPTYVIDBUF:    ld      A,(SCR_MODE)    ; check screen mode
055D: FE02    	                cp      $02             ; is it G2 mode?
055F: CA8305  	                jp      Z,EMPTYG2       ; yes, jump over
0562: FE03    	                cp      $03             ; is it MC mode?
0564: CAB405  	                jp      Z,EMPTYMC       ; yes, jump over
0567: 3ADF81  	                ld      A,(SCR_SIZE_H)  ; load height of screen
056A: 47      	                ld      B,A             ; move rows into B
056B: AF      	                xor     A               ; filling char is $00
056C: 2AE281  	                ld      HL,(SCR_NAM_TB) ; load the name table address
056F: CDEC05  	                call    SETVDPADRS      ; send address to VDP
0572: 0E30    	                ld      C,VDP_DAT       ; VDP address for passing data
0574: 5F      	LDCOLSTOEMPTY:  ld      E,A             ; store filling char into E
0575: 3ADE81  	                ld      A,(SCR_SIZE_W)  ; load # of cols to empty into A
0578: 57      	                ld      D,A             ; move A into D
0579: 7B      	                ld      A,E             ; recover filling char
057A: ED79    	RPTEMPTYBUF:    out     (C),A           ; write empty byte into VRAM
057C: 00      	                nop
057D: 15      	                dec     D               ; decr. D
057E: 20FA    	                jr      NZ,RPTEMPTYBUF  ; repeat for the # of cols
0580: 10F2    	                djnz    LDCOLSTOEMPTY   ; repeat for the # of rows
0582: C9      	                ret                     ; return to caller
0583: 2AE281  	EMPTYG2:        ld      HL,(SCR_NAM_TB) ; yes, additional setup for G2 - load G2 name table address (usually $1800)
0586: CDD905  	                call    SETNAMETABLE    ; set name table
0589: 210000  	                ld      HL,$0000        ; set pattern table
058C: CDEC05  	                call    SETVDPADRS      ; send address to VDP
058F: AF      	                xor     A               ; empty pattern
0590: 1618    	                ld      D,$18           ; 6144 ($1800) cell to clean, 24 pages ($18)
0592: 47      	                ld      B,A             ; 256 bytes for page
0593: 0E30    	                ld      C,VDP_DAT       ; VDP data mode
0595: ED79    	CLRG2PTNTBL:    out     (C),A           ; clear pattern
0597: 00      	                nop                     ; little delay
0598: 00      	                nop
0599: 10FA    	                djnz    CLRG2PTNTBL     ; repeat for 1 page
059B: 15      	                dec     D               ; next page
059C: 20F7    	                jr      NZ,CLRG2PTNTBL  ; repeat
059E: 210020  	                ld      HL,$2000        ; load the color table address
05A1: CDEC05  	                call    SETVDPADRS      ; send address to VDP
05A4: 3AED81  	                ld      A,(FRGNDCLR)    ; load foreground
05A7: 87      	                add     A,A
05A8: 87      	                add     A,A
05A9: 87      	                add     A,A
05AA: 87      	                add     A,A             ; move to high nibble
05AB: 57      	                ld      D,A             ; store into D
05AC: 3AEE81  	                ld      A,(BKGNDCLR)    ; load background color
05AF: B2      	                or      D               ; combine with background color
05B0: 1618    	                ld      D,$18           ; 6144 ($1800) cells to fill, so 24 pages ($18)
05B2: 1817    	                jr      STARTEMPTY
05B4: 210008  	EMPTYMC:        ld      HL,$0800        ; MC name table
05B7: CDD905  	                call    SETNAMETABLE    ; set name table
05BA: 210000  	                ld      HL,$0000        ; color table address
05BD: CDEC05  	                call    SETVDPADRS      ; send address to VDP
05C0: 3AEE81  	                ld      A,(BKGNDCLR)    ; load background
05C3: 57      	                ld      D,A             ; store into D
05C4: 87      	                add     A,A
05C5: 87      	                add     A,A
05C6: 87      	                add     A,A
05C7: 87      	                add     A,A             ; move to high nibble
05C8: B2      	                or      D               ; set background color for high and low nibble
05C9: 1608    	                ld      D,$08           ; 2048 ($0800) cells to fill, so 8 pages ($08)
05CB: 0E30    	STARTEMPTY:     ld      C,VDP_DAT       ; VDP address for passing data
05CD: 0600    	                ld      B,$00           ; 256 bytes each page ($00=256)
05CF: ED79    	SNDCLRSET:      out     (C),A           ; send color setting
05D1: 00      	                nop                     ; wait a while
05D2: 00      	                nop
05D3: 10FA    	                djnz    SNDCLRSET       ; repeat for 1 page
05D5: 15      	                dec     D               ; have we filled all the pages?
05D6: 20F7    	                jr      NZ,SNDCLRSET    ; no, repeat
05D8: C9      	                ret                     ; return to caller
              	
              	; set name table for G2 mode (patterns from $00 to $FF for each of the 3 areas of the screen)
05D9: CDEC05  	SETNAMETABLE:   call    SETVDPADRS      ; send address to VDP
05DC: 0E30    	                ld      C,VDP_DAT       ; VDP address for passing data
05DE: 1603    	                ld      D,$03           ; 3 pages to fill into VRAM (768 cells)
05E0: AF      	                xor     A               ; starting char name #0 (chars go from 0 to 255)
05E1: 47      	                ld      B,A             ; reset B
05E2: ED79    	RPTFLL1:        out     (C),A           ; send name to VRAM
05E4: 00      	                nop
05E5: 3C      	                inc     A               ; increment # of name
05E6: 10FA    	                djnz    RPTFLL1         ; repeat for 256 cells (1 page)
05E8: 15      	                dec     D               ; did we fill all the pages?
05E9: 20F7    	                jr      NZ,RPTFLL1      ; no, continue
05EB: C9      	                ret                     ; return to caller
              	
              	; set an address into VRAM: address is in HL
05EC: 0E32    	SETVDPADRS:     ld      C,VDP_SET       ; VDP address mode
05EE: CBF4    	                set     6,H             ; set bit #6 of address, to write to VRAM
05F0: ED69    	                out     (C),L           ; send low and...
05F2: ED61    	                out     (C),H           ; ...high byte of the first cell
05F4: C9      	                ret                     ; return to caller
              	
              	; clear the video buffer and position the cursor at 0,0
05F5: CD5A05  	CLEARVIDBUF:    call    EMPTYVIDBUF     ; clear video buffer
05F8: AF      	                xor     A               ; reset A
05F9: 32E481  	                ld      (SCR_CURS_X),A  ; cursor X to 0
05FC: 32E581  	                ld      (SCR_CURS_Y),A  ; cursor Y to 0
05FF: C34806  	                jp      POS_CURSOR      ; position cursor & return to caller
              	
              	; HOME: position the cursor at coords. 0,0 
0602: AF      	ATHOME:         xor     A               ; position cursor at 0,0 by storing...
0603: 32E781  	                ld      (SCR_CUR_NY),A  ; ...new Y...
0606: 32E681  	                ld      (SCR_CUR_NX),A  ; ...and new X
0609: C35206  	                jp      MOVCRS          ; move cursor to new location & return to caller
              	
              	; load the char or byte at the VRAM position set by HL
              	; value is returned into A
060C: C5      	READ_VIDEO_LOC: push    BC              ; store BC
060D: 0E32    	                ld      C,VDP_SET       ; VDP setting mode
060F: 44      	                ld      B,H
0610: CBB8    	                res     7,B
0612: CBB0    	                res     6,B
0614: ED69    	                out     (C),L           ; low byte then...
0616: ED41    	                out     (C),B           ; high byte
0618: 0E30    	                ld      C,VDP_DAT       ; VDP data mode
061A: 00      	                nop                     ; wait...
061B: 00      	                nop                     ; ...a while
061C: 00      	                nop
061D: ED78    	                in      A,(C)           ; read byte at current VRAM location
061F: C1      	                pop     BC              ; restore BC
0620: C9      	                ret                     ; return to caller
              	
              	; write a byte at the VRAM position pointed by HL
              	; value is in A
0621: C5      	WRITE_VIDEO_LOC:push    BC              ; store BC
0622: 0E32    	                ld      C,VDP_SET       ; VDP setting mode
0624: 44      	                ld      B,H             ; copy H into B
0625: CBB8    	                res     7,B
0627: CBF0    	                set     6,B             ; write to VRAM
0629: ED69    	                out     (C),L           ; low byte then...
062B: ED41    	                out     (C),B           ; high byte of VRAM address
062D: 0E30    	                ld      C,VDP_DAT       ; VDP data mode
062F: 00      	                nop                     ; wait...
0630: 00      	                nop                     ; ...a while
0631: 00      	                nop
0632: ED79    	                out     (C),A           ; write byte into VRAM
0634: C1      	                pop     BC              ; restore BC
0635: C9      	                ret                     ; return to caller
              	
              	; write a value into a specific VDP register
              	; value is in E, register is in A
0636: C5      	WRITE_VREG:     push    BC              ; store BC
0637: C680    	                add     A,$80           ; set VDP to write to registers
0639: 0E32    	                ld      C,VDP_SET       ; VDP setting mode
063B: ED59    	                out     (C),E           ; send data to VDP
063D: ED79    	                out     (C),A           ; select the destination register
063F: C1      	                pop     BC              ; restore BC
0640: C9      	                ret                     ; return to caller
              	
              	; read VDP status register and return value into A
0641: C5      	READ_VSTAT:     push    BC              ; store BC
0642: 0E32    	                ld      C,VDP_SET       ; VDP register access
0644: ED78    	                in      A,(C)           ; read status register
0646: C1      	                pop     BC              ; restore BC
0647: C9      	                ret                     ; return to caller
              	
              	; position the cursor at the current coordinates, preserving underlying char
0648: CD7906  	POS_CURSOR:     call    LOAD_CRSR_POS   ; load the VRAM address of cursor into HL
064B: CD0C06  	                call    READ_VIDEO_LOC  ; load the current char at the cursor position (return in A)
064E: 32E881  	                ld      (SCR_ORG_CHR),A ; store the current char
0651: C9      	                ret
              	
              	; move cursor to new X,Y coordinates
0652: CD7006  	MOVCRS:         call    RSTCHRCRS       ; restore the char in the current cursor position
0655: CD5B06  	                call    NEWCRSRCOORD    ; set new cursor's coordinates
0658: C34806  	                jp      POS_CURSOR      ; position cursor into new location & return to caller
              	
              	
              	; set new cursor's coordinates:
065B: 3AE681  	NEWCRSRCOORD:   ld      A,(SCR_CUR_NX)  ; load new X
065E: 32E481  	                ld      (SCR_CURS_X),A  ; write new X
0661: 3AE781  	                ld      A,(SCR_CUR_NY)  ; load new Y
0664: 32E581  	                ld      (SCR_CURS_Y),A  ; write new Y
0667: 3EFF    	                ld      A,$FF           ; delete new values
0669: 32E681  	                ld      (SCR_CUR_NX),A  ; of X
066C: 32E781  	                ld      (SCR_CUR_NY),A  ; and Y
066F: C9      	                ret
              	
              	; recover char under the cursor and prints it onto the screen
0670: CD7906  	RSTCHRCRS:      call    LOAD_CRSR_POS   ; recover old cursor position
0673: 3AE881  	                ld      A,(SCR_ORG_CHR) ; recover old char
0676: C32106  	                jp      WRITE_VIDEO_LOC ; write char into VRAM & return
              	
              	; retrieve cursor position from either current coordinates or next place
              	; return address position into HL
0679: 3AE581  	LOAD_CRSR_POS:  ld      A,(SCR_CURS_Y)  ; load cursor Y
067C: 6F      	                ld      L,A             ; move it into reg.L
067D: AF      	                xor     A               ; reset A
067E: 67      	                ld      H,A             ; reset H
067F: 47      	                ld      B,A             ; reset B
0680: 29      	                add     HL,HL           ; create offset (each address is 2-bytes long so we need to double HL)
0681: 11AB09  	                ld      DE,POS_TB_CRS_40; load position table address of cursor for 40 cols
0684: 3ADE81  	                ld      A,(SCR_SIZE_W)  ; load screen width
0687: FE28    	                cp      $28             ; is it 40 cols?
0689: 2803    	                jr      Z,CONT_POS_CURS ; yes, jump over
068B: 117B09  	                ld      DE,POS_TB_CRS_32; no, load position table address of cursor for 32 cols
068E: 19      	CONT_POS_CURS:  add     HL,DE           ; the correct starting address of the required row is now into HL
068F: 5E23562B	                ld      DE,(HL)         ; load starting address of the required row into DE
0693: 2AE281  	                ld      HL,(SCR_NAM_TB) ; load starting address of name table
0696: 19      	                add     HL,DE           ; starting address of the current row into name table
0697: 3AE481  	                ld      A,(SCR_CURS_X)  ; load cursor X
069A: 4F      	                ld      C,A             ; transfer A into C
069B: 09      	                add     HL,BC           ; add X offset: now HL contains the address of the current cursor position
069C: C9      	                ret
              	
              	; find X,Y coordinates of a screen address pointed in VRAM by HL
              	; return them into L & A for X,Y
069D: D5      	HL2XY:          push    DE              ; store DE
069E: ED5BE281	                ld      DE,(SCR_NAM_TB) ; load starting address of name table into DE
06A2: AF      	                xor     A               ; clear Carry
06A3: ED52    	                sbc     HL,DE           ; find position relative to screen (from 0,0)
06A5: D1      	                pop     DE
06A6: 3ADE81  	                ld      A,(SCR_SIZE_W)  ; load screen width
06A9: 4F      	                ld      C,A             ; move it into C
06AA: CD9E3C  	                call    DIV_16_8        ; divide position by C: return Y into L and X into A
06AD: C9      	                ret                     ; return to caller
              	
              	;-------------------------------------------------------------------------------
              	; send current char to video buffer
06AE: F5      	CHAR2VID:       push    AF              ; store AF
06AF: C5      	                push    BC              ; store BC
06B0: D5      	                push    DE              ; store DE
06B1: E5      	                push    HL              ; store HL
06B2: 3AE981  	                ld      A,(CRSR_STATE)  ; store cursor state...
06B5: F5      	                push    AF              ; into stack
06B6: CD4E08  	                call    CURSOR_OFF      ; cursor off
06B9: 3AEC81  	                ld      A,(CHR4VID)     ; recover char
06BC: FE19    	                cp      HOME            ; is it HOME char ($19?)
06BE: 2006    	                jr      NZ,CHKCS        ; no, check over
06C0: CD0206  	                call    ATHOME          ; yes, move the cursor to 0,0
06C3: C33907  	                jp      EXITCHAR2VID    ; exit
06C6: FE0C    	CHKCS:          cp      CS              ; is it the CLEAR char ($0C)?
06C8: 2005    	                jr      NZ,CHKCR        ; no, check over
06CA: CDF505  	                call    CLEARVIDBUF     ; yes, clear video buffer and position cursor at 0,0
06CD: 186A    	                jr      EXITCHAR2VID    ; exit
06CF: FE0D    	CHKCR:          cp      CR              ; is it a carriage return ($0D)?
06D1: 2005    	                jr      NZ,CHKBKSP      ; no, jump over
06D3: CDD008  	                call    CRGRETURN       ; yes, go to the beginning of the next line
06D6: 1861    	                jr      EXITCHAR2VID    ; exit
06D8: FE08    	CHKBKSP:        cp      BKSP            ; is it the backspace ($08)?
06DA: 2005    	                jr      NZ,CHKCRSLFT    ; no, jump over
06DC: CD6B07  	                call    BACKSPACE       ; move cursor left 1 position
06DF: 1858    	                jr      EXITCHAR2VID    ; exit
06E1: FE1C    	CHKCRSLFT:      cp      CRSLFT          ; is it cursor left?
06E3: 2005    	                jr      NZ,CHKCRSUP     ; no, jump over
06E5: CD7E07  	                call    CURSORLEFT      ; move cursor left...
06E8: 184F    	                jr      EXITCHAR2VID    ; ...and exit
06EA: FE1E    	CHKCRSUP:       cp      CRSUP           ; is it cursor up?
06EC: 2005    	                jr      NZ,CHKCRSRGT    ; no, jump over
06EE: CDCA07  	                call    CURSORUP        ; move cursor up...
06F1: 1846    	                jr      EXITCHAR2VID    ; ...and exit
06F3: FE1D    	CHKCRSRGT:      cp      CRSRGT          ; is it cursor right?
06F5: 2005    	                jr      NZ,CHKCRSDWN    ; no, jump over
06F7: CDE307  	                call    CURSORRIGHT     ; move cursor right...
06FA: 183D    	                jr      EXITCHAR2VID    ; ...and exit
06FC: FE1F    	CHKCRSDWN:      cp      CRSDN           ; is it cursor down?
06FE: 2005    	                jr      NZ,CHKLF        ; no, jump over
0700: CD1808  	                call    CURSORDOWN      ; move cursor up...
0703: 1834    	                jr      EXITCHAR2VID    ; ...and exit
0705: FE0A    	CHKLF:          cp      LF              ; is it a line feed ($0A)?
0707: 2830    	                jr      Z,EXITCHAR2VID  ; CURRENTLY WE DON'T PRINT LF, WE JUST USE CR TO SUBSTITUTE CR+LF COMBINATION
0709: CD7906  	                call    LOAD_CRSR_POS   ; recover position of cursor
070C: 3AEC81  	                ld      A,(CHR4VID)     ; recover char to print
070F: CD2106  	                call    WRITE_VIDEO_LOC ; write A into VRAM at (HL)
0712: 3AE581  	                ld      A,(SCR_CURS_Y)  ; load cursor Y into A
0715: 5F      	                ld      E,A             ; store cursor Y into E
0716: 3AE481  	                ld      A,(SCR_CURS_X)  ; load cursor X
0719: 3C      	                inc     A               ; move 1 step to right
071A: 21DE81  	                ld      HL,SCR_SIZE_W   ; cell that keeps the width of screen
071D: BE      	                cp      (HL)            ; have we reached the most right position?
071E: 200F    	                jr      NZ,SETCSRCOORDS ; no, go over
0720: 1C      	                inc     E               ; yes, increment cursor Y (go to next line)
0721: 7B      	                ld      A,E             ; move cursor Y into A
0722: 21DF81  	                ld      HL,SCR_SIZE_H   ; cell that keeps the height of screen
0725: BE      	                cp      (HL)            ; have we reached the bottom of the screen?
0726: 2006    	                jr      NZ,SETCRSRY     ; no, jump over
0728: D5      	                push    DE
0729: CD5508  	                call    SCROLLUP        ; scroll screen up
072C: D1      	                pop     DE
072D: 1D      	                dec     E               ; decrement 1 row, to set cursor Y on the last line
072E: AF      	SETCRSRY:       xor     A               ; then set cursor X to 0 (go to beginning of line)
072F: 32E481  	SETCSRCOORDS:   ld      (SCR_CURS_X),A  ; store current cursor X
0732: 7B      	                ld      A,E             ; recover Y
0733: 32E581  	                ld      (SCR_CURS_Y),A  ; store current cursor Y
0736: CD4806  	                call    POS_CURSOR      ; position cursor to new location
0739: AF      	EXITCHAR2VID:   xor     A               ; reset char
073A: 32EC81  	                ld      (CHR4VID),A     ; to be sent to screen
073D: F1      	                pop     AF              ; recover cursor state
073E: A7      	                and     A               ; was it off (A=0)?
073F: C43808  	                call    NZ,CURSOR_ON    ; no, set cursor on
0742: E1      	                pop     HL              ; restore HL
0743: D1      	                pop     DE              ; restore DE
0744: C1      	                pop     BC              ; restore BC
0745: F1      	                pop     AF              ; restore AF
0746: C9      	                ret                     ; return to caller
              	
              	; flash the cursor at the current position
              	; (this sub-routine is called by CH3 timer ISR)
0747: 3AE981  	FLASHCURSOR:    ld      A,(CRSR_STATE)  ; now, check the cursor
074A: A7      	                and     A               ; cursor off (A=0)?
074B: C8      	                ret     Z               ; yes, return
074C: 3ACE81  	                ld      A,(TMRCNT)      ; no, load the first byte of the 100ths of A second's counter
074F: E620    	                and     $20             ; check if it's time to flash the cursor (check bit #6)
0751: 21EA81  	                ld      HL,LSTCSRSTA    ; load address of cell that stores the last cursor state
0754: 46      	                ld      B,(HL)          ; load last state
0755: B8      	                cp      B               ; compare current state with last state
0756: C8      	                ret     Z               ; same state, no change required - exit
0757: 77      	                ld      (HL),A          ; save new state
0758: F5      	                push    AF              ; store A (keep state for later use)
0759: CD7906  	                call    LOAD_CRSR_POS   ; load current cursor position into HL
075C: F1      	                pop     AF              ; recover current state
075D: 06FF    	                ld      B,$FF           ; cursor char
075F: FE20    	                cp      $20             ; is the cursor on video (A == $20)?
0761: 2804    	                jr      Z,PUTCRSCHR     ; yes, jump over
0763: 3AE881  	                ld      A,(SCR_ORG_CHR) ; no, load the original char
0766: 47      	                ld      B,A             ; move char into B
0767: 78      	PUTCRSCHR:      ld      A,B             ; recover char from B
0768: C32106  	                jp      WRITE_VIDEO_LOC ; print cursor/char at the current position & return
              	
              	
              	; delete the char at the left of the cursor
076B: CDA707  	BACKSPACE:      call    MVCRS2LFT       ; prepare to move cursor to left
076E: CD7006  	                call    RSTCHRCRS       ; restore char under the cursor
0771: CD5B06  	                call    NEWCRSRCOORD    ; set new cursor's coordinates
0774: CD7906  	                call    LOAD_CRSR_POS   ; find address of new video cell
0777: AF      	                xor     A               ; null char
0778: CD2106  	                call    WRITE_VIDEO_LOC ; write into video cell
077B: C34806  	                jp      POS_CURSOR      ; position cursor and return
              	
              	
              	; move cursor to left
077E: F5      	CURSORLEFT:     push    AF              ; store A
077F: 3AE481  	                ld      A,(SCR_CURS_X)  ; load cursor X into A
0782: A7      	                and     A               ; is it at the most left of the screen (X=0)?
0783: 280C    	                jr      Z,CHCKYPOS      ; yes, check Y position
0785: 3D      	                dec     A               ; no, decrement X
0786: 32E681  	                ld      (SCR_CUR_NX),A  ; store new X
0789: 3AE581  	                ld      A,(SCR_CURS_Y)  ; load current cursor Y
078C: 32E781  	                ld      (SCR_CUR_NY),A  ; no move over Y axis
078F: 1811    	                jr      CONTCRSLFT      ; go on moving cursor
0791: 3AE581  	CHCKYPOS:       ld      A,(SCR_CURS_Y)  ; load cursor Y
0794: A7      	                and     A               ; is it at the most top of the screen (Y=0)?
0795: 280E    	                jr      Z,EXITCURSORLEFT; yes, exit doing nothing
0797: 3D      	                dec     A               ; no, decrement Y
0798: 32E781  	                ld      (SCR_CUR_NY),A  ; store new Y
079B: 3ADE81  	                ld      A,(SCR_SIZE_W)  ; load current screen width
079E: 3D      	                dec     A               ; cursor to the most right position (width-0)
079F: 32E681  	                ld      (SCR_CUR_NX),A  ; set new cursor X
07A2: CD5206  	CONTCRSLFT:     call    MOVCRS          ; move cursor into new position
07A5: F1      	EXITCURSORLEFT: pop     AF              ; restore A
07A6: C9      	                ret                     ; return to caller
              	
              	; move cursor 1 position to the left
07A7: 3AE481  	MVCRS2LFT:      ld      A,(SCR_CURS_X)  ; load cursor X into A
07AA: A7      	                and     A               ; is it at the most left of the screen (X=0)?
07AB: 280B    	                jr      Z,CHKYPOS       ; yes, check Y position
07AD: 3D      	                dec     A               ; no, decrement X
07AE: 32E681  	                ld      (SCR_CUR_NX),A  ; store new X
07B1: 3AE581  	                ld      A,(SCR_CURS_Y)  ; load current cursor Y
07B4: 32E781  	                ld      (SCR_CUR_NY),A  ; no move over Y axis
07B7: C9      	                ret                     ; go on moving cursor
07B8: 3AE581  	CHKYPOS:        ld      A,(SCR_CURS_Y)  ; load cursor Y
07BB: A7      	                and     A               ; is it at the most top of the screen (Y=0)?
07BC: 28E7    	                jr      Z,EXITCURSORLEFT; yes, exit doing nothing
07BE: 3D      	                dec     A               ; no, decrement Y
07BF: 32E781  	                ld      (SCR_CUR_NY),A  ; store new Y
07C2: 3ADE81  	                ld      A,(SCR_SIZE_W)  ; load current screen width
07C5: 3D      	                dec     A               ; cursor to the most right position (width-1)
07C6: 32E681  	                ld      (SCR_CUR_NX),A  ; set new cursor X
07C9: C9      	                ret                     ; return to caller
              	
              	; move cursor up
07CA: F5      	CURSORUP:       push    AF              ; store A
07CB: 3AE581  	                ld      A,(SCR_CURS_Y)  ; load cursor Y into A
07CE: A7      	                and     A               ; is it at the most top of the screen (Y=0)?
07CF: 2810    	                jr      Z,EXITCURSORUP  ; yes, exit doing nothing
07D1: 3D      	                dec     A               ; no, decrement Y
07D2: 32E781  	                ld      (SCR_CUR_NY),A  ; store new Y
07D5: 3AE481  	                ld      A,(SCR_CURS_X)  ; load current cursor X
07D8: 32E681  	                ld      (SCR_CUR_NX),A  ; set new cursor X
07DB: CD7006  	                call    RSTCHRCRS       ; restore char under the cursor and print it
07DE: CD5206  	                call    MOVCRS          ; move cursor into new position
07E1: F1      	EXITCURSORUP:   pop     AF              ; restore A
07E2: C9      	                ret                     ; return to caller
              	
              	
              	; move cursor to right
07E3: F5      	CURSORRIGHT:    push    AF              ; store A
07E4: C5      	                push    BC              ; store B
07E5: 3ADE81  	                ld      A,(SCR_SIZE_W)  ; load current screen width (in text modes it's 32 or 40)
07E8: 3D      	                dec     A               ; decrement it (most right can only be 31 or 39)
07E9: 47      	                ld      B,A             ; move A into B
07EA: 3AE481  	                ld      A,(SCR_CURS_X)  ; load cursor X into A    
07ED: B8      	                cp      B               ; is cursor at the most right position on the screen?
07EE: 300C    	                jr      NC,CHCKYPOS2    ; yes, so jump to check Y position
07F0: 3C      	                inc     A               ; no, so increment X
07F1: 32E681  	                ld      (SCR_CUR_NX),A  ; store new X
07F4: 3AE581  	                ld      A,(SCR_CURS_Y)  ; load current cursor Y
07F7: 32E781  	                ld      (SCR_CUR_NY),A  ; no move over Y axis
07FA: 1813    	                jr      CONTCRSRGT      ; go on moving cursor
07FC: 3ADF81  	CHCKYPOS2:      ld      A,(SCR_SIZE_H)  ; load screen height
07FF: 3D      	                dec     A               ; decrement it (last row can only be 23)
0800: 47      	                ld      B,A             ; move bottom into B
0801: 3AE581  	                ld      A,(SCR_CURS_Y)  ; load cursor Y into A
0804: B8      	                cp      B               ; is the cursor at the bottom of the screen?
0805: 300E    	                jr      NC,EXITCURSORRGHT; yes, exit doing nothing
0807: 3C      	                inc     A               ; no, increment Y
0808: 32E781  	                ld      (SCR_CUR_NY),A  ; store new Y
080B: AF      	                xor     A               ; move cursor to top left
080C: 32E681  	                ld      (SCR_CUR_NX),A  ; store new X
080F: CD7006  	CONTCRSRGT:     call    RSTCHRCRS       ; restore char under the cursor and print it
0812: CD5206  	                call    MOVCRS          ; move cursor into new position
0815: C1      	EXITCURSORRGHT: pop     BC              ; retrieve BC
0816: F1      	                pop     AF              ; restore A
0817: C9      	                ret                     ; return to caller
              	
              	
              	; move cursor down
0818: F5      	CURSORDOWN:     push    AF              ; store A
0819: C5      	                push    BC              ; store B
081A: 3ADF81  	                ld      A,(SCR_SIZE_H)  ; load current screen height (in text modes it's 24)
081D: 3D      	                dec     A               ; decrement it (positions can only vary between 0 and 23)
081E: 47      	                ld      B,A             ; move X into B
081F: 3AE581  	                ld      A,(SCR_CURS_Y)  ; load cursor Y into A             
0822: B8      	                cp      B               ; is current cursor position < 23?
0823: 3010    	                jr      NC,EXITCURSORDOWN; no, exit doing nothing
0825: 3C      	                inc     A               ; yes, increment Y
0826: 32E781  	                ld      (SCR_CUR_NY),A  ; store new Y
0829: 3AE481  	                ld      A,(SCR_CURS_X)  ; load current cursor X
082C: 32E681  	                ld      (SCR_CUR_NX),A  ; set new cursor X
082F: CD7006  	                call    RSTCHRCRS       ; restore char under the cursor and print it
0832: CD5206  	                call    MOVCRS          ; move cursor into new position
0835: C1      	EXITCURSORDOWN: pop     BC              ; retrieve BC
0836: F1      	                pop     AF              ; retrieve A
0837: C9      	                ret                     ; return to caller
              	
              	
              	; set cursor on (visible on screen)
0838: F5      	CURSOR_ON:      push    AF              ; store AF
0839: 3AE981  	                ld      A,(CRSR_STATE)  ; load cursor state
083C: FE01    	                cp      $01             ; is it on?
083E: 280C    	                jr      Z,EXITCURSOR_ON ; yes, so nothing to do
0840: 3ADF81  	                ld      A,(SCR_SIZE_H)  ; check the video mode
0843: FE30    	                cp      $30             ; graphics 2 or 3 (if value>=48)?
0845: 3005    	                jr      NC,EXITCURSOR_ON; yes, so exit (no cursor in graphics 2 or 3)
0847: 3E01    	                ld      A,$01           ; cursor state ON
0849: 32E981  	                ld      (CRSR_STATE),A  ; set state
084C: F1      	EXITCURSOR_ON:  pop     AF              ; restore AF
084D: C9      	                ret                     ; return to caller
              	
              	; set cursor off (invisible on screen)
084E: F5      	CURSOR_OFF:     push    AF              ; store AF
084F: AF      	                xor     A               ; cursor state OFF
0850: 32E981  	                ld      (CRSR_STATE),A  ; set state
0853: F1      	                pop     AF              ; restore AF
0854: C9      	                ret
              	
              	; scroll the screen 1 row up
0855: AF      	SCROLLUP:       xor     A
0856: 32EB81  	                ld      (PRNTVIDEO),A
0859: 2AE281  	                ld      HL,(SCR_NAM_TB) ; start address of the name table
085C: 221F82  	                ld      (VIDTMP1),HL    ; store address of the destination row (1st row of the screen)
085F: 3ADE81  	                ld      A,(SCR_SIZE_W)  ; load the screen width
0862: 5F      	                ld      E,A             ; move width into E
0863: 1600    	                ld      D,$00           ; reset D
0865: 19      	                add     HL,DE           ; HL now contains the address of the source row (2nd row of the screen)
0866: 222182  	                ld      (VIDTMP2),HL    ; store address of source row
0869: 3ADF81  	                ld      A,(SCR_SIZE_H)  ; load the screen height
086C: 3D      	                dec     A               ; decrement the # of rows: now, A contains the # of rows to be moved
086D: 47      	                ld      B,A             ; move # of rows into B
086E: 3ADE81  	SCROLLNXTRW:    ld      A,(SCR_SIZE_W)  ; (re)load the screen width
0871: 5F      	                ld      E,A             ; move width into E
0872: 2A2182  	                ld      HL,(VIDTMP2)    ; load source address
0875: 0E32    	                ld      C,VDP_SET       ; VDP setting mode
0877: ED69    	                out     (C),L           ; low byte of source
0879: ED61    	                out     (C),H           ; high byte of source
087B: 21F781  	                ld      HL,VIDEOBUFF    ; load address of the first cell of the video buffer
087E: 0E30    	                ld      C,VDP_DAT       ; VDP data mode
0880: ED78    	LOADNEXTCOL:    in      A,(C)           ; load char
0882: 77      	                ld      (HL),A          ; store char
0883: 23      	                inc     HL              ; next cell of the buffer
0884: 1D      	                dec     E               ; count the chars to be read
0885: 20F9    	                jr      NZ,LOADNEXTCOL  ; repeat until we read the entire row
0887: 3ADE81  	                ld      A,(SCR_SIZE_W)  ; reload the screen width
088A: 5F      	                ld      E,A             ; move # of rows into E
088B: 1600    	                ld      D,$00           ; reset D
088D: 2A1F82  	                ld      HL,(VIDTMP1)    ; load address of destination row
0890: E5      	                push    HL              ; store HL
0891: 2A2182  	                ld      HL,(VIDTMP2)    ; current source will be..
0894: 221F82  	                ld      (VIDTMP1),HL    ; ..new destination
0897: 19      	                add     HL,DE           ; address of new
0898: 222182  	                ld      (VIDTMP2),HL    ; source row
089B: E1      	                pop     HL              ; restore address of current destination row
089C: CBF4    	                set     6,H             ; writing mode
089E: 0E32    	                ld      C,VDP_SET       ; VDP setting mode
08A0: ED69    	                out     (C),L           ; low byte
08A2: ED61    	                out     (C),H           ; high byte of address
08A4: 21F781  	                ld      HL,VIDEOBUFF    ; video buffer address
08A7: 0E30    	                ld      C,VDP_DAT       ; VDP data mode
08A9: 7E      	WRITEBUF:       ld      A,(HL)          ; load char
08AA: ED79    	                out     (C),A           ; send char
08AC: 23      	                inc     HL              ; increment buffer index
08AD: 1D      	                dec     E               ; next row
08AE: 20F9    	                jr      NZ,WRITEBUF     ; repeat until 0
08B0: 10BC    	                djnz    SCROLLNXTRW     ; repeat for the entire screen
08B2: 3ADE81  	                ld      A,(SCR_SIZE_W)  ; reload screen width
08B5: 47      	                ld      B,A             ; cells to empty into B
08B6: AF      	                xor     A               ; null char
08B7: 0E32    	                ld      C,VDP_SET       ; VDP set mode
08B9: 2A1F82  	                ld      HL,(VIDTMP1)    ; load address of the last row
08BC: CBF4    	                set     6,H             ; writing mode
08BE: ED69    	                out     (C),L           ; low byte then..
08C0: ED61    	                out     (C),H           ; high byte of address
08C2: 0E30    	                ld      C,VDP_DAT       ; VDP data mode
08C4: ED79    	RPTEMPTYROW:    out     (C),A           ; empty cell
08C6: 00      	                nop                     ; delay
08C7: 00      	                nop
08C8: 10FA    	                djnz    RPTEMPTYROW     ; repeat until the last row has been cleaned
08CA: 3E01    	                ld      A,$01
08CC: 32EB81  	                ld      (PRNTVIDEO),A   ; set print-on-video on
08CF: C9      	                ret                     ; return to caller
              	
              	; carriage return: first, it looks for char $00 at the beginning of the line (look for the first null char),
              	; then it starts sendind every char it finds on the screen to the terminal buffer of the BASIC interpreter
              	; until another null char is found. Finally, move to the next line and position the cursor at the beginning
              	; of the row (equivalent to CR+LF), then gets back control to the screen editor to let it interpret the line
81EF:         	CUR_POS         equ     TMPBFR1         ; cursor position
81F1:         	SRTTXT          equ     TMPBFR2         ; start of text line
81F3:         	ENDTXT          equ     TMPBFR3         ; end of text line
08D0:         	CRGRETURN:      ; preliminary: disable cursor if on, and retrieve char under it
08D0: 3AE981  	                ld      A,(CRSR_STATE)  ; recover cursor state
08D3: 32F581  	                ld      (TMPBFR4),A     ; store status
08D6: A7      	                and     A               ; is cursor on?
08D7: C44E08  	                call    NZ,CURSOR_OFF   ; yes, so set cursor off
08DA: CD7006  	                call    RSTCHRCRS       ; restore char under it
              	                ; first, check if cursor if off, so that we just interpret return as a new line command
08DD: 3A2982  	                ld      A,(KBDNPT)      ; check if input from keyboad
08E0: A7      	                and     A               ; if 0, input is not from keyboard...
08E1: CA5A09  	                jp      Z,PRNTRETURN    ; ...so just print a carriage return; otherwise, interpret the return
              	                ; first part: look for the beginning of the text line on screen
08E4: CD7906  	                call    LOAD_CRSR_POS   ; load cursor position into HL
08E7: 22EF81  	                ld      (CUR_POS),HL    ; store it
08EA: ED5BE281	                ld      DE,(SCR_NAM_TB) ; load VRAM address of top-left cell of screen ("home")
08EE: E5      	RPTNLLSRC:      push    HL
08EF: CD5F3C  	                call    CMP16           ; check if at "home"
08F2: E1      	                pop     HL
08F3: CAFE08  	                jp      Z,CNTNULL       ; yes, exit because there is nothing before
08F6: 2B      	                dec     HL              ; go 1 step back
08F7: CD0C06  	                call    READ_VIDEO_LOC  ; read char of current position
08FA: A7      	                and     A               ; is it $00 (null char)?
08FB: 20F1    	                jr      NZ,RPTNLLSRC    ; no, continue searching
08FD: 23      	                inc     HL              ; move 1 step forward to go back to the last cell with something in
              	                ; second part: look for the ending of the text on screen
08FE: 22F181  	CNTNULL:        ld      (SRTTXT),HL     ; store beginning of text
0901: 3ADF81  	                ld      A,(SCR_SIZE_H)
0904: 5F      	                ld      E,A             ; load screen height into DE
0905: 3ADE81  	                ld      A,(SCR_SIZE_W)
0908: 6F      	                ld      L,A             ; load screen width into HL
0909: AF      	                xor     A
090A: 67      	                ld      H,A
090B: 57      	                ld      D,A
090C: CD6A3C  	                call    MUL16           ; multiply HL times DE to get the screen size
090F: ED5BE281	                ld      DE,(SCR_NAM_TB) ; load screen name table start address into DE
0913: 19      	                add     HL,DE           ; get the address...
0914: 2B      	                dec     HL              ; ...of the "last" video cell
0915: EB      	                ex      DE,HL           ; store address into DE
0916: 2AEF81  	                ld      HL,(CUR_POS)    ; retrieve original cursor position
0919: E5      	RPTNLLSRC2:     push    HL
091A: CD5F3C  	                call    CMP16           ; check if at last position on screen (bottom right corner)
091D: E1      	                pop     HL
091E: CA2809  	                jp      Z,CNTNULL2      ; if yes, exit because these is nothing after
0921: 23      	                inc     HL              ; 1 more step forward
0922: CD0C06  	                call    READ_VIDEO_LOC  ; read char of current position
0925: A7      	                and     A               ; is it $00 (null char)?
0926: 20F1    	                jr      NZ,RPTNLLSRC2   ; no, continue searching
0928: 22F381  	CNTNULL2:       ld      (ENDTXT),HL     ; store ending of text line
092B: ED5BF181	                ld      DE,(SRTTXT)     ; load beginning of text line
092F: A7      	                and     A               ; clear Carry
0930: ED52    	                sbc     HL,DE           ; how many chars?
0932: 2826    	                jr      Z,PRNTRETURN    ; no chars found (HL-DE=0), so just print return & leave
              	                ;---    central part: send the text on the screen to the interpreter
0934: 2AF181  	                ld      HL,(SRTTXT)     ; load beginning of text line
0937: ED5BF381	                ld      DE,(ENDTXT)     ; load ending of text line
093B: CD0C06  	SNDCHRTOBFR:    call    READ_VIDEO_LOC  ; read char
093E: E5      	                push    HL
093F: CD3601  	                call    CHARINTOBFR     ; send char to buffer
0942: E1      	                pop     HL
0943: 23      	                inc     HL              ; go to next char
0944: E5      	                push    HL              ; store HL
0945: CD5F3C  	                call    CMP16           ; check if DE=HL (finish chars)
0948: E1      	                pop     HL
0949: 20F0    	                jr      NZ,SNDCHRTOBFR  ; no, repeat
094B: 3E0D    	                ld      A,CR            ; yes, so now send carriage return
094D: CD3601  	                call    CHARINTOBFR     ; send to buffer
0950: 2AF381  	                ld      HL,(ENDTXT)     ; recover address of last char of input text
0953: CD9D06  	                call    HL2XY           ; retrieve X,Y from address
0956: 7D      	                ld      A,L             ; move Y into A (we don't need X anymore)
0957: 32E581  	                ld      (SCR_CURS_Y),A  ; store new Y
              	                ;---    final part: go at the beginning of a new line on the screen
095A: AF      	PRNTRETURN:     xor     A               ; move to col 0
095B: 32E481  	                ld      (SCR_CURS_X),A  ; store new X
095E: 3AE581  	                ld      A,(SCR_CURS_Y)  ; load cursor Y into A
0961: 3C      	                inc     A               ; new row
0962: 21DF81  	                ld      HL,SCR_SIZE_H   ; load address of cell that keeps screen height
0965: BE      	                cp      (HL)            ; is the cursor over the bottom of the screen?
0966: 3806    	                jr      C,ADDNEWLINE    ; no, jump over
0968: 3D      	                dec     A               ; yes, so come back 1 row, then...
0969: F5      	                push    AF              ; (store A)
096A: CD5508  	                call    SCROLLUP        ; ...scroll the screen before to...
096D: F1      	                pop     AF              ; (retrieve A)
096E: 32E581  	ADDNEWLINE:     ld      (SCR_CURS_Y),A  ; ...store new Y
0971: 3AF581  	                ld      A,(TMPBFR4)     ; retrieve cursor state
0974: A7      	                and     A               ; was it off (A=0)?
0975: C43808  	                call    NZ,CURSOR_ON    ; no, set cursor on
0978: C34806  	                jp      POS_CURSOR      ; position cursor to new location & return to caller
              	
              	; ------------------------------------------------------------------------------
              	                ; this table contains the values of the offsets to be added to
              	                ; the starting address of the name table to find the correct
              	                ; value of the first cell of the corresponding row
              	                ; (by doing so, it's faster than doing a multipication)
              	                ; table for graphics 1 text mode: 32 cols
097B: 00002000	POS_TB_CRS_32   defw    $0000,$0020,$0040,$0060,$0080,$00A0,$00C0,$00E0
097F: 40006000	
0983: 8000A000	
0987: C000E000	
098B: 00012001	                defw    $0100,$0120,$0140,$0160,$0180,$01A0,$01C0,$01E0
098F: 40016001	
0993: 8001A001	
0997: C001E001	
099B: 00022002	                defw    $0200,$0220,$0240,$0260,$0280,$02A0,$02C0,$02E0
099F: 40026002	
09A3: 8002A002	
09A7: C002E002	
              	                ; table for pure text mode: 40 cols
09AB: 00002800	POS_TB_CRS_40   defw    $0000,$0028,$0050,$0078,$00A0,$00C8,$00F0,$0118
09AF: 50007800	
09B3: A000C800	
09B7: F0001801	
09BB: 40016801	                defw    $0140,$0168,$0190,$01B8,$01E0,$0208,$0230,$0258
09BF: 9001B801	
09C3: E0010802	
09C7: 30025802	
09CB: 8002A802	                defw    $0280,$02A8,$02D0,$02F8,$0320,$0348,$0370,$0398
09CF: D002F802	
09D3: 20034803	
09D7: 70039803	
              	
              	; ------------------------------------------------------------------------------
              	; reset VRAM
09DB: AF      	EMPTY_VRAM:     xor     A               ; reg.A cleared: we fill up VRAM with $00
09DC: 67      	                ld      H,A
09DD: 6F      	                ld      L,A             ; reset HL
09DE: CDEC05  	                call    SETVDPADRS      ; set address of first VRAM cell to $0000
09E1: 0640    	                ld      B,$40           ; $40 pages of RAM...
09E3: 57      	                ld      D,A             ; ...each one with $100 cells (tot. $4000 bytes)
09E4: 0E30    	                ld      C,VDP_DAT       ; VDP data mode
09E6: ED79    	EMPTVRM:        out     (C),A           ; after first byte, the VDP autoincrements VRAM pointer
09E8: 14      	                inc     D               ; next cell
09E9: 00      	                nop
09EA: 20FA    	                jr      NZ,EMPTVRM      ; repeat until page is fully cleared
09EC: 10F8    	                djnz    EMPTVRM         ; repeat for $40 pages
09EE: C9      	                ret                     ; return to caller
              	
              	; clear video registers in SRAM
09EF: 21DE81  	CLR_RAM_REG:    ld      HL,SCR_SIZE_W   ; address of first register
09F2: AF      	                xor     A               ; $00 to clean the registers
09F3: 0645    	                ld      B,CHASNDDTN-SCR_SIZE_W; how many bytes (registers) to clean (dinamically calculated)
09F5: 77      	RSTVDPRAMREG:   ld      (HL),A          ; reset register
09F6: 23      	                inc     HL              ; next register
09F7: 10FC    	                djnz    RSTVDPRAMREG    ; repeat
09F9: C9      	                ret                     ; return to caller
              	
              	; ------------------------------------------------------------------------------
              	; set a specific graphics mode, passed into reg. E
09FA: 0608    	SET_GFX_MODE:   ld      B,$08           ; 8 registers means 8 bytes..
09FC: CB23    	                sla     E               ; multiply E by 8..
09FE: CB23    	                sla     E               ; so that reg. E can point..
0A00: CB23    	                sla     E               ; to the correct settings
0A02: 1600    	SET_GFX_MODE2:  ld      D,$00           ; reset D
0A04: 21370A  	                ld      HL,VDPMODESET   ; pointer to register settings | <= here points the SHOW_LOGO sub-routine
0A07: 19      	                add     HL,DE           ; add offset to get the correct set of values for the required mode
0A08: 3E80    	                ld      A,$80           ; start with REG0 ($80+register number)
0A0A: 0E32    	                ld      C,VDP_SET       ; VDP set
0A0C: 56      	LDREGVLS:       ld      D,(HL)          ; load register's value
0A0D: ED51    	                out     (C),D           ; send data to VDP
0A0F: ED79    	                out     (C),A           ; indicate the register to send data to
0A11: 3C      	                inc     A               ; next register
0A12: 23      	                inc     HL              ; next value
0A13: 10F7    	                djnz    LDREGVLS        ; repeat for 8 registers
0A15: C9      	                ret
              	
              	; ------------------------------------------------------------------------------
0A16:         	LOADCHARSET:    ; reg. A contains the video mode
              	                ; reg. HL contains address of pattern table into VRAM
0A16: 0600    	                ld      B,$00           ; 0=256 chars to load (complete charset)
0A18: CBF4    	                set     $06,H           ; add $4000 to address to indicate that we want to write into VRAM
0A1A: 0E32    	                ld      C,VDP_SET       ; load VDP address into C
0A1C: ED69    	                out     (C),L           ; send low byte of address
0A1E: ED61    	                out     (C),H           ; send high byte
0A20: 21AD3C  	                ld      HL,CHRST68      ; starting address of 6x8 charset into ROM
0A23: A7      	                and     A               ; is it text mode (A=0)?
0A24: 2803    	                jr      Z,NXTCHAR       ; yes, so jump to load chars into VRAM
0A26: 21AD44  	                ld      HL,CHRST88      ; no, so we change and load the 8x8 charset
0A29: 1608    	NXTCHAR:        ld      D,$08           ; 8 bytes per pattern char
0A2B: 0E30    	                ld      C,VDP_DAT       ; VDP data mode
0A2D: 7E      	SENDCHRPTRNS:   ld      A,(HL)          ; load byte to send to VDP
0A2E: ED79    	                out     (C),A           ; write byte into VRAM
0A30: 23      	                inc     HL              ; inc byte pointer
0A31: 15      	                dec     D               ; 8 bytes sents (0 char)?
0A32: 20F9    	                jr      NZ,SENDCHRPTRNS ; no, continue
0A34: 10F3    	                djnz    NXTCHAR         ; yes, decrement chars counter and continue for all the chars
0A36: C9      	                ret                     ; return to caller
              	
              	;------------------------------------------------------------------------------
              	; NAME TABLE:       buffer video - contains the chars to be shown on video
              	; PATTERN TABLE:    charset - contains the chars/tiles to be loaded into the name table
              	; COLOR TABLE:      color settings for chars/tiles
              	
              	                ; VDP register settings for a text display
0A37: 00      	VDPMODESET      defb    %00000000       ; reg.0: external video off
0A38: D0      	                defb    %11010000       ; reg.1: 16K VRAM, video on, int. off, text mode (40x24)
0A39: 02      	                defb    $02             ; reg.2: name table set to $0800 ($02x$400)
0A3A: 00      	                defb    $00             ; reg.3: not used in text mode
0A3B: 00      	                defb    $00             ; reg.4: pattern table set to $0000
0A3C: 00      	                defb    $00             ; reg.5: not used in text mode
0A3D: 00      	                defb    $00             ; reg.6: not used in text mode
0A3E: F5      	                defb    $f5             ; reg.7: white text on light blue background
              	
0A3F:         	VDPMODESET1     ; VDP register settings for a graphics 1 mode
0A3F: 00      	                defb    %00000000       ; reg.0: ext. video off
0A40: C0      	                defb    %11000000       ; reg.1: 16K Vram; video on, int off, graphics mode 1, sprite size 8x8, sprite magn. 0
0A41: 06      	                defb    $06             ; reg.2: name table address: $1800
0A42: 80      	                defb    $80             ; reg.3: color table address: $2000
0A43: 00      	                defb    $00             ; reg.4: pattern table address: $0000
0A44: 36      	                defb    $36             ; reg.5: sprite attr. table address: $1B00
0A45: 07      	                defb    $07             ; reg.6: sprite pattern table addr.: $3800
0A46: 05      	                defb    $05             ; reg.7: backdrop color (light blue)
              	
0A47:         	VDPMODESET2     ; VDP register settings for a graphics 2 mode
0A47: 02      	                defb    %00000010       ; reg.0: graphics 2 mode, ext. video dis.
0A48: C0      	                defb    %11000000       ; reg.1: 16K VRAM, video on, INT off, sprite size 8x8, sprite magn. 0
0A49: 06      	                defb    $06             ; reg.2: name table addr.: $1800
0A4A: FF      	                defb    $FF             ; reg.3: color table addr.: $2000
0A4B: 03      	                defb    $03             ; reg.4: pattern table addr.: $0000
0A4C: 36      	                defb    $36             ; reg.5: sprite attr. table addr.: $1B00
0A4D: 07      	                defb    $07             ; reg.6: sprite pattern table addr.: $3800
0A4E: 05      	                defb    $05             ; reg.7: backdrop color: light blue
              	
0A4F:         	VDPMODESETMC    ; VDP register settings for a multicolor mode
0A4F: 00      	                defb    %00000000       ; reg.0: ext. video dis.
0A50: CB      	                defb    %11001011       ; reg.1: 16K VRAM, video on, INT off, multicolor mode, sprite size 8x8, sprite magn. 0
0A51: 02      	                defb    $02             ; reg.2: name table addr.: $0800
0A52: 00      	                defb    $00             ; reg.3: don't care
0A53: 00      	                defb    $00             ; reg.4: pattern table addr.: $0000
0A54: 36      	                defb    $36             ; reg.5: sprite attr. table addr.: $1B00
0A55: 07      	                defb    $07             ; reg.6: sprite pattern table addr.: $3800
0A56: 0F      	                defb    $0F             ; reg.7: backdrop color (white)
              	
0A57:         	VDPMODESETEX2   ; VDP register settings for an extended graphics 2 mode
0A57: 02      	                defb    %00000010       ; reg.0: graphics 2 mode, ext. video dis.
0A58: C0      	                defb    %11000000       ; reg.1: 16K VRAM, video on, INT off, sprite size 8x8, sprite magn. 0
0A59: 0E      	                defb    $0E             ; reg.2: name table addr.: $3800
0A5A: 9F      	                defb    $9F             ; reg.3: color table addr.: $2000
0A5B: 00      	                defb    $00             ; reg.4: pattern table addr.: $0000
0A5C: 76      	                defb    $76             ; reg.5: sprite attr. table addr.: $3B00
0A5D: 03      	                defb    $03             ; reg.6: sprite pattern table addr.: $1800
0A5E: 05      	                defb    $05             ; reg.7: backdrop color: light blue
              	
0A5F:         	LM80CLOGO       ; patterns to compose the splash screen logo
0A5F: 00000000	                defb    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0A63: 00...   	
0A7F: 00000F0A	                defb    0,0,15,10,11,16,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0A83: 0B100000	
0A87: 00000000	
0A8B: 00...   	
0A9F: 00000D17	                defb    0,0,13,23,0,12,0,0,0,1,0,0,0,20,0,0,6,5,6,21,22,7,6,21,22,7,6,1,1,7,0,0
0AA3: 000C0000	
0AA7: 00010000	
0AAB: 00140000	
0AAF: 06050615	
0AB3: 16070615	
0AB7: 16070601	
0ABB: 01070000	
0ABF: 00000D00	                defb    0,0,13,0,0,12,0,0,0,1,0,0,0,1,20,6,1,5,3,5,3,5,3,5,3,5,3,5,3,5,0,0
0AC3: 000C0000	
0AC7: 00010000	
0ACB: 00011406	
0ACF: 01050305	
0AD3: 03050305	
0AD7: 03050305	
0ADB: 03050000	
0ADF: 00000D00	                defb    0,0,13,0,0,12,0,0,0,1,0,0,0,1,1,1,1,5,9,20,19,8,3,5,19,5,3,5,0,0,0,0
0AE3: 000C0000	
0AE7: 00010000	
0AEB: 00010101	
0AEF: 01050914	
0AF3: 13080305	
0AF7: 13050305	
0AFB: 00000000	
0AFF: 00000D00	                defb    0,0,13,0,0,12,0,0,0,1,0,0,0,1,0,8,3,5,6,21,22,7,3,1,22,5,3,5,0,0,0,0
0B03: 000C0000	
0B07: 00010000	
0B0B: 00010008	
0B0F: 03050615	
0B13: 16070301	
0B17: 16050305	
0B1B: 00000000	
0B1F: 00000D00	                defb    0,0,13,0,0,12,0,0,0,1,0,0,0,1,0,0,3,5,3,5,3,5,3,5,3,5,3,5,3,5,0,0
0B23: 000C0000	
0B27: 00010000	
0B2B: 00010000	
0B2F: 03050305	
0B33: 03050305	
0B37: 03050305	
0B3B: 03050000	
0B3F: 00000D00	                defb    0,0,13,0,0,12,0,0,0,1,4,4,0,1,0,0,3,5,9,20,19,8,9,20,19,8,9,1,1,8,0,0
0B43: 000C0000	
0B47: 00010404	
0B4B: 00010000	
0B4F: 03050914	
0B53: 13080914	
0B57: 13080901	
0B5B: 01080000	
0B5F: 00000E12	                defb    0,0,14,18,18,17,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0B63: 12110000	
0B67: 00000000	
0B6B: 00...   	
0B7F: 00000000	                defb    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0; ------------------------------------------------------------------------------
0B83: 00...   	
              	; LM80C - PSG ROUTINES - R3.13.3
              	; ------------------------------------------------------------------------------
              	; The following code is intended to be used with LM80C Z80-based computer
              	; designed by Leonardo Miliani. Code and computer schematics are released under
              	; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
              	; kind of warranty: you can use them at your own risk.
              	; You are free to use them for any non-commercial use: you are only asked to
              	; maintain the copyright notices, include this advice and the note to the 
              	; attribution of the original version to Leonardo Miliani, if you intend to
              	; redistribuite them.
              	; https://www.leonardomiliani.com
              	; 
              	; Please support me by visiting the following links:
              	; Main project page: https://www.leonardomiliani.com
              	; Schematics and code: https://github.com/leomil72/LM80C
              	; Videos about the computer: https://www.youtube.com/user/leomil72/videos
              	; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
              	; ------------------------------------------------------------------------------
              	;
              	; ------------------------------------------------------------------------------
              	
              	;------------------------------------------------------------------------------
              	; configure the PSG
0B9F: 212382  	initPSG:        ld      HL,CHASNDDTN    ; starting address of sound & keyboard RAM registers
0BA2: 060B    	                ld      B,SERIALS_EN-CHASNDDTN; # of PSG sound & keyboard registers
0BA4: AF      	                xor     A               ; reset A
0BA5: 77      	EMPTSNDBFR:     ld      (HL),A          ; reset RAM register
0BA6: 23      	                inc     HL              ; next register
0BA7: 10FC    	                djnz    EMPTSNDBFR      ; repeat
0BA9: 0610    	CLRPSGREGS:     ld      B,$10           ; 16 registers to set
0BAB: 21BD0B  	                ld      HL,SNDREGCFG    ; starting address of register settings
0BAE: 1600    	                ld      D,$00           ; first register
0BB0: 7A      	RSTPSG:         ld      A,D             ; register value
0BB1: CDF70B  	                call    SETSNDREG       ; select register
0BB4: 7E      	                ld      A,(HL)          ; load value
0BB5: CDFC0B  	                call    WRTSNDREG       ; write to register
0BB8: 14      	                inc     D               ; next register
0BB9: 23      	                inc     HL              ; next value
0BBA: 10F4    	                djnz    RSTPSG          ; repeat for each register
0BBC: C9      	                ret                     ; return to caller
              	
0BBD: 00000000	SNDREGCFG:      defb $00,$00,$00,$00,$00,$00,$00,%10111111
0BC1: 000000BF	
0BC5: 00000000	                defb $00,$00,$00,$00,$00,$00,$ff,$ff
0BC9: 0000FFFF	
              	                ; reg. 7: set I/O ch.A to OUTPUT, I/O ch.B to INPUT; set noise to OFF; set audio to OFF
              	
              	
              	; routine to play a welcome beep on channel C (tone 4010) and to shut it off
0BCD: 21E70B  	WLCMBEEP:       ld      HL,WLCBPDAT     ; data address
0BD0: C3D60B  	                jp      SENDSND
0BD3: 21EF0B  	NOBEEP:         ld      HL,NOBPDAT      ; data address
0BD6: C5      	SENDSND:        push    BC
0BD7: 0604    	                ld      B,$04           ; 4 pairs
0BD9: 7E      	RPTWLCMBP:      ld      A,(HL)          ; read register #
0BDA: CDF70B  	                call    SETSNDREG
0BDD: 23      	                inc     HL              ; next cell
0BDE: 7E      	                ld      A,(HL)          ; read value
0BDF: CDFC0B  	                call    WRTSNDREG
0BE2: 23      	                inc     HL
0BE3: 10F4    	                djnz    RPTWLCMBP       ; repeat
0BE5: C1      	                pop     BC
0BE6: C9      	                ret                     ; return to caller
              	
0BE7: 077B0456	WLCBPDAT:       defb    $07,%01111011,$04,$56,$05,$00,$0A,$0F
0BEB: 05000A0F	
0BEF: 04000500	NOBPDAT:        defb    $04,$00,$05,$00,$0A,$00,$07,%01111111
0BF3: 0A00077F	
              	
              	
              	; select register on PSG
0BF7: 0E40    	SETSNDREG:      ld      C,PSG_REG       ; PSG register port
0BF9: ED79    	                out     (C),A           ; set register
0BFB: C9      	                ret                     ; return to caller
              	
              	; send data to PSG
0BFC: 0E41    	WRTSNDREG:      ld      C,PSG_DAT       ; PSG data port
0BFE: ED79    	                out     (C),A           ; send data
0C00: C9      	                ret                     ; return to caller
              	
              	; manage the sounds' duration: each time this subroutine is called, it
              	; decrements the single sound durations (measured in ms) and eventually
              	; shut off the audio channel whose counter has reached 0.
              	; (this sub-routine is called by CH3 timer ISR)
0C01: DDE5    	MNGSNDS:        push    IX              ; store IX
0C03: DD212382	                ld      IX,CHASNDDTN    ; starting address of tones duration
0C07: 0603    	                ld      B,$03           ; 3 channels to check
0C09: 2601    	                ld      H,$01           ; mixer channels: A=>bit 1, B=>bit 2, C=>bit 3
0C0B: DD5E00  	CHKSNDCH:       ld      E,(IX+0)        ; load LSB into E
0C0E: DD5601  	                ld      D,(IX+1)        ; load MSB into D
0C11: 7B      	                ld      A,E             ; load E into A
0C12: B2      	                or      D               ; check that DE=0
0C13: 2831    	                jr      Z,CNTCHKSND     ; yes, jump over
0C15: 1B      	                dec     DE              ; no, so decrement DE
0C16: 7B      	                ld      A,E             ; reload E into A...
0C17: DD7300  	                ld      (IX+0),E        ; store new...
0C1A: DD7201  	                ld      (IX+1),D        ; ...duration and...
0C1D: B2      	                or      D               ; ...do another check to see if DE=0
0C1E: 2026    	                jr      NZ,CNTCHKSND    ; no, so jump over
              	                                        ; if yes, let's shut down the corresponding channel
              	                                        ; to shut down a tone we disable it into the mixer
              	                                        ; then set 0 into its tone registers
0C20: 1607    	                ld      D,$07           ; mixer register
0C22: 0E40    	                ld      C,PSG_REG       ; PSG register selector port
0C24: ED51    	                out     (C),D           ; set mixer register
0C26: ED78    	                in      A,(C)           ; load current value
0C28: B4      	                or      H               ; set off the channel into the mixer (remember that 1=OFF)
0C29: ED51    	                out     (C),D           ; select mixer register
0C2B: 0E41    	                ld      C,PSG_DAT       ; PSG data port
0C2D: ED79    	                out     (C),A           ; send new value for the mixer
0C2F: 3E03    	                ld      A,$03           ; three channels
0C31: 90      	                sub     B               ; find current channel (0->A, 1->B, 2->C)
0C32: 87      	                add     A,A             ; and find first register (A=>0, B=>2, C=>4)
0C33: 0E40    	                ld      C,PSG_REG       ; PSG register selector port
0C35: ED79    	                out     (C),A           ; select first tone register of channel
0C37: 2E00    	                ld      L,$00           ; value 0 into L
0C39: 0E41    	                ld      C,PSG_DAT       ; PSG data selector port
0C3B: ED69    	                out     (C),L           ; write 0 into register
0C3D: 0E40    	                ld      C,PSG_REG       ; PSG register selector port
0C3F: 3C      	                inc     A               ; next tone register
0C40: ED79    	                out     (C),A           ; select second tone register of channel
0C42: 0E41    	                ld      C,PSG_DAT       ; PSG data selector port
0C44: ED69    	                out     (C),L           ; write 0 into register
0C46: DD23    	CNTCHKSND:      inc     IX              ; set for...
0C48: DD23    	                inc     IX              ; ...next channel...
0C4A: CB24    	                sla     H               ; shift left H 1 bit
0C4C: 10BD    	                djnz    CHKSNDCH        ; repeat for 3 channels
0C4E: DDE1    	                pop     IX              ; restore IX
0C50: C9      	                ret                     ; return to caller
              	
              	; read a specific row of the keyboard matrix, set by A
              	; return read into A
0C51: C5      	READKBLN:       push    BC
0C52: 060F    	                ld      B,$0F           ; reg #15
0C54: 0E40    	                ld      C,PSG_REG       ; PSG register port
0C56: ED41    	                out     (C),B           ; select reg #15
0C58: 0E41    	                ld      C,PSG_DAT       ; PSG data port
0C5A: ED79    	                out     (C),A           ; activate the row
0C5C: 060E    	                ld      B,$0E           ; register #14 (port B)
0C5E: 0E40    	                ld      C,PSG_REG       ; PSG register port
0C60: ED41    	                out     (C),B           ; select reg. 14 (port B)
0C62: ED78    	                in      A,(C)           ; read register #14
0C64: C1      	                pop     BC
0C65: C9      	                ret
              	
              	; read the keyboard matrix to look for a key pressure
0C66: 0E40    	KEYBOARD:       ld      C,PSG_REG       ; PSG register port
0C68: 0607    	                ld      B,$07           ; set register #7...
0C6A: ED41    	                out     (C),B           ; ...to work with
0C6C: ED78    	                in      A,(C)           ; read register #7
0C6E: CBFF    	                set     7,A             ; port A set to output
0C70: CBB7    	                res     6,A             ; port B set to input
0C72: ED41    	                out     (C),B           ; set register #7
0C74: 0E41    	                ld      C,PSG_DAT       ; PSG data port
0C76: ED79    	                out     (C),A           ; set I/O ports w/o altering the rest of the mixer
              	                ; check special keys (SHIFT/ALT/CTRL)
0C78: 3EFD    	                ld      A,%11111101     ; select SHIFT row
0C7A: CD510C  	                call    READKBLN        ; read row
0C7D: CB5F    	                bit     3,A             ; test if SHIFT key is pressed (4th bit is reset)
0C7F: 2005    	                jr      NZ,CHECKALT     ; no, so go on
0C81: 212D82  	                ld      HL,CONTROLKEYS  ; control key flags
0C84: 3601    	                ld      (HL),%00000001  ; set SHIFT flag, reset CTRL & ALT flags (currently multiply control keys are NOT supported)
0C86: 3EFE    	CHECKALT:       ld      A,%11111110     ; select ALT row
0C88: CD510C  	                call    READKBLN        ; read ALT row
0C8B: CB6F    	                bit     5,A             ; test if ALT key is pressed (5th bit is reset)
0C8D: 2005    	                jr      NZ,CHECKCTRL    ; no, so go on
0C8F: 212D82  	                ld      HL,CONTROLKEYS  ; control key flags
0C92: 3604    	                ld      (HL),%00000100  ; set ALT flag, reset SHIFT & CTRL flag (currently multiply control keys are NOT supported)
0C94: 3EFE    	CHECKCTRL:      ld      A,%11111110     ; select CTRL row
0C96: CD510C  	                call    READKBLN        ; read CTRL row
0C99: CB57    	                bit     2,A             ; test if CTRL key is pressed (3rd bit is reset)
0C9B: 2005    	                jr      NZ,CHECKKBD     ; no, so make a normal reading
0C9D: 212D82  	                ld      HL,CONTROLKEYS  ; control key flags
0CA0: 3602    	                ld      (HL),%00000010  ; set CTRL flag, reset SHIFT & ALT flags (currently multiply control keys are NOT supported)
0CA2: 0608    	CHECKKBD:       ld      B,$08           ; 8 lines
0CA4: 3E7F    	                ld      A,%01111111     ; start from the last line of the matrix
0CA6: 160F    	RPTKBDRD:       ld      D,$0F           ; register #14 (port A)
0CA8: 0E40    	                ld      C,PSG_REG       ; PSG register port
0CAA: ED51    	                out     (C),D           ; select reg. #14
0CAC: 0E41    	                ld      C,PSG_DAT       ; PSG data port
0CAE: ED79    	                out     (C),A           ; activate 1 line (active line is grounded, i.e. with a LOW signal)
0CB0: 5F      	                ld      E,A             ; save current line into E
0CB1: 160E    	                ld      D,$0E           ; register #15 (port B)
0CB3: 0E40    	                ld      C,PSG_REG       ; PSG register port
0CB5: ED51    	                out     (C),D           ; select reg. 15 (port B)
0CB7: 00      	                nop
0CB8: ED78    	                in      A,(C)           ; read register #15
0CBA: FEFF    	                cp      $FF             ; is there any line set to 0?
0CBC: 282E    	                jr      Z,NOKEYPRSD     ; no, go to the next row
              	                ; check control keys
0CBE: 322A82  	                ld      (KBTMP),A       ; yes, check if a control key was pressed. First, store current row
0CC1: 78      	                ld      A,B             ; copy current row (B) into A
0CC2: FE02    	                cp      $02             ; is it the row of the SHIFT?
0CC4: 200F    	                jr      NZ,TESTALT      ; no, continue checking the other control keys
0CC6: 3A2A82  	                ld      A,(KBTMP)       ; yes, retrieve current row data
0CC9: CB5F    	                bit     3,A             ; check SHIFT bit line
0CCB: 202E    	                jr      NZ,FINDKEY      ; no SHIFT, continue checking
0CCD: CBDF    	                set     3,A             ; yes, it's the SHIFT. So remove SHIFT bit
0CCF: FEFF    	                cp      $FF             ; after deleting the SHIFT bit, is there any other bit selected?
0CD1: 2028    	                jr      NZ,FINDKEY      ; yes, go to check which one
0CD3: 1817    	                jr      NOKEYPRSD       ; no, go to next row        
0CD5: FE01    	TESTALT:        cp      $01             ; is it the line of ALT & CTRL?
0CD7: 3A2A82  	                ld      A,(KBTMP)       ; retrieve current row data
0CDA: 201F    	                jr      NZ,FINDKEY      ; no, continue
0CDC: CB6F    	                bit     5,A             ; yes, check ALT bit line
0CDE: 2002    	                jr      NZ,TESTCTRL     ; no ALT, continue checking
0CE0: CBEF    	                set     5,A             ; yes, it's the ALT. So remove ALT bit
0CE2: CB57    	TESTCTRL:       bit     2,A             ; check CTRL bit line
0CE4: 2002    	                jr      NZ,ENDCTRLCK    ; no CTRL, continue checking
0CE6: CBD7    	                set     2,A             ; delete CTRL bit flag
0CE8: FEFF    	ENDCTRLCK:      cp      $FF             ; after deleting the ALT & CTRL bits, is there any other bit selected?
0CEA: 200F    	                jr      NZ,FINDKEY      ; yes, go to check which one
0CEC: 7B      	NOKEYPRSD:      ld      A,E             ; no key pressed, load current output port
0CED: 0F      	                rrca                    ; rotate right by 1
0CEE: 10B6    	                djnz    RPTKBDRD        ; repeat for 8 lines
0CF0: AF      	                xor     A               ; if exit from here, no key has been pressed...
0CF1: 322C82  	                ld      (LASTKEYPRSD),A ; ...so reset the last key cell...
0CF4: 322D82  	                ld      (CONTROLKEYS),A ; ...reset contro key flags...
0CF7: 322982  	                ld      (KBDNPT),A      ; ...no input from keyboard...
0CFA: C9      	                ret                     ; ...and leave
0CFB: 1EFF    	FINDKEY:        ld      E,$FF           ; counter
0CFD: 1C      	CHKLN:          inc     E               ; E goes from 0 to 7
0CFE: CB3F    	                srl     A               ; is the first bit reset? (we're looking for a "0", meaning grounded line)
0D00: 38FB    	                jr      C,CHKLN         ; no, check next bit
0D02: 3A2D82  	                ld      A,(CONTROLKEYS) ; load control key flags
0D05: 21D00D  	                ld      HL,KBMAP        ; normal keymap
0D08: FE01    	                cp      $01             ; SHIFT flag?
0D0A: 2005    	                jr      NZ,CHKCTRL      ; no, jump over
0D0C: 21100E  	                ld      HL,KBMAP_SFT    ; SHIFT keymap
0D0F: 1810    	                jr      LOADMAP         ; and load it
0D11: FE02    	CHKCTRL:        cp      $02             ; CTRL flag?
0D13: 2005    	                jr      NZ,CHKALT       ; no, jump over
0D15: 21900E  	                ld      HL,KBMAP_CTRL   ; CTRL map
0D18: 1807    	                jr      LOADMAP         ; and load it
0D1A: FE04    	CHKALT:         cp      $04             ; ALT flag?
0D1C: 2003    	                jr      NZ,LOADMAP      ; no, check over
0D1E: 21500E  	                ld      HL,KBMAP_ALT    ; ALT map
0D21: 05      	LOADMAP:        dec     B               ; decrement row # (rows go from 0 to 7)
0D22: 48      	                ld      C,B             ; move B into C and...
0D23: CB21    	                sla     C               ; ...multiply it...
0D25: CB21    	                sla     C               ; ...by 8 to find...
0D27: CB21    	                sla     C               ; ...the current row into the matrix
0D29: 0600    	                ld      B,$00           ; reset B
0D2B: 09      	                add     HL,BC           ; find the address of the current row
0D2C: 50      	                ld      D,B             ; reset D
0D2D: 19      	                add     HL,DE           ; find the current column
0D2E: 3A2C82  	                ld      A,(LASTKEYPRSD) ; load the last key pressed
0D31: BE      	                cp      (HL)            ; is it the same key?
0D32: 2847    	                jr      Z,LVKBRDCHK     ; yes, so do nothing
0D34: 7E      	                ld      A,(HL)          ; no, load it...
0D35: 322C82  	                ld      (LASTKEYPRSD),A ; ...store it...
0D38: 322B82  	                ld      (TMPKEYBFR),A   ; ...insert it into the INKEY buffer...
0D3B: 32EC81  	                ld      (CHR4VID),A     ; ...and store char for video
0D3E: FE03    	                cp      CTRLC           ; is it RUN/STOP?
0D40: 2005    	                jr      NZ,CNTKBCK      ; no, jump over
0D42: CD3601  	                call    CHARINTOBFR     ; yes, send directly to buffer and...
0D45: 1830    	                jr      LVKBRDCHK2      ; ...leave
0D47: 010008  	CNTKBCK:        ld      BC,$0800        ; 8 FN keys (B), FN key number (C)
0D4A: 21C80D  	                ld      HL,FNKEYSORD    ; FN keys codes
0D4D: BE      	CHKFNK:         cp      (HL)            ; is it an FN key?
0D4E: CA7C0D  	                jp      Z,PRNTFNKEY     ; yes, jump over
0D51: 0C      	                inc     C               ; next FN key
0D52: 23      	                inc     HL              ; next FN key code
0D53: 10F8    	                djnz    CHKFNK          ; continue for 8 FN keys
0D55: 3E01    	SNDKEYTOBFR:    ld      A,$01           ; normal key - set input flag
0D57: 322982  	                ld      (KBDNPT),A      ; to keyboard
0D5A: 3AEB81  	                ld      A,(PRNTVIDEO)   ; load status of print-on-video
0D5D: B7      	                or      A               ; is the print-on-video disabled?
0D5E: CA670D  	                jp      Z,PUTCHRBUF     ; yes, so send char to input buffer
0D61: 3AE981  	                ld      A,(CRSR_STATE)  ; check cursor state
0D64: B7      	                or      A               ; is it 0 (cursor OFF)?
0D65: 200D    	                jr      NZ,PNT2VD       ; no, print on screen
0D67: AF      	PUTCHRBUF:      xor     A
0D68: 322982  	                ld      (KBDNPT),A      ; if send to input buffer, set RETURN as from BASIC
0D6B: 3A2B82  	                ld      A,(TMPKEYBFR)   ; retrieve char
0D6E: CD3601  	                call    CHARINTOBFR     ; cursor off, so send char to buffer...
0D71: C3770D  	                jp      LVKBRDCHK2      ; ...and leave
0D74: CDAE06  	PNT2VD:         call    CHAR2VID        ; send char to video
0D77: AF      	LVKBRDCHK2:     xor     A
0D78: 322D82  	                ld      (CONTROLKEYS),A ; reset control key flags
0D7B: C9      	LVKBRDCHK:      ret                     ; return to caller: the current key code is into TMPKEYBFR    
              	                ; manage FN keys          
0D7C: 57      	PRNTFNKEY:      ld      D,A             ; copy A into D
0D7D: 2AAF80  	                ld      HL,(LINEAT)     ; Get current line number
0D80: 23      	                inc     HL              ; -1 means direct statement
0D81: 7C      	                ld      A,H
0D82: B5      	                or      L
0D83: 7A      	                ld      A,D             ; retrieve char
0D84: 20CF    	                jr      NZ,SNDKEYTOBFR  ; indirect mode - just send FN key code to buffer
0D86: 79      	                ld      A,C             ; direct mode, so print text - first, get FN key number
0D87: 87      	                add     A,A
0D88: 87      	                add     A,A
0D89: 87      	                add     A,A
0D8A: 87      	                add     A,A             ; FN key number * 16
0D8B: 4F      	                ld      C,A             ; move it into C
0D8C: 0600    	                ld      B,$00           ; reset B, to get offset
0D8E: 21B380  	                ld      HL,FNKEYS       ; load address of FN keys texts
0D91: 09      	                add     HL,BC           ; get correct text address
0D92: 0610    	                ld      B,$10           ; 16 chars
0D94: 7E      	LDFNKEYCHR:     ld      A,(HL)          ; load char
0D95: A7      	                and     A               ; null char?
0D96: CA770D  	                jp      Z,LVKBRDCHK2    ; yes, so leave
0D99: 57      	                ld      D,A             ; pass char into D
0D9A: 3AEB81  	                ld      A,(PRNTVIDEO)   ; load status of print-on-video
0D9D: B7      	                or      A               ; is the print-on-video disabled?
0D9E: CAAE0D  	                jp      Z,PUTCHRBUF1    ; yes, so send char to input buffer
0DA1: 3AE981  	                ld      A,(CRSR_STATE)  ; check cursor state
0DA4: B7      	                or      A               ; is it 0 (cursor OFF)?
0DA5: C4BB0D  	                call    NZ,PRNTFNK      ; no, print on screen
0DA8: 23      	CNTFNK:         inc     HL              ; next char
0DA9: 10E9    	                djnz    LDFNKEYCHR      ; repeat for max. 16 chars
0DAB: C3770D  	                jp      LVKBRDCHK2      ; leave
0DAE: AF      	PUTCHRBUF1:     xor     A               ; if send to input buffer,... 
0DAF: 322982  	                ld      (KBDNPT),A      ; ...set input as from BASIC
0DB2: 7A      	                ld      A,D             ; retrieve char
0DB3: E5      	                push    HL              ; store HL
0DB4: CD3601  	                call    CHARINTOBFR     ; cursor off, so send char to buffer...
0DB7: E1      	                pop     HL              ; retrieve HL
0DB8: C3A80D  	                jp      CNTFNK          ; jump over
0DBB: 7A      	PRNTFNK:        ld      A,D             ; recover char
0DBC: 32EC81  	                ld      (CHR4VID),A     ; store char for printing
0DBF: 3E01    	                ld      A,$01           ; normal key - set input flag
0DC1: 322982  	                ld      (KBDNPT),A      ; to keyboard
0DC4: CDAE06  	                call    CHAR2VID        ; print on screen
0DC7: C9      	                ret                     ; return to caller
              	
              	
              	;-----------------------------------------------------------------------
0DC8: 01020405	FNKEYSORD:      defb 1,2,4,5,6,22,23,24                 ; order of FN Keys
0DCC: 06161718	
              	;-----------------------------------------------------------------------
              	; key codes
0DD0: 31190E03	KBMAP:          defb '1',25,14,3,' ',16,'q','2'         ; 25=HOME  14=CTRL  3=RUN/STOP 16=C=
0DD4: 20107132	
0DD8: 33776114	                defb '3','w','a',20,'z','s','e','4'     ; 20=SHIFT
0DDC: 7A736534	
0DE0: 35726478	                defb '5','r','d','x','c','f','t','6'
0DE4: 63667436	
0DE8: 37796776	                defb '7','y','g','v','b','h','u','8'
0DEC: 62687538	
0DF0: 39696A6E	                defb '9','i','j','n','m','k','o','0'
0DF4: 6D6B6F30	
0DF8: 1F706C2C	                defb 31,'p','l',',','.',':','-',30      ; 31=CURSOR DOWN  30=CURSOR UP
0DFC: 2E3A2D1E	
0E00: 1C2A3B2F	                defb 28,'*',';','/',27,'=','+',29       ; 28=CURSOR LEFT  27=ESCAPE  29=CURSOR RIGHT
0E04: 1B3D2B1D	
0E08: 080DFC40	                defb 8,13,252,'@',1,2,4,24              ; 8=DEL(backspace)  13=RETURN  252=£  1=F1  2=F2  4=F3  24=HELP
0E0C: 01020418	
              	
              	; shifted codes - not all the keys have the shifted version
0E10: 210C0E03	KBMAP_SFT:      defb '!',12,14,3,' ',16,'Q',34          ; 12=CLEAR  14=CTRL  3=RUN/STOP 16=C=   34="
0E14: 20105122	
0E18: 23574114	                defb '#','W','A',20,'Z','S','E','$'     ; 20=SHIFT
0E1C: 5A534524	
0E20: 25524458	                defb '%','R','D','X','C','F','T','&'
0E24: 43465426	
0E28: 27594756	                defb 39,'Y','G','V','B','H','U','('     ; 39='
0E2C: 42485528	
0E30: 29494A4E	                defb ')','I','J','N','M','K','O',94     ; 94=^
0E34: 4D4B4F5E	
0E38: 1F504C3C	                defb 31,'P','L','<','>','[','_',30      ; 31=CURSOR DOWN  30=CURSOR UP
0E3C: 3E5B5F1E	
0E40: 1C2A5D3F	                defb 28,'*',']','?',27,198,'+',29       ; 28=CURSOR LEFT  27=ESCAPE  29=CURSOR RIGHT
0E44: 1BC62B1D	
0E48: 080DD340	                defb 8,13,211,'@',5,6,22,23             ; 211=€  5=F4  6=F5  22=F6  23=F7
0E4C: 05061617	
              	
              	; ALT (C=) codes - not all the keys have the alt-ed version
0E50: 310C0E03	KBMAP_ALT:      defb '1',12,14,3,' ',16,222,196         ; 12=CLEAR  14=CTRL  3=RUN/STOP  16=C=  34="
0E54: 2010DEC4	
0E58: 33DD8514	                defb '3',221,133,20,131,130,165,'4'     ; 20=SHIFT
0E5C: 8382A534	
0E60: 35A2A684	                defb '5',162,166,132,157,163,168,'6'
0E64: 9DA3A836	
0E68: 37ABA9A1	                defb '7',171,169,161,158,172,213,'8'    ;
0E6C: 9EACD538	
0E70: 39D6D89F	                defb '9',214,216,159,160,215,135,195    ;
0E74: A0D787C3	
0E78: 1F888AC1	                defb 31,136,138,193,192,123,144,30      ; 31=CURSOR DOWN  123={  30=CURSOR UP
0E7C: C07B901E	
0E80: 1C8F7DFE	                defb 28,143,125,254,27,209,148,29       ; 28=CURSOR LEFT  125=}  27=ESCAPE  29=CURSOR RIGHT
0E84: 1BD1941D	
0E88: 080DE089	                defb 8,13,224,137,5,6,22,23             ; 8=DEL(backspace)  13=RETURN  252=£  5=F4  6=F5  22=F6  23=F7
0E8C: 05061617	
              	
              	; CTRL codes - not all the keys have the control-ed version
0E90: 31190E03	KBMAP_CTRL:     defb '1',25,14,3,' ',16,154,'2'         ; 25=HOME  14=CTRL  3=RUN/STOP  16=C=
0E94: 20109A32	
0E98: 339C9514	                defb '3',156,149,20,152,150,153,'4'     ; 20=SHIFT
0E9C: 98969934	
0EA0: 359BB097	                defb '5',155,176,151,177,175,165,'6'
0EA4: B1AFA536	
0EA8: 37A6A8B2	                defb '7',166,168,178,179,169,167,'8'
0EAC: B3A9A738	
0EB0: 39B8AAAC	                defb '9',184,170,172,171,181,164,'0'
0EB4: ABB5A430	
0EB8: 1FA3AD2C	                defb 31,163,173,',','.',':',186,30      ; 31=CURSOR DOWN  30=CURSOR UP
0EBC: 2E3ABA1E	
0EC0: 1CE13B2F	                defb 28,225,';','/',27,212,185,29       ; 28=CURSOR LEFT  27=ESCAPE  212=π  29=CURSOR RIGHT
0EC4: 1BD4B91D	
0EC8: 080DBDA2	                defb 8,13,189,162,1,2,4,24              ; 8=DEL(backspace)  13=RETURN  252=£  1=F1  2=F2  4=F3  24=HELP; ------------------------------------------------------------------------------
0ECC: 01020418	
              	; LM80C BASIC - R3.13.3
              	; ------------------------------------------------------------------------------
              	; The following code is intended to be used with LM80C Z80-based computer
              	; designed by Leonardo Miliani. Code and computer schematics are released under
              	; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
              	; kind of warranty: you can use them at your own risk.
              	; You are free to use them for any non-commercial use: you are only asked to
              	; maintain the copyright notices, include this advice and the note to the 
              	; attribution of the original version to Leonardo Miliani, if you intend to
              	; redistribuite them.
              	; https://www.leonardomiliani.com
              	; 
              	; Please support me by visiting the following links:
              	; Main project page: https://www.leonardomiliani.com
              	; Schematics and code: https://github.com/leomil72/LM80C
              	; Videos about the computer: https://www.youtube.com/user/leomil72/videos
              	; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
              	; ------------------------------------------------------------------------------
              	; NASCOM BASIC versions:
              	; 4.7  - original version by NASCOM
              	; 4.7b - modified version by Grant Searle (additional commands & functions)
              	; 4.8  - modified by Leonardo Miliani (new commands/functions)
              	
              	
              	;------------------------------------------------------------------------------
              	;  B A S I C
              	;------------------------------------------------------------------------------
              	
              	; GENERAL EQUATES
              	
0000:         	NLLCR           equ     $00             ; null char (used as space/empty char in video prints)
0003:         	CTRLC           equ     $03             ; Control "C"
0007:         	CTRLG           equ     $07             ; Control "G"
0008:         	BKSP            equ     $08             ; Back space
000A:         	LF              equ     $0A             ; Line feed
000C:         	CS              equ     $0C             ; Clear screen
000D:         	CR              equ     $0D             ; Carriage return
000F:         	CTRLO           equ     $0F             ; Control "O"
0011:         	CTRLQ           equ     $11             ; Control "Q"
0012:         	CTRLR           equ     $12             ; Control "R"
0013:         	CTRLS           equ     $13             ; Control "S"
0015:         	CTRLU           equ     $15             ; Control "U"
0019:         	HOME            equ     $19             ; Home (cursor at 0,0)
001B:         	ESC             equ     $1B             ; Escape
0020:         	SPC             equ     $20             ; Space
007F:         	DEL             equ     $7F             ; Delete
              	; cursor ASCII codes
001C:         	CRSLFT          equ     $1C             ; cursor left
001D:         	CRSRGT          equ     $1D             ; cursor right
001E:         	CRSUP           equ     $1E             ; cursor up
001F:         	CRSDN           equ     $1F             ; cursor down
              	
              	
              	; BASIC WORK SPACE LOCATIONS
              	; BY STARTING FROM $805E THE INTERPRETER ALLOCATES THE FOLLOWING RAM CELLS
              	; TO STORE IMPORTANT VALUES USED FOR SOME SPECIFIC FUNCTIONS:
              	; THEY CAN BE VECTOR (ADDRESSES) FUNCTIONS, SYSTEM DATAS (I.E. VARIABLES)
              	; AND SO ON. THE FIRST CELLS ARE FILLED WITH VALUES STORED INTO ROM AT $(INITAB) ADDRESS
805E:         	WRKSPC          equ     basicStarted+$01; (3) BASIC Work space
8061:         	NMIUSR          equ     WRKSPC+$03      ; (3) NMI exit point routine
8064:         	USR             equ     NMIUSR+$03      ; (3) "USR (x)" jump  <-- in $8065/8066 the user can store the address of a specific machine language routine
8067:         	OUTSUB          equ     USR+$03         ; (1) "out p,n"
8068:         	OTPORT          equ     OUTSUB+$01      ; (2) Port (p)
806A:         	DIVSUP          equ     OTPORT+$02      ; (1) Division support routine
806B:         	DIV1            equ     DIVSUP+$01      ; (4) <- Values
806F:         	DIV2            equ     DIV1+$04        ; (4) <-   to
8073:         	DIV3            equ     DIV2+$04        ; (3) <-   be
8076:         	DIV4            equ     DIV3+$03        ; (2) <-inserted
8078:         	SEED            equ     DIV4+$02        ; (35) Random number seed  <-- starting address of a seed table
809B:         	LSTRND          equ     SEED+$23        ; (4) Last random number
809F:         	INPSUB          equ     LSTRND+$04      ; (1) #INP (x)" Routine
80A0:         	INPORT          equ     INPSUB+$01      ; (2) PORT (x)
80A2:         	LWIDTH          equ     INPORT+$02      ; (1) Terminal width
80A3:         	COMMAN          equ     LWIDTH+$01      ; (1) Width for commas
80A4:         	NULFLG          equ     COMMAN+$01      ; (1) Null after input byte flag
80A5:         	CTLOFG          equ     NULFLG+$01      ; (1) Control "O" flag
80A6:         	CHKSUM          equ     CTLOFG+$01      ; (2) Array load/save check sum
80A8:         	NMIFLG          equ     CHKSUM+$02      ; (1) Flag for NMI break routine
80A9:         	BRKFLG          equ     NMIFLG+$01      ; (1) Break flag
80AA:         	RINPUT          equ     BRKFLG+$01      ; (3) Input reflection
80AD:         	STRSPC          equ     RINPUT+$03      ; (2) Bottom of string space
80AF:         	LINEAT          equ     STRSPC+$02      ; (2) Current line number
80B1:         	HLPLN           equ     LINEAT+$02      ; (2) Current line with errors
80B3:         	FNKEYS          equ     HLPLN+$02       ; (128) text of FN keys
8133:         	BASTXT          equ     FNKEYS+$80      ; (3) Pointer to start of program   <-- actually this is the last value pre-filled by the firmware at startup
8136:         	BUFFER          equ     BASTXT+$03      ; (5) Input buffer
813B:         	STACK           equ     BUFFER+$05      ; (85) Initial stack
8190:         	CURPOS          equ     STACK+$55       ; (1) Character position on line
8191:         	LCRFLG          equ     CURPOS+$01      ; (1) Locate/Create flag
8192:         	TYPE            equ     LCRFLG+$01      ; (1) Data type flag
8193:         	DATFLG          equ     TYPE+$01        ; (1) Literal statement flag
8194:         	LSTRAM          equ     DATFLG+$01      ; (2) Last available RAM
8196:         	TMSTPT          equ     LSTRAM+$02      ; (2) Temporary string pointer
8198:         	TMSTPL          equ     TMSTPT+$02      ; (12) Temporary string pool
81A4:         	TMPSTR          equ     TMSTPL+$0C      ; (4) Temporary string
81A8:         	STRBOT          equ     TMPSTR+$04      ; (2) Bottom of string space
81AA:         	CUROPR          equ     STRBOT+$02      ; (2) Current operator in EVAL
81AC:         	LOOPST          equ     CUROPR+$02      ; (2) First statement of loop
81AE:         	DATLIN          equ     LOOPST+$02      ; (2) Line of current DATA item
81B0:         	FORFLG          equ     DATLIN+$02      ; (1) "FOR" loop flag
81B1:         	LSTBIN          equ     FORFLG+$01      ; (1) Last byte entered
81B2:         	READFG          equ     LSTBIN+$01      ; (1) Read/Input flag
81B3:         	BRKLIN          equ     READFG+$01      ; (2) Line of break
81B5:         	NXTOPR          equ     BRKLIN+$02      ; (2) Next operator in EVAL
81B7:         	ERRLIN          equ     NXTOPR+$02      ; (2) Line of error
81B9:         	CONTAD          equ     ERRLIN+$02      ; (2) Where to CONTinue
81BB:         	PROGND          equ     CONTAD+$02      ; (2) End of program
81BD:         	VAREND          equ     PROGND+$02      ; (2) End of variables
81BF:         	ARREND          equ     VAREND+$02      ; (2) End of arrays
81C1:         	NXTDAT          equ     ARREND+$02      ; (2) Next data item
81C3:         	FNRGNM          equ     NXTDAT+$02      ; (2) Name of FN argument
81C5:         	FNARG           equ     FNRGNM+$02      ; (4) FN argument value
81C9:         	FPREG           equ     FNARG+$04       ; (3) Floating point register
81CC:         	FPEXP           equ     FPREG+$03       ; (1) Floating point exponent
81CD:         	SGNRES          equ     FPEXP+$01       ; (1) Sign of result
81CE:         	TMRCNT          equ     SGNRES+$01      ; (4) TMR counter for 1/100 seconds
81D2:         	CTC0IV          equ     TMRCNT+$04      ; (3) CTC0 interrupt vector
81D5:         	CTC1IV          equ     CTC0IV+$03      ; (3) CTC1 interrupt vector
81D8:         	CTC2IV          equ     CTC1IV+$03      ; (3) CTC2 interrupt vector
81DB:         	CTC3IV          equ     CTC2IV+$03      ; (3) CTC3 interrupt vector
              	; - - - - - - - - - - - - - - - - - - -   VIDEO REGISTERS - FROM HERE...
81DE:         	SCR_SIZE_W      equ     CTC3IV+$03      ; (1) screen width (it can be either 40 chars or 32 chars/bytes)
81DF:         	SCR_SIZE_H      equ     SCR_SIZE_W+$01  ; (1) screen height (it can be 24/48/192: 24 for text, 48 for MC, 192 for graphics)
81E0:         	SCR_MODE        equ     SCR_SIZE_H+$01  ; (1) screen mode (0=text, 1=G1, 2=G2, 3=MC, 4=ExG2)
81E2:         	SCR_NAM_TB      equ     SCR_MODE+$02    ; (2) video name table address
81E4:         	SCR_CURS_X      equ     SCR_NAM_TB+$02  ; (1) cursor X
81E5:         	SCR_CURS_Y      equ     SCR_CURS_X+$01  ; (1) cursor Y
81E6:         	SCR_CUR_NX      equ     SCR_CURS_Y+$01  ; (1) new cursor X position
81E7:         	SCR_CUR_NY      equ     SCR_CUR_NX+$01  ; (1) new cursor Y position
81E8:         	SCR_ORG_CHR     equ     SCR_CUR_NY+$01  ; (1) original char positioned under the cursor
81E9:         	CRSR_STATE      equ     SCR_ORG_CHR+$01 ; (1) state of cursor (1=on, 0=off)
81EA:         	LSTCSRSTA       equ     CRSR_STATE+$01  ; (1) last cursor state
81EB:         	PRNTVIDEO       equ     LSTCSRSTA+$01   ; (1) print on video buffer (1=on / 0=off) set to off on graphic only modes
81EC:         	CHR4VID         equ     PRNTVIDEO+$01   ; (1) char for video buffer
81ED:         	FRGNDCLR        equ     CHR4VID+$01     ; (1) foreground color as set by SCREEN or COLOR commands
81EE:         	BKGNDCLR        equ     FRGNDCLR+$01    ; (1) background color as set by SCREEN or COLOR commands
81EF:         	TMPBFR1         equ     BKGNDCLR+$01    ; (2) word for general purposes use (temp. buffer for 1 or 2 bytes)
81F1:         	TMPBFR2         equ     TMPBFR1+$02     ; (2) word for general purposes use (temp. buffer for 1 or 2 bytes)
81F3:         	TMPBFR3         equ     TMPBFR2+$02     ; (2) word for general purposes use (temp. buffer for 1 or 2 bytes)
81F5:         	TMPBFR4         equ     TMPBFR3+$02     ; (2) word for general purposes use (temp. buffer for 1 or 2 bytes)
81F7:         	VIDEOBUFF       equ     TMPBFR4+$02     ; (40) buffer used for video scrolling and other purposes
821F:         	VIDTMP1         equ     VIDEOBUFF+$28   ; (2) temporary video word
8221:         	VIDTMP2         equ     VIDTMP1+$02     ; (2) temporary video word
              	; - - - - - - - - - - - - - - - - - - -   ...TO HERE. DO NOT ADD ANYTHING RELATED TO VPD OUT OF THIS RANGE,
              	                                        ; OTHERWISE YOU WILL HAVE TO CHECK THE POINTER IN "CLR_RAM_REG" FUNCTION
              	; - - - - - - - - - - - - - - - - - - -   SOUND & KEYBOARD REGISTERS - FROM HERE...
8223:         	CHASNDDTN       equ     VIDTMP2+$02     ; (2) sound Ch.A duration (1/100s)
8225:         	CHBSNDDTN       equ     CHASNDDTN+$02   ; (2) sound Ch.B duration (1/100s)
8227:         	CHCSNDDTN       equ     CHBSNDDTN+$02   ; (2) sound Ch.C duration (1/100s)
8229:         	KBDNPT          equ     CHCSNDDTN+$02   ; (1) temp cell used to flag if input comes from keyboard
822A:         	KBTMP           equ     KBDNPT+$01      ; (1) temp cell used by keyboard scanner
822B:         	TMPKEYBFR       equ     KBTMP+$01       ; (1) temp buffer for last key pressed
822C:         	LASTKEYPRSD     equ     TMPKEYBFR+$01   ; (1) last key code pressed
822D:         	CONTROLKEYS     equ     LASTKEYPRSD+$01 ; (1) flags for control keys (bit#0=SHIFT; bit#1=CTRL; bit#2=C=)
              	; - - - - - - - - - - - - - - - - - - -   ...TO HERE. DO NOT ADD ANYTHING RELATED TO PSG OUT OF THIS RANGE,
              	                                        ; OTHERWISE YOU WILL HAVE TO CHANGE THE POINTER IN "initPSG" FUNCTION
822E:         	SERIALS_EN      equ     CONTROLKEYS+$01 ; (1) serial ports status: bit 0 for Port1(A), bit 1 for Port2(B): 0=OFF, 1=ON
822F:         	SERABITS        equ     SERIALS_EN+$01  ; (1) serial port A data bits
8230:         	PBUFF           equ     SERABITS+$01    ; (13) Number print buffer
823D:         	MULVAL          equ     PBUFF+$0D       ; (3) Multiplier
8240:         	PROGST          equ     MULVAL+$03      ; (100) Start of program text area
82A4:         	STLOOK          equ     PROGST+$64      ; Start of memory test
              	
              	; BASIC ERROR CODE VALUES
              	; These values act as an offset to point to the error message into the error table
              	; must be incremented by 2 because they point to a word address jump
0000:         	NF              equ     $00             ; NEXT without FOR
0002:         	SN              equ     $02             ; Syntax error
0004:         	RG              equ     $04             ; RETURN without GOSUB
0006:         	OD              equ     $06             ; Out of DATA
0008:         	FC              equ     $08             ; Function call error
000A:         	OV              equ     $0A             ; Overflow
000C:         	OM              equ     $0C             ; Out of memory
000E:         	UL              equ     $0E             ; Undefined line number
0010:         	BS              equ     $10             ; Bad subscript
0012:         	DD              equ     $12             ; Re-Dimensioned array
0014:         	DZ              equ     $14             ; Division by zero (/0)
0016:         	ID              equ     $16             ; Illegal direct
0018:         	TM              equ     $18             ; Type mis-match
001A:         	OS              equ     $1A             ; Out of string space
001C:         	LS              equ     $1C             ; String too long
001E:         	ST              equ     $1E             ; String formula too complex
0020:         	CN              equ     $20             ; Can't continue
0022:         	UF              equ     $22             ; Undefined FN function
0024:         	MO              equ     $24             ; Missing operand
0026:         	HX              equ     $26             ; HEX error
0028:         	BN              equ     $28             ; BIN error
002A:         	GM              equ     $2A             ; No Graphics Mode
002C:         	SC              equ     $2C             ; Serial configuration
002E:         	SA              equ     $2E             ; Serial port already open
0030:         	HP              equ     $30             ; HELP call
              	
0ED0: C3D60E  	COLD:   jp      STARTB          ; Jump for cold start
0ED3: C36E0F  	WARM:   jp      WARMST          ; Jump for warm start
              	
0ED6: C3DD0E  	STARTB: jp      CSTART          ; Jump to initialise
0ED9: F71A    	        defw    DEINT           ; Get integer -32768 to 32767
0EDB: A022    	        defw    ABPASS          ; Return integer in AB
0EDD: 215E80  	CSTART: ld      HL,WRKSPC       ; Start of workspace RAM
0EE0: F9      	        ld      SP,HL           ; Set up a temporary stack
0EE1: C34A3C  	        jp      INITST          ; Go to initialise
              	
0EE4: 21D713  	INIT:   ld      HL,INITAB       ; Initialise workspace
0EE7: 01DA00  	        ld      BC,INITBE-INITAB+3; Bytes to copy
0EEA: 115E80  	        ld      DE,WRKSPC       ; Into workspace RAM
0EED: EDB0    	        ldir                    ; Copy data
0EEF: EB      	        ex      DE,HL           ; Copy DE into HL
0EF0: F9      	        ld      SP,HL           ; Temporary stack
0EF1: CD8816  	        call    CLREG           ; Clear registers and stack
0EF4: CDFA1C  	        call    PRNTCRLF        ; Output CRLF
0EF7: 328F81  	        ld      (BUFFER+88+1),A ; Mark end of buffer
0EFA: 324082  	        ld      (PROGST),A      ; Initialise program area
0EFD: 1810    	        jr      MNOASK          ; usually, don't ask for memory top (only when there are errors)
0EFF: 21B80F  	MSIZE:  ld      HL,MEMMSG       ; Point to message
0F02: CDBE23  	        call    PRS             ; Output "Memory size"
0F05: CDA516  	        call    PROMPT          ; Get input with '?'
0F08: CD411A  	        call    GETCHR          ; Get next character
0F0B: B7      	        or      A               ; Set flags
0F0C: C2240F  	        jp      NZ,TSTMEM       ; If number - Test if RAM there
0F0F: 21A482  	MNOASK: ld      HL,STLOOK       ; Point to start of RAM
0F12: 23      	MLOOP:  inc     HL              ; Next byte
0F13: 7C      	        ld      A,H             ; Above address FFFF ?
0F14: B5      	        or      L
0F15: CA360F  	        jp      Z,SETTOP        ; Yes - 64K RAM
0F18: 7E      	        ld      A,(HL)          ; Get contents
0F19: 47      	        ld      B,A             ; Save it
0F1A: 2F      	        cpl                     ; Flip all bits
0F1B: 77      	        ld      (HL),A          ; Put it back
0F1C: BE      	        cp      (HL)            ; RAM there if same
0F1D: 70      	        ld      (HL),B          ; Restore old contents
0F1E: CA120F  	        jp      Z,MLOOP         ; If RAM - test next byte
0F21: C3360F  	        jp      SETTOP          ; Top of RAM found
              	
0F24: CD111B  	TSTMEM: call    ATOH            ; Get high memory into DE
0F27: B7      	        or      A               ; Set flags on last byte
0F28: C23C15  	        jp      NZ,SNERR        ; ?SN Error if bad character
0F2B: EB      	        ex      DE,HL           ; Address into HL
0F2C: 2B      	        dec     HL              ; Back one byte
0F2D: 3ED9    	        ld      A,%11011001     ; Test byte
0F2F: 46      	        ld      B,(HL)          ; Get old contents
0F30: 77      	        ld      (HL),A          ; Load test byte
0F31: BE      	        cp      (HL)            ; RAM there if same
0F32: 70      	        ld      (HL),B          ; Restore old contents
0F33: C2FF0E  	        jp      NZ,MSIZE        ; Ask again if no RAM
              	
0F36: 2B      	SETTOP: dec     HL              ; Back one byte
0F37: 11A382  	        ld      DE,STLOOK-1     ; See if enough RAM
0F3A: CD1818  	        call    CPDEHL          ; Compare DE with HL
0F3D: DAFF0E  	        jp      C,MSIZE         ; Ask again if not enough RAM
0F40: 119CFF  	        ld      DE,0-100        ; 100 Bytes string space
0F43: 229481  	        ld      (LSTRAM),HL     ; Save last available RAM
0F46: 19      	        add     HL,DE           ; Allocate string space
0F47: 22AD80  	        ld      (STRSPC),HL     ; Save string space
0F4A: CD6316  	        call    CLRPTR          ; Clear program area
0F4D: 2AAD80  	        ld      HL,(STRSPC)     ; Get end of memory
0F50: 11EFFF  	        ld      DE,0-17         ; Offset for free bytes
0F53: 19      	        add     HL,DE           ; Adjust HL
0F54: 114082  	        ld      DE,PROGST       ; Start of program text
0F57: 7D      	        ld      A,L             ; Get LSB
0F58: 93      	        sub     E               ; Adjust it
0F59: 6F      	        ld      L,A             ; Re-save
0F5A: 7C      	        ld      A,H             ; Get MSB
0F5B: 9A      	        sbc     A,D             ; Adjust it
0F5C: 67      	        ld      H,A             ; Re-save
0F5D: E5      	        push    HL              ; Save bytes free
0F5E: 21870F  	        ld      HL,SIGNON       ; Sign-on message
0F61: CDBE23  	        call    PRS             ; Output string
0F64: E1      	        pop     HL              ; Get bytes free back
0F65: CD5E2E  	        call    PRNTHL          ; Output amount of free memory
0F68: 217A0F  	        ld      HL,BFREE        ; " Bytes free" message
0F6B: CDBE23  	        call    PRS             ; Output string
              	
0F6E: 313B81  	WARMST: ld      SP,STACK        ; Temporary stack
0F71: CD8816  	BRKRET: call    CLREG           ; Clear registers and stack
0F74: CD3808  	        call    CURSOR_ON       ; enable cursor
0F77: C39615  	        jp      PRNTOK          ; Go to get command line
              	
0F7A: 20427974	BFREE:  defb    " Bytes free",CR,0
0F7E: 65732066	
0F82: 7265650D	
0F86: 00      	
              	
0F87: 5A383020	SIGNON: defb    "Z80 BASIC Ver 4.8",CR
0F8B: 42415349	
0F8F: 43205665	
0F93: 7220342E	
0F97: 380D    	
0F99: 436F7079	        defb    "Copyright ",251," 1978"
0F9D: 72696768	
0FA1: 7420FB20	
0FA5: 31393738	
0FA9: 20627920	        defb    " by Microsoft",CR,0
0FAD: 4D696372	
0FB1: 6F736F66	
0FB5: 740D00  	
              	
0FB8: 4D656D6F	MEMMSG: defb    "Memory top",0
0FBC: 72792074	
0FC0: 6F7000  	
              	
              	; The following list reports all the functions supported by the interpreter.
              	; To add a custom function, the user must first insert the reserved word here,
              	; then into the list of the reserved words below, and finally must increment the
              	; ZSGN token value and all the following ones after ZSGN by 1 for every added
              	; function.
              	
              	; FUNCTION ADDRESS TABLE (this is a sort of offset table)
              	; this list must be coherent with the tokens' functions list. This means that every
              	; entry here must have the corresponding entry in the tokens list.
0FC3: D32C    	FNCTAB: defw    SGN
0FC5: 6822    	        defw    TMR         ; added by Leonardo Miliani
0FC7: 972D    	        defw    INT
0FC9: E92C    	        defw    ABS
0FCB: 6480    	        defw    USR
0FCD: 7E22    	        defw    FRE
0FCF: F926    	        defw    INP
0FD1: AC22    	        defw    POS
0FD3: 5D2F    	        defw    SQR
0FD5: 3C30    	        defw    RND
0FD7: 272B    	        defw    LOG
0FD9: AB2F    	        defw    EXP
0FDB: B130    	        defw    COS
0FDD: B730    	        defw    SIN
0FDF: 1831    	        defw    TAN
0FE1: 2D31    	        defw    ATN
0FE3: D527    	        defw    PEEK
0FE5: 9831    	        defw    DEEK
0FE7: DC27    	        defw    VPEEK       ; added by Leonardo Miliani
0FE9: AC29    	        defw    VSTAT       ; added by Leonardo Miliani
0FEB: B729    	        defw    SSTAT       ; added by Leonardo Miliani
0FED: CB29    	        defw    INKEY       ; added by Leonardo Miliani
0FEF: FF33    	        defw    POINT       ; added by Leonardo Miliani
0FF1: 9025    	        defw    INSTR       ; added by Leonardo Miliani
0FF3: 3025    	        defw    LEN
0FF5: 4823    	        defw    STR
0FF7: C026    	        defw    VAL
0FF9: 3F25    	        defw    ASC
0FFB: 5025    	        defw    CHR
0FFD: 493B    	        defw    HEX         ; added by Grant Searle
0FFF: DA3B    	        defw    BIN         ; added by Grant Searle
1001: 6025    	        defw    LEFT
1003: 8626    	        defw    RIGHT
1005: 9026    	        defw    MID
              	
              	; RESERVED WORD LIST
              	; Here are all the reserved words used by the interpreter
              	; To add custom functions/commands, the user must insert the keyword
              	; in this list, following the schematic
1007: C54E44  	WORDS:  defb    'E'+$80,"ND"            ; from here the list contains the COMMANDS
100A: C64F52  	        defb    'F'+$80,"OR"
100D: CE455854	        defb    'N'+$80,"EXT"
1011: C4415441	        defb    'D'+$80,"ATA"
1015: C94E5055	        defb    'I'+$80,"NPUT"
1019: 54      	
101A: C4494D  	        defb    'D'+$80,"IM"
101D: D2454144	        defb    'R'+$80,"EAD"
1021: CC4554  	        defb    'L'+$80,"ET"
1024: C74F544F	        defb    'G'+$80,"OTO"
1028: D2554E  	        defb    'R'+$80,"UN"
102B: C946    	        defb    'I'+$80,"F"
102D: D2455354	        defb    'R'+$80,"ESTORE"
1031: 4F5245  	
1034: C74F5355	        defb    'G'+$80,"OSUB"
1038: 42      	
1039: D2455455	        defb    'R'+$80,"ETURN"
103D: 524E    	
103F: D2454D  	        defb    'R'+$80,"EM"
1042: D3544F50	        defb    'S'+$80,"TOP"
1046: CF5554  	        defb    'O'+$80,"UT"
1049: CF4E    	        defb    'O'+$80,"N"
104B: CE554C4C	        defb    'N'+$80,"ULL"
104F: D7414954	        defb    'W'+$80,"AIT"
1053: C44546  	        defb    'D'+$80,"EF"
1056: D04F4B45	        defb    'P'+$80,"OKE"
105A: C44F4B45	        defb    'D'+$80,"OKE"
105E: D6504F4B	        defb    'V'+$80,"POKE"          ; added by Leonardo Miliani
1062: 45      	
1063: D3524547	        defb    'S'+$80,"REG"           ; added by Leonardo Miliani
1067: D6524547	        defb    'V'+$80,"REG"           ; added by Leonardo Miliani
106B: D3435245	        defb    'S'+$80,"CREEN"         ; changed by Leonardo Miliani
106F: 454E    	
1071: CC4F4341	        defb    'L'+$80,"OCATE"         ; added by Leonardo Miliani
1075: 5445    	
1077: D34F554E	        defb    'S'+$80,"OUND"          ; added by Leonardo Miliani
107B: 44      	
107C: D64F4C55	        defb    'V'+$80,"OLUME"         ; added by Leonardo Miliani
1080: 4D45    	
1082: D0415553	        defb    'P'+$80,"AUSE"          ; added by Leonardo Miliani
1086: 45      	
1087: C34F4C4F	        defb    'C'+$80,"OLOR"          ; added by Leonardo Miliani
108B: 52      	
108C: D04C4F54	        defb    'P'+$80,"LOT"           ; added by Leonardo Miliani
1090: C4524157	        defb    'D'+$80,"RAW"           ; added by Leonardo Miliani
1094: C3495243	        defb    'C'+$80,"IRCLE"         ; added by Leonardo Miliani
1098: 4C45    	
109A: D3455249	        defb    'S'+$80,"ERIAL"         ; added by Leonardo Miliani
109E: 414C    	
10A0: C8454C50	        defb    'H'+$80,"ELP"           ; changed by Leonardo Miliani - was LINES
10A4: C34C53  	        defb    'C'+$80,"LS"            ; restored command
10A7: CB4559  	        defb    'K'+$80,"EY"            ; added by Leonardo Miliani
10AA: CE4D49  	        defb    'N'+$80,"MI"            ; added by Leonardo Miliani
10AD: C7505249	        defb    'G'+$80,"PRINT"         ; added by Leonardo Miliani
10B1: 4E54    	
10B3: D7494454	        defb    'W'+$80,"IDTH"
10B7: 48      	
10B8: D35953  	        defb    'S'+$80,"YS"            ; added by Leonardo Miliani
10BB: D2455345	        defb    'R'+$80,"ESET"          ; changed by Leonardo Miliani
10BF: 54      	
10C0: D052494E	        defb    'P'+$80,"RINT"
10C4: 54      	
10C5: C34F4E54	        defb    'C'+$80,"ONT"
10C9: CC495354	        defb    'L'+$80,"IST"
10CD: C34C4541	        defb    'C'+$80,"LEAR"
10D1: 52      	
10D2: C34C4F41	        defb    'C'+$80,"LOAD"
10D6: 44      	
10D7: C3534156	        defb    'C'+$80,"SAVE"
10DB: 45      	
10DC: CE4557  	        defb    'N'+$80,"EW"
10DF: D4414228	        defb    'T'+$80,"AB("
10E3: D44F    	        defb    'T'+$80,"O"
10E5: C64E    	        defb    'F'+$80,"N"
10E7: D3504328	        defb    'S'+$80,"PC("
10EB: D448454E	        defb    'T'+$80,"HEN"
10EF: CE4F54  	        defb    'N'+$80,"OT"
10F2: D3544550	        defb    'S'+$80,"TEP"
              	        ; from here: operators
10F6: AB      	        defb    '+'+$80
10F7: AD      	        defb    '-'+$80
10F8: AA      	        defb    '*'+$80
10F9: AF      	        defb    '/'+$80
10FA: A5      	        defb    '%'+$80
10FB: A3      	        defb    '#'+$80
10FC: DE      	        defb    '^'+$80
10FD: C14E44  	        defb    'A'+$80,"ND"
1100: D84F52  	        defb    'X'+$80,"OR"
1103: CF52    	        defb    'O'+$80,"R"
1105: BE      	        defb    '>'+$80
1106: BD      	        defb    '='+$80
1107: BC      	        defb    '<'+$80
              	
              	        ; from here there are the tokens' FUNCTIONS list
              	        ; this list must be coherent with the functions list above
1108: D3474E  	        defb    'S'+$80,"GN"
110B: D44D52  	        defb    'T'+$80,"MR"            ; added by Leonardo Miliani
110E: C94E54  	        defb    'I'+$80,"NT"
1111: C14253  	        defb    'A'+$80,"BS"
1114: D55352  	        defb    'U'+$80,"SR"
1117: C65245  	        defb    'F'+$80,"RE"
111A: C94E50  	        defb    'I'+$80,"NP"
111D: D04F53  	        defb    'P'+$80,"OS"
1120: D35152  	        defb    'S'+$80,"QR"
1123: D24E44  	        defb    'R'+$80,"ND"
1126: CC4F47  	        defb    'L'+$80,"OG"
1129: C55850  	        defb    'E'+$80,"XP"
112C: C34F53  	        defb    'C'+$80,"OS"
112F: D3494E  	        defb    'S'+$80,"IN"
1132: D4414E  	        defb    'T'+$80,"AN"
1135: C1544E  	        defb    'A'+$80,"TN"
1138: D045454B	        defb    'P'+$80,"EEK"
113C: C445454B	        defb    'D'+$80,"EEK"
1140: D6504545	        defb    'V'+$80,"PEEK"          ; added by Leonardo Miliani
1144: 4B      	
1145: D6535441	        defb    'V'+$80,"STAT"          ; added by Leonardo Miliani
1149: 54      	
114A: D3535441	        defb    'S'+$80,"STAT"          ; added by Leonardo Miliani
114E: 54      	
114F: C94E4B45	        defb    'I'+$80,"NKEY"          ; added by Leonardo Miliani
1153: 59      	
1154: D04F494E	        defb    'P'+$80,"OINT"          ; added by Leonardo Miliani
1158: 54      	
1159: C94E5354	        defb    'I'+$80,"NSTR"          ; added by Leonardo Miliani
115D: 52      	
115E: CC454E  	        defb    'L'+$80,"EN"
1161: D3545224	        defb    'S'+$80,"TR$"
1165: D6414C  	        defb    'V'+$80,"AL"
1168: C15343  	        defb    'A'+$80,"SC"
116B: C3485224	        defb    'C'+$80,"HR$"
116F: C8455824	        defb    'H'+$80,"EX$"           ; added by Grant Searle
1173: C2494E24	        defb    'B'+$80,"IN$"           ; added by Grant Searle
1177: CC454654	        defb    'L'+$80,"EFT$"
117B: 24      	
117C: D2494748	        defb    'R'+$80,"IGHT$"
1180: 5424    	
1182: CD494424	        defb    'M'+$80,"ID$"
1186: 80      	        defb    $80                     ; End-of-list marker
              	
              	; KEYWORD ADDRESS TABLE
              	; this list must be coherent with the commands'
              	; tokens list above
1187: 8B1A    	WORDTB: defw    PEND
1189: 8819    	        defw    FOR
118B: 6B1E    	        defw    NEXT
118D: E41B    	        defw    DATA
118F: 701D    	        defw    INPUT
1191: C020    	        defw    DIM
1193: A21D    	        defw    READ
1195: FB1B    	        defw    LET
1197: A11B    	        defw    GOTO
1199: 7C1B    	        defw    RUN
119B: 731C    	        defw    IF
119D: 511A    	        defw    RESTOR
119F: 901B    	        defw    GOSUB
11A1: BF1B    	        defw    RETURN
11A3: E61B    	        defw    REM
11A5: 891A    	        defw    STOP
11A7: 0527    	        defw    POUT
11A9: 551C    	        defw    ON
11AB: E61B    	        defw    REM         ; removed - was NULL
11AD: 0B27    	        defw    WAIT
11AF: B422    	        defw    DEF
11B1: FF27    	        defw    POKE
11B3: A331    	        defw    DOKE
11B5: 0428    	        defw    VPOKE       ; added by Leonardo Miliani
11B7: 4128    	        defw    SREG        ; added by Leonardo Miliani
11B9: 9029    	        defw    VREG        ; added by Leonardo Miliani
11BB: D931    	        defw    SCREEN      ; mod function: now it sets up a graphics mode (Leonardo Miliani)
11BD: 0F28    	        defw    LOCATE      ; added by Leonardo Miliani
11BF: 9B28    	        defw    SOUND       ; added by Leonardo Miliani
11C1: 6228    	        defw    VOLUME      ; added by Leonardo Miliani
11C3: BA31    	        defw    PAUSE       ; added by Leonardo Miliani
11C5: 5432    	        defw    COLOR       ; added by Leonardo Miliani
11C7: 3D34    	        defw    PLOT        ; added by Leonardo Miliani
11C9: BC34    	        defw    DRAW        ; added by Leonardo Miliani
11CB: E335    	        defw    CIRCLE      ; added by Leonardo Miliani
11CD: E837    	        defw    SERIAL      ; added by Leonardo Miliani
11CF: E339    	        defw    HELP        ; changed by Leonardo Miliani - was LINES
11D1: 7C31    	        defw    CLS
11D3: FE39    	        defw    KEY         ; added by Leonardo Miliani
11D5: 4D27    	        defw    NMI         ; added by Leonardo Miliani
11D7: 0E33    	        defw    GPRINT      ; added by Leonardo Miliani
11D9: 9031    	        defw    WIDTH
11DB: A727    	        defw    SYS         ; added by Leonardo Miliani
11DD: 3F3C    	        defw    RESET       ; new behaviour: now it resets the system
11DF: 971C    	        defw    PRINT
11E1: BD1A    	        defw    CONT
11E3: 7D18    	        defw    LIST
11E5: 361B    	        defw    CLEAR
11E7: E61B    	        defw    REM         ; not implemented (was CLOAD)
11E9: E61B    	        defw    REM         ; not implemented (was CSAVE)
11EB: 6216    	        defw    NEW
              	
              	; RESERVED WORD TOKEN VALUES
              	; if you add a function or command you must increment by 1
              	; the values below. Pay attention that you must increment only the
              	; values AFTER the position where you entered the function/command word
              	; in the "Reserver word list" above. I.E.: VPOKE has been added between
              	; DOKE and SCREEN, and since REM is the reserved work listed below
              	; that is before the point where VPOKE has been entered, every entry
              	; after REM has been incremented.
              	; Another example: when TMR has been added, since it's a function, every
              	; entry after & included ZSGN must be checked (read below)
              	
0080:         	ZEND    equ     $80             ; END        <-- from here, there are the commands
0081:         	ZFOR    equ     $81             ; FOR
0083:         	ZDATA   equ     $83             ; DATA
0088:         	ZGOTO   equ     $88             ; GOTO
008C:         	ZGOSUB  equ     $8C             ; GOSUB
008E:         	ZREM    equ     $8E             ; REM
00AC:         	ZPRINT  equ     $AC             ; PRINT
00B2:         	ZNEW    equ     $B2             ; NEW
              	
00B3:         	ZTAB    equ     $B3             ; TAB
00B4:         	ZTO     equ     $B4             ; TO
00B5:         	ZFN     equ     $B5             ; FN
00B6:         	ZSPC    equ     $B6             ; SPC
00B7:         	ZTHEN   equ     $B7             ; THEN
00B8:         	ZNOT    equ     $B8             ; NOT
00B9:         	ZSTEP   equ     $B9             ; STEP
              	
00BA:         	ZPLUS   equ     $BA             ; +         <-- from here, there are the math operators
00BB:         	ZMINUS  equ     $BB             ; -
00BC:         	ZTIMES  equ     $BC             ; *
00BD:         	ZDIV    equ     $BD             ; /
00BE:         	ZMOD    equ     $BE             ; %
00BF:         	ZDINT   equ     $BF             ; #
00C3:         	ZOR     equ     $C3             ; OR
00C4:         	ZGTR    equ     $C4             ; >
00C5:         	ZEQUAL  equ     $C5             ; M
00C6:         	ZLTH    equ     $C6             ; <
              	
00C7:         	ZSGN    equ     $C7             ; SGN       <-- from here, there are the functions
00DD:         	ZPOINT  equ     $DD             ; ZPOINT    <-- if the user enters a custom function, between
              	                                ;               SGN and POINT, he/she must increment this pointer by 1
00DE:         	ZINSTR  equ     $DE             ; ZINSTR    <-- same here
00E6:         	ZLEFT   equ     $E6             ; LEFT$     <-- if the user enters a custom function anywhere,
              	                                ;               he/she must increment this pointer by 1
              	
              	; ARITHMETIC PRECEDENCE TABLE
              	; in the formulas below, <last> is a number stored into the stack that must be retrieved
              	; with POP BC, POP DE; FPREG is a f.p. number store into the RAM register FPREG
11ED: 79      	PRITAB: defb    $79             ; Precedence value
11EE: 452E    	        defw    PADD            ; FPREG = <last> + FPREG
              	
11F0: 79      	        defb    $79             ; Precedence value
11F1: 282A    	        defw    PSUB            ; FPREG = <last> - FPREG
              	
11F3: 7C      	        defb    $7C             ; Precedence value
11F4: 662B    	        defw    MULT            ; PPREG = <last> * FPREG
              	
11F6: 7C      	        defb    $7C             ; Precedence value
11F7: 182C    	        defw    DIV             ; FPREG = <last> / FPREG
              	
11F9: 7C      	        defb    $7C             ; Precedence value
11FA: C32B    	        defw    MOD             ; FPREG = INT(<last>)-(INT(FPREG)*INT(<last>/FPREG))
              	
11FC: 7C      	        defb    $7C             ; precedence value
11FD: BB2B    	        defw    DINT            ; FPREG = INT(<last> / FPREG )
              	
11FF: 7F      	        defb    $7F             ; Precedence value
1200: 662F    	        defw    POWER           ; FPREG = <last> ^ FPREG
              	
1202: 50      	        defb    $50             ; Precedence value
1203: 0920    	        defw    PAND            ; FPREG = <last> AND FPREG
              	
1205: 4A      	        defb    $4A             ; Precedence value
1206: 1120    	        defw    PXOR            ; FPREG = <last> XOR FPREG
              	
1208: 46      	        defb    $46             ; Precedence value
1209: 0C20    	        defw    POR             ; FPREG = <last> OR FPREG
              	
              	; BASIC ERROR CODE LIST
              	
120B:         	ERRORS  equ $
120B: 4E455854	NFMSG:  defb    "NEXT Without FOR",0
120F: 20576974	
1213: 686F7574	
1217: 20464F52	
121B: 00      	
121C: 53796E74	SNMSG:  defb    "Syntax",0
1220: 617800  	
1223: 52455455	RGMSG:  defb    "RETURN without GOSUB",0
1227: 524E2077	
122B: 6974686F	
122F: 75742047	
1233: 4F535542	
1237: 00      	
1238: 4F757420	ODMSG:  defb    "Out of DATA",0
123C: 6F662044	
1240: 41544100	
1244: 496C6C65	FCMSG:  defb    "Illegal Function Call",0
1248: 67616C20	
124C: 46756E63	
1250: 74696F6E	
1254: 2043616C	
1258: 6C00    	
125A: 4F766572	OVMSG:  defb    "Overflow",0
125E: 666C6F77	
1262: 00      	
1263: 4F757420	OMMSG:  defb    "Out of Memory",0
1267: 6F66204D	
126B: 656D6F72	
126F: 7900    	
1271: 556E6465	ULMSG:  defb    "Undefined Line",0
1275: 66696E65	
1279: 64204C69	
127D: 6E6500  	
1280: 42616420	BSMSG:  defb    "Bad Subscript",0
1284: 53756273	
1288: 63726970	
128C: 7400    	
128E: 52652D44	DDMSG:  defb    "Re-Dimensioned Array",0
1292: 696D656E	
1296: 73696F6E	
129A: 65642041	
129E: 72726179	
12A2: 00      	
12A3: 44697669	DZMSG:  defb    "Division by Zero",0
12A7: 73696F6E	
12AB: 20627920	
12AF: 5A65726F	
12B3: 00      	
12B4: 496C6C65	IDMSG:  defb    "Illegal Direct",0
12B8: 67616C20	
12BC: 44697265	
12C0: 637400  	
12C3: 54797065	TMMSG:  defb    "Type Mis-match",0
12C7: 204D6973	
12CB: 2D6D6174	
12CF: 636800  	
12D2: 4F757420	OSMSG:  defb    "Out of String Space",0
12D6: 6F662053	
12DA: 7472696E	
12DE: 67205370	
12E2: 61636500	
12E6: 53747269	LSMSG:  defb    "String Too Long",0
12EA: 6E672054	
12EE: 6F6F204C	
12F2: 6F6E6700	
12F6: 53747269	STMSG:  defb    "String Formula Too Complex",0
12FA: 6E672046	
12FE: 6F726D75	
1302: 6C612054	
1306: 6F6F2043	
130A: 6F6D706C	
130E: 657800  	
1311: 43616E27	CNMSG:  defb    "Can't Continue",0
1315: 7420436F	
1319: 6E74696E	
131D: 756500  	
1320: 556E6465	UFMSG:  defb    "Undefined FN Function",0
1324: 66696E65	
1328: 6420464E	
132C: 2046756E	
1330: 6374696F	
1334: 6E00    	
1336: 4D697373	MOMSG:  defb    "Missing Operand",0
133A: 696E6720	
133E: 4F706572	
1342: 616E6400	
1346: 48455820	HXMSG:  defb    "HEX Format",0
134A: 466F726D	
134E: 617400  	
1351: 42494E20	BNMSG:  defb    "BIN Format",0
1355: 466F726D	
1359: 617400  	
135C: 4E6F2047	GMMSG:  defb    "No Graphics Mode",0
1360: 72617068	
1364: 69637320	
1368: 4D6F6465	
136C: 00      	
136D: 53657269	SCMSG:  defb    "Serial Configuration",0
1371: 616C2043	
1375: 6F6E6669	
1379: 67757261	
137D: 74696F6E	
1381: 00      	
1382: 53657269	SAMSG:  defb    "Serial Port Already Open",0
1386: 616C2050	
138A: 6F727420	
138E: 416C7265	
1392: 61647920	
1396: 4F70656E	
139A: 00      	
139B: 48454C50	HPMSG:  defb    "HELP Call",0
139F: 2043616C	
13A3: 6C00    	
              	
13A5:         	ERRTBL  equ $
13A5: 0B12    	NFPTR   defw    NFMSG
13A7: 1C12    	SNPTR   defw    SNMSG
13A9: 2312    	RGPTR   defw    RGMSG
13AB: 3812    	ODPTR   defw    ODMSG
13AD: 4412    	FCPTR   defw    FCMSG
13AF: 5A12    	OVPTR   defw    OVMSG
13B1: 6312    	OMPTR   defw    OMMSG
13B3: 7112    	ULPTR   defw    ULMSG
13B5: 8012    	BSPTR   defw    BSMSG
13B7: 8E12    	DDPTR   defw    DDMSG
13B9: A312    	DZPTR   defw    DZMSG
13BB: B412    	IDPTR   defw    IDMSG
13BD: C312    	TMPTR   defw    TMMSG
13BF: D212    	OSPTR   defw    OSMSG
13C1: E612    	LSPTR   defw    LSMSG
13C3: F612    	STPTR   defw    STMSG
13C5: 1113    	CNPTR   defw    CNMSG
13C7: 2013    	UFPTR   defw    UFMSG
13C9: 3613    	MOPTR   defw    MOMSG
13CB: 4613    	HXPTR   defw    HXMSG
13CD: 5113    	BNPTR   defw    BNMSG
13CF: 5C13    	GMPRT   defw    GMMSG
13D1: 6D13    	SCPTR   defw    SCMSG
13D3: 8213    	SAPTR   defw    SAMSG
13D5: 9B13    	HPPTR   defw    HPMSG
              	
              	; INITIALISATION TABLE -------------------------------------------------------
              	; these values are copied into RAM at startup
13D7: C36E0F  	INITAB: jp      WARMST          ; Warm start jump
13DA: ED4500  	        defb    $ED,$45,$00     ; RETN + NOP for default NMI service routine
13DD: C30C1B  	        jp      FCERR           ; "USR (X)" jump (Set to Error)
13E0: D300    	        out     (0),A           ; "out p,n" skeleton
13E2: C9      	        ret
13E3: D600    	        sub     $00             ; Division support routine
13E5: 6F      	        ld      L,A
13E6: 7C      	        ld      A,H
13E7: DE00    	        sbc     A,$00
13E9: 67      	        ld      H,A
13EA: 78      	        ld      A,B
13EB: DE00    	        sbc     A,$00
13ED: 47      	        ld      B,A
13EE: 3E00    	        ld      A,$00
13F0: C9      	        ret
13F1: 000000  	        defb    $00,$00,$00     ; Random number seed table used by RND
13F4: 354ACA99	        defb    $35,$4A,$CA,$99 ;-2.65145E+07
13F8: 391C7698	        defb    $39,$1C,$76,$98 ; 1.61291E+07
13FC: 2295B398	        defb    $22,$95,$B3,$98 ;-1.17691E+07
1400: 0ADD4798	        defb    $0A,$DD,$47,$98 ; 1.30983E+07
1404: 53D19999	        defb    $53,$D1,$99,$99 ;-2-01612E+07
1408: 0A1A9F98	        defb    $0A,$1A,$9F,$98 ;-1.04269E+07
140C: 65BCCD98	        defb    $65,$BC,$CD,$98 ;-1.34831E+07
1410: D6773E98	        defb    $D6,$77,$3E,$98 ; 1.24825E+07
1414: 52C74F80	        defb    $52,$C7,$4F,$80 ; Last random number
1418: DB00    	        in      A,($00)         ; INP (x) skeleton
141A: C9      	        ret
141B: FF      	        defb    $FF             ; Terminal width (255 = no auto CRLF)
141C: 1C      	        defb    $1C             ; Width for commas (3 columns)
141D: 00      	        defb    $00             ; No nulls after input bytes
141E: 00      	        defb    $00             ; Output enabled (^O off)
141F: 0000    	        defw    $00             ; Array load/save check sum
1421: 00      	        defb    $00             ; Break not by NMI
1422: 00      	        defb    $00             ; Break flag
1423: C39E17  	        jp      TTYLIN          ; Input reflection (set to TTY)
1426: A482    	        defw    STLOOK          ; Temp string space
1428: FEFF    	        defw    -2              ; Current line number (cold)
142A: FFFF    	        defw    -1              ; Current line with errors (no errors)
142C: 4C495354	DEFFNKS:defm    "LIST",13,0,0,0,0,0,0,0,0,0,0,0     ; KEY 1
1430: 0D000000	
1434: 00000000	
1438: 00000000	
143C: 52554E0D	        defm    "RUN",13,0,0,0,0,0,0,0,0,0,0,0,0    ; KEY 2
1440: 00000000	
1444: 00...   	
144C: 53435245	        defm    "SCREEN1",13,0,0,0,0,0,0,0,0        ; KEY 3
1450: 454E310D	
1454: 00000000	
1458: 00000000	
145C: 434F4C4F	        defm    "COLOR1,15,5",13,0,0,0,0            ; KEY 4
1460: 52312C31	
1464: 352C350D	
1468: 00000000	
146C: 53455249	        defm    "SERIAL1,38400",13,0,0              ; KEY 5
1470: 414C312C	
1474: 33383430	
1478: 300D0000	
147C: 53435245	        defm    "SCREEN2",13,0,0,0,0,0,0,0,0        ; KEY 6
1480: 454E320D	
1484: 00000000	
1488: 00000000	
148C: 434F4E54	        defm    "CONT",13,0,0,0,0,0,0,0,0,0,0,0     ; KEY 7
1490: 0D000000	
1494: 00000000	
1498: 00000000	
149C: 48454C50	        defm    "HELP",13,0,0,0,0,0,0,0,0,0,0,0     ; KEY 8 (HELP KEY)
14A0: 0D000000	
14A4: 00000000	
14A8: 00000000	
14AC: 4182    	        defw    PROGST+1        ; Start of program text
14AE:         	INITBE:
              	
              	; END OF INITIALISATION TABLE ---------------------------------------------------
              	
14AE: 20457272	ERRMSG: defb    " Error",0
14B2: 6F7200  	
14B5: 20696E20	INMSG:  defb    " in ",0
14B9: 00      	
14B9:         	ZERBYT  equ     $-1             ; A zero byte
14BA: 4F6B0D00	OKMSG:  defb    "Ok",CR,0,0
14BE: 00      	
14BF: 42726561	BRKMSG: defb    "Break",0
14C3: 6B00    	
              	
14C5: 210400  	BAKSTK: ld      HL,$04          ; Look for "FOR" block with
14C8: 39      	        add     HL,SP           ; same index as specified
14C9: 7E      	LOKFOR: ld      A,(HL)          ; Get block ID
14CA: 23      	        inc     HL              ; Point to index address
14CB: FE81    	        cp      ZFOR            ; Is it a "FOR" token
14CD: C0      	        ret     NZ              ; No - exit
14CE: 4E      	        ld      C,(HL)          ; BC = Address of "FOR" index
14CF: 23      	        inc     HL
14D0: 46      	        ld      B,(HL)
14D1: 23      	        inc     HL              ; Point to sign of STEP
14D2: E5      	        push    HL              ; Save pointer to sign
14D3: 69      	        ld      L,C             ; HL = address of "FOR" index
14D4: 60      	        ld      H,B
14D5: 7A      	        ld      A,D             ; See if an index was specified
14D6: B3      	        or      E               ; DE = 0 if no index specified
14D7: EB      	        ex      DE,HL           ; Specified index into HL
14D8: CADF14  	        jp      Z,INDFND        ; Skip if no index given
14DB: EB      	        ex      DE,HL           ; Index back into DE
14DC: CD1818  	        call    CPDEHL          ; Compare index with one given
14DF: 010D00  	INDFND: ld      BC,16-3         ; Offset to next block
14E2: E1      	        pop     HL              ; Restore pointer to sign
14E3: C8      	        ret     Z               ; Return if block found
14E4: 09      	        add     HL,BC           ; Point to next block
14E5: C3C914  	        jp      LOKFOR          ; Keep on looking
              	
14E8: CD0215  	MOVUP:  call    ENFMEM          ; See if enough memory
14EB: C5      	MOVSTR: push    BC              ; Save end of source
14EC: E3      	        ex      (SP),HL         ; Swap source and dest" end
14ED: C1      	        pop     BC              ; Get end of destination
14EE: CD1818  	MOVLP:  call    CPDEHL          ; See if list moved
14F1: 7E      	        ld      A,(HL)          ; Get byte
14F2: 02      	        ld      (BC),A          ; Move it
14F3: C8      	        ret     Z               ; Exit if all done
14F4: 0B      	        dec     BC              ; Next byte to move to
14F5: 2B      	        dec     HL              ; Next byte to move
14F6: C3EE14  	        jp      MOVLP           ; Loop until all bytes moved
              	
14F9: E5      	CHKSTK: push    HL              ; Save code string address
14FA: 2ABF81  	        ld      HL,(ARREND)     ; Lowest free memory
14FD: 0600    	        ld      B,$00           ; BC = Number of levels to test
14FF: 09      	        add     HL,BC           ; 2 Bytes for each level
1500: 09      	        add     HL,BC
1501: 3E      	        defb    $3E             ; Skip "push HL"
1502: E5      	ENFMEM: push    HL              ; Save code string address
1503: 3ED0    	        ld      A,$D0           ; LOW -48 ; 48 Bytes minimum RAM
1505: 95      	        sub     L
1506: 6F      	        ld      L,A
1507: 3EFF    	        ld      A,$FF           ; HIGH (-48) ; 48 Bytes minimum RAM
1509: 9C      	        sbc     A,H
150A: DA1115  	        jp      C,OMERR         ; Not enough - ?OM Error
150D: 67      	        ld      H,A
150E: 39      	        add     HL,SP           ; Test if stack is overflowed
150F: E1      	        pop     HL              ; Restore code string address
1510: D8      	        ret     C               ; Return if enough memory
1511: 1E0C    	OMERR:  ld      E,OM            ; ?OM Error
1513: C35015  	        jp      ERROR
              	
              	
              	; if in graphics mode, return to text (called by "NOLIN" and "ERROR")
1516: F5      	EXITGM: push    AF              ; store AF
1517: 3AE081  	        ld      A,(SCR_MODE)    ; check screen mode
151A: FE02    	        cp      $02             ; G2?
151C: CA2315  	        jp      Z,LDG1          ; yes, back to G1
151F: FE03    	        cp      $03             ; G3?
1521: 2011    	        jr      NZ,LDG1ND       ; no, so return
1523: E5      	LDG1:   push    HL              ; store HL
1524: D5      	        push    DE              ; store DE
1525: 110100  	        ld      DE,$0001        ; sprites set to defaults, G1 mode
1528: F3      	        di                      ; disable INTs
1529: CD8003  	        call    initVDP         ; initialize VDP with mode pointed by E
152C: FB      	        ei                      ; re-enable INTs
152D: 3E01    	        ld      A,$01           ; activate the...
152F: 32EB81  	        ld      (PRNTVIDEO),A   ; ...video buffer...
1532: D1      	        pop     DE              ; retrieve DE
1533: E1      	        pop     HL              ; retrieve HL
1534: F1      	LDG1ND: pop     AF              ; retrieve AF
1535: C9      	        ret                     ; return to caller
              	
              	
1536: 2AAE81  	DATSNR: ld      HL,(DATLIN)     ; Get line of current DATA item
1539: 22AF80  	        ld      (LINEAT),HL     ; Save as current line
153C: 1E02    	SNERR:  ld      E,SN            ; ?SN Error
153E: 01      	        defb    $01             ; Skip "ld E,DZ"
153F: 1E14    	DZERR:  ld      E,DZ            ; ?/0 Error
1541: 01      	        defb    $01             ; Skip "ld E,NF"
1542: 1E00    	NFERR:  ld      E,NF            ; ?NF Error
1544: 01      	        defb    $01             ; Skip "ld E,DD"
1545: 1E12    	DDERR:  ld      E,DD            ; ?DD Error
1547: 01      	        defb    $01             ; Skip "ld E,UF"
1548: 1E22    	UFERR:  ld      E,UF            ; ?UF Error
154A: 01      	        defb    $01             ; Skip "ld E,OV
154B: 1E0A    	OVERR:  ld      E,OV            ; ?OV Error
154D: 01      	        defb    $01             ; Skip "ld E,TM"
154E: 1E18    	TMERR:  ld      E,TM            ; ?TM Error
              	
1550: CD8816  	ERROR:  call    CLREG           ; Clear registers and stack
1553: CD1615  	        call    EXITGM          ; exit from graphic modes
1556: 32A580  	        ld      (CTLOFG),A      ; Enable output (A is 0)
1559: CD3808  	        call    CURSOR_ON       ; enable cursor
155C: CDE81C  	        call    STTLIN          ; Start new line
155F: 21A513  	        ld      HL,ERRTBL       ; Point to error codes
1562: 57      	        ld      D,A             ; D = 0 (A is 0)
1563: 3E3F    	        ld      A,'?'
1565: CD2918  	        call    OUTC            ; Output '?'
1568: 19      	        add     HL,DE           ; Offset to correct error code
1569: 5E      	        ld      E,(HL)          ; load pointer to error message
156A: 23      	        inc     HL              ; by loading LSB,
156B: 56      	        ld      D,(HL)          ; then MSB
156C: 626B    	        ld      HL,DE           ; load pointer to HL
156E: CDBE23  	        call    PRS             ; Output error message
1571: 21AE14  	        ld      HL,ERRMSG       ; "Error" message
1574: CDBE23  	ERRIN:  call    PRS             ; Output message
1577: 2AAF80  	        ld      HL,(LINEAT)     ; Get line of error
157A: 11FEFF  	        ld      DE,-2           ; Cold start error if -2
157D: CD1818  	        call    CPDEHL          ; See if cold start error
1580: CADD0E  	        jp      Z,CSTART        ; Cold start error - Restart
1583: 7C      	        ld      A,H             ; Was it a direct error?
1584: A5      	        and     L               ; Line = -1 if direct error
1585: 3C      	        inc     A
1586: CA9115  	        jp      Z,PTLN          ; Yes, jump over
1589: E5      	        push    HL              ; indirect mode - store HL
158A: 2AAF80  	        ld      HL,(LINEAT)     ; copy current line number
158D: 22B180  	        ld      (HLPLN),HL      ; save in HELP line register
1590: E1      	        pop     HL              ; retrieve HL
1591: C4562E  	PTLN:   call    NZ,LINEIN       ; No - output line of error
              	
1594: 3E      	        defb    $3E             ; Skip "pop BC"
1595: C1      	POPNOK: pop     BC              ; Drop address in input buffer
              	
              	; run into direct mode: print OK and get command
1596: AF      	PRNTOK: xor     A               ; Output "Ok" and get command
1597: 32A580  	        ld      (CTLOFG),A      ; Enable output
159A: CDE81C  	        call    STTLIN          ; Start new line
159D: 21BA14  	        ld      HL,OKMSG        ; "Ok" message
15A0: CDBE23  	        call    PRS             ; Output "Ok"
15A3: CD3808  	GETCMD: call    CURSOR_ON       ; enable cursor
15A6: 21FFFF  	        ld      HL,-1           ; Flag direct mode
15A9: 22AF80  	        ld      (LINEAT),HL     ; Save as current line
15AC: CD9E17  	        call    GETLIN          ; Get an input line
15AF: DAA315  	        jp      C,GETCMD        ; Get line again if break
15B2: CD411A  	        call    GETCHR          ; Get first character
15B5: 17      	        rla                     ; 8th bit is copied into carry and original carry is copied into bit 0)
15B6: DA3C15  	        jp      C,SNERR         ; if char >=128 (8th bit set) then raise an error
15B9: 1F      	        rra                     ; recover original char and Carry
15BA: 3C      	        inc     A               ; Test if end of line
15BB: 3D      	        dec     A               ; Without affecting Carry
15BC: CAA315  	        jp      Z,GETCMD        ; Nothing entered - Get another
15BF: F5      	        push    AF              ; Save Carry status
15C0: CD4E08  	        call    CURSOR_OFF      ; cursor disabled
15C3: CD111B  	        call    ATOH            ; Get line number into DE
15C6: D5      	        push    DE              ; Save line number
15C7: CDB516  	        call    CRUNCH          ; Tokenise rest of line
15CA: 47      	        ld      B,A             ; Length of tokenised line
15CB: D1      	        pop     DE              ; Restore line number
15CC: F1      	        pop     AF              ; Restore Carry
15CD: D2211A  	        jp      NC,EXCUTE       ; No line number - Direct mode
15D0: D5      	        push    DE              ; Save line number
15D1: C5      	        push    BC              ; Save length of tokenised line
15D2: AF      	        xor     A
15D3: 32B181  	        ld      (LSTBIN),A      ; Clear last byte input
15D6: CD411A  	        call    GETCHR          ; Get next character
15D9: B7      	        or      A               ; Set flags
15DA: F5      	        push    AF              ; And save them
15DB: CD4216  	        call    SRCHLN          ; Search for line number in DE
15DE: DAE715  	        jp      C,LINFND        ; Jump if line found
15E1: F1      	        pop     AF              ; Get status
15E2: F5      	        push    AF              ; And re-save
15E3: CABA1B  	        jp      Z,ULERR         ; Nothing after number - Error
15E6: B7      	        or      A               ; Clear Carry
15E7: C5      	LINFND: push    BC              ; Save address of line in prog
15E8: D2FE15  	        jp      NC,INEWLN       ; Line not found - Insert new
15EB: EB      	        ex      DE,HL           ; Next line address in DE
15EC: 2ABB81  	        ld      HL,(PROGND)     ; End of program
15EF: 1A      	SFTPRG: ld      A,(DE)          ; Shift rest of program down
15F0: 02      	        ld      (BC),A
15F1: 03      	        inc     BC              ; Next destination
15F2: 13      	        inc     DE              ; Next source
15F3: CD1818  	        call    CPDEHL          ; All done?
15F6: C2EF15  	        jp      NZ,SFTPRG       ; More to do
15F9: 60      	        ld      H,B             ; HL - New end of program
15FA: 69      	        ld      L,C
15FB: 22BB81  	        ld      (PROGND),HL     ; Update end of program
              	
15FE: D1      	INEWLN: pop     DE              ; Get address of line,
15FF: F1      	        pop     AF              ; Get status
1600: CA2516  	        jp      Z,SETPTR        ; No text - Set up pointers
1603: 2ABB81  	        ld      HL,(PROGND)     ; Get end of program
1606: E3      	        ex      (SP),HL         ; Get length of input line
1607: C1      	        pop     BC              ; End of program to BC
1608: 09      	        add     HL,BC           ; Find new end
1609: E5      	        push    HL              ; Save new end
160A: CDE814  	        call    MOVUP           ; Make space for line
160D: E1      	        pop     HL              ; Restore new end
160E: 22BB81  	        ld      (PROGND),HL     ; Update end of program pointer
1611: EB      	        ex      DE,HL           ; Get line to move up in HL
1612: 74      	        ld      (HL),H          ; Save MSB
1613: D1      	        pop     DE              ; Get new line number
1614: 23      	        inc     HL              ; Skip pointer
1615: 23      	        inc     HL
1616: 73      	        ld      (HL),E          ; Save LSB of line number
1617: 23      	        inc     HL
1618: 72      	        ld      (HL),D          ; Save MSB of line number
1619: 23      	        inc     HL              ; To first byte in line
161A: 113681  	        ld      DE,BUFFER       ; Copy buffer to program
161D: 1A      	MOVBUF: ld      A,(DE)          ; Get source
161E: 77      	        ld      (HL),A          ; Save destinations
161F: 23      	        inc     HL              ; Next source
1620: 13      	        inc     DE              ; Next destination
1621: B7      	        or      A               ; Done?
1622: C21D16  	        jp      NZ,MOVBUF       ; No - Repeat
1625: CD6E16  	SETPTR: call    RUNFST          ; Set line pointers
1628: 23      	        inc     HL              ; To LSB of pointer
1629: EB      	        ex      DE,HL           ; Address to DE
162A: 62      	PTRLP:  ld      H,D             ; Address to HL
162B: 6B      	        ld      L,E
162C: 7E      	        ld      A,(HL)          ; Get LSB of pointer
162D: 23      	        inc     HL              ; To MSB of pointer
162E: B6      	        or      (HL)            ; Compare with MSB pointer
162F: CAA315  	        jp      Z,GETCMD        ; Get command line if end
1632: 23      	        inc     HL              ; To LSB of line number
1633: 23      	        inc     HL              ; Skip line number
1634: 23      	        inc     HL              ; Point to first byte in line
1635: AF      	        xor     A               ; Looking for 00 byte
1636: BE      	FNDEND: cp      (HL)            ; Found end of line?
1637: 23      	        inc     HL              ; Move to next byte
1638: C23616  	        jp      NZ,FNDEND       ; No - Keep looking
163B: EB      	        ex      DE,HL           ; Next line address to HL
163C: 73      	        ld      (HL),E          ; Save LSB of pointer
163D: 23      	        inc     HL
163E: 72      	        ld      (HL),D          ; Save MSB of pointer
163F: C32A16  	        jp      PTRLP           ; Do next line
              	
1642: 2A3381  	SRCHLN: ld      HL,(BASTXT)     ; Start of program text
1645: 44      	SRCHLP: ld      B,H             ; BC = Address to look at
1646: 4D      	        ld      C,L
1647: 7E      	        ld      A,(HL)          ; Get address of next line
1648: 23      	        inc     HL
1649: B6      	        or      (HL)            ; End of program found?
164A: 2B      	        dec     HL
164B: C8      	        ret     Z               ; Yes - Line not found
164C: 23      	        inc     HL
164D: 23      	        inc     HL
164E: 7E      	        ld      A,(HL)          ; Get LSB of line number
164F: 23      	        inc     HL
1650: 66      	        ld      H,(HL)          ; Get MSB of line number
1651: 6F      	        ld      L,A
1652: CD1818  	        call    CPDEHL          ; Compare with line in DE
1655: 60      	        ld      H,B             ; HL = Start of this line
1656: 69      	        ld      L,C
1657: 7E      	        ld      A,(HL)          ; Get LSB of next line address
1658: 23      	        inc     HL
1659: 66      	        ld      H,(HL)          ; Get MSB of next line address
165A: 6F      	        ld      L,A             ; Next line to HL
165B: 3F      	        ccf
165C: C8      	        ret     Z               ; Lines found - Exit
165D: 3F      	        ccf
165E: D0      	        ret     NC              ; Line not found,at line after
165F: C34516  	        jp      SRCHLP          ; Keep looking
              	
1662: C0      	NEW:    ret     NZ              ; Return if any more on line
1663: 2A3381  	CLRPTR: ld      HL,(BASTXT)     ; Point to start of program
1666: AF      	        xor     A               ; Set program area to empty
1667: 77      	        ld      (HL),A          ; Save LSB = 00
1668: 23      	        inc     HL
1669: 77      	        ld      (HL),A          ; Save MSB = 00
166A: 23      	        inc     HL
166B: 22BB81  	        ld      (PROGND),HL     ; Set program end
              	
166E: 2A3381  	RUNFST: ld      HL,(BASTXT)     ; Clear all variables
1671: 2B      	        dec     HL
              	
1672: 22B381  	INTVAR: ld      (BRKLIN),HL     ; Initialise RUN variables
1675: 2A9481  	        ld      HL,(LSTRAM)     ; Get end of RAM
1678: 22A881  	        ld      (STRBOT),HL     ; Clear string space
167B: AF      	        xor     A
167C: CD511A  	        call    RESTOR          ; Reset DATA pointers
167F: 2ABB81  	        ld      HL,(PROGND)     ; Get end of program
1682: 22BD81  	        ld      (VAREND),HL     ; Clear variables
1685: 22BF81  	        ld      (ARREND),HL     ; Clear arrays
              	
1688: C1      	CLREG:  pop     BC              ; Save return address
1689: 2AAD80  	        ld      HL,(STRSPC)     ; Get end of working RAM
168C: F9      	        ld      SP,HL           ; Set stack
168D: 219881  	        ld      HL,TMSTPL       ; Temporary string pool
1690: 229681  	        ld      (TMSTPT),HL     ; Reset temporary string ptr
1693: AF      	        xor     A               ; A = 00
1694: 6F      	        ld      L,A             ; HL = 0000
1695: 67      	        ld      H,A
1696: 22B981  	        ld      (CONTAD),HL     ; No CONTinue
1699: 32B081  	        ld      (FORFLG),A      ; Clear FOR flag
169C: 22C381  	        ld      (FNRGNM),HL     ; Clear FN argument
169F: E5      	        push    HL              ; HL = 0000
16A0: C5      	        push    BC              ; Put back return
16A1: 2AB381  	DOAGN:  ld      HL,(BRKLIN)     ; Get address of code to RUN
16A4: C9      	        ret                     ; Return to execution driver
              	
16A5: 3E3F    	PROMPT: ld      A,'?'           ; '?'
16A7: CD2918  	        call    OUTC            ; Output character
16AA: 3E00    	        ld      A,NLLCR         ; null char
16AC: CD2918  	        call    OUTC            ; Output character
16AF: CD3808  	        call    CURSOR_ON       ; enable cursor
16B2: C3AA80  	        jp      RINPUT          ; Get input line
              	
16B5: AF      	CRUNCH: xor     A               ; Tokenise line @ HL to BUFFER
16B6: 329381  	        ld      (DATFLG),A      ; Reset literal flag
16B9: 0E05    	        ld      C,2+3           ; 2 byte number and 3 nulls
16BB: 113681  	        ld      DE,BUFFER       ; Start of input buffer
16BE: 7E      	CRNCLP: ld      A,(HL)          ; Get byte
16BF: FE20    	        cp      SPC             ; Is it a space?
16C1: CA3D17  	        jp      Z,MOVDIR        ; Yes - Copy direct
16C4: 47      	        ld      B,A             ; Save character
16C5: FE22    	        cp      22H             ; '"'             ; Is it a quote?
16C7: CA5D17  	        jp      Z,CPYLIT        ; Yes - Copy literal string
16CA: B7      	        or      A               ; Is it end of buffer?
16CB: CA6417  	        jp      Z,ENDBUF        ; Yes - End buffer
16CE: 3A9381  	        ld      A,(DATFLG)      ; Get data type
16D1: B7      	        or      A               ; Literal?
16D2: 7E      	        ld      A,(HL)          ; Get byte to copy
16D3: C23D17  	        jp      NZ,MOVDIR       ; Literal - Copy direct
16D6: FE3F    	        cp      '?'             ; Is it '?' short for PRINT
16D8: 3EAC    	        ld      A,ZPRINT        ; "PRINT" token
16DA: CA3D17  	        jp      Z,MOVDIR        ; Yes - replace it
16DD: 7E      	        ld      A,(HL)          ; Get byte again
16DE: FE30    	        cp      '0'             ; Is it less than '0'
16E0: DAE816  	        jp      C,FNDWRD        ; Yes - Look for reserved words
16E3: FE3C    	        cp      $3C  ;60; ";"+1       ; Is it "0123456789:;" ?
16E5: DA3D17  	        jp      C,MOVDIR        ; Yes - copy it direct
16E8: D5      	FNDWRD: push    DE              ; Look for reserved words
16E9: 110610  	        ld      DE,WORDS-1      ; Point to table
16EC: C5      	        push    BC              ; Save count
16ED: 013917  	        ld      BC,RETNAD       ; Where to return to
16F0: C5      	        push    BC              ; Save return address
16F1: 067F    	        ld      B,ZEND-1        ; First token value -1
16F3: 7E      	        ld      A,(HL)          ; Get byte
16F4: FE61    	        cp      'a'             ; Less than 'a' ?
16F6: DA0117  	        jp      C,SEARCH        ; Yes - search for words
16F9: FE7B    	        cp      'z'+1           ; Greater than 'z' ?
16FB: D20117  	        jp      NC,SEARCH       ; Yes - search for words
16FE: E65F    	        and     %01011111       ; Force upper case
1700: 77      	        ld      (HL),A          ; Replace byte
1701: 4E      	SEARCH: ld      C,(HL)          ; Search for a word
1702: EB      	        ex      DE,HL
1703: 23      	GETNXT: inc     HL              ; Get next reserved word
1704: B6      	        or      (HL)            ; Start of word?
1705: F20317  	        jp      P,GETNXT        ; No - move on
1708: 04      	        inc     B               ; Increment token value
1709: 7E      	        ld      A,(HL)          ; Get byte from table
170A: E67F    	        and     %01111111       ; Strip bit 7
170C: C8      	        ret     Z               ; Return if end of list
170D: B9      	        cp      C               ; Same character as in buffer?
170E: C20317  	        jp      NZ,GETNXT       ; No - get next word
1711: EB      	        ex      DE,HL
1712: E5      	        push    HL              ; Save start of word
              	
1713: 13      	NXTBYT: inc     DE              ; Look through rest of word
1714: 1A      	        ld      A,(DE)          ; Get byte from table
1715: B7      	        or      A               ; End of word ?
1716: FA3517  	        jp      M,MATCH         ; Yes - Match found
1719: 4F      	        ld      C,A             ; Save it
171A: 78      	        ld      A,B             ; Get token value
171B: FE88    	        cp      ZGOTO           ; Is it "GOTO" token ?
171D: C22417  	        jp      NZ,NOSPC        ; No - Don't allow spaces
1720: CD411A  	        call    GETCHR          ; Get next character
1723: 2B      	        dec     HL              ; Cancel increment from GETCHR
1724: 23      	NOSPC:  inc     HL              ; Next byte
1725: 7E      	        ld      A,(HL)          ; Get byte
1726: FE61    	        cp      'a'             ; Less than 'a' ?
1728: DA2D17  	        jp      C,NOCHNG        ; Yes - don't change
172B: E65F    	        and     %01011111       ; Make upper case
172D: B9      	NOCHNG: cp      C               ; Same as in buffer ?
172E: CA1317  	        jp      Z,NXTBYT        ; Yes - keep testing
1731: E1      	        pop     HL              ; Get back start of word
1732: C30117  	        jp      SEARCH          ; Look at next word
              	
1735: 48      	MATCH:  ld      C,B             ; Word found - Save token value
1736: F1      	        pop     AF              ; Throw away return
1737: EB      	        ex      DE,HL
1738: C9      	        ret                     ; Return to "RETNAD"
1739: EB      	RETNAD: ex      DE,HL           ; Get address in string
173A: 79      	        ld      A,C             ; Get token value
173B: C1      	        pop     BC              ; Restore buffer length
173C: D1      	        pop     DE              ; Get destination address
173D: 23      	MOVDIR: inc     HL              ; Next source in buffer
173E: 12      	        ld      (DE),A          ; Put byte in buffer
173F: 13      	        inc     DE              ; Move up buffer
1740: 0C      	        inc     C               ; Increment length of buffer
1741: D63A    	        sub     ':'             ; End of statement?
1743: CA4B17  	        jp      Z,SETLIT        ; Jump if multi-statement line
1746: FE49    	        cp      ZDATA-$3A       ; Is it DATA statement ?
1748: C24E17  	        jp      NZ,TSTREM       ; No - see if REM
174B: 329381  	SETLIT: ld      (DATFLG),A      ; Set literal flag
174E: D654    	TSTREM: sub     ZREM-$3A        ; Is it REM?
1750: C2BE16  	        jp      NZ,CRNCLP       ; No - Leave flag
1753: 47      	        ld      B,A             ; Copy rest of buffer
1754: 7E      	NXTCHR: ld      A,(HL)          ; Get byte
1755: B7      	        or      A               ; End of line ?
1756: CA6417  	        jp      Z,ENDBUF        ; Yes - Terminate buffer
1759: B8      	        cp      B               ; End of statement ?
175A: CA3D17  	        jp      Z,MOVDIR        ; Yes - Get next one
175D: 23      	CPYLIT: inc     HL              ; Move up source string
175E: 12      	        ld      (DE),A          ; Save in destination
175F: 0C      	        inc     C               ; Increment length
1760: 13      	        inc     DE              ; Move up destination
1761: C35417  	        jp      NXTCHR          ; Repeat
              	
1764: 213581  	ENDBUF: ld      HL,BUFFER-1     ; Point to start of buffer
1767: 12      	        ld      (DE),A          ; Mark end of buffer (A = 00)
1768: 13      	        inc     DE
1769: 12      	        ld      (DE),A          ; A = 00
176A: 13      	        inc     DE
176B: 12      	        ld      (DE),A          ; A = 00
176C: C9      	        ret
              	
176D: 3AA480  	DODEL:  ld      A,(NULFLG)      ; Get null flag status
1770: B7      	        or      A               ; Is it zero?
1771: 3E00    	        ld      A,$00           ; Zero A - Leave flags
1773: 32A480  	        ld      (NULFLG),A      ; Zero null flag
1776: C28117  	        jp      NZ,ECHDEL       ; Set - Echo it
1779: 05      	        dec     B               ; Decrement length
177A: CA9E17  	        jp      Z,GETLIN        ; Get line again if empty
177D: CD2918  	        call    OUTC            ; Output null character
1780: 3E      	        defb    $3E             ; Skip "dec B"
1781: 05      	ECHDEL: dec     B               ; Count bytes in buffer
1782: 2B      	        dec     HL              ; Back space buffer
1783: CA9517  	        jp      Z,OTKLN         ; No buffer - Try again
1786: 7E      	        ld      A,(HL)          ; Get deleted byte
1787: CD2918  	        call    OUTC            ; Echo it
178A: C3A717  	        jp      MORINP          ; Get more input
              	
178D: 05      	DELCHR: dec     B               ; Count bytes in buffer
178E: 2B      	        dec     HL              ; Back space buffer
178F: CD2918  	        call    OUTC            ; Output character in A
1792: C2A717  	        jp      NZ,MORINP       ; Not end - Get more
1795: CD2918  	OTKLN:  call    OUTC            ; Output character in A
1798: CDFA1C  	KILIN:  call    PRNTCRLF        ; Output CRLF
179B: C39E17  	        jp      TTYLIN          ; Get line again
              	
179E:         	GETLIN:
179E: 213681  	TTYLIN: ld      HL,BUFFER       ; Get a line by character
17A1: 0601    	        ld      B,$01           ; Set buffer as empty
17A3: AF      	        xor     A
17A4: 32A480  	        ld      (NULFLG),A      ; Clear null flag
17A7: CD6A18  	MORINP: call    CLOTST          ; Get character and test ^O
17AA: 4F      	        ld      C,A             ; Save character in C
17AB: FE7F    	        cp      DEL             ; Delete character?
17AD: CA6D17  	        jp      Z,DODEL         ; Yes - Process it
17B0: 3AA480  	        ld      A,(NULFLG)      ; Get null flag
17B3: B7      	        or      A               ; Test null flag status
17B4: CAC017  	        jp      Z,PROCES        ; Reset - Process character
17B7: 3E00    	        ld      A,$00           ; Set a null
17B9: CD2918  	        call    OUTC            ; Output null
17BC: AF      	        xor     A               ; Clear A
17BD: 32A480  	        ld      (NULFLG),A      ; Reset null flag
17C0: 79      	PROCES: ld      A,C             ; Get character
17C1: FE07    	        cp      CTRLG           ; Bell?
17C3: CA0018  	        jp      Z,PUTCTL        ; Yes - Save it
17C6: FE03    	        cp      CTRLC           ; Is it control "C"?
17C8: CCF517  	        call    Z,GMNCR         ; Yes - exit from graphic mode & Output CRLF
17CB: 37      	        scf                     ; Flag break
17CC: C8      	        ret     Z               ; Return if control "C"
17CD: FE0D    	        cp      CR              ; Is it enter?
17CF: CAF01C  	        jp      Z,ENDINP        ; Yes - Terminate input
17D2: FE15    	        cp      CTRLU           ; Is it control "U"?
17D4: CA9817  	        jp      Z,KILIN         ; Yes - Get another line
17D7: FE08    	        cp      BKSP            ; Is it backspace?
17D9: CA8D17  	        jp      Z,DELCHR        ; Yes - Delete character
17DC: FE12    	        cp      CTRLR           ; Is it control "R"?
17DE: C2FB17  	        jp      NZ,PUTBUF       ; No - Put in buffer
17E1: C5      	        push    BC              ; Save buffer length
17E2: D5      	        push    DE              ; Save DE
17E3: E5      	        push    HL              ; Save buffer address
17E4: 3600    	        ld      (HL),$00        ; Mark end of buffer
17E6: CD593C  	        call    OUTNCR          ; Output and do CRLF
17E9: 213681  	        ld      HL,BUFFER       ; Point to buffer start
17EC: CDBE23  	        call    PRS             ; Output buffer
17EF: E1      	        pop     HL              ; Restore buffer address
17F0: D1      	        pop     DE              ; Restore DE
17F1: C1      	        pop     BC              ; Restore buffer length
17F2: C3A717  	        jp      MORINP          ; Get another character
17F5: CD1615  	GMNCR:  call    EXITGM          ; exit from graphic mode
17F8: C3FA1C  	        jp      PRNTCRLF        ; output CRLF
              	
17FB: FE20    	PUTBUF: cp      SPC             ; Is it a control code?
17FD: DAA717  	        jp      C,MORINP        ; Yes - Ignore
1800: 78      	PUTCTL: ld      A,B             ; Get number of bytes in buffer
1801: FE59    	        cp      $58+$01         ; Test for line overflow
1803: 3E08    	        ld      A,BKSP          ; Set a bell
1805: D21218  	        jp      NC,OUTNBS       ; Ring bell if buffer full
1808: 79      	        ld      A,C             ; Get character
1809: 71      	        ld      (HL),C          ; Save in buffer
180A: 32B181  	        ld      (LSTBIN),A      ; Save last input byte
180D: 23      	        inc     HL              ; Move up buffer
180E: 04      	        inc     B               ; Increment length
180F: C3A717  	OUTIT:  jp      MORINP          ; Get another character
              	
1812: CD2918  	OUTNBS: call    OUTC            ; Output bell and back over it
              	        ;ld      A,BKSP          ; send back space
              	        ;call    OUTC            ;
1815: C30F18  	        jp      OUTIT           ; get more chars
              	
1818: 7C      	CPDEHL: ld      A,H             ; Get H
1819: 92      	        sub     D               ; Compare with D
181A: C0      	        ret     NZ              ; Different - Exit
181B: 7D      	        ld      A,L             ; Get L
181C: 93      	        sub     E               ; Compare with E
181D: C9      	        ret                     ; Return status
              	
181E: 7E      	CHKSYN: ld      A,(HL)          ; Check syntax of character
181F: E3      	        ex      (SP),HL         ; Address of test byte
1820: BE      	        cp      (HL)            ; Same as in code string?
1821: 23      	        inc     HL              ; Return address
1822: E3      	        ex      (SP),HL         ; Put it back
1823: CA411A  	        jp      Z,GETCHR        ; Yes - Get next character
1826: C33C15  	        jp      SNERR           ; Different - ?SN Error
              	
1829: F5      	OUTC:   push    AF              ; Save character
182A: 3AA580  	        ld      A,(CTLOFG)      ; Get control "O" flag
182D: B7      	        or      A               ; Is it set?
182E: C2F323  	        jp      NZ,POPAF        ; Yes - don't output
1831: F1      	        pop     AF              ; Restore character
1832: C5      	        push    BC              ; Save buffer length
1833: F5      	        push    AF              ; Save character
1834: FE20    	        cp      SPC             ; Is it a control code?
1836: DA4D18  	        jp      C,DINPOS        ; Yes - Don't inc POS(X)
1839: 3AA280  	        ld      A,(LWIDTH)      ; Get line width
183C: 47      	        ld      B,A             ; To B
183D: 3A9081  	        ld      A,(CURPOS)      ; Get cursor position
1840: 04      	        inc     B               ; Width 255?
1841: CA4918  	        jp      Z,INCLEN        ; Yes - No width limit
1844: 05      	        dec     B               ; Restore width
1845: B8      	        cp      B               ; At end of line?
1846: CCFA1C  	        call    Z,PRNTCRLF      ; Yes - output CRLF
1849: 3C      	INCLEN: inc     A               ; Move on one character
184A: 329081  	        ld      (CURPOS),A      ; Save new position
184D: AF      	DINPOS: xor     A
184E: 322982  	        ld      (KBDNPT),A      ; set flag for no char from keyboard
1851: F1      	        pop     AF              ; Restore character
1852: C1      	        pop     BC              ; Restore buffer length
1853: F5      	        push    AF
1854: CD5C18  	        call    SND2VID         ; send char to video
1857: F1      	        pop     AF
1858: CD3C3C  	        call    MONOUT          ; send char to serial if enabled
185B: C9      	        ret
              	
              	; print char to video if cursor is on
185C: 32EC81  	SND2VID:ld      (CHR4VID),A     ; store A
185F: 3AEB81  	        ld      A,(PRNTVIDEO)   ; check print-on-video
1862: B7      	        or      A               ; is it off?
1863: C8      	        ret     Z               ; yes, so return
1864: F3      	        di                      ; disable INTs
1865: CDAE06  	        call    CHAR2VID        ; cursor is on, so print char on screen
1868: FB      	        ei                      ; re-enable INTs
1869: C9      	        ret                     ; return to caller
              	
186A: CD7A31  	CLOTST: call    GETINP          ; Get input character
186D: FE0F    	        cp      CTRLO           ; Is it control "O"?
186F: C0      	        ret     NZ              ; No don't flip flag
1870: 3AA580  	        ld      A,(CTLOFG)      ; Get flag
1873: 2F      	        cpl                     ; Flip it
1874: 32A580  	        ld      (CTLOFG),A      ; Put it back
1877: A7      	        and     A               ; is output enabled?
1878: CC3808  	        call    Z,CURSOR_ON     ; yes, so cursor on
187B: AF      	        xor     A               ; Null character
187C: C9      	        ret
              	
              	; LIST: list the program stored into memory
187D: C1      	LIST:   pop     BC              ; rubbish - not needed (legacy from original call of LIST)
187E: 2B      	        dec     HL              ; dec 'cos GETCHR INCs
187F: CD411A  	        call    GETCHR          ; Get next character
1882: CACE18  	        jp      Z,LSTALL        ; list all if nothing follows
1885: FEBB    	        cp      ZMINUS          ; is it '-'?
1887: 2020    	        jr      NZ,LST01        ; no, look for a line number
1889: 110000  	        ld      DE,$0000        ; yes, set search from 0
188C: CD6919  	        call    SRCHLIN         ; find address of line number
188F: ED43EF81	        ld      (TMPBFR1),BC    ; store address of starting line
1893: CD1E18  	        call    CHKSYN          ; skip '-'
1896: BB      	        defb    ZMINUS
1897: CD111B  	        call    ATOH            ; now, look for another number (ASCII number to DE)
189A: CD6919  	        call    SRCHLIN         ; find address of line number
189D: ED43F181	        ld      (TMPBFR2),BC    ; store address of ending line
18A1: ED4BEF81	        ld      BC,(TMPBFR1)    ; retrieve address of starting line
18A5: C5      	        push    BC              ; store address of line for later use
18A6: C30019  	        jp      LISTLP          ; go listing
18A9: CD111B  	LST01:  call    ATOH            ; get a line number (ASCII number to DE)
18AC: CD6919  	LST01H: call    SRCHLIN         ; find address of line number
18AF: ED43EF81	        ld      (TMPBFR1),BC    ; store address of starting line
18B3: ED43F181	        ld      (TMPBFR2),BC    ; same address for ending line (we'll change later if needed)
18B7: 2B      	        dec     HL              ; dec 'cos GETCHR INCs
18B8: CD411A  	        call    GETCHR          ; Get next character
18BB: CACA18  	        jp      Z,LST06         ; nothing follows, so ending & starting lines are the same
18BE: FEBB    	        cp      ZMINUS          ; is it '-'?
18C0: CAE618  	        jp      Z,LST03         ; yes, read ending line
18C3: CD6919  	LST04:  call    SRCHLIN         ; find address of line number
18C6: ED43F181	        ld      (TMPBFR2),BC    ; set address of ending line
18CA: C5      	LST06:  push    BC              ; store address for later use
18CB: C30019  	        jp      LISTLP          ; jump to list
18CE: 11F9FF  	LSTALL  ld      DE,65529        ; set ending line to max. allowed line number
18D1: CD6919  	        call    SRCHLIN         ; get address of last line
18D4: ED43F181	        ld      (TMPBFR2),BC    ; store it
18D8: 110000  	        ld      DE,$0000        ; set start to first line in memory
18DB: CD6919  	        call    SRCHLIN         ; get address of first line
18DE: ED43EF81	        ld      (TMPBFR1),BC    ; store it
18E2: C5      	        push    BC              ; store address of starting line for later use
18E3: C30019  	        jp      LISTLP          ; start printing
18E6: CD1E18  	LST03:  call    CHKSYN          ; skip '-'
18E9: BB      	        defb    ZMINUS
18EA: CD111B  	        call    ATOH            ; look for another number (return into DE)
18ED: 7A      	        ld      A,D
18EE: B3      	        or      E               ; is line=0?
18EF: 2003    	        jr      NZ,LST05        ; no, jump over
18F1: 11F9FF  	        ld      DE,65529        ; yes set last valid line number
18F4: CD6919  	LST05:  call    SRCHLIN         ; find address of line number
18F7: ED43F181	        ld      (TMPBFR2),BC    ; store address of ending line
18FB: ED4BEF81	        ld      BC,(TMPBFR1)    ; retrieve address of starting line
18FF: C5      	        push    BC              ; store it for later use
1900: E1      	LISTLP: pop     HL              ; Restore address of line
1901: 4E      	        ld      C,(HL)          ; Get LSB of next line
1902: 23      	        inc     HL
1903: 46      	        ld      B,(HL)          ; Get MSB of next line
1904: 23      	        inc     HL
1905: 78      	        ld      A,B             ; BC = 0 (End of program)?
1906: B1      	        or      C
1907: CA9615  	        jp      Z,PRNTOK        ; Yes - Go to command mode
190A: CD6C1A  	        call    TSTBRK          ; Test for break key
190D: CD6F19  	        call    TSTSPC          ; test for space
1910: C5      	        push    BC              ; Save address of next line
1911: 3AE481  	        ld      A,(SCR_CURS_X)  ; load current X pos of cursor
1914: A7      	        and     A               ; is it at the beginning of a new line?
1915: 200B    	        jr      NZ,LST08        ; No, jump over
1917: 3E0D    	        ld      A,CR            ; yes, so just send a CR
1919: CD3C3C  	        call    MONOUT          ; to serial if it's open
191C: AF      	        xor     A               ; then, set cursor
191D: 329081  	        ld      (CURPOS),A      ; to position 0
1920: 1803    	        jr      LST07           ; and continue
1922: CDFA1C  	LST08:  call    PRNTCRLF        ; output CRLF
1925: 5E      	LST07:  ld      E,(HL)          ; Get LSB of line number
1926: 23      	        inc     HL
1927: 56      	        ld      D,(HL)          ; Get MSB of line number
1928: 23      	        inc     HL
1929: E5      	        push    HL              ; Save address of line start
192A: EB      	        ex      DE,HL           ; Line number to HL
192B: CD5E2E  	        call    PRNTHL          ; Output line number in decimal
192E: 3E20    	        ld      A,SPC           ; Space after line number
1930: E1      	        pop     HL              ; Restore start of line address
1931: CD2918  	LSTLP2: call    OUTC            ; Output character in A
1934: 7E      	LSTLP3: ld      A,(HL)          ; Get next byte in line
1935: B7      	        or      A               ; End of line?
1936: 23      	        inc     HL              ; To next byte in line
1937: CA5B19  	        jp      Z,NXTLN         ; Yes - check next line
193A: F23119  	        jp      P,LSTLP2        ; No token - output it
193D: D67F    	        sub     ZEND-1          ; Find and output word
193F: 4F      	        ld      C,A             ; Token offset+1 to C
1940: 110710  	        ld      DE,WORDS        ; Reserved word list
1943: 1A      	FNDTOK: ld      A,(DE)          ; Get character in list
1944: 13      	        inc     DE              ; Move on to next
1945: B7      	        or      A               ; Is it start of word?
1946: F24319  	        jp      P,FNDTOK        ; No - Keep looking for word
1949: 0D      	        dec     C               ; Count words
194A: C24319  	        jp      NZ,FNDTOK       ; Not there - keep looking
194D: E67F    	OUTWRD: and     %01111111       ; Strip bit 7
194F: CD2918  	        call    OUTC            ; Output character
1952: 1A      	        ld      A,(DE)          ; Get next character
1953: 13      	        inc     DE              ; Move on to next
1954: B7      	        or      A               ; Is it end of word?
1955: F24D19  	        jp      P,OUTWRD        ; No - output the rest
1958: C33419  	        jp      LSTLP3          ; Next byte in line
195B: D1      	NXTLN:  pop     DE              ; recover address of current line
195C: 2AF181  	        ld      HL,(TMPBFR2)    ; address of last line to print
195F: CD5F3C  	        call    CMP16           ; check if current line is over last printable line
1962: DA9615  	        jp      C,PRNTOK        ; finish - leave & print OK
1965: D5      	        push    DE              ; store address of current line
1966: C30019  	        jp      LISTLP          ; continue listing
1969: E5      	SRCHLIN:push    HL              ; store HL (this is needed because HL store the pointer to the input buffer)
196A: CD4216  	        call    SRCHLN          ; search for line number in DE
196D: E1      	        pop     HL              ; retrieve HL
196E: C9      	        ret                     ; return to caller
              	
              	; during LISTing, check if PAUSE is pressed, then pause listing and
              	; wait for another pressing of PAUSE to continue or CTRL-C/BREAK to exit
196F: 3A2B82  	TSTSPC: ld      A,(TMPKEYBFR)   ; Get input character
1972: FE20    	        cp      SPC             ; Is it SPACE?
1974: C0      	        ret     NZ              ; No, return
1975: CD7A31  	WTSPC   call    GETINP          ; Yes, stop listing and wait for another space or BREAK
1978: FE20    	        cp      SPC             ; is it SPACE?
197A: 2005    	        jr      NZ,CNTWTSP      ; no, continue
197C: AF      	        xor     A
197D: 322B82  	        ld      (TMPKEYBFR),A   ; reset key
1980: C9      	        ret                     ; return to caller
1981: FE03    	CNTWTSP:cp      CTRLC           ; is it CTRL-C/BREAK?
1983: 20F0    	        jr      NZ,WTSPC        ; no, loop
1985: C3710F  	        jp      BRKRET          ; exit and output "Ok"
              	
              	
1988: 3E64    	FOR:    ld      A,$64           ; Flag "FOR" assignment
198A: 32B081  	        ld      (FORFLG),A      ; Save "FOR" flag
198D: CDFB1B  	        call    LET             ; Set up initial index
1990: C1      	        pop     BC              ; Drop RETurn address
1991: E5      	        push    HL              ; Save code string address
1992: CDE41B  	        call    DATA            ; Get next statement address
1995: 22AC81  	        ld      (LOOPST),HL     ; Save it for start of loop
1998: 210200  	        ld      HL,$0002        ; Offset for "FOR" block
199B: 39      	        add     HL,SP           ; Point to it
199C: CDC914  	FORSLP: call    LOKFOR          ; Look for existing "FOR" block
199F: D1      	        pop     DE              ; Get code string address
19A0: C2B819  	        jp      NZ,FORFND       ; No nesting found
19A3: 09      	        add     HL,BC           ; Move into "FOR" block
19A4: D5      	        push    DE              ; Save code string address
19A5: 2B      	        dec     HL
19A6: 56      	        ld      D,(HL)          ; Get MSB of loop statement
19A7: 2B      	        dec     HL
19A8: 5E      	        ld      E,(HL)          ; Get LSB of loop statement
19A9: 23      	        inc     HL
19AA: 23      	        inc     HL
19AB: E5      	        push    HL              ; Save block address
19AC: 2AAC81  	        ld      HL,(LOOPST)     ; Get address of loop statement
19AF: CD1818  	        call    CPDEHL          ; Compare the FOR loops
19B2: E1      	        pop     HL              ; Restore block address
19B3: C29C19  	        jp      NZ,FORSLP       ; Different FORs - Find another
19B6: D1      	        pop     DE              ; Restore code string address
19B7: F9      	        ld      SP,HL           ; Remove all nested loops
              	
19B8: EB      	FORFND: ex      DE,HL           ; Code string address to HL
19B9: 0E08    	        ld      C,$08
19BB: CDF914  	        call    CHKSTK          ; Check for 8 levels of stack
19BE: E5      	        push    HL              ; Save code string address
19BF: 2AAC81  	        ld      HL,(LOOPST)     ; Get first statement of loop
19C2: E3      	        ex      (SP),HL         ; Save and restore code string
19C3: E5      	        push    HL              ; Re-save code string address
19C4: 2AAF80  	        ld      HL,(LINEAT)     ; Get current line number
19C7: E3      	        ex      (SP),HL         ; Save and restore code string
19C8: CDB91E  	        call    TSTNUM          ; Make sure it's a number
19CB: CD1E18  	        call    CHKSYN          ; Make sure "TO" is next
19CE: B4      	        defb    ZTO             ; "TO" token
19CF: CDB61E  	        call    GETNUM          ; Get "TO" expression value
19D2: E5      	        push    HL              ; Save code string address
19D3: CD102D  	        call    BCDEFP          ; Move "TO" value to BCDE
19D6: E1      	        pop     HL              ; Restore code string address
19D7: C5      	        push    BC              ; Save "TO" value in block
19D8: D5      	        push    DE
19D9: 010081  	        ld      BC,$8100        ; BCDE - 1 (default STEP)
19DC: 51      	        ld      D,C             ; C=0
19DD: 5A      	        ld      E,D             ; D=0
19DE: 7E      	        ld      A,(HL)          ; Get next byte in code string
19DF: FEB9    	        cp      ZSTEP           ; See if "STEP" is stated
19E1: 3E01    	        ld      A,$01           ; Sign of step = 1
19E3: C2F419  	        jp      NZ,SAVSTP       ; No STEP given - Default to 1
19E6: CD411A  	        call    GETCHR          ; Jump over "STEP" token
19E9: CDB61E  	        call    GETNUM          ; Get step value
19EC: E5      	        push    HL              ; Save code string address
19ED: CD102D  	        call    BCDEFP          ; Move STEP to BCDE
19F0: CDC42C  	        call    TSTSGN          ; Test sign of FPREG
19F3: E1      	        pop     HL              ; Restore code string address
19F4: C5      	SAVSTP: push    BC              ; Save the STEP value in block
19F5: D5      	        push    DE
19F6: F5      	        push    AF              ; Save sign of STEP
19F7: 33      	        inc     SP              ; Don't save flags
19F8: E5      	        push    HL              ; Save code string address
19F9: 2AB381  	        ld      HL,(BRKLIN)     ; Get address of index variable
19FC: E3      	        ex      (SP),HL         ; Save and restore code string
19FD: 0681    	PUTFID: ld      B,ZFOR          ; "FOR" block marker
19FF: C5      	        push    BC              ; Save it
1A00: 33      	        inc     SP              ; Don't save C
              	
1A01: CD6C1A  	RUNCNT: call    TSTBRK          ; Execution driver - Test break
1A04: 22B381  	        ld      (BRKLIN),HL     ; Save code address for break
1A07: 7E      	        ld      A,(HL)          ; Get next byte in code string
1A08: FE3A    	        cp      ':'             ; Multi statement line?
1A0A: CA211A  	        jp      Z,EXCUTE        ; Yes - Execute it
1A0D: B7      	        or      A               ; End of line?
1A0E: C23C15  	        jp      NZ,SNERR        ; No - Syntax error
1A11: 23      	        inc     HL              ; Point to address of next line
1A12: 7E      	        ld      A,(HL)          ; Get LSB of line pointer
1A13: 23      	        inc     HL
1A14: B6      	        or      (HL)            ; Is it zero (End of prog)?
1A15: CA931A  	        jp      Z,ENDPRG        ; Yes - Terminate execution
1A18: 23      	        inc     HL              ; Point to line number
1A19: 5E      	        ld      E,(HL)          ; Get LSB of line number
1A1A: 23      	        inc     HL
1A1B: 56      	        ld      D,(HL)          ; Get MSB of line number
1A1C: EB      	        ex      DE,HL           ; Line number to HL
1A1D: 22AF80  	        ld      (LINEAT),HL     ; Save as current line number
1A20: EB      	        ex      DE,HL           ; Line number back to DE
1A21: CD411A  	EXCUTE: call    GETCHR          ; Get key word
1A24: 11011A  	        ld      DE,RUNCNT       ; Where to RETurn to
1A27: D5      	        push    DE              ; Save for RETurn
1A28: C8      	IFJMP:  ret     Z               ; Go to RUNCNT if end of STMT
              	
1A29: D680    	ONJMP:  sub     ZEND            ; Is it a token?
1A2B: DAFB1B  	        jp      C,LET           ; No - try to assign it
1A2E: FE33    	        cp      ZNEW+1-ZEND     ; END to NEW ?
1A30: D23C15  	        jp      NC,SNERR        ; Not a key word - ?SN Error
1A33: 07      	        rlca                    ; Double it
1A34: 4F      	        ld      C,A             ; BC = Offset into table
1A35: 0600    	        ld      B,0
1A37: EB      	        ex      DE,HL           ; Save code string address
1A38: 218711  	        ld      HL,WORDTB       ; Keyword address table
1A3B: 09      	        add     HL,BC           ; Point to routine address
1A3C: 4E      	        ld      C,(HL)          ; Get LSB of routine address
1A3D: 23      	        inc     HL
1A3E: 46      	        ld      B,(HL)          ; Get MSB of routine address
1A3F: C5      	        push    BC              ; Save routine address
1A40: EB      	        ex      DE,HL           ; Restore code string address
              	
              	; get a char from input buffer: exit with NC if character found is
              	; not a number; exit with Z if nothing found; char is into A
1A41: 23      	GETCHR: inc     HL              ; Point to next character
1A42: 7E      	        ld      A,(HL)          ; Get next code string byte
1A43: FE3A    	        cp      ':'             ; Z if ':'
1A45: D0      	        ret     NC              ; NC if > "9"
1A46: FE20    	        cp      SPC
1A48: CA411A  	        jp      Z,GETCHR        ; Skip over spaces
1A4B: FE30    	        cp      '0'
1A4D: 3F      	        ccf                     ; NC if < '0'
1A4E: 3C      	        inc     A               ; Test for zero - Leave carry
1A4F: 3D      	        dec     A               ; Z if Null
1A50: C9      	        ret
              	
1A51: EB      	RESTOR: ex      DE,HL           ; Save code string address
1A52: 2A3381  	        ld      HL,(BASTXT)     ; Point to start of program
1A55: CA661A  	        jp      Z,RESTNL        ; Just RESTORE - reset pointer
1A58: EB      	        ex      DE,HL           ; Restore code string address
1A59: CD111B  	        call    ATOH            ; Get line number to DE
1A5C: E5      	        push    HL              ; Save code string address
1A5D: CD4216  	        call    SRCHLN          ; Search for line number in DE
1A60: 60      	        ld      H,B             ; HL = Address of line
1A61: 69      	        ld      L,C
1A62: D1      	        pop     DE              ; Restore code string address
1A63: D2BA1B  	        jp      NC,ULERR        ; ?UL Error if not found
1A66: 2B      	RESTNL: dec     HL              ; Byte before DATA statement
1A67: 22C181  	UPDATA: ld      (NXTDAT),HL     ; Update DATA pointer
1A6A: EB      	        ex      DE,HL           ; Restore code string address
1A6B: C9      	        ret
              	
              	
1A6C: DF      	TSTBRK: rst     $18             ; Check input status
1A6D: C8      	        ret     Z               ; No key, go back
1A6E: D7      	        rst     $10             ; Get the key into A
1A6F: FE1B    	        cp      ESC             ; Escape key?
1A71: 2811    	        jr      Z,BRK           ; Yes, break
1A73: FE03    	        cp      CTRLC           ; <Ctrl-C>
1A75: 280D    	        jr      Z,BRK           ; Yes, break
1A77: FE13    	        cp      CTRLS           ; Stop scrolling?
1A79: C0      	        ret     NZ              ; Other key, ignore
              	
              	
1A7A: D7      	STALL:  rst     $10             ; Wait for key
1A7B: FE11    	        cp      CTRLQ           ; Resume scrolling?
1A7D: C8      	        ret     Z               ; Release the chokehold
1A7E: FE03    	        cp      CTRLC           ; Second break?
1A80: 2807    	        jr      Z,STOP          ; Break during hold exits prog
1A82: 18F6    	        jr      STALL           ; Loop until <Ctrl-Q> or <brk>
              	
1A84: 3EFF    	BRK:    ld      A,$FF           ; Set BRKFLG
1A86: 32A980  	        ld      (BRKFLG),A      ; Store it
              	
1A89: C0      	STOP:   ret     NZ              ; Exit if anything else
1A8A: F6      	        defb    $F6             ; Flag "STOP"
1A8B: C0      	PEND:   ret     NZ              ; Exit if anything else
1A8C: 22B381  	        ld      (BRKLIN),HL     ; Save point of break
1A8F: 21      	        defb    $21             ; Skip "OR 11111111B"
1A90: F6FF    	INPBRK: or      %11111111       ; Flag "Break" wanted
1A92: C1      	        pop     BC              ; Return not needed and more
1A93: 2AAF80  	ENDPRG: ld      HL,(LINEAT)     ; Get current line number
1A96: F5      	        push    AF              ; Save STOP / END status
1A97: 7D      	        ld      A,L             ; Is it direct break?
1A98: A4      	        and     H
1A99: 3C      	        inc     A               ; Line is -1 if direct break
1A9A: CAA61A  	        jp      Z,NOLIN         ; Yes - No line number
1A9D: 22B781  	        ld      (ERRLIN),HL     ; Save line of break
1AA0: 2AB381  	        ld      HL,(BRKLIN)     ; Get point of break
1AA3: 22B981  	        ld      (CONTAD),HL     ; Save point to CONTinue
1AA6: AF      	NOLIN:  xor     A
1AA7: 32A580  	        ld      (CTLOFG),A      ; Enable output
1AAA: CDE81C  	        call    STTLIN          ; Start a new line
1AAD: F1      	        pop     AF              ; Restore STOP / END status
1AAE: 21BF14  	        ld      HL,BRKMSG       ; "Break" message
1AB1: C2B71A  	        jp      NZ,ERRINT       ; "in line" wanted?
1AB4: C39615  	        jp      PRNTOK          ; Go to command mode
1AB7: CD1615  	ERRINT: call    EXITGM          ; exit from graphics mode
1ABA: C37415  	        jp      ERRIN           ; print message
              	
              	
1ABD: 21FFFF  	CONT:   ld      HL,-1           ; reset...
1AC0: 22B180  	        ld      (HLPLN),HL      ; ...HELP line register
1AC3: 2AB981  	        ld      HL,(CONTAD)     ; Get CONTinue address
1AC6: 7C      	        ld      A,H             ; Is it zero?
1AC7: B5      	        or      L
1AC8: 1E20    	        ld      E,CN            ; ?CN Error
1ACA: CA5015  	        jp      Z,ERROR         ; Yes - output "?CN Error"
1ACD: EB      	        ex      DE,HL           ; Save code string address
1ACE: 2AB781  	        ld      HL,(ERRLIN)     ; Get line of last break
1AD1: 22AF80  	        ld      (LINEAT),HL     ; Set up current line number
1AD4: EB      	        ex      DE,HL           ; Restore code string address
1AD5: C9      	        ret                     ; CONTinue where left off
              	
1AD6: E5      	ACCSUM: push    HL              ; Save address in array
1AD7: 2AA680  	        ld      HL,(CHKSUM)     ; Get check sum
1ADA: 0600    	        ld      B,$00           ; BC - Value of byte
1ADC: 4F      	        ld      C,A
1ADD: 09      	        add     HL,BC           ; Add byte to check sum
1ADE: 22A680  	        ld      (CHKSUM),HL     ; Re-save check sum
1AE1: E1      	        pop     HL              ; Restore address in array
1AE2: C9      	        ret
              	
1AE3: 7E      	CHKLTR: ld      A,(HL)          ; Get byte
1AE4: FE41    	        cp      'A'             ; < 'a' ?
1AE6: D8      	        ret     C               ; Carry set if not letter
1AE7: FE5B    	        cp      'Z'+1           ; > 'z' ?
1AE9: 3F      	        ccf
1AEA: C9      	        ret                     ; Carry set if not letter
              	
1AEB: CD411A  	FPSINT: call    GETCHR          ; Get next character
1AEE: CDB61E  	POSINT: call    GETNUM          ; Get integer 0 to 32767
1AF1: CDC42C  	DEPINT: call    TSTSGN          ; Test sign of FPREG
1AF4: FA0C1B  	        jp      M,FCERR         ; Negative - ?FC Error
1AF7: 3ACC81  	DEINT:  ld      A,(FPEXP)       ; Get integer value to DE
1AFA: FE90    	        cp      $80+$10         ; Exponent in range (16 bits)?
1AFC: DA6C2D  	        jp      C,FPINT         ; Yes - convert it
1AFF: 018090  	        ld      BC,$9080        ; BCDE = -32768
1B02: 110000  	        ld      DE,$0000
1B05: E5      	        push    HL              ; Save code string address
1B06: CD3F2D  	        call    CMPNUM          ; Compare FPREG with BCDE
1B09: E1      	        pop     HL              ; Restore code string address
1B0A: 51      	        ld      D,C             ; MSB to D
1B0B: C8      	        ret     Z               ; Return if in range
1B0C: 1E08    	FCERR:  ld      E,FC            ; ?FC Error
1B0E: C35015  	        jp      ERROR           ; Output error-
              	
1B11: 2B      	ATOH:   dec     HL              ; ASCII number to DE binary
1B12: 110000  	GETLN:  ld      DE,$0000        ; Get number to DE
1B15: CD411A  	GTLNLP: call    GETCHR          ; Get next character
1B18: D0      	        ret     NC              ; Exit if not a digit
1B19: E5      	        push    HL              ; Save code string address
1B1A: F5      	        push    AF              ; Save digit
1B1B: 219819  	        ld      HL,65529/10     ; Largest number 65529
1B1E: CD1818  	        call    CPDEHL          ; Number in range?
1B21: DA3C15  	        jp      C,SNERR         ; No - ?SN Error
1B24: 62      	        ld      H,D             ; HL = Number
1B25: 6B      	        ld      L,E
1B26: 19      	        add     HL,DE           ; Times 2
1B27: 29      	        add     HL,HL           ; Times 4
1B28: 19      	        add     HL,DE           ; Times 5
1B29: 29      	        add     HL,HL           ; Times 10
1B2A: F1      	        pop     AF              ; Restore digit
1B2B: D630    	        sub     '0'             ; Make it 0 to 9
1B2D: 5F      	        ld      E,A             ; DE = Value of digit
1B2E: 1600    	        ld      D,0
1B30: 19      	        add     HL,DE           ; Add to number
1B31: EB      	        ex      DE,HL           ; Number to DE
1B32: E1      	        pop     HL              ; Restore code string address
1B33: C3151B  	        jp      GTLNLP          ; Go to next character
              	
1B36: CA7216  	CLEAR:  jp      Z,INTVAR        ; Just "CLEAR" Keep parameters
1B39: CDEE1A  	        call    POSINT          ; Get integer 0 to 32767 to DE
1B3C: 2B      	        dec     HL              ; Cancel increment
1B3D: CD411A  	        call    GETCHR          ; Get next character
1B40: E5      	        push    HL              ; Save code string address
1B41: 2A9481  	        ld      HL,(LSTRAM)     ; Get end of RAM
1B44: CA591B  	        jp      Z,STORED        ; No value given - Use stored
1B47: E1      	        pop     HL              ; Restore code string address
1B48: CD1E18  	        call    CHKSYN          ; Check for comma
1B4B: 2C      	        defb    ','
1B4C: D5      	        push    DE              ; Save number
1B4D: CDEE1A  	        call    POSINT          ; Get integer 0 to 32767
1B50: 2B      	        dec     HL              ; Cancel increment
1B51: CD411A  	        call    GETCHR          ; Get next character
1B54: C23C15  	        jp      NZ,SNERR        ; ?SN Error if more on line
1B57: E3      	        ex      (SP),HL         ; Save code string address
1B58: EB      	        ex      DE,HL           ; Number to DE
1B59: 7D      	STORED: ld      A,L             ; Get LSB of new RAM top
1B5A: 93      	        sub     E               ; Subtract LSB of string space
1B5B: 5F      	        ld      E,A             ; Save LSB
1B5C: 7C      	        ld      A,H             ; Get MSB of new RAM top
1B5D: 9A      	        sbc     A,D             ; Subtract MSB of string space
1B5E: 57      	        ld      D,A             ; Save MSB
1B5F: DA1115  	        jp      C,OMERR         ; ?OM Error if not enough mem
1B62: E5      	        push    HL              ; Save RAM top
1B63: 2ABB81  	        ld      HL,(PROGND)     ; Get program end
1B66: 012800  	        ld      BC,$28          ; 40 Bytes minimum working RAM
1B69: 09      	        add     HL,BC           ; Get lowest address
1B6A: CD1818  	        call    CPDEHL          ; Enough memory?
1B6D: D21115  	        jp      NC,OMERR        ; No - ?OM Error
1B70: EB      	        ex      DE,HL           ; RAM top to HL
1B71: 22AD80  	        ld      (STRSPC),HL     ; Set new string space
1B74: E1      	        pop     HL              ; End of memory to use
1B75: 229481  	        ld      (LSTRAM),HL     ; Set new top of RAM
1B78: E1      	        pop     HL              ; Restore code string address
1B79: C37216  	        jp      INTVAR          ; Initialise variables
              	
1B7C: E5      	RUN:    push    HL              ; store HL
1B7D: 21FFFF  	        ld      HL,-1           ; reset...
1B80: 22B180  	        ld      (HLPLN),HL      ; ...HELP line register
1B83: E1      	        pop     HL              ; retrieve HL
1B84: CA6E16  	        jp      Z,RUNFST        ; RUN from start if just RUN
1B87: CD7216  	        call    INTVAR          ; Initialise variables
1B8A: 01011A  	        ld      BC,RUNCNT       ; Execution driver loop
1B8D: C3A01B  	        jp      RUNLIN          ; RUN from line number
              	
1B90: 0E03    	GOSUB:  ld      C,$03           ; 3 Levels of stack needed
1B92: CDF914  	        call    CHKSTK          ; Check for 3 levels of stack
1B95: C1      	        pop     BC              ; Get return address
1B96: E5      	        push    HL              ; Save code string for RETURN
1B97: E5      	        push    HL              ; And for GOSUB routine
1B98: 2AAF80  	        ld      HL,(LINEAT)     ; Get current line
1B9B: E3      	        ex      (SP),HL         ; Into stack - Code string out
1B9C: 3E8C    	        ld      A,ZGOSUB        ; "GOSUB" token
1B9E: F5      	        push    AF              ; Save token
1B9F: 33      	        inc     SP              ; Don't save flags
              	
1BA0: C5      	RUNLIN: push    BC              ; Save return address
1BA1: CD111B  	GOTO:   call    ATOH            ; ASCII number to DE binary
1BA4: CDE61B  	        call    REM             ; Get end of line
1BA7: E5      	        push    HL              ; Save end of line
1BA8: 2AAF80  	        ld      HL,(LINEAT)     ; Get current line
1BAB: CD1818  	        call    CPDEHL          ; Line after current?
1BAE: E1      	        pop     HL              ; Restore end of line
1BAF: 23      	        inc     HL              ; Start of next line
1BB0: DC4516  	        call    C,SRCHLP        ; Line is after current line
1BB3: D44216  	        call    NC,SRCHLN       ; Line is before current line
1BB6: 60      	        ld      H,B             ; Set up code string address
1BB7: 69      	        ld      L,C
1BB8: 2B      	        dec     HL              ; Incremented after
1BB9: D8      	        ret     C               ; Line found
1BBA: 1E0E    	ULERR:  ld      E,UL            ; ?UL Error
1BBC: C35015  	        jp      ERROR           ; Output error message
              	
1BBF: C0      	RETURN: ret     NZ              ; Return if not just RETURN
1BC0: 16FF    	        ld      D,-1            ; Flag "GOSUB" search
1BC2: CDC514  	        call    BAKSTK          ; Look "GOSUB" block
1BC5: F9      	        ld      SP,HL           ; Kill all FORs in subroutine
1BC6: FE8C    	        cp      ZGOSUB          ; Test for "GOSUB" token
1BC8: 1E04    	        ld      E,RG            ; ?RG Error
1BCA: C25015  	        jp      NZ,ERROR        ; Error if no "GOSUB" found
1BCD: E1      	        pop     HL              ; Get RETURN line number
1BCE: 22AF80  	        ld      (LINEAT),HL     ; Save as current
1BD1: 23      	        inc     HL              ; Was it from direct statement?
1BD2: 7C      	        ld      A,H
1BD3: B5      	        or      L               ; Return to line
1BD4: C2DE1B  	        jp      NZ,RETLIN       ; No - Return to line
1BD7: 3AB181  	        ld      A,(LSTBIN)      ; Any INPUT in subroutine?
1BDA: B7      	        or      A               ; If so buffer is corrupted
1BDB: C29515  	        jp      NZ,POPNOK       ; Yes - Go to command mode
1BDE: 21011A  	RETLIN: ld      HL,RUNCNT       ; Execution driver loop
1BE1: E3      	        ex      (SP),HL         ; Into stack - Code string out
1BE2: 3E      	        defb    $3E             ; Skip "pop HL"
1BE3: E1      	NXTDTA: pop     HL              ; Restore code string address
              	
1BE4: 013A    	DATA:   defb    $01,$3A         ; ':' End of statement
1BE6: 0E00    	REM:    ld      C,$00           ; 00  End of statement
1BE8: 0600    	        ld      B,$00
1BEA: 79      	NXTSTL: ld      A,C             ; Statement and byte
1BEB: 48      	        ld      C,B
1BEC: 47      	        ld      B,A             ; Statement end byte
1BED: 7E      	NXTSTT: ld      A,(HL)          ; Get byte
1BEE: B7      	        or      A               ; End of line?
1BEF: C8      	        ret     Z               ; Yes - Exit
1BF0: B8      	        cp      B               ; End of statement?
1BF1: C8      	        ret     Z               ; Yes - Exit
1BF2: 23      	        inc     HL              ; Next byte
1BF3: FE22    	        cp      $22             ; '"'             ; Literal string?
1BF5: CAEA1B  	        jp      Z,NXTSTL        ; Yes - Look for another '"'
1BF8: C3ED1B  	        jp      NXTSTT          ; Keep looking
              	
1BFB: CDC520  	LET:    call    GETVAR          ; Get variable name
1BFE: CD1E18  	        call    CHKSYN          ; Make sure "=" follows
1C01: C5      	        defb    ZEQUAL          ; "=" token
1C02: D5      	        push    DE              ; Save address of variable
1C03: 3A9281  	        ld      A,(TYPE)        ; Get data type
1C06: F5      	        push    AF              ; Save type
1C07: CDC81E  	        call    EVAL            ; Evaluate expression
1C0A: F1      	        pop     AF              ; Restore type
1C0B: E3      	        ex      (SP),HL         ; Save code - Get var addr
1C0C: 22B381  	        ld      (BRKLIN),HL     ; Save address of variable
1C0F: 1F      	        rra                     ; Adjust type
1C10: CDBB1E  	        call    CHKTYP          ; Check types are the same
1C13: CA4E1C  	        jp      Z,LETNUM        ; Numeric - Move value
1C16: E5      	LETSTR: push    HL              ; Save address of string var
1C17: 2AC981  	        ld      HL,(FPREG)      ; Pointer to string entry
1C1A: E5      	        push    HL              ; Save it on stack
1C1B: 23      	        inc     HL              ; Skip over length
1C1C: 23      	        inc     HL
1C1D: 5E      	        ld      E,(HL)          ; LSB of string address
1C1E: 23      	        inc     HL
1C1F: 56      	        ld      D,(HL)          ; MSB of string address
1C20: 2A3381  	        ld      HL,(BASTXT)     ; Point to start of program
1C23: CD1818  	        call    CPDEHL          ; Is string before program?
1C26: D23D1C  	        jp      NC,CRESTR       ; Yes - Create string entry
1C29: 2AAD80  	        ld      HL,(STRSPC)     ; Point to string space
1C2C: CD1818  	        call    CPDEHL          ; Is string literal in program?
1C2F: D1      	        pop     DE              ; Restore address of string
1C30: D2451C  	        jp      NC,MVSTPT       ; Yes - Set up pointer
1C33: 21A481  	        ld      HL,TMPSTR       ; Temporary string pool
1C36: CD1818  	        call    CPDEHL          ; Is string in temporary pool?
1C39: D2451C  	        jp      NC,MVSTPT       ; No - Set up pointer
1C3C: 3E      	        defb    $3E             ; Skip "pop DE"
1C3D: D1      	CRESTR: pop     DE              ; Restore address of string
1C3E: CD1F25  	        call    BAKTMP          ; Back to last tmp-str entry
1C41: EB      	        ex      DE,HL           ; Address of string entry
1C42: CD5823  	        call    SAVSTR          ; Save string in string area
1C45: CD1F25  	MVSTPT: call    BAKTMP          ; Back to last tmp-str entry
1C48: E1      	        pop     HL              ; Get string pointer
1C49: CD1F2D  	        call    DETHL4          ; Move string pointer to var
1C4C: E1      	        pop     HL              ; Restore code string address
1C4D: C9      	        ret
              	
1C4E: E5      	LETNUM: push    HL              ; Save address of variable
1C4F: CD1C2D  	        call    FPTHL           ; Move value to variable
1C52: D1      	        pop     DE              ; Restore address of variable
1C53: E1      	        pop     HL              ; Restore code string address
1C54: C9      	        ret
              	
1C55: CD3C27  	ON:     call    GETINT          ; Get integer 0-255
1C58: 7E      	        ld      A,(HL)          ; Get "GOTO" or "GOSUB" token
1C59: 47      	        ld      B,A             ; Save in B
1C5A: FE8C    	        cp      ZGOSUB          ; "GOSUB" token?
1C5C: CA641C  	        jp      Z,ONGO          ; Yes - Find line number
1C5F: CD1E18  	        call    CHKSYN          ; Make sure it's "GOTO"
1C62: 88      	        defb    ZGOTO           ; "GOTO" token
1C63: 2B      	        dec     HL              ; Cancel increment
1C64: 4B      	ONGO:   ld      C,E             ; Integer of branch value
1C65: 0D      	ONGOLP: dec     C               ; Count branches
1C66: 78      	        ld      A,B             ; Get "GOTO" or "GOSUB" token
1C67: CA291A  	        jp      Z,ONJMP         ; Go to that line if right one
1C6A: CD121B  	        call    GETLN           ; Get line number to DE
1C6D: FE2C    	        cp      ','             ; Another line number?
1C6F: C0      	        ret     NZ              ; No - Drop through
1C70: C3651C  	        jp      ONGOLP          ; Yes - loop
              	
1C73: CDC81E  	IF:     call    EVAL            ; Evaluate expression
1C76: 7E      	        ld      A,(HL)          ; Get token
1C77: FE88    	        cp      ZGOTO           ; "GOTO" token?
1C79: CA811C  	        jp      Z,IFGO          ; Yes - Get line
1C7C: CD1E18  	        call    CHKSYN          ; Make sure it's "THEN"
1C7F: B7      	        defb    ZTHEN           ; "THEN" token
1C80: 2B      	        dec     HL              ; Cancel increment
1C81: CDB91E  	IFGO:   call    TSTNUM          ; Make sure it's numeric
1C84: CDC42C  	        call    TSTSGN          ; Test state of expression
1C87: CAE61B  	        jp      Z,REM           ; False - Drop through
1C8A: CD411A  	        call    GETCHR          ; Get next character
1C8D: DAA11B  	        jp      C,GOTO          ; Number - GOTO that line
1C90: C3281A  	        jp      IFJMP           ; Otherwise do statement
              	
1C93: 2B      	MRPRNT: dec     HL              ; dec 'cos GETCHR INCs
1C94: CD411A  	        call    GETCHR          ; Get next character
1C97: CAFA1C  	PRINT:  jp      Z,PRNTCRLF      ; CRLF if just PRINT
1C9A: C8      	PRNTLP: ret     Z               ; End of list - Exit
1C9B: FEB3    	        cp      ZTAB            ; "TAB(" token?
1C9D: CA221D  	        jp      Z,DOTAB         ; Yes - Do TAB routine
1CA0: FEB6    	        cp      ZSPC            ; "SPC(" token?
1CA2: CA221D  	        jp      Z,DOTAB         ; Yes - Do SPC routine
1CA5: E5      	        push    HL              ; Save code string address
1CA6: FE2C    	        cp      ','             ; Comma?
1CA8: CA091D  	        jp      Z,DOCOM         ; Yes - Move to next zone
1CAB: FE3B    	        cp      ';'             ; Semi-colon?
1CAD: CA461D  	        jp      Z,NEXITM        ; Do semi-colon routine
1CB0: C1      	        pop     BC              ; Code string address to BC
1CB1: CDC81E  	        call    EVAL            ; Evaluate expression
1CB4: E5      	        push    HL              ; Save code string address
1CB5: 3A9281  	        ld      A,(TYPE)        ; Get variable type
1CB8: B7      	        or      A               ; Is it a string variable?
1CB9: C2E11C  	        jp      NZ,PRNTST       ; Yes - Output string contents
1CBC: CD692E  	        call    NUMASC          ; Convert number to text
1CBF: CD7C23  	        call    CRTST           ; Create temporary string
1CC2: 3600    	        ld      (HL),NLLCR      ; Followed by a NULL char (was SPC, space)
1CC4: 2AC981  	        ld      HL,(FPREG)      ; Get length of output
1CC7: 34      	        inc     (HL)            ; Plus 1 for the space
1CC8: 2AC981  	        ld      HL,(FPREG)      ; < Not needed >
1CCB: 3AA280  	        ld      A,(LWIDTH)      ; Get width of line
1CCE: 47      	        ld      B,A             ; To B
1CCF: 04      	        inc     B               ; Width 255 (No limit)?
1CD0: CADD1C  	        jp      Z,PRNTNB        ; Yes - Output number string
1CD3: 04      	        inc     B               ; Adjust it
1CD4: 3A9081  	        ld      A,(CURPOS)      ; Get cursor position
1CD7: 86      	        add     A,(HL)          ; Add length of string
1CD8: 3D      	        dec     A               ; Adjust it
1CD9: B8      	        cp      B               ; Will output fit on this line?
1CDA: D4FA1C  	        call    NC,PRNTCRLF     ; No - CRLF first
1CDD: CDC123  	PRNTNB: call    PRS1            ; Output string at (HL)
1CE0: AF      	        xor     A               ; Skip call by setting 'z' flag
1CE1: C4C123  	PRNTST: call    NZ,PRS1         ; Output string at (HL)
1CE4: E1      	        pop     HL              ; Restore code string address
1CE5: C3931C  	        jp      MRPRNT          ; See if more to PRINT
              	
1CE8: 3A9081  	STTLIN: ld      A,(CURPOS)      ; Make sure on new line
1CEB: B7      	        or      A               ; Already at start?
1CEC: C8      	        ret     Z               ; Yes - Do nothing
1CED: C3FA1C  	        jp      PRNTCRLF        ; Start a new line
              	
1CF0: AF      	ENDINP: xor     A
1CF1: 322982  	        ld      (KBDNPT),A      ; char is not from keyboard
1CF4: 77      	        ld      (HL),A          ; Mark end of buffer
1CF5: 213581  	        ld      HL,BUFFER-1     ; Point to buffer
1CF8: 180A    	        jr      CNTEND
1CFA: 3E0D    	PRNTCRLF:ld     A,CR            ; Load a CR
1CFC: CD2918  	        call    OUTC            ; Output character
1CFF: 3E0A    	        ld      A,LF            ; Load a LF
1D01: CD2918  	        call    OUTC            ; Output character
1D04: AF      	CNTEND: xor     A               ; Set to position 0
1D05: 329081  	        ld      (CURPOS),A      ; Store it
1D08: C9      	        ret                     ; return to caller
              	
1D09: 3AA380  	DOCOM:  ld      A,(COMMAN)      ; Get comma width
1D0C: 47      	        ld      B,A             ; Save in B
1D0D: 3A9081  	        ld      A,(CURPOS)      ; Get current position
1D10: B8      	        cp      B               ; Within the limit?
1D11: D4FA1C  	        call    NC,PRNTCRLF     ; No - output CRLF
1D14: D2461D  	        jp      NC,NEXITM       ; Get next item
1D17: D60E    	ZONELP: sub     $0E             ; Next zone of 14 characters
1D19: D2171D  	        jp      NC,ZONELP       ; Repeat if more zones
1D1C: 2F      	        cpl                     ; Number of null chars to output
1D1D: 0E00    	        ld      C,NLLCR         ; null char
1D1F: C33C1D  	        jp      ASPCS           ; Output them
              	
1D22: F5      	DOTAB:  push    AF              ; Save token
1D23: CD3927  	        call    FNDNUM          ; Evaluate expression
1D26: CD1E18  	        call    CHKSYN          ; Make sure ")" follows
1D29: 29      	        defb    ')'
1D2A: 2B      	        dec     HL              ; Back space on to ")"
1D2B: F1      	        pop     AF              ; Restore token
1D2C: 0E00    	        ld      C,NLLCR         ; for SPC we use NULL char (was SPACE)
1D2E: D6B6    	        sub     ZSPC            ; Was it "SPC(" ?
1D30: E5      	        push    HL              ; Save code string address
1D31: CA371D  	        jp      Z,DOSPC         ; Yes - Do 'E' spaces
1D34: 3AE481  	        ld      A,(SCR_CURS_X)  ; Get current X position
1D37: 2F      	DOSPC:  cpl                     ; Number of spaces to print to
1D38: 83      	        add     A,E             ; Total number to print
1D39: D2461D  	        jp      NC,NEXITM       ; TAB < Current POS(X)
1D3C: 3C      	ASPCS:  inc     A               ; Output A spaces
1D3D: 47      	        ld      B,A             ; Save number to print
1D3E: 79      	SPCLP:  ld      A,C             ; char to print
1D3F: CD2918  	        call    OUTC            ; Output character in A
1D42: 05      	        dec     B               ; Count them
1D43: C23E1D  	        jp      NZ,SPCLP        ; Repeat if more
1D46: E1      	NEXITM: pop     HL              ; Restore code string address
1D47: CD411A  	        call    GETCHR          ; Get next character
1D4A: C39A1C  	        jp      PRNTLP          ; More to print
              	
1D4D: 3F526564	REDO:   defb    "?Redo from start",CR,0
1D51: 6F206672	
1D55: 6F6D2073	
1D59: 74617274	
1D5D: 0D00    	
              	
1D5F: 3AB281  	BADINP: ld      A,(READFG)      ; READ or INPUT?
1D62: B7      	        or      A
1D63: C23615  	        jp      NZ,DATSNR       ; READ - ?SN Error
1D66: C1      	        pop     BC              ; Throw away code string addr
1D67: 214D1D  	        ld      HL,REDO         ; "Redo from start" message
1D6A: CDBE23  	        call    PRS             ; Output string
1D6D: C3A116  	        jp      DOAGN           ; Do last INPUT again
              	
1D70: CD2923  	INPUT:  call    IDTEST          ; Test for illegal direct
1D73: 7E      	        ld      A,(HL)          ; Get character after "INPUT"
1D74: FE22    	        cp      $22             ; '"' ; Is there a prompt string?
1D76: 3E00    	        ld      A,$00           ; Clear A and leave flags
1D78: 32A580  	        ld      (CTLOFG),A      ; Enable output
1D7B: C28A1D  	        jp      NZ,NOPMPT       ; No prompt - get input
1D7E: CD7D23  	        call    QTSTR           ; Get string terminated by '"'
1D81: CD1E18  	        call    CHKSYN          ; Check for ';' after prompt
1D84: 3B      	        defb    ";"
1D85: E5      	        push    HL              ; Save code string address
1D86: CDC123  	        call    PRS1            ; Output prompt string
1D89: 3E      	        defb    $3E             ; Skip "push HL"
1D8A: E5      	NOPMPT: push    HL              ; Save code string address
1D8B: CDA516  	        call    PROMPT          ; Get input with "? " prompt
1D8E: C1      	        pop     BC              ; Restore code string address
1D8F: DA901A  	        jp      C,INPBRK        ; Break pressed - Exit
1D92: 23      	        inc     HL              ; Next byte
1D93: 7E      	        ld      A,(HL)          ; Get it
1D94: B7      	        or      A               ; End of line?
1D95: 2B      	        dec     HL              ; Back again
1D96: C5      	        push    BC              ; Re-save code string address
1D97: CD4E08  	        call    CURSOR_OFF      ; disable cursor
1D9A: CAE31B  	        jp      Z,NXTDTA        ; Yes - Find next DATA stmt
1D9D: 362C    	        ld      (HL),','        ; Store comma as separator
1D9F: C3A71D  	        jp      NXTITM          ; Get next item
              	
1DA2: E5      	READ:   push    HL              ; Save code string address
1DA3: 2AC181  	        ld      HL,(NXTDAT)     ; Next DATA statement
1DA6: F6      	        defb    $F6             ; Flag "READ"
1DA7: AF      	NXTITM: xor     A               ; Flag "INPUT"
1DA8: 32B281  	        ld      (READFG),A      ; Save "READ"/"INPUT" flag
1DAB: E3      	        ex      (SP),HL         ; Get code str' , Save pointer
1DAC: C3B31D  	        jp      GTVLUS          ; Get values
              	
1DAF: CD1E18  	NEDMOR: call    CHKSYN          ; Check for comma between items
1DB2: 2C      	        defb    ','
1DB3: CDC520  	GTVLUS: call    GETVAR          ; Get variable name
1DB6: E3      	        ex      (SP),HL         ; Save code str" , Get pointer
1DB7: D5      	        push    DE              ; Save variable address
1DB8: 7E      	        ld      A,(HL)          ; Get next "INPUT"/"DATA" byte
1DB9: FE2C    	        cp      ','             ; Comma?
1DBB: CADB1D  	        jp      Z,ANTVLU        ; Yes - Get another value
1DBE: 3AB281  	        ld      A,(READFG)      ; Is it READ?
1DC1: B7      	        or      A
1DC2: C2471E  	        jp      NZ,FDTLP        ; Yes - Find next DATA stmt
1DC5: 3E3F    	        ld      A,'?'           ; More INPUT needed
1DC7: CD2918  	        call    OUTC            ; Output character
1DCA: CDA516  	        call    PROMPT          ; Get INPUT with prompt
1DCD: D1      	        pop     DE              ; Variable address
1DCE: C1      	        pop     BC              ; Code string address
1DCF: DA901A  	        jp      C,INPBRK        ; Break pressed
1DD2: 23      	        inc     HL              ; Point to next DATA byte
1DD3: 7E      	        ld      A,(HL)          ; Get byte
1DD4: B7      	        or      A               ; Is it zero (No input) ?
1DD5: 2B      	        dec     HL              ; Back space INPUT pointer
1DD6: C5      	        push    BC              ; Save code string address
1DD7: CAE31B  	        jp      Z,NXTDTA        ; Find end of buffer
1DDA: D5      	        push    DE              ; Save variable address
1DDB: 3A9281  	ANTVLU: ld      A,(TYPE)        ; Check data type
1DDE: B7      	        or      A               ; Is it numeric?
1DDF: CA051E  	        jp      Z,INPBIN        ; Yes - Convert to binary
1DE2: CD411A  	        call    GETCHR          ; Get next character
1DE5: 57      	        ld      D,A             ; Save input character
1DE6: 47      	        ld      B,A             ; Again
1DE7: FE22    	        cp      $22             ; '"'     ; Start of literal sting?
1DE9: CAF91D  	        jp      Z,STRENT        ; Yes - Create string entry
1DEC: 3AB281  	        ld      A,(READFG)      ; "READ" or "INPUT" ?
1DEF: B7      	        or      A
1DF0: 57      	        ld      D,A             ; Save 00 if "INPUT"
1DF1: CAF61D  	        jp      Z,ITMSEP        ; "INPUT" - End with 00
1DF4: 163A    	        ld      D,':'           ; "DATA" - End with 00 or ':'
1DF6: 062C    	ITMSEP: ld      B,','           ; Item separator
1DF8: 2B      	        dec     HL              ; Back space for DTSTR
1DF9: CD8023  	STRENT: call    DTSTR           ; Get string terminated by D
1DFC: EB      	        ex      DE,HL           ; String address to DE
1DFD: 21101E  	        ld      HL,LTSTND       ; Where to go after LETSTR
1E00: E3      	        ex      (SP),HL         ; Save HL , get input pointer
1E01: D5      	        push    DE              ; Save address of string
1E02: C3161C  	        jp      LETSTR          ; Assign string to variable
              	
1E05: CD411A  	INPBIN: call    GETCHR          ; Get next character
1E08: CDCB2D  	        call    ASCTFP          ; Convert ASCII to FP number
1E0B: E3      	        ex      (SP),HL         ; Save input ptr, Get var addr
1E0C: CD1C2D  	        call    FPTHL           ; Move FPREG to variable
1E0F: E1      	        pop     HL              ; Restore input pointer
1E10: 2B      	LTSTND: dec     HL              ; dec 'cos GETCHR INCs
1E11: CD411A  	        call    GETCHR          ; Get next character
1E14: CA1C1E  	        jp      Z,MORDT         ; End of line - More needed?
1E17: FE2C    	        cp      ','             ; Another value?
1E19: C25F1D  	        jp      NZ,BADINP       ; No - Bad input
1E1C: E3      	MORDT:  ex      (SP),HL         ; Get code string address
1E1D: 2B      	        dec     HL              ; dec 'cos GETCHR INCs
1E1E: CD411A  	        call    GETCHR          ; Get next character
1E21: C2AF1D  	        jp      NZ,NEDMOR       ; More needed - Get it
1E24: D1      	        pop     DE              ; Restore DATA pointer
1E25: 3AB281  	        ld      A,(READFG)      ; "READ" or "INPUT" ?
1E28: B7      	        or      A
1E29: EB      	        ex      DE,HL           ; DATA pointer to HL
1E2A: C2671A  	        jp      NZ,UPDATA       ; Update DATA pointer if "READ"
1E2D: D5      	        push    DE              ; Save code string address
1E2E: B6      	        or      (HL)            ; More input given?
1E2F: 21371E  	        ld      HL,EXTIG        ; "?Extra ignored" message
1E32: C4BE23  	        call    NZ,PRS          ; Output string if extra given
1E35: E1      	        pop     HL              ; Restore code string address
1E36: C9      	        ret
              	
1E37: 3F457874	EXTIG:  defb    "?Extra ignored",CR,0
1E3B: 72612069	
1E3F: 676E6F72	
1E43: 65640D00	
              	
1E47: CDE41B  	FDTLP:  call    DATA            ; Get next statement
1E4A: B7      	        or      A               ; End of line?
1E4B: C2601E  	        jp      NZ,FANDT        ; No - See if DATA statement
1E4E: 23      	        inc     HL
1E4F: 7E      	        ld      A,(HL)          ; End of program?
1E50: 23      	        inc     HL
1E51: B6      	        or      (HL)            ; 00 00 Ends program
1E52: 1E06    	        ld      E,OD            ; ?OD Error
1E54: CA5015  	        jp      Z,ERROR         ; Yes - Out of DATA
1E57: 23      	        inc     HL
1E58: 5E      	        ld      E,(HL)          ; LSB of line number
1E59: 23      	        inc     HL
1E5A: 56      	        ld      D,(HL)          ; MSB of line number
1E5B: EB      	        ex      DE,HL
1E5C: 22AE81  	        ld      (DATLIN),HL     ; Set line of current DATA item
1E5F: EB      	        ex      DE,HL
1E60: CD411A  	FANDT:  call    GETCHR          ; Get next character
1E63: FE83    	        cp      ZDATA           ; "DATA" token
1E65: C2471E  	        jp      NZ,FDTLP        ; No "DATA" - Keep looking
1E68: C3DB1D  	        jp      ANTVLU          ; Found - Convert input
              	
1E6B: 110000  	NEXT:   ld      DE,$0000        ; In case no index given
1E6E: C4C520  	NEXT1:  call    NZ,GETVAR       ; Get index address
1E71: 22B381  	        ld      (BRKLIN),HL     ; Save code string address
1E74: CDC514  	        call    BAKSTK          ; Look for "FOR" block
1E77: C24215  	        jp      NZ,NFERR        ; No "FOR" - ?NF Error
1E7A: F9      	        ld      SP,HL           ; Clear nested loops
1E7B: D5      	        push    DE              ; Save index address
1E7C: 7E      	        ld      A,(HL)          ; Get sign of STEP
1E7D: 23      	        inc     HL
1E7E: F5      	        push    AF              ; Save sign of STEP
1E7F: D5      	        push    DE              ; Save index address
1E80: CD022D  	        call    PHLTFP          ; Move index value to FPREG
1E83: E3      	        ex      (SP),HL         ; Save address of TO value
1E84: E5      	        push    HL              ; Save address of index
1E85: CD1E2A  	        call    ADDPHL          ; Add STEP to index value
1E88: E1      	        pop     HL              ; Restore address of index
1E89: CD1C2D  	        call    FPTHL           ; Move value to index variable
1E8C: E1      	        pop     HL              ; Restore address of TO value
1E8D: CD132D  	        call    LOADFP          ; Move TO value to BCDE
1E90: E5      	        push    HL              ; Save address of line of FOR
1E91: CD3F2D  	        call    CMPNUM          ; Compare index with TO value
1E94: E1      	        pop     HL              ; Restore address of line num
1E95: C1      	        pop     BC              ; Address of sign of STEP
1E96: 90      	        sub     B               ; Compare with expected sign
1E97: CD132D  	        call    LOADFP          ; BC = Loop stmt,DE = Line num
1E9A: CAA61E  	        jp      Z,KILFOR        ; Loop finished - Terminate it
1E9D: EB      	        ex      DE,HL           ; Loop statement line number
1E9E: 22AF80  	        ld      (LINEAT),HL     ; Set loop line number
1EA1: 69      	        ld      L,C             ; Set code string to loop
1EA2: 60      	        ld      H,B
1EA3: C3FD19  	        jp      PUTFID          ; Put back "FOR" and continue
              	
1EA6: F9      	KILFOR: ld      SP,HL           ; Remove "FOR" block
1EA7: 2AB381  	        ld      HL,(BRKLIN)     ; Code string after "NEXT"
1EAA: 7E      	        ld      A,(HL)          ; Get next byte in code string
1EAB: FE2C    	        cp      ','             ; More NEXTs ?
1EAD: C2011A  	        jp      NZ,RUNCNT       ; No - Do next statement
1EB0: CD411A  	        call    GETCHR          ; Position to index name
1EB3: CD6E1E  	        call    NEXT1           ; Re-enter NEXT routine
              	; < will not RETurn to here , Exit to RUNCNT or Loop >
              	
1EB6: CDC81E  	GETNUM: call    EVAL            ; Get a numeric expression
1EB9: F6      	TSTNUM: defb    $F6             ; Clear carry (numeric)
1EBA: 37      	TSTSTR: scf                     ; Set carry (string)
1EBB: 3A9281  	CHKTYP: ld      A,(TYPE)        ; Check types match
1EBE: 8F      	        adc     A,A             ; Expected + actual
1EBF: B7      	        or      A               ; Clear carry , set parity
1EC0: E8      	        ret     PE              ; Even parity - Types match
1EC1: C34E15  	        jp      TMERR           ; Different types - Error
              	
1EC4: CD1E18  	OPNPAR: call    CHKSYN          ; Make sure "(" follows
1EC7: 28      	        defb    '('
1EC8: 2B      	EVAL:   dec     HL              ; Evaluate expression & save
1EC9: 1600    	        ld      D,$00           ; Precedence value
1ECB: D5      	EVAL1:  push    DE              ; Save precedence
1ECC: 0E01    	        ld      C,$01
1ECE: CDF914  	        call    CHKSTK          ; Check for 1 level of stack
1ED1: CD3F1F  	        call    OPRND           ; Get next expression value
1ED4: 22B581  	EVAL2:  ld      (NXTOPR),HL     ; Save address of next operator
1ED7: 2AB581  	EVAL3:  ld      HL,(NXTOPR)     ; Restore address of next opr
1EDA: C1      	        pop     BC              ; Precedence value and operator
1EDB: 78      	        ld      A,B             ; Get precedence value
1EDC: FE78    	        cp      $78             ; "AND", "OR", or "XOR" ?
1EDE: D4B91E  	        call    NC,TSTNUM       ; No - Make sure it's a number
1EE1: 7E      	        ld      A,(HL)          ; Get next operator / function
1EE2: 1600    	        ld      D,$00           ; Clear Last relation
1EE4: D6C4    	RLTLP:  sub     ZGTR            ; ">" Token
1EE6: DA001F  	        jp      C,FOPRND        ; + - * / ^ AND OR XOR - Test it
1EE9: FE03    	        cp      ZLTH+1-ZGTR     ; < = >
1EEB: D2001F  	        jp      NC,FOPRND       ; Function - Call it
1EEE: FE01    	        cp      ZEQUAL-ZGTR     ; "="
1EF0: 17      	        rla                     ; <- Test for legal
1EF1: AA      	        xor     D               ; <- combinations of < = >
1EF2: BA      	        cp      D               ; <- by combining last token
1EF3: 57      	        ld      D,A             ; <- with current one
1EF4: DA3C15  	        jp      C,SNERR         ; Error if "<<' '==" or ">>"
1EF7: 22AA81  	        ld      (CUROPR),HL     ; Save address of current token
1EFA: CD411A  	        call    GETCHR          ; Get next character
1EFD: C3E41E  	        jp      RLTLP           ; Treat the two as one
              	
1F00: 7A      	FOPRND: ld      A,D             ; < = > found ?
1F01: B7      	        or      A
1F02: C24020  	        jp      NZ,TSTRED       ; Yes - Test for reduction
1F05: 7E      	        ld      A,(HL)          ; Get operator token
1F06: 22AA81  	        ld      (CUROPR),HL     ; Save operator address
1F09: D6BA    	        sub     ZPLUS           ; Operator or function?
1F0B: D8      	        ret     C               ; Neither - Exit
1F0C: FE0A    	        cp      ZOR+1-ZPLUS     ; Is it + - * / ^ AND XOR OR ?
1F0E: D0      	        ret     NC              ; No - Exit
1F0F: 5F      	        ld      E,A             ; Coded operator
1F10: 3A9281  	        ld      A,(TYPE)        ; Get data type
1F13: 3D      	        dec     A               ; FF = numeric , 00 = string
1F14: B3      	        or      E               ; Combine with coded operator
1F15: 7B      	        ld      A,E             ; Get coded operator
1F16: CAB424  	        jp      Z,CONCAT        ; String concatenation
1F19: 07      	        rlca                    ; Times 2
1F1A: 83      	        add     A,E             ; Times 3
1F1B: 5F      	        ld      E,A             ; To DE (D is 0)
1F1C: 21ED11  	        ld      HL,PRITAB       ; Precedence table
1F1F: 19      	        add     HL,DE           ; To the operator concerned
1F20: 78      	        ld      A,B             ; Last operator precedence
1F21: 56      	        ld      D,(HL)          ; Get evaluation precedence
1F22: BA      	        cp      D               ; Compare with eval precedence
1F23: D0      	        ret     NC              ; Exit if higher precedence
1F24: 23      	        inc     HL              ; Point to routine address
1F25: CDB91E  	        call    TSTNUM          ; Make sure it's a number
              	
1F28: C5      	STKTHS: push    BC              ; Save last precedence & token
1F29: 01D71E  	        ld      BC,EVAL3        ; Where to go on prec' break
1F2C: C5      	        push    BC              ; Save on stack for return
1F2D: 43      	        ld      B,E             ; Save operator
1F2E: 4A      	        ld      C,D             ; Save precedence
1F2F: CDF52C  	        call    STAKFP          ; Move value to stack
1F32: 58      	        ld      E,B             ; Restore operator
1F33: 51      	        ld      D,C             ; Restore precedence
1F34: 4E      	        ld      C,(HL)          ; Get LSB of routine address
1F35: 23      	        inc     HL
1F36: 46      	        ld      B,(HL)          ; Get MSB of routine address
1F37: 23      	        inc     HL
1F38: C5      	        push    BC              ; Save routine address
1F39: 2AAA81  	        ld      HL,(CUROPR)     ; Address of current operator
1F3C: C3CB1E  	        jp      EVAL1           ; Loop until prec' break
              	
1F3F: AF      	OPRND:  xor     A               ; Get operand routine
1F40: 329281  	        ld      (TYPE),A        ; Set numeric expected
1F43: CD411A  	        call    GETCHR          ; Get next character
1F46: 1E24    	        ld      E,MO            ; ?MO Error
1F48: CA5015  	        jp      Z,ERROR         ; No operand - Error
1F4B: DACB2D  	        jp      C,ASCTFP        ; Number - Get value
1F4E: CDE31A  	        call    CHKLTR          ; See if a letter
1F51: D2A61F  	        jp      NC,CONVAR       ; Letter - Find variable
1F54: FE26    	        cp      '&'             ; &H = HEX, &B = BINARY
1F56: 2012    	        jr      NZ,NOTAMP
1F58: CD411A  	        call    GETCHR          ; Get next character
1F5B: FE48    	        cp      'H'             ; Hex number indicated? [function added]
1F5D: CA9C3B  	        jp      Z,HEXTFP        ; Convert Hex to FPREG
1F60: FE42    	        cp      'B'             ; Binary number indicated? [function added]
1F62: CA0C3C  	        jp      Z,BINTFP        ; Convert Bin to FPREG
1F65: 1E02    	        ld      E,SN            ; If neither then a ?SN Error
1F67: CA5015  	        jp      Z,ERROR         ;
1F6A: FEBA    	NOTAMP: cp      ZPLUS           ; '+' Token ?
1F6C: CA3F1F  	        jp      Z,OPRND         ; Yes - Look for operand
1F6F: FE2E    	        cp      '.'             ; '.' ?
1F71: CACB2D  	        jp      Z,ASCTFP        ; Yes - Create FP number
1F74: FEBB    	        cp      ZMINUS          ; '-' Token ?
1F76: CA951F  	        jp      Z,MINUS         ; Yes - Do minus
1F79: FE22    	        cp      $22             ; '"'             ; Literal string ?
1F7B: CA7D23  	        jp      Z,QTSTR         ; Get string terminated by '"'
1F7E: FEB8    	        cp      ZNOT            ; "NOT" Token ?
1F80: CAA020  	        jp      Z,EVNOT         ; Yes - Eval NOT expression
1F83: FEB5    	        cp      ZFN             ; "FN" Token ?
1F85: CAE122  	        jp      Z,DOFN          ; Yes - Do FN routine
1F88: D6C7    	        sub     ZSGN            ; Is it a function?
1F8A: D2B71F  	        jp      NC,FNOFST       ; Yes - Evaluate function
1F8D: CDC41E  	EVLPAR: call    OPNPAR          ; Evaluate expression in "()"
1F90: CD1E18  	        call    CHKSYN          ; Make sure ")" follows
1F93: 29      	        defb    ')'
1F94: C9      	        ret
              	
1F95: 167D    	MINUS:  ld      D,$7D           ; '-' precedence
1F97: CDCB1E  	        call    EVAL1           ; Evaluate until prec' break
1F9A: 2AB581  	        ld      HL,(NXTOPR)     ; Get next operator address
1F9D: E5      	        push    HL              ; Save next operator address
1F9E: CDED2C  	        call    INVSGN          ; Negate value
1FA1: CDB91E  	RETNUM: call    TSTNUM          ; Make sure it's a number
1FA4: E1      	        pop     HL              ; Restore next operator address
1FA5: C9      	        ret
              	
1FA6: CDC520  	CONVAR: call    GETVAR          ; Get variable address to DE
1FA9: E5      	FRMEVL: push    HL              ; Save code string address
1FAA: EB      	        ex      DE,HL           ; Variable address to HL
1FAB: 22C981  	        ld      (FPREG),HL      ; Save address of variable
1FAE: 3A9281  	        ld      A,(TYPE)        ; Get type
1FB1: B7      	        or      A               ; Numeric?
1FB2: CC022D  	        call    Z,PHLTFP        ; Yes - Move contents to FPREG
1FB5: E1      	        pop     HL              ; Restore code string address
1FB6: C9      	        ret
              	
1FB7: 0600    	FNOFST: ld      B,$00           ; Get address of function
1FB9: 07      	        rlca                    ; Double function offset
1FBA: 4F      	        ld      C,A             ; BC = Offset in function table
1FBB: C5      	        push    BC              ; Save adjusted token value
1FBC: CD411A  	        call    GETCHR          ; Get next character
1FBF: 79      	        ld      A,C             ; Get adjusted token value
1FC0: FE2C    	        cp      2*(ZPOINT-ZSGN) ; "POINT" token?
1FC2: CAFF33  	        jp      Z,POINT         ; Yes, do "POINT"
1FC5: FE2E    	        cp      2*(ZINSTR-ZSGN) ; "INSTR" token?
1FC7: CA9025  	        jp      Z,INSTR         ; Yes, do "INSTR"
1FCA: FE3D    	        cp      2*(ZLEFT-ZSGN)-1; Adj' LEFT$,RIGHT$ or MID$ ?
1FCC: DAE81F  	        jp      C,FNVAL         ; No - Do function
1FCF: CDC41E  	        call    OPNPAR          ; Evaluate expression  (X,...
1FD2: CD1E18  	        call    CHKSYN          ; Make sure ',' follows
1FD5: 2C      	        defb    ','
1FD6: CDBA1E  	        call    TSTSTR          ; Make sure it's a string
1FD9: EB      	        ex      DE,HL           ; Save code string address
1FDA: 2AC981  	        ld      HL,(FPREG)      ; Get address of string
1FDD: E3      	        ex      (SP),HL         ; Save address of string
1FDE: E5      	        push    HL              ; Save adjusted token value
1FDF: EB      	        ex      DE,HL           ; Restore code string address
1FE0: CD3C27  	        call    GETINT          ; Get integer 0-255
1FE3: EB      	        ex      DE,HL           ; Save code string address
1FE4: E3      	        ex      (SP),HL         ; Save integer,HL = adj' token
1FE5: C3F01F  	        jp      GOFUNC          ; Jump to string function
              	
1FE8: CD8D1F  	FNVAL:  call    EVLPAR          ; Evaluate expression
1FEB: E3      	        ex      (SP),HL         ; HL = Adjusted token value
1FEC: 11A11F  	        ld      DE,RETNUM       ; Return number from function
1FEF: D5      	        push    DE              ; Save on stack
1FF0: 01C30F  	GOFUNC: ld      BC,FNCTAB       ; Function routine addresses
1FF3: 09      	        add     HL,BC           ; Point to right address
1FF4: 4E      	        ld      C,(HL)          ; Get LSB of address
1FF5: 23      	        inc     HL              ;
1FF6: 66      	        ld      H,(HL)          ; Get MSB of address
1FF7: 69      	        ld      L,C             ; Address to HL
1FF8: E9      	        jp      (HL)            ; Jump to function
              	
1FF9: 15      	SGNEXP: dec     D               ; Dee to flag negative exponent
1FFA: FEBB    	        cp      ZMINUS          ; '-' token ?
1FFC: C8      	        ret     Z               ; Yes - Return
1FFD: FE2D    	        cp      '-'             ; '-' ASCII ?
1FFF: C8      	        ret     Z               ; Yes - Return
2000: 14      	        inc     D               ; Inc to flag positive exponent
2001: FE2B    	        cp      '+'             ; '+' ASCII ?
2003: C8      	        ret     Z               ; Yes - Return
2004: FEBA    	        cp      ZPLUS           ; '+' token ?
2006: C8      	        ret     Z               ; Yes - Return
2007: 2B      	        dec     HL              ; dec 'cos GETCHR INCs
2008: C9      	        ret                     ; Return "NZ"
              	
              	; execute OR, AND, and XOR operations
2009: AF      	PAND:   xor     A               ; for AND, Z=1
200A: 1807    	        jr      CNTLGC          
200C: AF      	POR     xor     A               ; for OR, Z=0, S=1
200D: D601    	        sub     $01
200F: 1802    	        jr      CNTLGC
2011: AF      	PXOR:   xor     A               ; for XOR, Z=0, S=0
2012: 3C      	        inc     A
2013: F5      	CNTLGC: push    AF              ; store operand's flags
2014: CDB91E  	        call    TSTNUM          ; Make sure it's a number
2017: CDF71A  	        call    DEINT           ; Get integer -32768 to 32767
201A: F1      	        pop     AF              ; retrieve operand's flags
201B: EB      	        ex      DE,HL           ; <- Get last
201C: C1      	        pop     BC              ; <-  value
201D: E3      	        ex      (SP),HL         ; <-  from
201E: EB      	        ex      DE,HL           ; <-  stack
201F: CD052D  	        call    FPBCDE          ; Move last value to FPREG
2022: F5      	        push    AF              ; store operand's flags
2023: CDF71A  	        call    DEINT           ; Get integer -32768 to 32767
2026: F1      	        pop     AF              ; retrieve operand's flags
2027: C1      	        pop     BC              ; Get value
2028: 79      	        ld      A,C             ; Get LSB
2029: 219F22  	        ld      HL,ACPASS       ; Address of save AC as current
202C: 2005    	        jr      NZ,POR1         ; if X/OR, jump over
202E: A3      	PAND1:  and     E               ; "AND" LSBs
202F: 4F      	        ld      C,A             ; Save LSB
2030: 78      	        ld      A,B             ; Get MSB
2031: A2      	        and     D               ; "AND" MSBs
2032: E9      	        jp      (HL)            ; Save AC as current (ACPASS)
2033: F23B20  	POR1:   jp      P,PXOR1         ; if S=0, jump to XOR
2036: B3      	        or      E               ; "OR" LSBs
2037: 4F      	        ld      C,A             ; Save LSB
2038: 78      	        ld      A,B             ; Get MSB
2039: B2      	        or      D               ; "OR" MSBs
203A: E9      	        jp      (HL)            ; Save AC as current (ACPASS)
203B: AB      	PXOR1:  xor     E               ; "XOR" LSBs
203C: 4F      	        ld      C,A             ; Save LSB
203D: 78      	        ld      A,B             ; Get MSB
203E: AA      	        xor     D               ; "XOR" MSBs
203F: E9      	        jp      (HL)            ; Save AC as current (ACPASS) 
              	
2040: 215220  	TSTRED: ld      HL,CMPLOG       ; Logical compare routine
2043: 3A9281  	        ld      A,(TYPE)        ; Get data type
2046: 1F      	        rra                     ; Carry set = string
2047: 7A      	        ld      A,D             ; Get last precedence value
2048: 17      	        rla                     ; Times 2 plus carry
2049: 5F      	        ld      E,A             ; To E
204A: 1664    	        ld      D,$64           ; Relational precedence
204C: 78      	        ld      A,B             ; Get current precedence
204D: BA      	        cp      D               ; Compare with last
204E: D0      	        ret     NC              ; Eval if last was rel' or log'
204F: C3281F  	        jp      STKTHS          ; Stack this one and get next
              	
2052: 5420    	CMPLOG: defw    CMPLG1          ; Compare two values / strings
2054: 79      	CMPLG1: ld      A,C             ; Get data type
2055: B7      	        or      A
2056: 1F      	        rra
2057: C1      	        pop     BC              ; Get last expression to BCDE
2058: D1      	        pop     DE
2059: F5      	        push    AF              ; Save status
205A: CDBB1E  	        call    CHKTYP          ; Check that types match
205D: 219620  	        ld      HL,CMPRES       ; Result to comparison
2060: E5      	        push    HL              ; Save for RETurn
2061: CA3F2D  	        jp      Z,CMPNUM        ; Compare values if numeric
2064: AF      	        xor     A               ; Compare two strings
2065: 329281  	        ld      (TYPE),A        ; Set type to numeric
2068: D5      	        push    DE              ; Save string name
2069: CD0125  	        call    GSTRCU          ; Get current string
206C: 7E      	        ld      A,(HL)          ; Get length of string
206D: 23      	        inc     HL
206E: 23      	        inc     HL
206F: 4E      	        ld      C,(HL)          ; Get LSB of address
2070: 23      	        inc     HL
2071: 46      	        ld      B,(HL)          ; Get MSB of address
2072: D1      	        pop     DE              ; Restore string name
2073: C5      	        push    BC              ; Save address of string
2074: F5      	        push    AF              ; Save length of string
2075: CD0525  	        call    GSTRDE          ; Get second string
2078: CD132D  	        call    LOADFP          ; Get address of second string
207B: F1      	        pop     AF              ; Restore length of string 1
207C: 57      	        ld      D,A             ; Length to D
207D: E1      	        pop     HL              ; Restore address of string 1
207E: 7B      	CMPSTR: ld      A,E             ; Bytes of string 2 to do
207F: B2      	        or      D               ; Bytes of string 1 to do
2080: C8      	        ret     Z               ; Exit if all bytes compared
2081: 7A      	        ld      A,D             ; Get bytes of string 1 to do
2082: D601    	        sub     $01
2084: D8      	        ret     C               ; Exit if end of string 1
2085: AF      	        xor     A
2086: BB      	        cp      E               ; Bytes of string 2 to do
2087: 3C      	        inc     A
2088: D0      	        ret     NC              ; Exit if end of string 2
2089: 15      	        dec     D               ; Count bytes in string 1
208A: 1D      	        dec     E               ; Count bytes in string 2
208B: 0A      	        ld      A,(BC)          ; Byte in string 2
208C: BE      	        cp      (HL)            ; Compare to byte in string 1
208D: 23      	        inc     HL              ; Move up string 1
208E: 03      	        inc     BC              ; Move up string 2
208F: CA7E20  	        jp      Z,CMPSTR        ; Same - Try next bytes
2092: 3F      	        ccf                     ; Flag difference (">" or "<")
2093: C3CF2C  	        jp      FLGDIF          ; "<" gives -1 , ">" gives +1
              	
2096: 3C      	CMPRES: inc     A               ; Increment current value
2097: 8F      	        adc     A,A             ; Double plus carry
2098: C1      	        pop     BC              ; Get other value
2099: A0      	        and     B               ; Combine them
209A: C6FF    	        add     A,-1            ; Carry set if different
209C: 9F      	        sbc     A,A             ; 00 - Equal , FF - Different
209D: C3D62C  	        jp      FLGREL          ; Set current value & continue
              	
20A0: 165A    	EVNOT:  ld      D,$5A           ; Precedence value for "NOT"
20A2: CDCB1E  	        call    EVAL1           ; Eval until precedence break
20A5: CDB91E  	        call    TSTNUM          ; Make sure it's a number
20A8: CDF71A  	        call    DEINT           ; Get integer -32768 - 32767
20AB: 7B      	        ld      A,E             ; Get LSB
20AC: 2F      	        cpl                     ; Invert LSB
20AD: 4F      	        ld      C,A             ; Save "NOT" of LSB
20AE: 7A      	        ld      A,D             ; Get MSB
20AF: 2F      	        cpl                     ; Invert MSB
20B0: CD9F22  	        call    ACPASS          ; Save AC as current
20B3: C1      	        pop     BC              ; Clean up stack
20B4: C3D71E  	        jp      EVAL3           ; Continue evaluation
              	
20B7: 2B      	DIMRET: dec     HL              ; dec 'cos GETCHR INCs
20B8: CD411A  	        call    GETCHR          ; Get next character
20BB: C8      	        ret     Z               ; End of DIM statement
20BC: CD1E18  	        call    CHKSYN          ; Make sure ',' follows
20BF: 2C      	        defb    ','
20C0: 01B720  	DIM:    ld      BC,DIMRET       ; Return to "DIMRET"
20C3: C5      	        push    BC              ; Save on stack
20C4: F6      	        defb    $F6             ; Flag "Create" variable
20C5: AF      	GETVAR: xor     A               ; Find variable address,to DE
20C6: 329181  	        ld      (LCRFLG),A      ; Set locate / create flag
20C9: 46      	        ld      B,(HL)          ; Get First byte of name
20CA: CDE31A  	GTFNAM: call    CHKLTR          ; See if a letter
20CD: DA3C15  	        jp      C,SNERR         ; ?SN Error if not a letter
20D0: AF      	        xor     A
20D1: 4F      	        ld      C,A             ; Clear second byte of name
20D2: 329281  	        ld      (TYPE),A        ; Set type to numeric
20D5: CD411A  	        call    GETCHR          ; Get next character
20D8: DAE120  	        jp      C,SVNAM2        ; Numeric - Save in name
20DB: CDE31A  	        call    CHKLTR          ; See if a letter
20DE: DAEE20  	        jp      C,CHARTY        ; Not a letter - Check type
20E1: 4F      	SVNAM2: ld      C,A             ; Save second byte of name
20E2: CD411A  	ENDNAM: call    GETCHR          ; Get next character
20E5: DAE220  	        jp      C,ENDNAM        ; Numeric - Get another
20E8: CDE31A  	        call    CHKLTR          ; See if a letter
20EB: D2E220  	        jp      NC,ENDNAM       ; Letter - Get another
20EE: D624    	CHARTY: sub     '$'             ; String variable?
20F0: C2FD20  	        jp      NZ,NOTSTR       ; No - Numeric variable
20F3: 3C      	        inc     A               ; A = 1 (string type)
20F4: 329281  	        ld      (TYPE),A        ; Set type to string
20F7: 0F      	        rrca                    ; A = 80H , Flag for string
20F8: 81      	        add     A,C             ; 2nd byte of name has bit 7 on
20F9: 4F      	        ld      C,A             ; Resave second byte on name
20FA: CD411A  	        call    GETCHR          ; Get next character
20FD: 3AB081  	NOTSTR: ld      A,(FORFLG)      ; Array name needed ?
2100: 3D      	        dec     A
2101: CAAA21  	        jp      Z,ARLDSV        ; Yes - Get array name
2104: F20D21  	        jp      P,NSCFOR        ; No array with "FOR" or "FN"
2107: 7E      	        ld      A,(HL)          ; Get byte again
2108: D628    	        sub     '('             ; Subscripted variable?
210A: CA8221  	        jp      Z,SBSCPT        ; Yes - Sort out subscript
              	
210D: AF      	NSCFOR: xor     A               ; Simple variable
210E: 32B081  	        ld      (FORFLG),A      ; Clear "FOR" flag
2111: E5      	        push    HL              ; Save code string address
2112: 50      	        ld      D,B             ; DE = Variable name to find
2113: 59      	        ld      E,C
2114: 2AC381  	        ld      HL,(FNRGNM)     ; FN argument name
2117: CD1818  	        call    CPDEHL          ; Is it the FN argument?
211A: 11C581  	        ld      DE,FNARG        ; Point to argument value
211D: CAB42B  	        jp      Z,POPHRT        ; Yes - Return FN argument value
2120: 2ABD81  	        ld      HL,(VAREND)     ; End of variables
2123: EB      	        ex      DE,HL           ; Address of end of search
2124: 2ABB81  	        ld      HL,(PROGND)     ; Start of variables address
2127: CD1818  	FNDVAR: call    CPDEHL          ; End of variable list table?
212A: CA4021  	        jp      Z,CFEVAL        ; Yes - Called from EVAL?
212D: 79      	        ld      A,C             ; Get second byte of name
212E: 96      	        sub     (HL)            ; Compare with name in list
212F: 23      	        inc     HL              ; Move on to first byte
2130: C23521  	        jp      NZ,FNTHR        ; Different - Find another
2133: 78      	        ld      A,B             ; Get first byte of name
2134: 96      	        sub     (HL)            ; Compare with name in list
2135: 23      	FNTHR:  inc     HL              ; Move on to LSB of value
2136: CA7421  	        jp      Z,RETADR        ; Found - Return address
2139: 23      	        inc     HL              ; <- Skip
213A: 23      	        inc     HL              ; <- over
213B: 23      	        inc     HL              ; <- F.P.
213C: 23      	        inc     HL              ; <- value
213D: C32721  	        jp      FNDVAR          ; Keep looking
              	
2140: E1      	CFEVAL: pop     HL              ; Restore code string address
2141: E3      	        ex      (SP),HL         ; Get return address
2142: D5      	        push    DE              ; Save address of variable
2143: 11A91F  	        ld      DE,FRMEVL       ; Return address in EVAL
2146: CD1818  	        call    CPDEHL          ; Called from EVAL ?
2149: D1      	        pop     DE              ; Restore address of variable
214A: CA7721  	        jp      Z,RETNUL        ; Yes - Return null variable
214D: E3      	        ex      (SP),HL         ; Put back return
214E: E5      	        push    HL              ; Save code string address
214F: C5      	        push    BC              ; Save variable name
2150: 010600  	        ld      BC,$0006        ; 2 byte name plus 4 byte data
2153: 2ABF81  	        ld      HL,(ARREND)     ; End of arrays
2156: E5      	        push    HL              ; Save end of arrays
2157: 09      	        add     HL,BC           ; Move up 6 bytes
2158: C1      	        pop     BC              ; Source address in BC
2159: E5      	        push    HL              ; Save new end address
215A: CDE814  	        call    MOVUP           ; Move arrays up
215D: E1      	        pop     HL              ; Restore new end address
215E: 22BF81  	        ld      (ARREND),HL     ; Set new end address
2161: 60      	        ld      H,B             ; End of variables to HL
2162: 69      	        ld      L,C
2163: 22BD81  	        ld      (VAREND),HL     ; Set new end address
              	
2166: 2B      	ZEROLP: dec     HL              ; Back through to zero variable
2167: 3600    	        ld      (HL),$00        ; Zero byte in variable
2169: CD1818  	        call    CPDEHL          ; Done them all?
216C: C26621  	        jp      NZ,ZEROLP       ; No - Keep on going
216F: D1      	        pop     DE              ; Get variable name
2170: 73      	        ld      (HL),E          ; Store second character
2171: 23      	        inc     HL
2172: 72      	        ld      (HL),D          ; Store first character
2173: 23      	        inc     HL
2174: EB      	RETADR: ex      DE,HL           ; Address of variable in DE
2175: E1      	        pop     HL              ; Restore code string address
2176: C9      	        ret
              	
2177: 32CC81  	RETNUL: ld      (FPEXP),A       ; Set result to zero
217A: 21B914  	        ld      HL,ZERBYT       ; Also set a null string
217D: 22C981  	        ld      (FPREG),HL      ; Save for EVAL
2180: E1      	        pop     HL              ; Restore code string address
2181: C9      	        ret
              	
2182: E5      	SBSCPT: push    HL              ; Save code string address
2183: 2A9181  	        ld      HL,(LCRFLG)     ; Locate/Create and Type
2186: E3      	        ex      (SP),HL         ; Save and get code string
2187: 57      	        ld      D,A             ; Zero number of dimensions
2188: D5      	SCPTLP: push    DE              ; Save number of dimensions
2189: C5      	        push    BC              ; Save array name
218A: CDEB1A  	        call    FPSINT          ; Get subscript (0-32767)
218D: C1      	        pop     BC              ; Restore array name
218E: F1      	        pop     AF              ; Get number of dimensions
218F: EB      	        ex      DE,HL
2190: E3      	        ex      (SP),HL         ; Save subscript value
2191: E5      	        push    HL              ; Save LCRFLG and TYPE
2192: EB      	        ex      DE,HL
2193: 3C      	        inc     A               ; Count dimensions
2194: 57      	        ld      D,A             ; Save in D
2195: 7E      	        ld      A,(HL)          ; Get next byte in code string
2196: FE2C    	        cp      ','             ; Comma (more to come)?
2198: CA8821  	        jp      Z,SCPTLP        ; Yes - More subscripts
219B: CD1E18  	        call    CHKSYN          ; Make sure ")" follows
219E: 29      	        defb    ')'
219F: 22B581  	        ld      (NXTOPR),HL     ; Save code string address
21A2: E1      	        pop     HL              ; Get LCRFLG and TYPE
21A3: 229181  	        ld      (LCRFLG),HL     ; Restore Locate/create & type
21A6: 1E00    	        ld      E,$00           ; Flag not CSAVE* or CLOAD*
21A8: D5      	        push    DE              ; Save number of dimensions (D)
21A9: 11      	        defb    $11             ; Skip "push HL" and "push AF'
              	
21AA: E5      	ARLDSV: push    HL              ; Save code string address
21AB: F5      	        push    AF              ; A = 00 , Flags set = Z,N
21AC: 2ABD81  	        ld      HL,(VAREND)     ; Start of arrays
21AF: 3E      	        defb    $3E             ; Skip "add HL,DE"
21B0: 19      	FNDARY: add     HL,DE           ; Move to next array start
21B1: EB      	        ex      DE,HL
21B2: 2ABF81  	        ld      HL,(ARREND)     ; End of arrays
21B5: EB      	        ex      DE,HL           ; Current array pointer
21B6: CD1818  	        call    CPDEHL          ; End of arrays found?
21B9: CAE221  	        jp      Z,CREARY        ; Yes - Create array
21BC: 7E      	        ld      A,(HL)          ; Get second byte of name
21BD: B9      	        cp      C               ; Compare with name given
21BE: 23      	        inc     HL              ; Move on
21BF: C2C421  	        jp      NZ,NXTARY       ; Different - Find next array
21C2: 7E      	        ld      A,(HL)          ; Get first byte of name
21C3: B8      	        cp      B               ; Compare with name given
21C4: 23      	NXTARY: inc     HL              ; Move on
21C5: 5E      	        ld      E,(HL)          ; Get LSB of next array address
21C6: 23      	        inc     HL
21C7: 56      	        ld      D,(HL)          ; Get MSB of next array address
21C8: 23      	        inc     HL
21C9: C2B021  	        jp      NZ,FNDARY       ; Not found - Keep looking
21CC: 3A9181  	        ld      A,(LCRFLG)      ; Found Locate or Create it?
21CF: B7      	        or      A
21D0: C24515  	        jp      NZ,DDERR        ; Create - ?DD Error
21D3: F1      	        pop     AF              ; Locate - Get number of dim'ns
21D4: 44      	        ld      B,H             ; BC Points to array dim'ns
21D5: 4D      	        ld      C,L
21D6: CAB42B  	        jp      Z,POPHRT        ; Jump if array load/save
21D9: 96      	        sub     (HL)            ; Same number of dimensions?
21DA: CA4022  	        jp      Z,FINDEL        ; Yes - Find element
21DD: 1E10    	BSERR:  ld      E,BS            ; ?BS Error
21DF: C35015  	        jp      ERROR           ; Output error
              	
21E2: 110400  	CREARY: ld      DE,$0004        ; 4 Bytes per entry
21E5: F1      	        pop     AF              ; Array to save or 0 dim'ns?
21E6: CA0C1B  	        jp      Z,FCERR         ; Yes - ?FC Error
21E9: 71      	        ld      (HL),C          ; Save second byte of name
21EA: 23      	        inc     HL
21EB: 70      	        ld      (HL),B          ; Save first byte of name
21EC: 23      	        inc     HL
21ED: 4F      	        ld      C,A             ; Number of dimensions to C
21EE: CDF914  	        call    CHKSTK          ; Check if enough memory
21F1: 23      	        inc     HL              ; Point to number of dimensions
21F2: 23      	        inc     HL
21F3: 22AA81  	        ld      (CUROPR),HL     ; Save address of pointer
21F6: 71      	        ld      (HL),C          ; Set number of dimensions
21F7: 23      	        inc     HL
21F8: 3A9181  	        ld      A,(LCRFLG)      ; Locate of Create?
21FB: 17      	        rla                     ; Carry set = Create
21FC: 79      	        ld      A,C             ; Get number of dimensions
21FD: 010B00  	CRARLP: ld      BC,10+1         ; Default dimension size 10
2200: D20522  	        jp      NC,DEFSIZ       ; Locate - Set default size
2203: C1      	        pop     BC              ; Get specified dimension size
2204: 03      	        inc     BC              ; Include zero element
2205: 71      	DEFSIZ: ld      (HL),C          ; Save LSB of dimension size
2206: 23      	        inc     HL
2207: 70      	        ld      (HL),B          ; Save MSB of dimension size
2208: 23      	        inc     HL
2209: F5      	        push    AF              ; Save num' of dim'ns an status
220A: E5      	        push    HL              ; Save address of dim'n size
220B: CDB02D  	        call    MLDEBC          ; Multiply DE by BC to find
220E: EB      	        ex      DE,HL           ; amount of mem needed (to DE)
220F: E1      	        pop     HL              ; Restore address of dimension
2210: F1      	        pop     AF              ; Restore number of dimensions
2211: 3D      	        dec     A               ; Count them
2212: C2FD21  	        jp      NZ,CRARLP       ; Do next dimension if more
2215: F5      	        push    AF              ; Save locate/create flag
2216: 42      	        ld      B,D             ; MSB of memory needed
2217: 4B      	        ld      C,E             ; LSB of memory needed
2218: EB      	        ex      DE,HL
2219: 19      	        add     HL,DE           ; Add bytes to array start
221A: DA1115  	        jp      C,OMERR         ; Too big - Error
221D: CD0215  	        call    ENFMEM          ; See if enough memory
2220: 22BF81  	        ld      (ARREND),HL     ; Save new end of array
              	
2223: 2B      	ZERARY: dec     HL              ; Back through array data
2224: 3600    	        ld      (HL),$00        ; Set array element to zero
2226: CD1818  	        call    CPDEHL          ; All elements zeroed?
2229: C22322  	        jp      NZ,ZERARY       ; No - Keep on going
222C: 03      	        inc     BC              ; Number of bytes + 1
222D: 57      	        ld      D,A             ; A=0
222E: 2AAA81  	        ld      HL,(CUROPR)     ; Get address of array
2231: 5E      	        ld      E,(HL)          ; Number of dimensions
2232: EB      	        ex      DE,HL           ; To HL
2233: 29      	        add     HL,HL           ; Two bytes per dimension size
2234: 09      	        add     HL,BC           ; Add number of bytes
2235: EB      	        ex      DE,HL           ; Bytes needed to DE
2236: 2B      	        dec     HL
2237: 2B      	        dec     HL
2238: 73      	        ld      (HL),E          ; Save LSB of bytes needed
2239: 23      	        inc     HL
223A: 72      	        ld      (HL),D          ; Save MSB of bytes needed
223B: 23      	        inc     HL
223C: F1      	        pop     AF              ; Locate / Create?
223D: DA6422  	        jp      C,ENDDIM        ; A is 0 , End if create
2240: 47      	FINDEL: ld      B,A             ; Find array element
2241: 4F      	        ld      C,A
2242: 7E      	        ld      A,(HL)          ; Number of dimensions
2243: 23      	        inc     HL
2244: 16      	        defb    $16             ; Skip "pop HL"
2245: E1      	FNDELP: pop     HL              ; Address of next dim' size
2246: 5E      	        ld      E,(HL)          ; Get LSB of dim'n size
2247: 23      	        inc     HL
2248: 56      	        ld      D,(HL)          ; Get MSB of dim'n size
2249: 23      	        inc     HL
224A: E3      	        ex      (SP),HL         ; Save address - Get index
224B: F5      	        push    AF              ; Save number of dim'ns
224C: CD1818  	        call    CPDEHL          ; Dimension too large?
224F: D2DD21  	        jp      NC,BSERR        ; Yes - ?BS Error
2252: E5      	        push    HL              ; Save index
2253: CDB02D  	        call    MLDEBC          ; Multiply previous by size
2256: D1      	        pop     DE              ; Index supplied to DE
2257: 19      	        add     HL,DE           ; Add index to pointer
2258: F1      	        pop     AF              ; Number of dimensions
2259: 3D      	        dec     A               ; Count them
225A: 44      	        ld      B,H             ; MSB of pointer
225B: 4D      	        ld      C,L             ; LSB of pointer
225C: C24522  	        jp      NZ,FNDELP       ; More - Keep going
225F: 29      	        add     HL,HL           ; 4 Bytes per element
2260: 29      	        add     HL,HL
2261: C1      	        pop     BC              ; Start of array
2262: 09      	        add     HL,BC           ; Point to element
2263: EB      	        ex      DE,HL           ; Address of element to DE
2264: 2AB581  	ENDDIM: ld      HL,(NXTOPR)     ; Got code string address
2267: C9      	        ret
              	
              	
              	; returns the value of the 32-bit system tick counter as
              	; two 16-bit words
2268: CDB91E  	TMR:    call    TSTNUM          ; Make sure it's a number
226B: CDF71A  	        call    DEINT           ; Get integer (-32768 to 32767)
226E: 2ACE81  	        ld      HL,(TMRCNT)     ; load the LSBytes of timer
2271: 7B      	        ld      A,E
2272: B2      	        or      D               ; is it 0?
2273: CA7922  	        jp      Z,ENDTMR        ; yes, jump over
2276: 2AD081  	        ld      HL,(TMRCNT+2)   ; load the MSBytes of timer
2279: 45      	ENDTMR: ld      B,L             ; move bytes...
227A: 7C      	        ld      A,H             ; ...into AB
227B: C3A022  	        jp      ABPASS          ; return word into AB
              	
              	
              	; returns the free space for BASIC or into the string pool
227E: 2ABF81  	FRE:    ld      HL,(ARREND)     ; Start of free memory
2281: EB      	        ex      DE,HL           ; To DE
2282: 210000  	        ld      HL,$0000        ; End of free memory
2285: 39      	        add     HL,SP           ; Current stack value
2286: 3A9281  	        ld      A,(TYPE)        ; Dummy argument type
2289: B7      	        or      A
228A: CA9A22  	        jp      Z,FRENUM        ; Numeric - Free variable space
228D: CD0125  	        call    GSTRCU          ; Current string to pool
2290: CD0124  	        call    GARBGE          ; Garbage collection
2293: 2AAD80  	        ld      HL,(STRSPC)     ; Bottom of string space in use
2296: EB      	        ex      DE,HL           ; To DE
2297: 2AA881  	        ld      HL,(STRBOT)     ; Bottom of string space
229A: 7D      	FRENUM: ld      A,L             ; Get LSB of end
229B: 93      	        sub     E               ; Subtract LSB of beginning
229C: 4F      	        ld      C,A             ; Save difference if C
229D: 7C      	        ld      A,H             ; Get MSB of end
229E: 9A      	        sbc     A,D             ; Subtract MSB of beginning
229F: 41      	ACPASS: ld      B,C             ; Return integer AC
22A0: 50      	ABPASS: ld      D,B             ; Return integer AB
22A1: 1E00    	        ld      E,$00
22A3: 219281  	        ld      HL,TYPE         ; Point to type
22A6: 73      	        ld      (HL),E          ; Set type to numeric
22A7: 0690    	        ld      B,$80+$10       ; 16 bit integer
22A9: C3DB2C  	        jp      RETINT          ; Return the integer
              	
              	; returns the X position of the cursor during a print
22AC: 3A9081  	POS:    ld      A,(CURPOS)      ; Get cursor position
22AF: 47      	PASSA:  ld      B,A             ; Put A into AB
22B0: AF      	        xor     A               ; Zero A
22B1: C3A022  	        jp      ABPASS          ; Return integer AB
              	
22B4: CD3723  	DEF:    call    CHEKFN          ; Get "FN" and name
22B7: CD2923  	        call    IDTEST          ; Test for illegal direct
22BA: 01E41B  	        ld      BC,DATA         ; To get next statement
22BD: C5      	        push    BC              ; Save address for RETurn
22BE: D5      	        push    DE              ; Save address of function ptr
22BF: CD1E18  	        call    CHKSYN          ; Make sure "(" follows
22C2: 28      	        defb    '('
22C3: CDC520  	        call    GETVAR          ; Get argument variable name
22C6: E5      	        push    HL              ; Save code string address
22C7: EB      	        ex      DE,HL           ; Argument address to HL
22C8: 2B      	        dec     HL
22C9: 56      	        ld      D,(HL)          ; Get first byte of arg name
22CA: 2B      	        dec     HL
22CB: 5E      	        ld      E,(HL)          ; Get second byte of arg name
22CC: E1      	        pop     HL              ; Restore code string address
22CD: CDB91E  	        call    TSTNUM          ; Make sure numeric argument
22D0: CD1E18  	        call    CHKSYN          ; Make sure ")" follows
22D3: 29      	        defb    ')'
22D4: CD1E18  	        call    CHKSYN          ; Make sure "=" follows
22D7: C5      	        defb    ZEQUAL          ; "=" token
22D8: 44      	        ld      B,H             ; Code string address to BC
22D9: 4D      	        ld      C,L
22DA: E3      	        ex      (SP),HL         ; Save code str , Get FN ptr
22DB: 71      	        ld      (HL),C          ; Save LSB of FN code string
22DC: 23      	        inc     HL
22DD: 70      	        ld      (HL),B          ; Save MSB of FN code string
22DE: C37623  	        jp      SVSTAD          ; Save address and do function
              	
22E1: CD3723  	DOFN:   call    CHEKFN          ; Make sure FN follows
22E4: D5      	        push    DE              ; Save function pointer address
22E5: CD8D1F  	        call    EVLPAR          ; Evaluate expression in "()"
22E8: CDB91E  	        call    TSTNUM          ; Make sure numeric result
22EB: E3      	        ex      (SP),HL         ; Save code str , Get FN ptr
22EC: 5E      	        ld      E,(HL)          ; Get LSB of FN code string
22ED: 23      	        inc     HL
22EE: 56      	        ld      D,(HL)          ; Get MSB of FN code string
22EF: 23      	        inc     HL
22F0: 7A      	        ld      A,D             ; And function DEFined?
22F1: B3      	        or      E
22F2: CA4815  	        jp      Z,UFERR         ; No - ?UF Error
22F5: 7E      	        ld      A,(HL)          ; Get LSB of argument address
22F6: 23      	        inc     HL
22F7: 66      	        ld      H,(HL)          ; Get MSB of argument address
22F8: 6F      	        ld      L,A             ; HL = Arg variable address
22F9: E5      	        push    HL              ; Save it
22FA: 2AC381  	        ld      HL,(FNRGNM)     ; Get old argument name
22FD: E3      	        ex      (SP),HL         ; Save old , Get new
22FE: 22C381  	        ld      (FNRGNM),HL     ; Set new argument name
2301: 2AC781  	        ld      HL,(FNARG+2)    ; Get LSB,NLSB of old arg value
2304: E5      	        push    HL              ; Save it
2305: 2AC581  	        ld      HL,(FNARG)      ; Get MSB,EXP of old arg value
2308: E5      	        push    HL              ; Save it
2309: 21C581  	        ld      HL,FNARG        ; HL = Value of argument
230C: D5      	        push    DE              ; Save FN code string address
230D: CD1C2D  	        call    FPTHL           ; Move FPREG to argument
2310: E1      	        pop     HL              ; Get FN code string address
2311: CDB61E  	        call    GETNUM          ; Get value from function
2314: 2B      	        dec     HL              ; dec 'cos GETCHR INCs
2315: CD411A  	        call    GETCHR          ; Get next character
2318: C23C15  	        jp      NZ,SNERR        ; Bad character in FN - Error
231B: E1      	        pop     HL              ; Get MSB,EXP of old arg
231C: 22C581  	        ld      (FNARG),HL      ; Restore it
231F: E1      	        pop     HL              ; Get LSB,NLSB of old arg
2320: 22C781  	        ld      (FNARG+2),HL    ; Restore it
2323: E1      	        pop     HL              ; Get name of old arg
2324: 22C381  	        ld      (FNRGNM),HL     ; Restore it
2327: E1      	        pop     HL              ; Restore code string address
2328: C9      	        ret
              	
2329: E5      	IDTEST: push    HL              ; Save code string address
232A: 2AAF80  	        ld      HL,(LINEAT)     ; Get current line number
232D: 23      	        inc     HL              ; -1 means direct statement
232E: 7C      	        ld      A,H
232F: B5      	        or      L
2330: E1      	        pop     HL              ; Restore code string address
2331: C0      	        ret     NZ              ; Return if in program
2332: 1E16    	        ld      E,ID            ; ?ID Error
2334: C35015  	        jp      ERROR
              	
2337: CD1E18  	CHEKFN: call    CHKSYN          ; Make sure FN follows
233A: B5      	        defb    ZFN             ; "FN" token
233B: 3E80    	        ld      A,$80
233D: 32B081  	        ld      (FORFLG),A      ; Flag FN name to find
2340: B6      	        or      (HL)            ; FN name has bit 7 set
2341: 47      	        ld      B,A             ; in first byte of name
2342: CDCA20  	        call    GTFNAM          ; Get FN name
2345: C3B91E  	        jp      TSTNUM          ; Make sure numeric function
              	
2348: CDB91E  	STR:    call    TSTNUM          ; Make sure it's a number
234B: CD692E  	        call    NUMASC          ; Turn number into text
234E: CD7C23  	STR1:   call    CRTST           ; Create string entry for it
2351: CD0125  	        call    GSTRCU          ; Current string to pool
2354: 015C25  	        ld      BC,TOPOOL       ; Save in string pool
2357: C5      	        push    BC              ; Save address on stack
              	
2358: 7E      	SAVSTR: ld      A,(HL)          ; Get string length
2359: 23      	        inc     HL
235A: 23      	        inc     HL
235B: E5      	        push    HL              ; Save pointer to string
235C: CDD723  	        call    TESTR           ; See if enough string space
235F: E1      	        pop     HL              ; Restore pointer to string
2360: 4E      	        ld      C,(HL)          ; Get LSB of address
2361: 23      	        inc     HL
2362: 46      	        ld      B,(HL)          ; Get MSB of address
2363: CD7023  	        call    CRTMST          ; Create string entry
2366: E5      	        push    HL              ; Save pointer to MSB of addr
2367: 6F      	        ld      L,A             ; Length of string
2368: CDF424  	        call    TOSTRA          ; Move to string area
236B: D1      	        pop     DE              ; Restore pointer to MSB
236C: C9      	        ret
              	
236D: CDD723  	MKTMST: call    TESTR           ; See if enough string space
2370: 21A481  	CRTMST: ld      HL,TMPSTR       ; Temporary string
2373: E5      	        push    HL              ; Save it
2374: 77      	        ld      (HL),A          ; Save length of string
2375: 23      	        inc     HL
2376: 23      	SVSTAD: inc     HL
2377: 73      	        ld      (HL),E          ; Save LSB of address
2378: 23      	        inc     HL
2379: 72      	        ld      (HL),D          ; Save MSB of address
237A: E1      	        pop     HL              ; Restore pointer
237B: C9      	        ret
              	
237C: 2B      	CRTST:  dec     HL              ; dec - INCed after
237D: 0622    	QTSTR:  ld      B,$22           ; '"'           ; Terminating quote
237F: 50      	        ld      D,B             ; Quote to D
2380: E5      	DTSTR:  push    HL              ; Save start
2381: 0EFF    	        ld      C,-1            ; Set counter to -1
2383: 23      	QTSTLP: inc     HL              ; Move on
2384: 7E      	        ld      A,(HL)          ; Get byte
2385: 0C      	        inc     C               ; Count bytes
2386: B7      	        or      A               ; End of line?
2387: CA9223  	        jp      Z,CRTSTE        ; Yes - Create string entry
238A: BA      	        cp      D               ; Terminator D found?
238B: CA9223  	        jp      Z,CRTSTE        ; Yes - Create string entry
238E: B8      	        cp      B               ; Terminator B found?
238F: C28323  	        jp      NZ,QTSTLP       ; No - Keep looking
2392: FE22    	CRTSTE: cp      $22             ; '"'             ; End with '"'?
2394: CC411A  	        call    Z,GETCHR        ; Yes - Get next character
2397: E3      	        ex      (SP),HL         ; Starting quote
2398: 23      	        inc     HL              ; First byte of string
2399: EB      	        ex      DE,HL           ; To DE
239A: 79      	        ld      A,C             ; Get length
239B: CD7023  	        call    CRTMST          ; Create string entry
239E: 11A481  	TSTOPL: ld      DE,TMPSTR       ; Temporary string
23A1: 2A9681  	        ld      HL,(TMSTPT)     ; Temporary string pool pointer
23A4: 22C981  	        ld      (FPREG),HL      ; Save address of string ptr
23A7: 3E01    	        ld      A,$01
23A9: 329281  	        ld      (TYPE),A        ; Set type to string
23AC: CD1F2D  	        call    DETHL4          ; Move string to pool
23AF: CD1818  	        call    CPDEHL          ; Out of string pool?
23B2: 229681  	        ld      (TMSTPT),HL     ; Save new pointer
23B5: E1      	        pop     HL              ; Restore code string address
23B6: 7E      	        ld      A,(HL)          ; Get next code byte
23B7: C0      	        ret     NZ              ; Return if pool OK
23B8: 1E1E    	        ld      E,ST            ; ?ST Error
23BA: C35015  	        jp      ERROR           ; String pool overflow
              	
23BD: 23      	PRNUMS: inc     HL              ; Skip leading space
23BE: CD7C23  	PRS:    call    CRTST           ; Create string entry for it
23C1: CD0125  	PRS1:   call    GSTRCU          ; Current string to pool
23C4: CD132D  	        call    LOADFP          ; Move string block to BCDE
23C7: 1C      	        inc     E               ; Length + 1
23C8: 1D      	PRSLP:  dec     E               ; Count characters
23C9: C8      	        ret     Z               ; End of string
23CA: 0A      	        ld      A,(BC)          ; Get byte to output
23CB: CD2918  	        call    OUTC            ; Output character in A
23CE: FE0D    	        cp      CR              ; Return?
23D0: CC041D  	        call    Z,CNTEND        ; Yes - Position cursor to 0
23D3: 03      	        inc     BC              ; Next byte in string
23D4: C3C823  	        jp      PRSLP           ; More characters to output
              	
23D7: B7      	TESTR:  or      A               ; Test if enough room
23D8: 0E      	        defb    $0E             ; No garbage collection done
23D9: F1      	GRBDON: pop     AF              ; Garbage collection done
23DA: F5      	        push    AF              ; Save status
23DB: 2AAD80  	        ld      HL,(STRSPC)     ; Bottom of string space in use
23DE: EB      	        ex      DE,HL           ; To DE
23DF: 2AA881  	        ld      HL,(STRBOT)     ; Bottom of string area
23E2: 2F      	        cpl                     ; Negate length (Top down)
23E3: 4F      	        ld      C,A             ; -Length to BC
23E4: 06FF    	        ld      B,-1            ; BC = -ve length of string
23E6: 09      	        add     HL,BC           ; Add to bottom of space in use
23E7: 23      	        inc     HL              ; Plus one for 2's complement
23E8: CD1818  	        call    CPDEHL          ; Below string RAM area?
23EB: DAF523  	        jp      C,TESTOS        ; Tidy up if not done else err
23EE: 22A881  	        ld      (STRBOT),HL     ; Save new bottom of area
23F1: 23      	        inc     HL              ; Point to first byte of string
23F2: EB      	        ex      DE,HL           ; Address to DE
23F3: F1      	POPAF:  pop     AF              ; Throw away status push
23F4: C9      	        ret
              	
23F5: F1      	TESTOS: pop     AF              ; Garbage collect been done?
23F6: 1E1A    	        ld      E,OS            ; ?OS Error
23F8: CA5015  	        jp      Z,ERROR         ; Yes - Not enough string space
23FB: BF      	        cp      A               ; Flag garbage collect done
23FC: F5      	        push    AF              ; Save status
23FD: 01D923  	        ld      BC,GRBDON       ; Garbage collection done
2400: C5      	        push    BC              ; Save for RETurn
2401: 2A9481  	GARBGE: ld      HL,(LSTRAM)     ; Get end of RAM pointer
2404: 22A881  	GARBLP: ld      (STRBOT),HL     ; Reset string pointer
2407: 210000  	        ld      HL,$0000
240A: E5      	        push    HL              ; Flag no string found
240B: 2AAD80  	        ld      HL,(STRSPC)     ; Get bottom of string space
240E: E5      	        push    HL              ; Save bottom of string space
240F: 219881  	        ld      HL,TMSTPL       ; Temporary string pool
2412: EB      	GRBLP:  ex      DE,HL
2413: 2A9681  	        ld      HL,(TMSTPT)     ; Temporary string pool pointer
2416: EB      	        ex      DE,HL
2417: CD1818  	        call    CPDEHL          ; Temporary string pool done?
241A: 011224  	        ld      BC,GRBLP        ; Loop until string pool done
241D: C26624  	        jp      NZ,STPOOL       ; No - See if in string area
2420: 2ABB81  	        ld      HL,(PROGND)     ; Start of simple variables
2423: EB      	SMPVAR: ex      DE,HL
2424: 2ABD81  	        ld      HL,(VAREND)     ; End of simple variables
2427: EB      	        ex      DE,HL
2428: CD1818  	        call    CPDEHL          ; All simple strings done?
242B: CA3924  	        jp      Z,ARRLP         ; Yes - Do string arrays
242E: 7E      	        ld      A,(HL)          ; Get type of variable
242F: 23      	        inc     HL
2430: 23      	        inc     HL
2431: B7      	        or      A               ; "S" flag set if string
2432: CD6924  	        call    STRADD          ; See if string in string area
2435: C32324  	        jp      SMPVAR          ; Loop until simple ones done
              	
2438: C1      	GNXARY: pop     BC              ; Scrap address of this array
2439: EB      	ARRLP:  ex      DE,HL
243A: 2ABF81  	        ld      HL,(ARREND)     ; End of string arrays
243D: EB      	        ex      DE,HL
243E: CD1818  	        call    CPDEHL          ; All string arrays done?
2441: CA8F24  	        jp      Z,SCNEND        ; Yes - Move string if found
2444: CD132D  	        call    LOADFP          ; Get array name to BCDE
2447: 7B      	        ld      A,E             ; Get type of array
2448: E5      	        push    HL              ; Save address of num of dim'ns
2449: 09      	        add     HL,BC           ; Start of next array
244A: B7      	        or      A               ; Test type of array
244B: F23824  	        jp      P,GNXARY        ; Numeric array - Ignore it
244E: 22AA81  	        ld      (CUROPR),HL     ; Save address of next array
2451: E1      	        pop     HL              ; Get address of num of dim'ns
2452: 4E      	        ld      C,(HL)          ; BC = Number of dimensions
2453: 0600    	        ld      B,$00
2455: 09      	        add     HL,BC           ; Two bytes per dimension size
2456: 09      	        add     HL,BC
2457: 23      	        inc     HL              ; Plus one for number of dim'ns
2458: EB      	GRBARY: ex      DE,HL
2459: 2AAA81  	        ld      HL,(CUROPR)     ; Get address of next array
245C: EB      	        ex      DE,HL
245D: CD1818  	        call    CPDEHL          ; Is this array finished?
2460: CA3924  	        jp      Z,ARRLP         ; Yes - Get next one
2463: 015824  	        ld      BC,GRBARY       ; Loop until array all done
2466: C5      	STPOOL: push    BC              ; Save return address
2467: F680    	        or      $80             ; Flag string type
2469: 7E      	STRADD: ld      A,(HL)          ; Get string length
246A: 23      	        inc     HL
246B: 23      	        inc     HL
246C: 5E      	        ld      E,(HL)          ; Get LSB of string address
246D: 23      	        inc     HL
246E: 56      	        ld      D,(HL)          ; Get MSB of string address
246F: 23      	        inc     HL
2470: F0      	        ret     P               ; Not a string - Return
2471: B7      	        or      A               ; Set flags on string length
2472: C8      	        ret     Z               ; Null string - Return
2473: 44      	        ld      B,H             ; Save variable pointer
2474: 4D      	        ld      C,L
2475: 2AA881  	        ld      HL,(STRBOT)     ; Bottom of new area
2478: CD1818  	        call    CPDEHL          ; String been done?
247B: 60      	        ld      H,B             ; Restore variable pointer
247C: 69      	        ld      L,C
247D: D8      	        ret     C               ; String done - Ignore
247E: E1      	        pop     HL              ; Return address
247F: E3      	        ex      (SP),HL         ; Lowest available string area
2480: CD1818  	        call    CPDEHL          ; String within string area?
2483: E3      	        ex      (SP),HL         ; Lowest available string area
2484: E5      	        push    HL              ; Re-save return address
2485: 60      	        ld      H,B             ; Restore variable pointer
2486: 69      	        ld      L,C
2487: D0      	        ret     NC              ; Outside string area - Ignore
2488: C1      	        pop     BC              ; Get return , Throw 2 away
2489: F1      	        pop     AF              ;
248A: F1      	        pop     AF              ;
248B: E5      	        push    HL              ; Save variable pointer
248C: D5      	        push    DE              ; Save address of current
248D: C5      	        push    BC              ; Put back return address
248E: C9      	        ret                     ; Go to it
              	
248F: D1      	SCNEND: pop     DE              ; Addresses of strings
2490: E1      	        pop     HL              ;
2491: 7D      	        ld      A,L             ; HL = 0 if no more to do
2492: B4      	        or      H
2493: C8      	        ret     Z               ; No more to do - Return
2494: 2B      	        dec     HL
2495: 46      	        ld      B,(HL)          ; MSB of address of string
2496: 2B      	        dec     HL
2497: 4E      	        ld      C,(HL)          ; LSB of address of string
2498: E5      	        push    HL              ; Save variable address
2499: 2B      	        dec     HL
249A: 2B      	        dec     HL
249B: 6E      	        ld      L,(HL)          ; HL = Length of string
249C: 2600    	        ld      H,$00
249E: 09      	        add     HL,BC           ; Address of end of string+1
249F: 50      	        ld      D,B             ; String address to DE
24A0: 59      	        ld      E,C
24A1: 2B      	        dec     HL              ; Last byte in string
24A2: 44      	        ld      B,H             ; Address to BC
24A3: 4D      	        ld      C,L
24A4: 2AA881  	        ld      HL,(STRBOT)     ; Current bottom of string area
24A7: CDEB14  	        call    MOVSTR          ; Move string to new address
24AA: E1      	        pop     HL              ; Restore variable address
24AB: 71      	        ld      (HL),C          ; Save new LSB of address
24AC: 23      	        inc     HL
24AD: 70      	        ld      (HL),B          ; Save new MSB of address
24AE: 69      	        ld      L,C             ; Next string area+1 to HL
24AF: 60      	        ld      H,B
24B0: 2B      	        dec     HL              ; Next string area address
24B1: C30424  	        jp      GARBLP          ; Look for more strings
              	
24B4: C5      	CONCAT: push    BC              ; Save prec' opr & code string
24B5: E5      	        push    HL              ;
24B6: 2AC981  	        ld      HL,(FPREG)      ; Get first string
24B9: E3      	        ex      (SP),HL         ; Save first string
24BA: CD3F1F  	        call    OPRND           ; Get second string
24BD: E3      	        ex      (SP),HL         ; Restore first string
24BE: CDBA1E  	        call    TSTSTR          ; Make sure it's a string
24C1: 7E      	        ld      A,(HL)          ; Get length of second string
24C2: E5      	        push    HL              ; Save first string
24C3: 2AC981  	        ld      HL,(FPREG)      ; Get second string
24C6: E5      	        push    HL              ; Save second string
24C7: 86      	        add     A,(HL)          ; Add length of second string
24C8: 1E1C    	        ld      E,LS            ; ?LS Error
24CA: DA5015  	        jp      C,ERROR         ; String too long - Error
24CD: CD6D23  	        call    MKTMST          ; Make temporary string
24D0: D1      	        pop     DE              ; Get second string to DE
24D1: CD0525  	        call    GSTRDE          ; Move to string pool if needed
24D4: E3      	        ex      (SP),HL         ; Get first string
24D5: CD0425  	        call    GSTRHL          ; Move to string pool if needed
24D8: E5      	        push    HL              ; Save first string
24D9: 2AA681  	        ld      HL,(TMPSTR+2)   ; Temporary string address
24DC: EB      	        ex      DE,HL           ; To DE
24DD: CDEB24  	        call    SSTSA           ; First string to string area
24E0: CDEB24  	        call    SSTSA           ; Second string to string area
24E3: 21D41E  	        ld      HL,EVAL2        ; Return to evaluation loop
24E6: E3      	        ex      (SP),HL         ; Save return,get code string
24E7: E5      	        push    HL              ; Save code string address
24E8: C39E23  	        jp      TSTOPL          ; To temporary string to pool
              	
24EB: E1      	SSTSA:  pop     HL              ; Return address
24EC: E3      	        ex      (SP),HL         ; Get string block,save return
24ED: 7E      	        ld      A,(HL)          ; Get length of string
24EE: 23      	        inc     HL
24EF: 23      	        inc     HL
24F0: 4E      	        ld      C,(HL)          ; Get LSB of string address
24F1: 23      	        inc     HL
24F2: 46      	        ld      B,(HL)          ; Get MSB of string address
24F3: 6F      	        ld      L,A             ; Length to L
24F4: 2C      	TOSTRA: inc     L               ; inc - DECed after
24F5: 2D      	TSALP:  dec     L               ; Count bytes moved
24F6: C8      	        ret     Z               ; End of string - Return
24F7: 0A      	        ld      A,(BC)          ; Get source
24F8: 12      	        ld      (DE),A          ; Save destination
24F9: 03      	        inc     BC              ; Next source
24FA: 13      	        inc     DE              ; Next destination
24FB: C3F524  	        jp      TSALP           ; Loop until string moved
              	
24FE: CDBA1E  	GETSTR: call    TSTSTR          ; Make sure it's a string
2501: 2AC981  	GSTRCU: ld      HL,(FPREG)      ; Get current string
2504: EB      	GSTRHL: ex      DE,HL           ; Save DE
2505: CD1F25  	GSTRDE: call    BAKTMP          ; Was it last tmp-str?
2508: EB      	        ex      DE,HL           ; Restore DE
2509: C0      	        ret     NZ              ; No - Return
250A: D5      	        push    DE              ; Save string
250B: 50      	        ld      D,B             ; String block address to DE
250C: 59      	        ld      E,C
250D: 1B      	        dec     DE              ; Point to length
250E: 4E      	        ld      C,(HL)          ; Get string length
250F: 2AA881  	        ld      HL,(STRBOT)     ; Current bottom of string area
2512: CD1818  	        call    CPDEHL          ; Last one in string area?
2515: C21D25  	        jp      NZ,POPHL        ; No - Return
2518: 47      	        ld      B,A             ; Clear B (A=0)
2519: 09      	        add     HL,BC           ; Remove string from str' area
251A: 22A881  	        ld      (STRBOT),HL     ; Save new bottom of str' area
251D: E1      	POPHL:  pop     HL              ; Restore string
251E: C9      	        ret
              	
251F: 2A9681  	BAKTMP: ld      HL,(TMSTPT)     ; Get temporary string pool top
2522: 2B      	        dec     HL              ; Back
2523: 46      	        ld      B,(HL)          ; Get MSB of address
2524: 2B      	        dec     HL              ; Back
2525: 4E      	        ld      C,(HL)          ; Get LSB of address
2526: 2B      	        dec     HL              ; Back
2527: 2B      	        dec     HL              ; Back
2528: CD1818  	        call    CPDEHL          ; String last in string pool?
252B: C0      	        ret     NZ              ; Yes - Leave it
252C: 229681  	        ld      (TMSTPT),HL     ; Save new string pool top
252F: C9      	        ret
              	
2530: 01AF22  	LEN:    ld      BC,PASSA        ; To return integer A
2533: C5      	        push    BC              ; Save address
2534: CDFE24  	GETLEN: call    GETSTR          ; Get string and its length
2537: AF      	        xor     A
2538: 57      	        ld      D,A             ; Clear D
2539: 329281  	        ld      (TYPE),A        ; Set type to numeric
253C: 7E      	        ld      A,(HL)          ; Get length of string
253D: B7      	        or      A               ; Set status flags
253E: C9      	        ret
              	
253F: 01AF22  	ASC:    ld      BC,PASSA        ; To return integer A
2542: C5      	        push    BC              ; Save address
2543: CD3425  	GTFLNM: call    GETLEN          ; Get length of string
2546: CA0C1B  	        jp      Z,FCERR         ; Null string - Error
2549: 23      	        inc     HL
254A: 23      	        inc     HL
254B: 5E      	        ld      E,(HL)          ; Get LSB of address
254C: 23      	        inc     HL
254D: 56      	        ld      D,(HL)          ; Get MSB of address
254E: 1A      	        ld      A,(DE)          ; Get first byte of string
254F: C9      	        ret
              	
2550: 3E01    	CHR:    ld      A,$01           ; One character string
2552: CD6D23  	        call    MKTMST          ; Make a temporary string
2555: CD3F27  	        call    MAKINT          ; Make it integer A
2558: 2AA681  	        ld      HL,(TMPSTR+2)   ; Get address of string
255B: 73      	        ld      (HL),E          ; Save character
255C: C1      	TOPOOL: pop     BC              ; Clean up stack
255D: C39E23  	        jp      TSTOPL          ; Temporary string to pool
              	
2560: CDEF26  	LEFT:   call    LFRGNM          ; Get number and ending ")"
2563: AF      	        xor     A               ; Start at first byte in string
2564: E3      	RIGHT1: ex      (SP),HL         ; Save code string,Get string
2565: 4F      	        ld      C,A             ; Starting position in string
2566: E5      	MID1:   push    HL              ; Save string block address
2567: 7E      	        ld      A,(HL)          ; Get length of string
2568: B8      	        cp      B               ; Compare with number given
2569: DA6E25  	        jp      C,ALLFOL        ; All following bytes required
256C: 78      	        ld      A,B             ; Get new length
256D: 11      	        defb    $11             ; Skip "ld C,0"
256E: 0E00    	ALLFOL: ld      C,$00           ; First byte of string
2570: C5      	        push    BC              ; Save position in string
2571: CDD723  	        call    TESTR           ; See if enough string space
2574: C1      	        pop     BC              ; Get position in string
2575: E1      	        pop     HL              ; Restore string block address
2576: E5      	        push    HL              ; And re-save it
2577: 23      	        inc     HL
2578: 23      	        inc     HL
2579: 46      	        ld      B,(HL)          ; Get LSB of address
257A: 23      	        inc     HL
257B: 66      	        ld      H,(HL)          ; Get MSB of address
257C: 68      	        ld      L,B             ; HL = address of string
257D: 0600    	        ld      B,$00           ; BC = starting address
257F: 09      	        add     HL,BC           ; Point to that byte
2580: 44      	        ld      B,H             ; BC = source string
2581: 4D      	        ld      C,L
2582: CD7023  	        call    CRTMST          ; Create a string entry
2585: 6F      	        ld      L,A             ; Length of new string
2586: CDF424  	        call    TOSTRA          ; Move string to string area
2589: D1      	        pop     DE              ; Clear stack
258A: CD0525  	        call    GSTRDE          ; Move to string pool if needed
258D: C39E23  	        jp      TSTOPL          ; Temporary string to pool
              	
              	
              	; INSTR statement - look for a string inside another string
              	; usage: INSTR(A$,B$) -> search for B$ into A$
              	; return 0 if B$ is not contained into A$ or LEN(A$)<LEN(B$)
              	; return 1~255 to indicate the starting position of B$ into A$
              	; ex.: INSTR("HELLO","LO") returns 4
              	;PT=0
              	;DO
              	;  TF=0:TP=0
              	;  IF S1(PT)=S2(0) THEN
              	;    TF=1:TP=PT:PT1=PT:PT2=0
              	;    DO
              	;      IF S1(PT1)<>S2(PT2) THEN TF=0:EXIT
              	;      PT1=PT1+1
              	;      PT2=PT2+1
              	;    LOOP UNTIL PT2=LEN(S2)
              	;  IF TF<>0 THEN EXIT
              	;  PT=PT+1
              	;LOOP UNTIL PT>=LEN(S1)-LEN(S2)
              	;IF TF=0 THEN RETURN 0 ELSE RETURN TP
81EF:         	LNS1    equ     TMPBFR1
81F1:         	ADRS1   equ     TMPBFR2
81F3:         	LNS2    equ     TMPBFR3
81F5:         	ADRS2   equ     TMPBFR4
81F7:         	PT      equ     VIDEOBUFF
81F9:         	PT1     equ     VIDEOBUFF+2
81FB:         	PT2     equ     VIDEOBUFF+4
81FD:         	TP      equ     VIDEOBUFF+6
81FF:         	TF      equ     VIDEOBUFF+8
2590: CD1E18  	INSTR:  call    CHKSYN          ; make sure "(" follows
2593: 28      	        defb    '('
2594: 2B      	        dec     HL
2595: CD411A  	        call    GETCHR          ; check if something follows
2598: CA3C15  	        jp      Z,SNERR         ; if nothing else, raise a syntax error
259B: CDC81E  	        call    EVAL            ; Evaluate expression
259E: CDBA1E  	        call    TSTSTR          ; Make sure it's a string
25A1: 22F781  	        ld      (VIDEOBUFF),HL  ; store code string pointer into a temp buffer
25A4: CD0125  	        call    GSTRCU          ; check that a string follows
25A7: CD132D  	        call    LOADFP          ; Move string block to BCDE (BC=pointer, E=length)
25AA: ED53EF81	        ld      (LNS1),DE       ; store values into
25AE: ED43F181	        ld      (ADRS1),BC      ; temp buffers
25B2: 2AF781  	        ld      HL,(VIDEOBUFF)  ; retrieve code string pointer from temp buffer
25B5: CD1E18  	        call    CHKSYN          ; Make sure ',' follows
25B8: 2C      	        defb    ','
25B9: 2B      	        dec     HL
25BA: CD411A  	        call    GETCHR          ; check if something follows
25BD: CA3C15  	        jp      Z,SNERR         ; if nothing else, raise a syntax error
25C0: CDC81E  	        call    EVAL            ; Evaluate expression
25C3: CDBA1E  	        call    TSTSTR          ; Make sure it's a string
25C6: 22F781  	        ld      (VIDEOBUFF),HL  ; store code string pointer into a temp buffer
25C9: CD0125  	        call    GSTRCU          ; check that a string follows
25CC: CD132D  	        call    LOADFP          ; Move string block to BCDE (BC=pointer, E=length)
25CF: ED53F381	        ld      (LNS2),DE       ; store values into
25D3: ED43F581	        ld      (ADRS2),BC      ; temp buffers
25D7: 2AF781  	        ld      HL,(VIDEOBUFF)  ; retrieve code string pointer from temp buffer
25DA: CD1E18  	        call    CHKSYN          ; make sure ")" follows
25DD: 29      	        defb    ')'
25DE: E5      	        push    HL              ; store current code string pointer (the point after the ")" ) ...
25DF: FDE1    	        pop     IY              ; ...into IY
25E1: AF      	        xor     A               ; reset 10 RAM cells
25E2: 060A    	        ld      B,$0A           ; (INSTR registers)
25E4: 21F781  	        ld      HL,PT           ; first cell
25E7: 77      	EMPTINS:ld      (HL),A          ; reset cell
25E8: 23      	        inc     HL              ; next cell
25E9: 10FC    	        djnz    EMPTINS         ; repeat
25EB: ED5BF381	        ld      DE,(LNS2)       ; load len(S2) into DE
25EF: 2AEF81  	        ld      HL,(LNS1)       ; load len(S1) into HL
25F2: CD5F3C  	        call    CMP16           ; check that len(S1)>=len(S2)
25F5: DA6A26  	        jp      C,RZINSTR       ; if len(S2)>len(S1) then return 0
25F8: AF      	RPTINST:xor     A               ; reset...
25F9: 32FD81  	        ld      (TP),A          ; ...TP...
25FC: 32FF81  	        ld      (TF),A          ; ...and TF
25FF: ED4BF781	        ld      BC,(PT)         ; pointer to S1
2603: 2AF181  	        ld      HL,(ADRS1)      ; first cell of S1
2606: 09      	        add     HL,BC           ; get current position into RAM
2607: 7E      	        ld      A,(HL)          ; load S1(PT)
2608: 2AF581  	        ld      HL,(ADRS2)      ; pointer to first char of S2
260B: BE      	        cp      (HL)            ; is S1(PT)=S2(0)?
260C: 203A    	        jr      NZ,CNT1INS      ; no, continue
260E: 3AF781  	        ld      A,(PT)          ; load current PT
2611: 32FD81  	        ld      (TP),A          ; TP=PT
2614: 32F981  	        ld      (PT1),A         ; P1=PT
2617: AF      	        xor     A               ; set...
2618: 32FB81  	        ld      (PT2),A         ; ...PT2=0
261B: 3C      	        inc     A               ;
261C: 32FF81  	        ld      (TF),A          ; set TF=1
261F: ED4BF981	RP2INST:ld      BC,(PT1)        ; load pointer PT1
2623: 2AF181  	        ld      HL,(ADRS1)      ; load address of S1
2626: 09      	        add     HL,BC           ; find char of S1 pointed by PT1
2627: 7E      	        ld      A,(HL)          ; load S1(PT1)
2628: ED4BFB81	        ld      BC,(PT2)        ; load pointer PT2
262C: 2AF581  	        ld      HL,(ADRS2)      ; load char of S2 pointed by PT2
262F: 09      	        add     HL,BC           ; find S2(PT2)
2630: BE      	        cp      (HL)            ; is S1(PT1)=S2(PT2)?
2631: 204C    	        jr      NZ,CNTZIN       ; no, exit inner loop
2633: 21F981  	        ld      HL,PT1
2636: 34      	        inc     (HL)            ; increment PT1
2637: 3AFB81  	        ld      A,(PT2)
263A: 3C      	        inc     A               ; increment PT2
263B: 32FB81  	        ld      (PT2),A
263E: CA4826  	        jp      Z,CNT1INS       ; if PT2>255 then exit
2641: 21F381  	        ld      HL,LNS2         ; len(S2)
2644: BE      	        cp      (HL)            ; PT2=len(S2)?
2645: DA1F26  	        jp      C,RP2INST       ; no (PT2<len(S2) - repeat
2648: 3AFF81  	CNT1INS:ld      A,(TF)          ; check TF
264B: A7      	        and     A               ; TF=0? (clears also Carry for next SBC)
264C: 201C    	        jr      NZ,RZINSTR      ; no, exit
264E: 2AEF81  	        ld      HL,(LNS1)       ; load len(S1)
2651: ED4BF381	        ld      BC,(LNS2)       ; load len(S2)
2655: ED42    	        sbc     HL,BC           ; HL=len(S1)-len(S2)
2657: ED5BF781	        ld      DE,(PT)         ; load pointer
265B: 1C      	        inc     E               ; PT=PT+1
265C: ED53F781	        ld      (PT),DE         ; store new value
2660: EB      	        ex      DE,HL           ; invert registers
2661: CD5F3C  	        call    CMP16           ; check if PT>len(S1)-len(S2)
2664: DAF825  	        jp      C,RPTINST       ; repeat if <
2667: CAF825  	        jp      Z,RPTINST       ; repeat if =
266A: 3AFF81  	RZINSTR:ld      A,(TF)          ; current value of TF
266D: A7      	        and     A               ; is it 0?
266E: CA7526  	        jp      Z,LVINSTR       ; yes, return 0
2671: 3AFD81  	        ld      A,(TP)          ; return TP...
2674: 3C      	        inc     A               ; ...incremented by 1
2675: E1      	LVINSTR:pop     HL              ; drop original return point
2676: FDE5    	        push    IY              ; load current string address from IY into stack
2678: 11A11F  	        ld      DE,RETNUM       ; Address of Return number from function...
267B: D5      	        push    DE              ; ...saved on stack
267C: C3AF22  	        jp      PASSA           ; return TP
267F: AF      	CNTZIN: xor     A               ; set...
2680: 32FF81  	        ld      (TF),A          ; TF=0
2683: C34826  	        jp      CNT1INS         ; continue
              	
              	
2686: CDEF26  	RIGHT:  call    LFRGNM          ; Get number and ending ")"
2689: D1      	        pop     DE              ; Get string length
268A: D5      	        push    DE              ; And re-save
268B: 1A      	        ld      A,(DE)          ; Get length
268C: 90      	        sub     B               ; Move back N bytes
268D: C36425  	        jp      RIGHT1          ; Go and get sub-string
              	
2690: EB      	MID:    ex      DE,HL           ; Get code string address
2691: 7E      	        ld      A,(HL)          ; Get next byte ',' or ")"
2692: CDF426  	        call    MIDNUM          ; Get number supplied
2695: 04      	        inc     B               ; Is it character zero?
2696: 05      	        dec     B
2697: CA0C1B  	        jp      Z,FCERR         ; Yes - Error
269A: C5      	        push    BC              ; Save starting position
269B: 1EFF    	        ld      E,$FF           ; All of string
269D: FE29    	        cp      ')'             ; Any length given?
269F: CAA926  	        jp      Z,RSTSTR        ; No - Rest of string
26A2: CD1E18  	        call    CHKSYN          ; Make sure ',' follows
26A5: 2C      	        defb    ','
26A6: CD3C27  	        call    GETINT          ; Get integer 0-255
26A9: CD1E18  	RSTSTR: call    CHKSYN          ; Make sure ")" follows
26AC: 29      	        defb    ')'
26AD: F1      	        pop     AF              ; Restore starting position
26AE: E3      	        ex      (SP),HL         ; Get string,save code string
26AF: 016625  	        ld      BC,MID1         ; Continuation of MID$ routine
26B2: C5      	        push    BC              ; Save for return
26B3: 3D      	        dec     A               ; Starting position-1
26B4: BE      	        cp      (HL)            ; Compare with length
26B5: 0600    	        ld      B,$00           ; Zero bytes length
26B7: D0      	        ret     NC              ; Null string if start past end
26B8: 4F      	        ld      C,A             ; Save starting position-1
26B9: 7E      	        ld      A,(HL)          ; Get length of string
26BA: 91      	        sub     C               ; Subtract start
26BB: BB      	        cp      E               ; Enough string for it?
26BC: 47      	        ld      B,A             ; Save maximum length available
26BD: D8      	        ret     C               ; Truncate string if needed
26BE: 43      	        ld      B,E             ; Set specified length
26BF: C9      	        ret                     ; Go and create string
              	
26C0: CD3425  	VAL:    call    GETLEN          ; Get length of string
26C3: CA932A  	        jp      Z,RESZER        ; Result zero
26C6: 5F      	        ld      E,A             ; Save length
26C7: 23      	        inc     HL
26C8: 23      	        inc     HL
26C9: 7E      	        ld      A,(HL)          ; Get LSB of address
26CA: 23      	        inc     HL
26CB: 66      	        ld      H,(HL)          ; Get MSB of address
26CC: 6F      	        ld      L,A             ; HL = String address
26CD: E5      	        push    HL              ; Save string address
26CE: 19      	        add     HL,DE
26CF: 46      	        ld      B,(HL)          ; Get end of string+1 byte
26D0: 72      	        ld      (HL),D          ; Zero it to terminate
26D1: E3      	        ex      (SP),HL         ; Save string end,get start
26D2: C5      	        push    BC              ; Save end+1 byte
26D3: 7E      	        ld      A,(HL)          ; Get starting byte
26D4: FE24    	        cp      '$'             ; Hex number indicated? [function added]
26D6: C2DE26  	        jp      NZ,VAL1
26D9: CD9C3B  	        call    HEXTFP          ; Convert Hex to FPREG
26DC: 180D    	        jr      VAL3
26DE: FE25    	VAL1:   cp      '%'             ; Binary number indicated? [function added]
26E0: C2E826  	        jp      NZ,VAL2
26E3: CD0C3C  	        call    BINTFP          ; Convert Bin to FPREG
26E6: 1803    	        jr      VAL3
26E8: CDCB2D  	VAL2:   call    ASCTFP          ; Convert ASCII string to FP
26EB: C1      	VAL3:   pop     BC              ; Restore end+1 byte
26EC: E1      	        pop     HL              ; Restore end+1 address
26ED: 70      	        ld      (HL),B          ; Put back original byte
26EE: C9      	        ret
              	
26EF: EB      	LFRGNM: ex      DE,HL           ; Code string address to HL
26F0: CD1E18  	        call    CHKSYN          ; Make sure ")" follows
26F3: 29      	        defb    ')'
26F4: C1      	MIDNUM: pop     BC              ; Get return address
26F5: D1      	        pop     DE              ; Get number supplied
26F6: C5      	        push    BC              ; Re-save return address
26F7: 43      	        ld      B,E             ; Number to B
26F8: C9      	        ret
              	
26F9: CD3F27  	INP:    call    MAKINT          ; Make it integer A
26FC: 32A080  	        ld      (INPORT),A      ; Set input port
26FF: CD9F80  	        call    INPSUB          ; Get input from port
2702: C3AF22  	        jp      PASSA           ; Return integer A
              	
2705: CD2927  	POUT:   call    SETIO           ; Set up port number
2708: C36780  	        jp      OUTSUB          ; Output data and return
              	
270B: CD2927  	WAIT:   call    SETIO           ; Set up port number
270E: F5      	        push    AF              ; Save AND mask
270F: 1E00    	        ld      E,$00           ; Assume zero if none given
2711: 2B      	        dec     HL              ; dec 'cos GETCHR INCs
2712: CD411A  	        call    GETCHR          ; Get next character
2715: CA1F27  	        jp      Z,NOXOR         ; No XOR byte given
2718: CD1E18  	        call    CHKSYN          ; Make sure ',' follows
271B: 2C      	        defb    ','
271C: CD3C27  	        call    GETINT          ; Get integer 0-255 to XOR with
271F: C1      	NOXOR:  pop     BC              ; Restore AND mask
2720: CD9F80  	WAITLP: call    INPSUB          ; Get input
2723: AB      	        xor     E               ; Flip selected bits
2724: A0      	        and     B               ; Result non-zero?
2725: CA2027  	        jp      Z,WAITLP        ; No = keep waiting
2728: C9      	        ret
              	
2729: CD3C27  	SETIO:  call    GETINT          ; Get integer 0-255
272C: 32A080  	        ld      (INPORT),A      ; Set input port
272F: 326880  	        ld      (OTPORT),A      ; Set output port
2732: CD1E18  	        call    CHKSYN          ; Make sure ',' follows
2735: 2C      	        defb    ','
2736: C33C27  	        jp      GETINT          ; Get integer 0-255 and return
              	
2739: CD411A  	FNDNUM: call    GETCHR          ; Get next character
273C: CDB61E  	GETINT: call    GETNUM          ; Get a number from 0 to 255
273F: CDF11A  	MAKINT: call    DEPINT          ; Make sure value 0 - 255
2742: 7A      	        ld      A,D             ; Get MSB of number
2743: B7      	        or      A               ; Zero?
2744: C20C1B  	        jp      NZ,FCERR        ; No - Error
2747: 2B      	        dec     HL              ; dec 'cos GETCHR INCs
2748: CD411A  	        call    GETCHR          ; Get next character
274B: 7B      	        ld      A,E             ; Get number to A
274C: C9      	        ret
              	
              	
              	; activate a Non-Maskable Interrupt hooked to VDP interrupt signal
274D: CDB61E  	NMI:    call    GETNUM          ; Get memory address
2750: CDF71A  	        call    DEINT           ; get integer -32768 to 32767
2753: 7B      	        ld      A,E             ; check if address is 0
2754: B2      	        or      D
2755: 2011    	        jr      NZ,NM1          ; no, so jump over
2757: F3      	        di                      ; disable INTs
2758: CD8427  	        call    NMIDINT         ; disable VDP INT
275B: E5      	        push    HL              ; store HL
275C: 21ED45  	        ld      HL,$45ED        ; these are the op-codes for "RETN"
275F: 226180  	        ld      (NMIUSR),HL     ; store RETN
2762: AF      	        xor     A
2763: 326380  	        ld      (NMIUSR+2),A    ; "NOP"
2766: 1811    	        jr      NMI2            ; execute the last part of code
2768: E5      	NM1:    push    HL              ; store current HL
2769: EB      	        ex      DE,HL           ; move address argument into HL
276A: F3      	        di                      ; disable INTs
276B: CD8427  	        call    NMIDINT         ; disable VDP INT, if enabled
276E: 3EC3    	        ld      A,$C3           ; "jp" instruction
2770: 326180  	        ld      (NMIUSR),A      ; store it
2773: 226280  	        ld      (NMIUSR+1),HL   ; store address
2776: CD7D27  	        call    NMIEINT         ; re-enable VDP INT
2779: FB      	NMI2:   ei                      ; re-enable INTS
277A: 00      	        nop                     ; wait for INTs
277B: E1      	        pop    HL               ; retrieve HL
277C: C9      	        ret                     ; return to caller
              	; enable VDP INT
277D: CD9327  	NMIEINT:call    NMIVR1          ; load default VReg #1 setting
2780: F620    	        or      %00100000       ; enable VDP INT
2782: 1803    	        jr      NMIINT          ; rest of code is shared
              	; disable VDP INT
2784: CD9327  	NMIDINT:call    NMIVR1          ; load default VReg #1 setting
2787: D5      	NMIINT: push    DE              ; store DE
2788: 5F      	        ld      E,A             ; move value into E
2789: 3E01    	        ld      A,$01           ; VREG #1
278B: F3      	        di                      ; disable INTs
278C: CD3606  	        call    WRITE_VREG      ; disable VDP INT
278F: FB      	        ei                      ; re-enable INTs
2790: 00      	        nop                     ; wait for INTs being enabled
2791: D1      	        pop     DE              ; retrieve DE
2792: C9      	        ret                     ; return to caller
              	
              	; load VREG #1 setting for current screen mode and return it into A
2793: E5      	NMIVR1: push    HL              ; store HL
2794: D5      	        push    DE              ; store DE
2795: 3AE081  	        ld      A,(SCR_MODE)    ; check screen mode
2798: 87      	        add     A,A             ; multiply A by 8...
2799: 87      	        add     A,A             ; ...so that reg. A can points..
279A: 87      	        add     A,A             ; to the correct settings
279B: 3C      	        inc     A               ; need to change VREG 1
279C: 5F      	        ld      E,A             ; copy A into E
279D: 1600    	        ld      D,$00           ; reset D
279F: 21370A  	        ld      HL,VDPMODESET   ; pointer to register #1 setting...
27A2: 19      	        add     HL,DE           ; ...for current screen mode
27A3: 7E      	        ld      A,(HL)          ; load current setting
27A4: D1      	        pop     DE              ; retrieve DE
27A5: E1      	        pop     HL              ; retrieve HL
27A6: C9      	        ret                     ; return to caller
              	
              	; execute a machine language routine, eventually passing a param into A
27A7: CDB61E  	SYS:    call    GETNUM          ; Get memory address
27AA: CDF71A  	        call    DEINT           ; Get integer -32768 to 32767
27AD: ED53F181	        ld      (TMPBFR2),DE    ; store user routine's address
27B1: AF      	        xor     A               ; reset A
27B2: 32EF81  	        ld      (TMPBFR1),A     ; store into temp buffer
27B5: 2B      	        dec     HL              ; dec 'cos GETCHR INCs
27B6: CD411A  	        call    GETCHR          ; check next character
27B9: 280A    	        jr      Z,NOSYSPR       ; jump if nothing follows
27BB: CD1E18  	        call    CHKSYN          ; Make sure ',' follows
27BE: 2C      	        defb    ','
27BF: CD3C27  	        call    GETINT          ; get byte value (0~255) if something follows
27C2: 32EF81  	        ld      (TMPBFR1),A     ; store into temp buffer
27C5: 3AEF81  	NOSYSPR:ld      A,(TMPBFR1)     ; recover A
27C8: ED5BF181	        ld      DE,(TMPBFR2)    ; recover user routine's address
27CC: E5      	        push    HL              ; save code string address
27CD: EB      	        ex      DE,HL           ; move user routine's address into HL
27CE: 11D327  	        ld      DE,SYSRET       ; set point of return after the user routine
27D1: D5      	        push    DE              ; store into stack
27D2: E9      	        jp      (HL)            ; call user routine
27D3: E1      	SYSRET: pop     HL              ; retrieve code string address
27D4: C9      	        ret                     ; return to caller
              	
              	
              	; read the contents of a byte from RAM
27D5: CDF71A  	PEEK:   call    DEINT           ; Get memory address into DE
27D8: 1A      	        ld      A,(DE)          ; Read value of memory cell
27D9: C3AF22  	        jp      PASSA           ; Return into A
              	
              	; read the contents of a byte from VRAM
27DC: CDF71A  	VPEEK:  call    DEINT           ; Get VRAM address into DE
27DF: EB      	        ex      DE,HL           ; Copy param into HL
27E0: F3      	        di                      ; Disable interrupts
27E1: CD0C06  	        call    READ_VIDEO_LOC  ; Read data from VRAM at address HL
27E4: FB      	        ei                      ; Re-enable interrupts
27E5: EB      	        ex      DE,HL           ; Restore HL
27E6: C3AF22  	        jp      PASSA           ; Return value into A
              	
              	; recover params for POKE/VPOKE commands
              	; returns address into DE and byte to be written into A
27E9: CDB61E  	PKEPRMS:call    GETNUM          ; Get memory address
27EC: CDF71A  	        call    DEINT           ; Get integer -32768 to 32767
27EF: ED53EF81	        ld      (TMPBFR1),DE    ; Store DE into a temp. buffer
27F3: CD1E18  	        call    CHKSYN          ; Make sure ',' follows
27F6: 2C      	        defb    ','
27F7: CD3C27  	        call    GETINT          ; Get integer 0-255
27FA: ED5BEF81	        ld      DE,(TMPBFR1)    ; Restore memory address
27FE: C9      	        ret                     ; Return to caller
              	
              	; write a byte into SRAM
27FF: CDE927  	POKE:   call    PKEPRMS         ; Get params: address and value, return into DE and A, resp.
2802: 12      	        ld      (DE),A          ; Load it into memory
2803: C9      	        ret
              	
              	; write a byte into VRAM
2804: CDE927  	VPOKE:  call    PKEPRMS         ; Get params: address and value, return into DE and A, resp.
2807: EB      	        ex      DE,HL           ; Copy address into HL
2808: F3      	        di                      ; Disable interrupts
2809: CD2106  	        call    WRITE_VIDEO_LOC ; write data into VRAM at address HL
280C: FB      	        ei                      ; Re-enable interrupts
280D: EB      	        ex      DE,HL           ; Restore HL
280E: C9      	        ret                     ; Return to caller
              	
              	; position the cursor at a specific X,Y location onto screen
280F: CD3C27  	LOCATE: call    GETINT          ; get the first param into A
2812: E5      	        push    HL              ; store HL
2813: 21DE81  	        ld      HL,SCR_SIZE_W   ; load address of screen width
2816: 5E      	        ld      E,(HL)          ; load screen width into E
2817: E1      	        pop     HL              ; restore HL
2818: BB      	        cp      E               ; compare witdh with param
2819: D20C1B  	        jp      NC,FCERR        ; value over the width of the screen, exit with Illegal F.C. error
281C: 32EF81  	        ld      (TMPBFR1),A     ; Store X into a temp. buffer
281F: CD1E18  	        call    CHKSYN          ; Make sure ',' follows
2822: 2C      	        defb    ','
2823: CD3C27  	        call    GETINT          ; Get the second param into A
2826: E5      	        push    HL              ; store HL
2827: 21DF81  	        ld      HL,SCR_SIZE_H   ; load address of screen width
282A: 5E      	        ld      E,(HL)          ; load screen width into A
282B: E1      	        pop     HL              ; restore HL
282C: BB      	        cp      E               ; compare witdh with param
282D: D20C1B  	        jp      NC,FCERR        ; value over the height of the screen, exit with Illegal F.C. error
2830: 32E781  	        ld      (SCR_CUR_NY),A  ; store new Y
2833: 3AEF81  	        ld      A,(TMPBFR1)     ; recover the new X
2836: 32E681  	        ld      (SCR_CUR_NX),A  ; store new X
2839: E5      	        push    HL              ; store HL
283A: F3      	        di                      ; disable INTs
283B: CD5206  	        call    MOVCRS          ; move cursor to new location
283E: FB      	        ei                      ; re-enable INTs
283F: E1      	        pop     HL              ; restore HL
2840: C9      	        ret                     ; return to caller
              	
              	; write a byte into one of the PSG registers
2841: CD3C27  	SREG:   call    GETINT          ; Get register number back into A
2844: FE10    	        cp      $10             ; check if value >= 16 (PSG registers go from 0 to 15)
2846: D20C1B  	        jp      NC,FCERR        ; If yes, exit and raise an Illegal function call Error
2849: 32EF81  	        ld      (TMPBFR1),A     ; Store A into a temp. buffer
284C: CD1E18  	        call    CHKSYN          ; Make sure ',' follows
284F: 2C      	        defb    ','
2850: CD3C27  	        call    GETINT          ; get second value (0-255), returned into A
2853: 5F      	        ld      E,A             ; store value into E
2854: 3AEF81  	        ld      A,(TMPBFR1)     ; recover VDP register and store into D
2857: F3      	        di                      ; disable INTs
2858: 0E40    	        ld      C,PSG_REG       ; output port to access PSG registers
285A: ED79    	        out     (C),A           ; send register # to PSG
285C: 0E41    	        ld      C,PSG_DAT       ; output port to send data to PSG
285E: ED59    	        out     (C),E           ; send byte to write into selected register
2860: FB      	        ei                      ; re-enable INTs
2861: C9      	        ret                     ; return to caller
              	
              	; VOLUME ch,vol
              	; set the volume for the audio channels
              	; "ch" is 1~3 for corresponding channel, or 0 for all; "vol" is 0~15 (0=OFF, 15=MAX)
2862: CD3C27  	VOLUME: call    GETINT          ; get integer 0-255 (recover channel)
2865: FE04    	        cp      $04             ; check if it's in the range 0~3
2867: D20C1B  	        jp      NC,FCERR        ; if not, exit with Illegal function call error
286A: 32EF81  	        ld      (TMPBFR1),A     ; Store A into a temp. buffer
286D: CD1E18  	        call    CHKSYN          ; Make sure ',' follows
2870: 2C      	        defb    ','
2871: CD3C27  	        call    GETINT          ; get integer 0-255 (recover channel)
2874: FE10    	        cp      $10             ; check if it's in the range 0~15
2876: D20C1B  	        jp      NC,FCERR        ; if not, exit with Illegal funcion call
2879: 57      	        ld      D,A             ; store volume into D
287A: 3AEF81  	        ld      A,(TMPBFR1)     ; retrieve channel
287D: A7      	        and     A               ; is it 0? (0=every channel)
287E: 2010    	        jr      NZ,VOLCH        ; no, jump over
2880: 0603    	        ld      B,$03           ; yes, set every channel
2882: 1E08    	        ld      E,$08           ; register volume of first channel
2884: 0E40    	RPVOLCG:ld      C,PSG_REG       ; PSG register port
2886: ED59    	        out     (C),E           ; set register #
2888: 0E41    	        ld      C,PSG_DAT       ; PSG data port
288A: ED51    	        out     (C),D           ; send volume
288C: 1C      	        inc     E               ; next register
288D: 10F5    	        djnz    RPVOLCG         ; repeat for each channel
288F: C9      	        ret                     ; return to caller
2890: 0E40    	VOLCH:  ld      C,PSG_REG       ; PSG register port
2892: C607    	        add     $07             ; add 7 to A so that we have the correct register (1->8, 2->9, 3->10)
2894: ED79    	        out     (C),A           ; set register
2896: 0E41    	        ld      C,PSG_DAT       ; PSG data port
2898: ED51    	        out     (C),D           ; send volume level
289A: C9      	        ret                     ; return to caller
              	
              	; SOUND ch,tone,dur
              	; play a tone or noise of "tone" frequency from selected channel "ch" for duration "dur"
              	; "ch" is 1~6 (0=means sound OFF,1~3 for tone, 4~6 for noise) / "tone" is 1~4,095 (0=means no tone) /
              	; "dur" is 1~16383 h.o.s.,0.001~163s (0=means non-stop tone)
289B: CD3C27  	SOUND:  call    GETINT          ; get integer 0-255 (recover channel)
289E: A7      	        and     A               ; is it zero?
289F: 2008    	        jr      NZ,CTSNDC       ; no, continue with checking of params
28A1: E5      	        push    HL              ; store HL
28A2: F3      	        di                      ; disable INTs
28A3: CDA90B  	        call    CLRPSGREGS      ; yes, it's zero, so reset PSG registers to shut down every sound
28A6: FB      	        ei                      ; re-enable INTs
28A7: E1      	        pop     HL              ; retrieve HL
28A8: C9      	        ret                     ; return to caller
28A9: 32EF81  	CTSNDC: ld      (TMPBFR1),A     ; no, continue by storing A into a temp. buffer
28AC: FE04    	        cp      $04             ; is channel >3?
28AE: D22E29  	        jp      NC,NOISUP       ; Yes - check to see if it's a noise channel
28B1: CD1E18  	        call    CHKSYN          ; No, continue checking by making sure ',' follows
28B4: 2C      	        defb    ','
28B5: CDB61E  	        call    GETNUM          ; Get tone frequency
28B8: CDF71A  	        call    DEINT           ; Get integer -32768 to 32767
28BB: ED53F181	        ld      (TMPBFR2),DE    ; Store frequency
28BF: CD1E18  	        call    CHKSYN          ; Make sure ',' follows
28C2: 2C      	        defb    ','
28C3: CDB61E  	        call    GETNUM          ; Get duration
28C6: CDF71A  	        call    DEINT           ; Get integer -32768 to 32767
28C9: ED53F381	        ld      (TMPBFR3),DE    ; Store duration
              	                                ; CHECK CHANNEL
28CD: 3AEF81  	        ld      A,(TMPBFR1)     ; recover channel
28D0: FE01    	        cp      $01             ; is channel <1?
28D2: DA0C1B  	        jp      C,FCERR         ; Yes - Illegal function call error
              	                                ; CHECK FREQUENCY
28D5: ED5BF181	        ld      DE,(TMPBFR2)    ; restore frequency from temp buffer
28D9: 7A      	        ld      A,D             ; move D into A and check if it is in the range 0~4095...
28DA: FE10    	        cp      $10             ; ...so D must not be greater than $0F (15)
28DC: D20C1B  	        jp      NC,FCERR        ; if not in the range, exit with an Illegal function call error
              	                                ; CHECK DURATION
28DF: ED5BF381	        ld      DE,(TMPBFR3)    ; restore duration from temp buffer
28E3: 7A      	        ld      A,D             ; check if it is in the range 0~16383...
28E4: E6C0    	        and     $C0             ; ...(15th & 14th bits must not be set)
28E6: C20C1B  	        jp      NZ,FCERR        ; if not in the range, exit with an Illegal function call error
              	                                ;
              	                                ; SET TONE:
              	                                ; let's start by setting up the channel
28E9: 3AEF81  	        ld      A,(TMPBFR1)     ; restore channel value
28EC: FE03    	        cp      $03             ; is it 3?
28EE: 2002    	        jr      NZ,SND1         ; no, jump over
28F0: 3E04    	        ld      A,%00000100     ; yes, for ch.3, set 3rd bit only (so A=001, B=010, C=100)
28F2: 2F      	SND1:   cpl                     ; complement of A - this is used later to set on the channel into the mixer
28F3: CD7B29  	        call    WRTSND          ; enable line into mixer of channel stored in A
              	                                ; SET FREQUENCY
              	                                ; we simply get frequency and subtract from 4096. The result
              	                                ; is put into register pair of the corresponding freq tone channel
28F6: ED5BF181	        ld      DE,(TMPBFR2)    ; restore frequency from temp buffer
28FA: E5      	        push    HL              ; store HL (it will be used by the subroutine)
28FB: 210010  	        ld      HL,$1000        ; load 4096 into HL
28FE: A7      	        and     A               ; reset C flag
28FF: ED52    	        sbc     HL,DE           ; subtract freq from HL - now the frequency is inverted, so we will send the low as high and vice-versa
2901: 3AEF81  	        ld      A,(TMPBFR1)     ; restore channel value
2904: 3D      	        dec     A               ; set A into the range 0~2
2905: 87      	        add     A,A             ; double A to find the register pair that correspond to the channel (A->0,1 / B->2,3, C->4,5)
2906: 0E40    	        ld      C,PSG_REG       ; PSG register port
2908: ED79    	        out     (C),A           ; select first register of the pair
290A: 0E41    	        ld      C,PSG_DAT       ; PSG data port
290C: ED69    	        out     (C),L           ; send high byte
290E: 0E40    	        ld      C,PSG_REG       ; PSG register support
2910: 3C      	        inc     A               ; second register of the pair
2911: ED79    	        out     (C),A           ; select register
2913: 0E41    	        ld      C,PSG_DAT       ; PSG data port
2915: ED61    	        out     (C),H           ; send low byte
2917: ED5BF381	        ld      DE,(TMPBFR3)    ; recover duration
291B: 3AEF81  	        ld      A,(TMPBFR1)     ; recover channel value
291E: 3D      	        dec     A               ; set channel into the range 0~2
291F: 87      	        add     A,A             ; double A to find the correct offset
2920: 212382  	        ld      HL,CHASNDDTN    ; set duration into...
2923: 85      	        add     A,L             ; ...the proper...
2924: 3001    	        jr      NC,SNDOVR       ; (is there a rest? no, jump over
2926: 24      	        inc     H               ; yes, increment H)
2927: 6F      	SNDOVR: ld      L,A             ; ...register pair...
2928: 7323722B	        ld      (HL),DE         ; ...and store the value
292C: E1      	        pop     HL              ; retrieve HL
292D: C9      	        ret                     ; Return to caller
292E: FE07    	NOISUP: cp      $07             ; is channel in range 4 to 6 (for a noise)?
2930: D20C1B  	        jp      NC,FCERR        ; no, so ILLEGAL FUNCTION CALL
2933: CD1E18  	        call    CHKSYN          ; yes, continue checking by making sure ',' follows
2936: 2C      	        defb    ','
2937: CD3C27  	        call    GETINT          ; get integer 0-255 (frequency)
293A: FE20    	        cp      $20             ; make sure it's in range 0~31
293C: D20C1B  	        jp      NC,FCERR        ; no, so Illegal function call
293F: 32F181  	        ld      (TMPBFR2),A     ; store freq.
2942: 2B      	        dec     HL              ; dec 'cos GETCHR INCs
2943: CD411A  	        call    GETCHR          ; check that nothing follows
2946: C23C15  	        jp      NZ,SNERR        ; error if no empty line
2949: 3AF181  	        ld      A,(TMPBFR2)     ; retrieve freq.
294C: 5F      	        ld      E,A             ; store freq into E
294D: 3AEF81  	        ld      A,(TMPBFR1)     ; retrieve channel
2950: D603    	        sub     $03             ; subtract 3 to get channel in range 1~3
2952: FE03    	        cp      $03             ; is it 3?
2954: 2002    	        jr      NZ,NOS1         ; no, jump over
2956: 3E04    	        ld      A,%00000100     ; yes, for ch.3, set 3rd bit only (so A=001, B=010, C=100)
2958: 87      	NOS1:   add     A,A
2959: 87      	        add     A,A
295A: 87      	        add     A,A             ; let's move A 3 bits to left
295B: 47      	        ld      B,A             ; store channel into B
295C: 7B      	        ld      A,E             ; check if
295D: A7      	        and     A               ; freq is 0 (means that noise reproduction must be halted)
295E: F3      	        di                      ; disable INts
295F: 200A    	        jr      NZ,NOS2         ; no, so jump over
2961: 3E07    	        ld      A,$07           ; mixer register
2963: CDF70B  	        call    SETSNDREG       ; set mixer register
2966: ED78    	        in      A,(C)           ; load current mixer value
2968: B0      	        or      B               ; disable noise
2969: 1819    	        jr      NOS3            ; continue over
296B: 78      	NOS2:   ld      A,B             ; recover channel
296C: 2F      	        cpl                     ; complement of A - this is used to set on the channel into the mixer
296D: CD7B29  	        call    WRTSND          ; enable line into mixer of channel stored in A
2970: 3E06    	        ld      A,$06           ; write into noise register
2972: CDF70B  	        call    SETSNDREG       ; set register into PSG
2975: 7B      	        ld      A,E             ; load value for noise frequency
2976: CDFC0B  	        call    WRTSNDREG       ; write data into register $06
2979: FB      	        ei                      ; re-enable INTs
297A: C9      	        ret
              	        ; enable line into mixer of channel stored in A
297B: 47      	WRTSND: ld      B,A             ; move channel into B
297C: 3E07    	        ld      A,$07           ; mixer register
297E: CDF70B  	        call    SETSNDREG       ; set mixer register
2981: ED78    	        in      A,(C)           ; load current value
2983: A0      	        and     B               ; set on the channel into the mixer (remember that 0=ON)
              	                                ; example: if channel is A (1), complement of 1 is 254 (11111110). So, 255 (in case
              	                                ; the register is still unchanged after reset) is 11111111 and
              	                                ; 11111111 AND 11111110 is equal to 11111110
              	                                ; 11111001 AND 11111110 is equal to 11111000 (in case channels B & C are ON)
2984: 47      	NOS3:   ld      B,A             ; store new mixer value into B
2985: 3E07    	        ld      A,$07           ; mixer address
2987: CDF70B  	        call    SETSNDREG       ; set register
298A: 78      	        ld      A,B             ; retrieve new mixer value from B
298B: CDFC0B  	        call    WRTSNDREG       ; send new value for the mixer
298E: FB      	        ei                      ; re-enable INTs
298F: C9      	        ret                     ; return to caller
              	
              	; write a byte into one of the VDP registers
2990: CD3C27  	VREG:   call    GETINT          ; Get register number back into A
2993: FE08    	        cp      $08             ; check if value is equal or greater than 8 (VDP registers are only 8, from 0 to 7)
2995: D20C1B  	        jp      NC,FCERR        ; If yes, exit and raise an Illegal function call Error
2998: 32EF81  	        ld      (TMPBFR1),A     ; Store A into a temp. buffer
299B: CD1E18  	        call    CHKSYN          ; Make sure ',' follows
299E: 2C      	        defb    ','
299F: CD3C27  	        call    GETINT          ; get value (0-255)
29A2: 5F      	        ld      E,A             ; store value into E
29A3: 3AEF81  	        ld      A,(TMPBFR1)     ; recover VDP register and store into A
29A6: F3      	        di                      ; disable INTs
29A7: CD3606  	        call    WRITE_VREG      ; write value into VDP register
29AA: FB      	        ei                      ; re-enable INTs
29AB: C9      	        ret                     ; return to caller
              	
              	; read the VDP status register and return it into A
29AC: CDF71A  	VSTAT:  call    DEINT           ; Get integer -32768 to 32767 (Note: we do NOT use it)
29AF: F3      	        di                      ; disable INTs
29B0: CD4106  	        call    READ_VSTAT      ; read VDP register status
29B3: FB      	        ei                      ; re-enable INTs
29B4: C3AF22  	        jp      PASSA           ; Return integer A
              	
              	; read from PSG register and return it into A
29B7: CDF71A  	SSTAT:  call    DEINT           ; get integer -32768 to 32767
29BA: 7B      	        ld      A,E             ; consider LSB
29BB: FE10    	        cp      $10             ; check if value >= 16 (PSG registers go from 0 to 15)
29BD: D20C1B  	        jp      NC,FCERR        ; If yes, exit and raise an Illegal function call Error
29C0: F3      	        di                      ; disable INts
29C1: 0E40    	        ld      C,PSG_REG       ; output port to set PSG register
29C3: ED79    	        out     (C),A           ; send register to read from
29C5: ED78    	        in      A,(C)           ; read register's contents and store into A
29C7: FB      	        ei                      ; re-enable INTs
29C8: C3AF22  	        jp      PASSA           ; return A
              	
              	; read the temp key buffer and return the value of the current key being pressed
              	; can wait for the number of 100thds of second before to return
29CB: CD2923  	INKEY:  call    IDTEST          ; Test for illegal direct
29CE: CDF71A  	        call    DEINT           ; get number param (100thds of second to wait) into DE
29D1: C5      	        push    BC              ; store BC
29D2: 3ACE81  	        ld      A,(TMRCNT)      ; Load current value of system timer
29D5: 47      	        ld      B,A             ; move it into B
29D6: 3ACE81  	CMP_A:  ld      A,(TMRCNT)      ; make a little delay of 1/100 sec...
29D9: B8      	        cp      B               ; ...to let the sniffer collect...
29DA: 20FA    	        jr      NZ,CMP_A        ; ...at least 1 char before to continue
29DC: 7A      	        ld      A,D             ; check the param
29DD: B3      	        or      E               ; if DE<>0 then...
29DE: 2005    	        jr      NZ,INKEY2       ; ...jump over...
29E0: 3A2B82  	        ld      A,(TMPKEYBFR)   ; ...else read the buffer and...
29E3: 182A    	        jr      ENDINK          ; ...return it
29E5: 7A      	INKEY2: ld      A,D             ; check if param>1023
29E6: FE04    	        cp      $04             ; to do this we check if MSB>3
29E8: D20C1B  	        jp      NC,FCERR        ; if MSB >=4 then error
29EB: E5      	        push    HL              ; store HL
29EC: 210900  	        ld      HL,$0009        ; check if value
29EF: CD5F3C  	        call    CMP16           ; is < 10
29F2: E1      	        pop     HL              ; retrieve HL
29F3: DAF929  	        jp      C,SRTINK        ; if value >= 10 then jump over
29F6: 110A00  	        ld      DE,$000A        ; else, use 10 (no intervals shorter than 10/100s)
29F9: 3ACE81  	SRTINK: ld      A,(TMRCNT)      ; Load the first byte of the system timer
29FC: 47      	        ld      B,A             ; move it into B
29FD: 3A2B82  	CHKINK: ld      A,(TMPKEYBFR)   ; load char code from buffer
2A00: A7      	        and     A               ; is it 0?
2A01: 200C    	        jr      NZ,ENDINK       ; no, so we can return it
2A03: 3ACE81  	        ld      A,(TMRCNT)      ; load the first byte of the system timer
2A06: B8      	        cp      B               ; is it the same value?
2A07: 28F4    	        jr      Z,CHKINK        ; yes, so read again
2A09: 47      	        ld      B,A             ; store new value
2A0A: 1B      	        dec     DE              ; no, decrement timer
2A0B: 7A      	        ld      A,D             ; check if zero reached
2A0C: B3      	        or      E               ; by ORing D and E
2A0D: 20EE    	        jr      NZ,CHKINK       ; if not 0, repeat
2A0F: C1      	ENDINK: pop     BC              ; restore BC
2A10: F5      	        push    AF              ; store A
2A11: F3      	        di                      ; disable INTs
2A12: AF      	        xor     A               ; clear the...
2A13: 322B82  	        ld      (TMPKEYBFR),A   ; ...TMP KEY buffer for the next read
2A16: FB      	        ei                      ; re-enable INTs
2A17: F1      	        pop     AF              ; retrieve A
2A18: C3AF22  	ENDINK2:jp      PASSA           ; return A as ASCII value
              	
2A1B: 21422F  	ROUND:  ld      HL,HALF         ; Add 0.5 to FPREG
2A1E: CD132D  	ADDPHL: call    LOADFP          ; Load FP at (HL) to BCDE
2A21: C32D2A  	        jp      FPADD           ; Add BCDE to FPREG
              	
2A24: CD132D  	SUBPHL: call    LOADFP          ; FPREG = -FPREG + number at HL
2A27: 21      	        defb    $21             ; Skip "pop BC" and "pop DE"
2A28: C1      	PSUB:   pop     BC              ; Get FP number from stack
2A29: D1      	        pop     DE
2A2A: CDED2C  	SUBCDE: call    INVSGN          ; Negate FPREG
2A2D: 78      	FPADD:  ld      A,B             ; Get FP exponent
2A2E: B7      	        or      A               ; Is number zero?
2A2F: C8      	        ret     Z               ; Yes - Nothing to add
2A30: 3ACC81  	        ld      A,(FPEXP)       ; Get FPREG exponent
2A33: B7      	        or      A               ; Is this number zero?
2A34: CA052D  	        jp      Z,FPBCDE        ; Yes - Move BCDE to FPREG
2A37: 90      	        sub     B               ; BCDE number larger?
2A38: D2472A  	        jp      NC,NOSWAP       ; No - Don't swap them
2A3B: 2F      	        cpl                     ; Two's complement
2A3C: 3C      	        inc     A               ;  FP exponent
2A3D: EB      	        ex      DE,HL
2A3E: CDF52C  	        call    STAKFP          ; Put FPREG on stack
2A41: EB      	        ex      DE,HL
2A42: CD052D  	        call    FPBCDE          ; Move BCDE to FPREG
2A45: C1      	        pop     BC              ; Restore number from stack
2A46: D1      	        pop     DE
2A47: FE19    	NOSWAP: cp      24+1            ; Second number insignificant?
2A49: D0      	        ret     NC              ; Yes - First number is result
2A4A: F5      	        push    AF              ; Save number of bits to scale
2A4B: CD2A2D  	        call    SIGNS           ; Set MSBs & sign of result
2A4E: 67      	        ld      H,A             ; Save sign of result
2A4F: F1      	        pop     AF              ; Restore scaling factor
2A50: CDF22A  	        call    SCALE           ; Scale BCDE to same exponent
2A53: B4      	        or      H               ; Result to be positive?
2A54: 21C981  	        ld      HL,FPREG        ; Point to FPREG
2A57: F26D2A  	        jp      P,MINCDE        ; No - Subtract FPREG from CDE
2A5A: CDD22A  	        call    PLUCDE          ; Add FPREG to CDE
2A5D: D2B32A  	        jp      NC,RONDUP       ; No overflow - Round it up
2A60: 23      	        inc     HL              ; Point to exponent
2A61: 34      	        inc     (HL)            ; Increment it
2A62: CA4B15  	        jp      Z,OVERR         ; Number overflowed - Error
2A65: 2E01    	        ld      L,$01           ; 1 bit to shift right
2A67: CD082B  	        call    SHRT1           ; Shift result right
2A6A: C3B32A  	        jp      RONDUP          ; Round it up
              	
2A6D: AF      	MINCDE: xor     A               ; Clear A and carry
2A6E: 90      	        sub     B               ; Negate exponent
2A6F: 47      	        ld      B,A             ; Re-save exponent
2A70: 7E      	        ld      A,(HL)          ; Get LSB of FPREG
2A71: 9B      	        sbc     A, E            ; Subtract LSB of BCDE
2A72: 5F      	        ld      E,A             ; Save LSB of BCDE
2A73: 23      	        inc     HL
2A74: 7E      	        ld      A,(HL)          ; Get NMSB of FPREG
2A75: 9A      	        sbc     A,D             ; Subtract NMSB of BCDE
2A76: 57      	        ld      D,A             ; Save NMSB of BCDE
2A77: 23      	        inc     HL
2A78: 7E      	        ld      A,(HL)          ; Get MSB of FPREG
2A79: 99      	        sbc     A,C             ; Subtract MSB of BCDE
2A7A: 4F      	        ld      C,A             ; Save MSB of BCDE
2A7B: DCDE2A  	CONPOS: call    C,COMPL         ; Overflow - Make it positive
              	
2A7E: 68      	BNORM:  ld      L,B             ; L = Exponent
2A7F: 63      	        ld      H,E             ; H = LSB
2A80: AF      	        xor     A
2A81: 47      	BNRMLP: ld      B,A             ; Save bit count
2A82: 79      	        ld      A,C             ; Get MSB
2A83: B7      	        or      A               ; Is it zero?
2A84: C2A02A  	        jp      NZ,PNORM        ; No - Do it bit at a time
2A87: 4A      	        ld      C,D             ; MSB = NMSB
2A88: 54      	        ld      D,H             ; NMSB= LSB
2A89: 65      	        ld      H,L             ; LSB = VLSB
2A8A: 6F      	        ld      L,A             ; VLSB= 0
2A8B: 78      	        ld      A,B             ; Get exponent
2A8C: D608    	        sub     $08             ; Count 8 bits
2A8E: FEE0    	        cp      -24-8           ; Was number zero?
2A90: C2812A  	        jp      NZ,BNRMLP       ; No - Keep normalising
2A93: AF      	RESZER: xor     A               ; Result is zero
2A94: 32CC81  	SAVEXP: ld      (FPEXP),A       ; Save result as zero
2A97: C9      	        ret
              	
2A98: 05      	NORMAL: dec     B               ; Count bits
2A99: 29      	        add     HL,HL           ; Shift HL left
2A9A: 7A      	        ld      A,D             ; Get NMSB
2A9B: 17      	        rla                     ; Shift left with last bit
2A9C: 57      	        ld      D,A             ; Save NMSB
2A9D: 79      	        ld      A,C             ; Get MSB
2A9E: 8F      	        adc     A,A             ; Shift left with last bit
2A9F: 4F      	        ld      C,A             ; Save MSB
2AA0: F2982A  	PNORM:  jp      P,NORMAL        ; Not done - Keep going
2AA3: 78      	        ld      A,B             ; Number of bits shifted
2AA4: 5C      	        ld      E,H             ; Save HL in EB
2AA5: 45      	        ld      B,L
2AA6: B7      	        or      A               ; Any shifting done?
2AA7: CAB32A  	        jp      Z,RONDUP        ; No - Round it up
2AAA: 21CC81  	        ld      HL,FPEXP        ; Point to exponent
2AAD: 86      	        add     A,(HL)          ; Add shifted bits
2AAE: 77      	        ld      (HL),A          ; Re-save exponent
2AAF: D2932A  	        jp      NC,RESZER       ; Underflow - Result is zero
2AB2: C8      	        ret     Z               ; Result is zero
2AB3: 78      	RONDUP: ld      A,B             ; Get VLSB of number
2AB4: 21CC81  	RONDB:  ld      HL,FPEXP        ; Point to exponent
2AB7: B7      	        or      A               ; Any rounding?
2AB8: FCC52A  	        call    M,FPROND        ; Yes - Round number up
2ABB: 46      	        ld      B,(HL)          ; B = Exponent
2ABC: 23      	        inc     HL
2ABD: 7E      	        ld      A,(HL)          ; Get sign of result
2ABE: E680    	        and     %10000000       ; Only bit 7 needed
2AC0: A9      	        xor     C               ; Set correct sign
2AC1: 4F      	        ld      C,A             ; Save correct sign in number
2AC2: C3052D  	        jp      FPBCDE          ; Move BCDE to FPREG
              	
2AC5: 1C      	FPROND: inc     E               ; Round LSB
2AC6: C0      	        ret     NZ              ; Return if ok
2AC7: 14      	        inc     D               ; Round NMSB
2AC8: C0      	        ret     NZ              ; Return if ok
2AC9: 0C      	        inc     C               ; Round MSB
2ACA: C0      	        ret     NZ              ; Return if ok
2ACB: 0E80    	        ld      C,$80           ; Set normal value
2ACD: 34      	        inc     (HL)            ; Increment exponent
2ACE: C0      	        ret     NZ              ; Return if ok
2ACF: C34B15  	        jp      OVERR           ; Overflow error
              	
2AD2: 7E      	PLUCDE: ld      A,(HL)          ; Get LSB of FPREG
2AD3: 83      	        add     A,E             ; Add LSB of BCDE
2AD4: 5F      	        ld      E,A             ; Save LSB of BCDE
2AD5: 23      	        inc     HL
2AD6: 7E      	        ld      A,(HL)          ; Get NMSB of FPREG
2AD7: 8A      	        adc     A,D             ; Add NMSB of BCDE
2AD8: 57      	        ld      D,A             ; Save NMSB of BCDE
2AD9: 23      	        inc     HL
2ADA: 7E      	        ld      A,(HL)          ; Get MSB of FPREG
2ADB: 89      	        adc     A,C             ; Add MSB of BCDE
2ADC: 4F      	        ld      C,A             ; Save MSB of BCDE
2ADD: C9      	        ret
              	
2ADE: 21CD81  	COMPL:  ld      HL,SGNRES       ; Sign of result
2AE1: 7E      	        ld      A,(HL)          ; Get sign of result
2AE2: 2F      	        cpl                     ; Negate it
2AE3: 77      	        ld      (HL),A          ; Put it back
2AE4: AF      	        xor     A
2AE5: 6F      	        ld      L,A             ; Set L to zero
2AE6: 90      	        sub     B               ; Negate exponent,set carry
2AE7: 47      	        ld      B,A             ; Re-save exponent
2AE8: 7D      	        ld      A,L             ; Load zero
2AE9: 9B      	        sbc     A,E             ; Negate LSB
2AEA: 5F      	        ld      E,A             ; Re-save LSB
2AEB: 7D      	        ld      A,L             ; Load zero
2AEC: 9A      	        sbc     A,D             ; Negate NMSB
2AED: 57      	        ld      D,A             ; Re-save NMSB
2AEE: 7D      	        ld      A,L             ; Load zero
2AEF: 99      	        sbc     A,C             ; Negate MSB
2AF0: 4F      	        ld      C,A             ; Re-save MSB
2AF1: C9      	        ret
              	
2AF2: 0600    	SCALE:  ld      B,$00           ; Clear underflow
2AF4: D608    	SCALLP: sub     $08             ; 8 bits (a whole byte)?
2AF6: DA012B  	        jp      C,SHRITE        ; No - Shift right A bits
2AF9: 43      	        ld      B,E             ; <- Shift
2AFA: 5A      	        ld      E,D             ; <- right
2AFB: 51      	        ld      D,C             ; <- eight
2AFC: 0E00    	        ld      C,$00           ; <- bits
2AFE: C3F42A  	        jp      SCALLP          ; More bits to shift
              	
2B01: C609    	SHRITE: add     A,8+1           ; Adjust count
2B03: 6F      	        ld      L,A             ; Save bits to shift
2B04: AF      	SHRLP:  xor     A               ; Flag for all done
2B05: 2D      	        dec     L               ; All shifting done?
2B06: C8      	        ret     Z               ; Yes - Return
2B07: 79      	        ld      A,C             ; Get MSB
2B08: 1F      	SHRT1:  rra                     ; Shift it right
2B09: 4F      	        ld      C,A             ; Re-save
2B0A: 7A      	        ld      A,D             ; Get NMSB
2B0B: 1F      	        rra                     ; Shift right with last bit
2B0C: 57      	        ld      D,A             ; Re-save it
2B0D: 7B      	        ld      A,E             ; Get LSB
2B0E: 1F      	        rra                     ; Shift right with last bit
2B0F: 5F      	        ld      E,A             ; Re-save it
2B10: 78      	        ld      A,B             ; Get underflow
2B11: 1F      	        rra                     ; Shift right with last bit
2B12: 47      	        ld      B,A             ; Re-save underflow
2B13: C3042B  	        jp      SHRLP           ; More bits to do
              	
2B16: 00000081	UNITY:  defb    $00,$00,$00,$81 ; 1.00000
              	
2B1A: 03      	LOGTAB: defb    $03             ; Table used by LOG
2B1B: AA561980	        defb    $AA,$56,$19,$80 ; 0.59898
2B1F: F1227680	        defb    $F1,$22,$76,$80 ; 0.96147
2B23: 45AA3882	        defb    $45,$AA,$38,$82 ; 2.88539
              	
2B27: CDC42C  	LOG:    call    TSTSGN          ; Test sign of value
2B2A: B7      	        or      A
2B2B: EA0C1B  	        jp      PE,FCERR        ; ?FC Error if <= zero
2B2E: 21CC81  	        ld      HL,FPEXP        ; Point to exponent
2B31: 7E      	        ld      A,(HL)          ; Get exponent
2B32: 013580  	        ld      BC,$8035        ; BCDE = SQR(1/2)
2B35: 11F304  	        ld      DE,$04F3
2B38: 90      	        sub     B               ; Scale value to be < 1
2B39: F5      	        push    AF              ; Save scale factor
2B3A: 70      	        ld      (HL),B          ; Save new exponent
2B3B: D5      	        push    DE              ; Save SQR(1/2)
2B3C: C5      	        push    BC
2B3D: CD2D2A  	        call    FPADD           ; Add SQR(1/2) to value
2B40: C1      	        pop     BC              ; Restore SQR(1/2)
2B41: D1      	        pop     DE
2B42: 04      	        inc     B               ; Make it SQR(2)
2B43: CD1A2C  	        call    DVBCDE          ; Divide by SQR(2)
2B46: 21162B  	        ld      HL,UNITY        ; Point to 1.
2B49: CD242A  	        call    SUBPHL          ; Subtract FPREG from 1
2B4C: 211A2B  	        ld      HL,LOGTAB       ; Coefficient table
2B4F: CD0C30  	        call    SUMSER          ; Evaluate sum of series
2B52: 018080  	        ld      BC,$8080        ; BCDE = -0.5
2B55: 110000  	        ld      DE,$0000
2B58: CD2D2A  	        call    FPADD           ; Subtract 0.5 from FPREG
2B5B: F1      	        pop     AF              ; Restore scale factor
2B5C: CD3F2E  	        call    RSCALE          ; Re-scale number
2B5F: 013180  	MULLN2: ld      BC,$8031        ; BCDE = Ln(2)
2B62: 111872  	        ld      DE,$7218
2B65: 21      	        defb    $21             ; Skip "pop BC" and "pop DE"
              	
2B66: C1      	MULT:   pop     BC              ; Get number from stack
2B67: D1      	        pop     DE
2B68: CDC42C  	FPMULT: call    TSTSGN          ; Test sign of FPREG
2B6B: C8      	        ret     Z               ; Return zero if zero
2B6C: 2E00    	        ld      L,$00           ; Flag add exponents
2B6E: CD822C  	        call    ADDEXP          ; Add exponents
2B71: 79      	        ld      A,C             ; Get MSB of multiplier
2B72: 323D82  	        ld      (MULVAL),A      ; Save MSB of multiplier
2B75: EB      	        ex      DE,HL
2B76: 223E82  	        ld      (MULVAL+1),HL   ; Save rest of multiplier
2B79: 010000  	        ld      BC,$0000        ; Partial product (BCDE) = zero
2B7C: 50      	        ld      D,B
2B7D: 58      	        ld      E,B
2B7E: 217E2A  	        ld      HL,BNORM        ; Address of normalise
2B81: E5      	        push    HL              ; Save for return
2B82: 218A2B  	        ld      HL,MULT8        ; Address of 8 bit multiply
2B85: E5      	        push    HL              ; Save for NMSB,MSB
2B86: E5      	        push    HL              ;
2B87: 21C981  	        ld      HL,FPREG        ; Point to number
2B8A: 7E      	MULT8:  ld      A,(HL)          ; Get LSB of number
2B8B: 23      	        inc     HL              ; Point to NMSB
2B8C: B7      	        or      A               ; Test LSB
2B8D: CAB62B  	        jp      Z,BYTSFT        ; Zero - shift to next byte
2B90: E5      	        push    HL              ; Save address of number
2B91: 2E08    	        ld      L,$08           ; 8 bits to multiply by
2B93: 1F      	MUL8LP: rra                     ; Shift LSB right
2B94: 67      	        ld      H,A             ; Save LSB
2B95: 79      	        ld      A,C             ; Get MSB
2B96: D2A42B  	        jp      NC,NOMADD       ; Bit was zero - Don't add
2B99: E5      	        push    HL              ; Save LSB and count
2B9A: 2A3E82  	        ld      HL,(MULVAL+1)   ; Get LSB and NMSB
2B9D: 19      	        add     HL,DE           ; Add NMSB and LSB
2B9E: EB      	        ex      DE,HL           ; Leave sum in DE
2B9F: E1      	        pop     HL              ; Restore MSB and count
2BA0: 3A3D82  	        ld      A,(MULVAL)      ; Get MSB of multiplier
2BA3: 89      	        adc     A,C             ; Add MSB
2BA4: 1F      	NOMADD: rra                     ; Shift MSB right
2BA5: 4F      	        ld      C,A             ; Re-save MSB
2BA6: 7A      	        ld      A,D             ; Get NMSB
2BA7: 1F      	        rra                     ; Shift NMSB right
2BA8: 57      	        ld      D,A             ; Re-save NMSB
2BA9: 7B      	        ld      A,E             ; Get LSB
2BAA: 1F      	        rra                     ; Shift LSB right
2BAB: 5F      	        ld      E,A             ; Re-save LSB
2BAC: 78      	        ld      A,B             ; Get VLSB
2BAD: 1F      	        rra                     ; Shift VLSB right
2BAE: 47      	        ld      B,A             ; Re-save VLSB
2BAF: 2D      	        dec     L               ; Count bits multiplied
2BB0: 7C      	        ld      A,H             ; Get LSB of multiplier
2BB1: C2932B  	        jp      NZ,MUL8LP       ; More - Do it
2BB4: E1      	POPHRT: pop     HL              ; Restore address of number
2BB5: C9      	        ret
              	
2BB6: 43      	BYTSFT: ld      B,E             ; Shift partial product left
2BB7: 5A      	        ld      E,D
2BB8: 51      	        ld      D,C
2BB9: 4F      	        ld      C,A
2BBA: C9      	        ret
              	
              	
              	; WORKING ––
2BBB: C1      	DINT:   pop     BC              ; Get number from stack
2BBC: D1      	        pop     DE
2BBD: CD1A2C  	        call    DVBCDE          ; get BCDE/FPREG and store result into FPREG
2BC0: C3972D  	        jp      INT             ; return INT(FPREG)
              	
              	
              	; A MODULO B - return remainder of the integer division A/B where:
              	; A is in stack; B is in FPREG
              	; math is:
              	; A=INT(A); B=INT(B); R=A-(B*INT(A/B))
2BC3: CD972D  	MOD:    call    INT             ; B=INT(B)
2BC6: CD102D  	        call    BCDEFP          ; copy B (from FPREG) into BCDE
2BC9: ED53F381	        ld      (TMPBFR3),DE    ; store B into...
2BCD: ED43F581	        ld      (TMPBFR4),BC    ; ...a temp buffer
2BD1: C1      	        pop     BC              ; recover A...
2BD2: D1      	        pop     DE              ; ...from stack
2BD3: CD052D  	        call    FPBCDE          ; store A into FPREG
2BD6: CD972D  	        call    INT             ; get integer part: A=INT(A)
2BD9: CD102D  	        call    BCDEFP          ; copy A (from FPREG) into BCDE
2BDC: ED53EF81	        ld      (TMPBFR1),DE    ; store A into...
2BE0: ED43F181	        ld      (TMPBFR2),BC    ; ...a temp buffer
              	                                ; begin calculation
2BE4: 2AF381  	        ld      HL,(TMPBFR3)    ; move B...
2BE7: 22C981  	        ld      (FPREG),HL      ; ...from...
2BEA: 2AF581  	        ld      HL,(TMPBFR4)    ; ...temp buffer...
2BED: 22CB81  	        ld      (FPREG+2),HL    ; ...into FPREG
2BF0: CD1A2C  	        call    DVBCDE          ; compute A/B and store into FPREG
2BF3: CD972D  	        call    INT             ; get integer part of result: now FPREG = INT(A/B)
2BF6: ED5BF381	        ld      DE,(TMPBFR3)    ; load B...
2BFA: ED4BF581	        ld      BC,(TMPBFR4)    ; ...into BCDE
2BFE: CD682B  	        call    FPMULT          ; get B*INT(A/B) and store into FPREG
2C01: ED5BEF81	        ld      DE,(TMPBFR1)    ; retrieve A from...
2C05: ED4BF181	        ld      BC,(TMPBFR2)    ; ...temp buffer
2C09: C32A2A  	        jp      SUBCDE          ; return result of A-(B*INT(A/B))
              	
              	
2C0C: CDF52C  	DIV10:  call    STAKFP          ; Save FPREG on stack
2C0F: 012084  	        ld      BC,$8420        ; BCDE = 10.
2C12: 110000  	        ld      DE,$0000
2C15: CD052D  	        call    FPBCDE          ; Move 10 to FPREG
              	
2C18: C1      	DIV:    pop     BC              ; Get number from stack
2C19: D1      	        pop     DE
2C1A: CDC42C  	DVBCDE: call    TSTSGN          ; Test sign of FPREG
2C1D: CA3F15  	        jp      Z,DZERR         ; Error if division by zero
2C20: 2EFF    	        ld      L,-1            ; Flag subtract exponents
2C22: CD822C  	        call    ADDEXP          ; Subtract exponents
2C25: 34      	        inc     (HL)            ; Add 2 to exponent to adjust
2C26: 34      	        inc     (HL)
2C27: 2B      	        dec     HL              ; Point to MSB
2C28: 7E      	        ld      A,(HL)          ; Get MSB of dividend
2C29: 327380  	        ld      (DIV3),A        ; Save for subtraction
2C2C: 2B      	        dec     HL
2C2D: 7E      	        ld      A,(HL)          ; Get NMSB of dividend
2C2E: 326F80  	        ld      (DIV2),A        ; Save for subtraction
2C31: 2B      	        dec     HL
2C32: 7E      	        ld      A,(HL)          ; Get MSB of dividend
2C33: 326B80  	        ld      (DIV1),A        ; Save for subtraction
2C36: 41      	        ld      B,C             ; Get MSB
2C37: EB      	        ex      DE,HL           ; NMSB,LSB to HL
2C38: AF      	        xor     A
2C39: 4F      	        ld      C,A             ; Clear MSB of quotient
2C3A: 57      	        ld      D,A             ; Clear NMSB of quotient
2C3B: 5F      	        ld      E,A             ; Clear LSB of quotient
2C3C: 327680  	        ld      (DIV4),A        ; Clear overflow count
2C3F: E5      	DIVLP:  push    HL              ; Save divisor
2C40: C5      	        push    BC
2C41: 7D      	        ld      A,L             ; Get LSB of number
2C42: CD6A80  	        call    DIVSUP          ; Subt' divisor from dividend
2C45: DE00    	        sbc     A,$00           ; Count for overflows
2C47: 3F      	        ccf
2C48: D2522C  	        jp      NC,RESDIV       ; Restore divisor if borrow
2C4B: 327680  	        ld      (DIV4),A        ; Re-save overflow count
2C4E: F1      	        pop     AF              ; Scrap divisor
2C4F: F1      	        pop     AF
2C50: 37      	        scf                     ; Set carry to
2C51: D2      	        defb    $D2             ; Skip "pop BC" and "pop HL"
              	
2C52: C1      	RESDIV: pop     BC              ; Restore divisor
2C53: E1      	        pop     HL
2C54: 79      	        ld      A,C             ; Get MSB of quotient
2C55: 3C      	        inc     A
2C56: 3D      	        dec     A
2C57: 1F      	        rra                     ; Bit 0 to bit 7
2C58: FAB42A  	        jp      M,RONDB         ; Done - Normalise result
2C5B: 17      	        rla                     ; Restore carry
2C5C: 7B      	        ld      A,E             ; Get LSB of quotient
2C5D: 17      	        rla                     ; Double it
2C5E: 5F      	        ld      E,A             ; Put it back
2C5F: 7A      	        ld      A,D             ; Get NMSB of quotient
2C60: 17      	        rla                     ; Double it
2C61: 57      	        ld      D,A             ; Put it back
2C62: 79      	        ld      A,C             ; Get MSB of quotient
2C63: 17      	        rla                     ; Double it
2C64: 4F      	        ld      C,A             ; Put it back
2C65: 29      	        add     HL,HL           ; Double NMSB,LSB of divisor
2C66: 78      	        ld      A,B             ; Get MSB of divisor
2C67: 17      	        rla                     ; Double it
2C68: 47      	        ld      B,A             ; Put it back
2C69: 3A7680  	        ld      A,(DIV4)        ; Get VLSB of quotient
2C6C: 17      	        rla                     ; Double it
2C6D: 327680  	        ld      (DIV4),A        ; Put it back
2C70: 79      	        ld      A,C             ; Get MSB of quotient
2C71: B2      	        or      D               ; Merge NMSB
2C72: B3      	        or      E               ; Merge LSB
2C73: C23F2C  	        jp      NZ,DIVLP        ; Not done - Keep dividing
2C76: E5      	        push    HL              ; Save divisor
2C77: 21CC81  	        ld      HL,FPEXP        ; Point to exponent
2C7A: 35      	        dec     (HL)            ; Divide by 2
2C7B: E1      	        pop     HL              ; Restore divisor
2C7C: C23F2C  	        jp      NZ,DIVLP        ; Ok - Keep going
2C7F: C34B15  	        jp      OVERR           ; Overflow error
              	
              	
2C82: 78      	ADDEXP: ld      A,B             ; Get exponent of dividend
2C83: B7      	        or      A               ; Test it
2C84: CAA62C  	        jp      Z,OVTST3        ; Zero - Result zero
2C87: 7D      	        ld      A,L             ; Get add/subtract flag
2C88: 21CC81  	        ld      HL,FPEXP        ; Point to exponent
2C8B: AE      	        xor     (HL)            ; Add or subtract it
2C8C: 80      	        add     A,B             ; Add the other exponent
2C8D: 47      	        ld      B,A             ; Save new exponent
2C8E: 1F      	        rra                     ; Test exponent for overflow
2C8F: A8      	        xor     B
2C90: 78      	        ld      A,B             ; Get exponent
2C91: F2A52C  	        jp      P,OVTST2        ; Positive - Test for overflow
2C94: C680    	        add     A,$80           ; Add excess 128
2C96: 77      	        ld      (HL),A          ; Save new exponent
2C97: CAB42B  	        jp      Z,POPHRT        ; Zero - Result zero
2C9A: CD2A2D  	        call    SIGNS           ; Set MSBs and sign of result
2C9D: 77      	        ld      (HL),A          ; Save new exponent
2C9E: 2B      	        dec     HL              ; Point to MSB
2C9F: C9      	        ret
              	
2CA0: CDC42C  	OVTST1: call    TSTSGN          ; Test sign of FPREG
2CA3: 2F      	        cpl                     ; Invert sign
2CA4: E1      	        pop     HL              ; Clean up stack
2CA5: B7      	OVTST2: or      A               ; Test if new exponent zero
2CA6: E1      	OVTST3: pop     HL              ; Clear off return address
2CA7: F2932A  	        jp      P,RESZER        ; Result zero
2CAA: C34B15  	        jp      OVERR           ; Overflow error
              	
2CAD: CD102D  	MLSP10: call    BCDEFP          ; Move FPREG to BCDE
2CB0: 78      	        ld      A,B             ; Get exponent
2CB1: B7      	        or      A               ; Is it zero?
2CB2: C8      	        ret     Z               ; Yes - Result is zero
2CB3: C602    	        add     A,$02           ; Multiply by 4
2CB5: DA4B15  	        jp      C,OVERR         ; Overflow - ?OV Error
2CB8: 47      	        ld      B,A             ; Re-save exponent
2CB9: CD2D2A  	        call    FPADD           ; Add BCDE to FPREG (Times 5)
2CBC: 21CC81  	        ld      HL,FPEXP        ; Point to exponent
2CBF: 34      	        inc     (HL)            ; Double number (Times 10)
2CC0: C0      	        ret     NZ              ; Ok - Return
2CC1: C34B15  	        jp      OVERR           ; Overflow error
              	
2CC4: 3ACC81  	TSTSGN: ld      A,(FPEXP)       ; Get sign of FPREG
2CC7: B7      	        or      A
2CC8: C8      	        ret     Z               ; RETurn if number is zero
2CC9: 3ACB81  	        ld      A,(FPREG+2)     ; Get MSB of FPREG
2CCC: FE      	        defb    0FEH            ; Test sign
2CCD: 2F      	RETREL: cpl                     ; Invert sign
2CCE: 17      	        rla                     ; Sign bit to carry
2CCF: 9F      	FLGDIF: sbc     A,A             ; Carry to all bits of A
2CD0: C0      	        ret     NZ              ; Return -1 if negative
2CD1: 3C      	        inc     A               ; Bump to +1
2CD2: C9      	        ret                     ; Positive - Return +1
              	
2CD3: CDC42C  	SGN:    call    TSTSGN          ; Test sign of FPREG
2CD6: 0688    	FLGREL: ld      B,$80+8         ; 8 bit integer in exponent
2CD8: 110000  	        ld      DE,0            ; Zero NMSB and LSB
2CDB: 21CC81  	RETINT: ld      HL,FPEXP        ; Point to exponent
2CDE: 4F      	        ld      C,A             ; CDE = MSB,NMSB and LSB
2CDF: 70      	        ld      (HL),B          ; Save exponent
2CE0: 0600    	        ld      B,0             ; CDE = integer to normalise
2CE2: 23      	        inc     HL              ; Point to sign of result
2CE3: 3680    	        ld      (HL),$80        ; Set sign of result
2CE5: 17      	        rla                     ; Carry = sign of integer
2CE6: C37B2A  	        jp      CONPOS          ; Set sign of result
              	
2CE9: CDC42C  	ABS:    call    TSTSGN          ; Test sign of FPREG
2CEC: F0      	        ret     P               ; Return if positive
2CED: 21CB81  	INVSGN: ld      HL,FPREG+2      ; Point to MSB
2CF0: 7E      	        ld      A,(HL)          ; Get sign of mantissa
2CF1: EE80    	        xor     $80             ; Invert sign of mantissa
2CF3: 77      	        ld      (HL),A          ; Re-save sign of mantissa
2CF4: C9      	        ret
              	
2CF5: EB      	STAKFP: ex      DE,HL           ; Save code string address
2CF6: 2AC981  	        ld      HL,(FPREG)      ; LSB,NLSB of FPREG
2CF9: E3      	        ex      (SP),HL         ; Stack them,get return
2CFA: E5      	        push    HL              ; Re-save return
2CFB: 2ACB81  	        ld      HL,(FPREG+2)    ; MSB and exponent of FPREG
2CFE: E3      	        ex      (SP),HL         ; Stack them,get return
2CFF: E5      	        push    HL              ; Re-save return
2D00: EB      	        ex      DE,HL           ; Restore code string address
2D01: C9      	        ret
              	
              	; store F.P. number from BCDE into FPREG
2D02: CD132D  	PHLTFP: call    LOADFP          ; Number at HL to BCDE
2D05: EB      	FPBCDE: ex      DE,HL           ; Save code string address
2D06: 22C981  	        ld      (FPREG),HL      ; Save LSB,NLSB of number
2D09: 60      	        ld      H,B             ; Exponent of number
2D0A: 69      	        ld      L,C             ; MSB of number
2D0B: 22CB81  	        ld      (FPREG+2),HL    ; Save MSB and exponent
2D0E: EB      	        ex      DE,HL           ; Restore code string address
2D0F: C9      	        ret
              	
              	; load F.P. number from FPREG into BCDE
2D10: 21C981  	BCDEFP: ld      HL,FPREG        ; Point to FPREG
2D13: 5E      	LOADFP: ld      E,(HL)          ; Get LSB of number
2D14: 23      	        inc     HL
2D15: 56      	        ld      D,(HL)          ; Get NMSB of number
2D16: 23      	        inc     HL
2D17: 4E      	        ld      C,(HL)          ; Get MSB of number
2D18: 23      	        inc     HL
2D19: 46      	        ld      B,(HL)          ; Get exponent of number
2D1A: 23      	INCHL:  inc     HL              ; Used for conditional "inc HL"
2D1B: C9      	        ret
              	
2D1C: 11C981  	FPTHL:  ld      DE,FPREG        ; Point to FPREG
2D1F: 0604    	DETHL4: ld      B,$04           ; 4 bytes to move
2D21: 1A      	DETHLB: ld      A,(DE)          ; Get source
2D22: 77      	        ld      (HL),A          ; Save destination
2D23: 13      	        inc     DE              ; Next source
2D24: 23      	        inc     HL              ; Next destination
2D25: 05      	        dec     B               ; Count bytes
2D26: C2212D  	        jp      NZ,DETHLB       ; Loop if more
2D29: C9      	        ret
              	
2D2A: 21CB81  	SIGNS:  ld      HL,FPREG+2      ; Point to MSB of FPREG
2D2D: 7E      	        ld      A,(HL)          ; Get MSB
2D2E: 07      	        rlca                    ; Old sign to carry
2D2F: 37      	        scf                     ; Set MSBit
2D30: 1F      	        rra                     ; Set MSBit of MSB
2D31: 77      	        ld      (HL),A          ; Save new MSB
2D32: 3F      	        ccf                     ; Complement sign
2D33: 1F      	        rra                     ; Old sign to carry
2D34: 23      	        inc     HL
2D35: 23      	        inc     HL
2D36: 77      	        ld      (HL),A          ; Set sign of result
2D37: 79      	        ld      A,C             ; Get MSB
2D38: 07      	        rlca                    ; Old sign to carry
2D39: 37      	        scf                     ; Set MSBit
2D3A: 1F      	        rra                     ; Set MSBit of MSB
2D3B: 4F      	        ld      C,A             ; Save MSB
2D3C: 1F      	        rra
2D3D: AE      	        xor     (HL)            ; New sign of result
2D3E: C9      	        ret
              	
2D3F: 78      	CMPNUM: ld      A,B             ; Get exponent of number
2D40: B7      	        or      A
2D41: CAC42C  	        jp      Z,TSTSGN        ; Zero - Test sign of FPREG
2D44: 21CD2C  	        ld      HL,RETREL       ; Return relation routine
2D47: E5      	        push    HL              ; Save for return
2D48: CDC42C  	        call    TSTSGN          ; Test sign of FPREG
2D4B: 79      	        ld      A,C             ; Get MSB of number
2D4C: C8      	        ret     Z               ; FPREG zero - Number's MSB
2D4D: 21CB81  	        ld      HL,FPREG+2      ; MSB of FPREG
2D50: AE      	        xor     (HL)            ; Combine signs
2D51: 79      	        ld      A,C             ; Get MSB of number
2D52: F8      	        ret     M               ; Exit if signs different
2D53: CD592D  	        call    CMPFP           ; Compare FP numbers
2D56: 1F      	        rra                     ; Get carry to sign
2D57: A9      	        xor     C               ; Combine with MSB of number
2D58: C9      	        ret
              	
2D59: 23      	CMPFP:  inc     HL              ; Point to exponent
2D5A: 78      	        ld      A,B             ; Get exponent
2D5B: BE      	        cp      (HL)            ; Compare exponents
2D5C: C0      	        ret     NZ              ; Different
2D5D: 2B      	        dec     HL              ; Point to MBS
2D5E: 79      	        ld      A,C             ; Get MSB
2D5F: BE      	        cp      (HL)            ; Compare MSBs
2D60: C0      	        ret     NZ              ; Different
2D61: 2B      	        dec     HL              ; Point to NMSB
2D62: 7A      	        ld      A,D             ; Get NMSB
2D63: BE      	        cp      (HL)            ; Compare NMSBs
2D64: C0      	        ret     NZ              ; Different
2D65: 2B      	        dec     HL              ; Point to LSB
2D66: 7B      	        ld      A,E             ; Get LSB
2D67: 96      	        sub     (HL)            ; Compare LSBs
2D68: C0      	        ret     NZ              ; Different
2D69: E1      	        pop     HL              ; Drop RETurn
2D6A: E1      	        pop     HL              ; Drop another RETurn
2D6B: C9      	        ret
              	
2D6C: 47      	FPINT:  ld      B,A             ; <- Move
2D6D: 4F      	        ld      C,A             ; <- exponent
2D6E: 57      	        ld      D,A             ; <- to all
2D6F: 5F      	        ld      E,A             ; <- bits
2D70: B7      	        or      A               ; Test exponent
2D71: C8      	        ret     Z               ; Zero - Return zero
2D72: E5      	        push    HL              ; Save pointer to number
2D73: CD102D  	        call    BCDEFP          ; Move FPREG to BCDE
2D76: CD2A2D  	        call    SIGNS           ; Set MSBs & sign of result
2D79: AE      	        xor     (HL)            ; Combine with sign of FPREG
2D7A: 67      	        ld      H,A             ; Save combined signs
2D7B: FC902D  	        call    M,DCBCDE        ; Negative - Decrement BCDE
2D7E: 3E98    	        ld      A,$80+24        ; 24 bits
2D80: 90      	        sub     B               ; Bits to shift
2D81: CDF22A  	        call    SCALE           ; Shift BCDE
2D84: 7C      	        ld      A,H             ; Get combined sign
2D85: 17      	        rla                     ; Sign to carry
2D86: DCC52A  	        call    C,FPROND        ; Negative - Round number up
2D89: 0600    	        ld      B,$00           ; Zero exponent
2D8B: DCDE2A  	        call    C,COMPL         ; If negative make positive
2D8E: E1      	        pop     HL              ; Restore pointer to number
2D8F: C9      	        ret
              	
2D90: 1B      	DCBCDE: dec     DE              ; Decrement BCDE
2D91: 7A      	        ld      A,D             ; Test LSBs
2D92: A3      	        and     E
2D93: 3C      	        inc     A
2D94: C0      	        ret     NZ              ; Exit if LSBs not FFFF
2D95: 0B      	        dec     BC              ; Decrement MSBs
2D96: C9      	        ret
              	
2D97: 21CC81  	INT:    ld      HL,FPEXP        ; Point to exponent
2D9A: 7E      	        ld      A,(HL)          ; Get exponent
2D9B: FE98    	        cp      $80+24          ; Integer accuracy only?
2D9D: 3AC981  	        ld      A,(FPREG)       ; Get LSB
2DA0: D0      	        ret     NC              ; Yes - Already integer
2DA1: 7E      	        ld      A,(HL)          ; Get exponent
2DA2: CD6C2D  	        call    FPINT           ; F.P to integer
2DA5: 3698    	        ld      (HL),$80+24     ; Save 24 bit integer
2DA7: 7B      	        ld      A,E             ; Get LSB of number
2DA8: F5      	        push    AF              ; Save LSB
2DA9: 79      	        ld      A,C             ; Get MSB of number
2DAA: 17      	        rla                     ; Sign to carry
2DAB: CD7B2A  	        call    CONPOS          ; Set sign of result
2DAE: F1      	        pop     AF              ; Restore LSB of number
2DAF: C9      	        ret
              	
2DB0: 210000  	MLDEBC: ld      HL,$0000        ; Clear partial product
2DB3: 78      	        ld      A,B             ; Test multiplier
2DB4: B1      	        or      C
2DB5: C8      	        ret     Z               ; Return zero if zero
2DB6: 3E10    	        ld      A,$10           ; 16 bits
2DB8: 29      	MLDBLP: add     HL,HL           ; Shift P.P left
2DB9: DADD21  	        jp      C,BSERR         ; ?BS Error if overflow
2DBC: EB      	        ex      DE,HL
2DBD: 29      	        add     HL,HL           ; Shift multiplier left
2DBE: EB      	        ex      DE,HL
2DBF: D2C62D  	        jp      NC,NOMLAD       ; Bit was zero - No add
2DC2: 09      	        add     HL,BC           ; Add multiplicand
2DC3: DADD21  	        jp      C,BSERR         ; ?BS Error if overflow
2DC6: 3D      	NOMLAD: dec     A               ; Count bits
2DC7: C2B82D  	        jp      NZ,MLDBLP       ; More
2DCA: C9      	        ret
              	
2DCB: FE2D    	ASCTFP: cp      '-'             ; Negative?
2DCD: F5      	        push    AF              ; Save it and flags
2DCE: CAD72D  	        jp      Z,CNVNUM        ; Yes - Convert number
2DD1: FE2B    	        cp      '+'             ; Positive?
2DD3: CAD72D  	        jp      Z,CNVNUM        ; Yes - Convert number
2DD6: 2B      	        dec     HL              ; dec 'cos GETCHR INCs
2DD7: CD932A  	CNVNUM: call    RESZER          ; Set result to zero
2DDA: 47      	        ld      B,A             ; Digits after point counter
2DDB: 57      	        ld      D,A             ; Sign of exponent
2DDC: 5F      	        ld      E,A             ; Exponent of ten
2DDD: 2F      	        cpl
2DDE: 4F      	        ld      C,A             ; Before or after point flag
2DDF: CD411A  	MANLP:  call    GETCHR          ; Get next character
2DE2: DA282E  	        jp      C,ADDIG         ; Digit - Add to number
2DE5: FE2E    	        cp      '.'
2DE7: CA032E  	        jp      Z,DPOINT        ; '.' - Flag point
2DEA: FE45    	        cp      'E'
2DEC: C2072E  	        jp      NZ,CONEXP       ; Not 'E' - Scale number
2DEF: CD411A  	        call    GETCHR          ; Get next character
2DF2: CDF91F  	        call    SGNEXP          ; Get sign of exponent
2DF5: CD411A  	EXPLP:  call    GETCHR          ; Get next character
2DF8: DA4A2E  	        jp      C,EDIGIT        ; Digit - Add to exponent
2DFB: 14      	        inc     D               ; Is sign negative?
2DFC: C2072E  	        jp      NZ,CONEXP       ; No - Scale number
2DFF: AF      	        xor     A
2E00: 93      	        sub     E               ; Negate exponent
2E01: 5F      	        ld      E,A             ; And re-save it
2E02: 0C      	        inc     C               ; Flag end of number
2E03: 0C      	DPOINT: inc     C               ; Flag point passed
2E04: CADF2D  	        jp      Z,MANLP         ; Zero - Get another digit
2E07: E5      	CONEXP: push    HL              ; Save code string address
2E08: 7B      	        ld      A,E             ; Get exponent
2E09: 90      	        sub     B               ; Subtract digits after point
2E0A: F4202E  	SCALMI: call    P,SCALPL        ; Positive - Multiply number
2E0D: F2162E  	        jp      P,ENDCON        ; Positive - All done
2E10: F5      	        push    AF              ; Save number of times to /10
2E11: CD0C2C  	        call    DIV10           ; Divide by 10
2E14: F1      	        pop     AF              ; Restore count
2E15: 3C      	        inc     A               ; Count divides
              	
2E16: C20A2E  	ENDCON: jp      NZ,SCALMI       ; More to do
2E19: D1      	        pop     DE              ; Restore code string address
2E1A: F1      	        pop     AF              ; Restore sign of number
2E1B: CCED2C  	        call    Z,INVSGN        ; Negative - Negate number
2E1E: EB      	        ex      DE,HL           ; Code string address to HL
2E1F: C9      	        ret
              	
2E20: C8      	SCALPL: ret     Z               ; Exit if no scaling needed
2E21: F5      	MULTEN: push    AF              ; Save count
2E22: CDAD2C  	        call    MLSP10          ; Multiply number by 10
2E25: F1      	        pop     AF              ; Restore count
2E26: 3D      	        dec     A               ; Count multiplies
2E27: C9      	        ret
              	
2E28: D5      	ADDIG:  push    DE              ; Save sign of exponent
2E29: 57      	        ld      D,A             ; Save digit
2E2A: 78      	        ld      A,B             ; Get digits after point
2E2B: 89      	        adc     A,C             ; Add one if after point
2E2C: 47      	        ld      B,A             ; Re-save counter
2E2D: C5      	        push    BC              ; Save point flags
2E2E: E5      	        push    HL              ; Save code string address
2E2F: D5      	        push    DE              ; Save digit
2E30: CDAD2C  	        call    MLSP10          ; Multiply number by 10
2E33: F1      	        pop     AF              ; Restore digit
2E34: D630    	        sub     '0'             ; Make it absolute
2E36: CD3F2E  	        call    RSCALE          ; Re-scale number
2E39: E1      	        pop     HL              ; Restore code string address
2E3A: C1      	        pop     BC              ; Restore point flags
2E3B: D1      	        pop     DE              ; Restore sign of exponent
2E3C: C3DF2D  	        jp      MANLP           ; Get another digit
              	
2E3F: CDF52C  	RSCALE: call    STAKFP          ; Put number on stack
2E42: CDD62C  	        call    FLGREL          ; Digit to add to FPREG
2E45: C1      	PADD:   pop     BC              ; Restore number
2E46: D1      	        pop     DE
2E47: C32D2A  	        jp      FPADD           ; Add BCDE to FPREG and return
              	
2E4A: 7B      	EDIGIT: ld      A,E             ; Get digit
2E4B: 07      	        rlca                    ; Times 2
2E4C: 07      	        rlca                    ; Times 4
2E4D: 83      	        add     A,E             ; Times 5
2E4E: 07      	        rlca                    ; Times 10
2E4F: 86      	        add     A,(HL)          ; Add next digit
2E50: D630    	        sub     '0'             ; Make it absolute
2E52: 5F      	        ld      E,A             ; Save new digit
2E53: C3F52D  	        jp      EXPLP           ; Look for another digit
              	
2E56: E5      	LINEIN: push    HL              ; Save code string address
2E57: 21B514  	        ld      HL,INMSG        ; Output " in "
2E5A: CDBE23  	        call    PRS             ; Output string at HL
2E5D: E1      	        pop     HL              ; Restore code string address
2E5E: EB      	PRNTHL: ex      DE,HL           ; Code string address to DE
2E5F: AF      	        xor     A
2E60: 0698    	        ld      B,$80+24        ; 24 bits
2E62: CDDB2C  	        call    RETINT          ; Return the integer
2E65: 21BD23  	        ld      HL,PRNUMS       ; Print number string
2E68: E5      	        push    HL              ; Save for return
2E69: 213082  	NUMASC: ld      HL,PBUFF        ; Convert number to ASCII
2E6C: E5      	        push    HL              ; Save for return
2E6D: CDC42C  	        call    TSTSGN          ; Test sign of FPREG
2E70: 3620    	        ld      (HL),SPC        ; Space at start
2E72: F2772E  	        jp      P,SPCFST        ; Positive - Space to start
2E75: 362D    	        ld      (HL),'-'        ; '-' sign at start
2E77: 23      	SPCFST: inc     HL              ; First byte of number
2E78: 3630    	        ld      (HL),'0'        ; '0' if zero
2E7A: CA2D2F  	        jp      Z,JSTZER        ; Return '0' if zero
2E7D: E5      	        push    HL              ; Save buffer address
2E7E: FCED2C  	        call    M,INVSGN        ; Negate FPREG if negative
2E81: AF      	        xor     A               ; Zero A
2E82: F5      	        push    AF              ; Save it
2E83: CD332F  	        call    RNGTST          ; Test number is in range
2E86: 014391  	SIXDIG: ld      BC,$9143        ; BCDE - 99999.9
2E89: 11F84F  	        ld      DE,$4FF8
2E8C: CD3F2D  	        call    CMPNUM          ; Compare numbers
2E8F: B7      	        or      A
2E90: E2A42E  	        jp      PO,INRNG        ; > 99999.9 - Sort it out
2E93: F1      	        pop     AF              ; Restore count
2E94: CD212E  	        call    MULTEN          ; Multiply by ten
2E97: F5      	        push    AF              ; Re-save count
2E98: C3862E  	        jp      SIXDIG          ; Test it again
              	
2E9B: CD0C2C  	GTSIXD: call    DIV10           ; Divide by 10
2E9E: F1      	        pop     AF              ; Get count
2E9F: 3C      	        inc     A               ; Count divides
2EA0: F5      	        push    AF              ; Re-save count
2EA1: CD332F  	        call    RNGTST          ; Test number is in range
2EA4: CD1B2A  	INRNG:  call    ROUND           ; Add 0.5 to FPREG
2EA7: 3C      	        inc     A
2EA8: CD6C2D  	        call    FPINT           ; F.P to integer
2EAB: CD052D  	        call    FPBCDE          ; Move BCDE to FPREG
2EAE: 010603  	        ld      BC,$0306        ; 1E+06 to 1E-03 range
2EB1: F1      	        pop     AF              ; Restore count
2EB2: 81      	        add     A,C             ; 6 digits before point
2EB3: 3C      	        inc     A               ; Add one
2EB4: FAC02E  	        jp      M,MAKNUM        ; Do it in 'E' form if < 1E-02
2EB7: FE08    	        cp      6+1+1           ; More than 999999 ?
2EB9: D2C02E  	        jp      NC,MAKNUM       ; Yes - Do it in 'E' form
2EBC: 3C      	        inc     A               ; Adjust for exponent
2EBD: 47      	        ld      B,A             ; Exponent of number
2EBE: 3E02    	        ld      A,2             ; Make it zero after
              	
2EC0: 3D      	MAKNUM: dec     A               ; Adjust for digits to do
2EC1: 3D      	        dec     A
2EC2: E1      	        pop     HL              ; Restore buffer address
2EC3: F5      	        push    AF              ; Save count
2EC4: 11462F  	        ld      DE,POWERS       ; Powers of ten
2EC7: 05      	        dec     B               ; Count digits before point
2EC8: C2D12E  	        jp      NZ,DIGTXT       ; Not zero - Do number
2ECB: 362E    	        ld      (HL),'.'        ; Save point
2ECD: 23      	        inc     HL              ; Move on
2ECE: 3630    	        ld      (HL),'0'        ; Save zero
2ED0: 23      	        inc     HL              ; Move on
2ED1: 05      	DIGTXT: dec     B               ; Count digits before point
2ED2: 362E    	        ld      (HL),'.'        ; Save point in case
2ED4: CC1A2D  	        call    Z,INCHL         ; Last digit - move on
2ED7: C5      	        push    BC              ; Save digits before point
2ED8: E5      	        push    HL              ; Save buffer address
2ED9: D5      	        push    DE              ; Save powers of ten
2EDA: CD102D  	        call    BCDEFP          ; Move FPREG to BCDE
2EDD: E1      	        pop     HL              ; Powers of ten table
2EDE: 062F    	        ld      B,'0'-1         ; ASCII '0' - 1
2EE0: 04      	TRYAGN: inc     B               ; Count subtractions
2EE1: 7B      	        ld      A,E             ; Get LSB
2EE2: 96      	        sub     (HL)            ; Subtract LSB
2EE3: 5F      	        ld      E,A             ; Save LSB
2EE4: 23      	        inc     HL
2EE5: 7A      	        ld      A,D             ; Get NMSB
2EE6: 9E      	        sbc     A,(HL)          ; Subtract NMSB
2EE7: 57      	        ld      D,A             ; Save NMSB
2EE8: 23      	        inc     HL
2EE9: 79      	        ld      A,C             ; Get MSB
2EEA: 9E      	        sbc     A,(HL)          ; Subtract MSB
2EEB: 4F      	        ld      C,A             ; Save MSB
2EEC: 2B      	        dec     HL              ; Point back to start
2EED: 2B      	        dec     HL
2EEE: D2E02E  	        jp      NC,TRYAGN       ; No overflow - Try again
2EF1: CDD22A  	        call    PLUCDE          ; Restore number
2EF4: 23      	        inc     HL              ; Start of next number
2EF5: CD052D  	        call    FPBCDE          ; Move BCDE to FPREG
2EF8: EB      	        ex      DE,HL           ; Save point in table
2EF9: E1      	        pop     HL              ; Restore buffer address
2EFA: 70      	        ld      (HL),B          ; Save digit in buffer
2EFB: 23      	        inc     HL              ; And move on
2EFC: C1      	        pop     BC              ; Restore digit count
2EFD: 0D      	        dec     C               ; Count digits
2EFE: C2D12E  	        jp      NZ,DIGTXT       ; More - Do them
2F01: 05      	        dec     B               ; Any decimal part?
2F02: CA112F  	        jp      Z,DOEBIT        ; No - Do 'E' bit
2F05: 2B      	SUPTLZ: dec     HL              ; Move back through buffer
2F06: 7E      	        ld      A,(HL)          ; Get character
2F07: FE30    	        cp      '0'             ; '0' character?
2F09: CA052F  	        jp      Z,SUPTLZ        ; Yes - Look back for more
2F0C: FE2E    	        cp      '.'             ; A decimal point?
2F0E: C41A2D  	        call    NZ,INCHL        ; Move back over digit
              	
2F11: F1      	DOEBIT: pop     AF              ; Get 'E' flag
2F12: CA302F  	        jp      Z,NOENED        ; No 'E' needed - End buffer
2F15: 3645    	        ld      (HL),'E'        ; Put 'E' in buffer
2F17: 23      	        inc     HL              ; And move on
2F18: 362B    	        ld      (HL),'+'        ; Put '+' in buffer
2F1A: F2212F  	        jp      P,OUTEXP        ; Positive - Output exponent
2F1D: 362D    	        ld      (HL),'-'        ; Put '-' in buffer
2F1F: 2F      	        cpl                     ; Negate exponent
2F20: 3C      	        inc     A
2F21: 062F    	OUTEXP: ld      B,'0'-1         ; ASCII '0' - 1
2F23: 04      	EXPTEN: inc     B               ; Count subtractions
2F24: D60A    	        sub     $0A             ; Tens digit
2F26: D2232F  	        jp      NC,EXPTEN       ; More to do
2F29: C63A    	        add     A,'0'+10        ; Restore and make ASCII
2F2B: 23      	        inc     HL              ; Move on
2F2C: 70      	        ld      (HL),B          ; Save MSB of exponent
2F2D: 23      	JSTZER: inc     HL              ;
2F2E: 77      	        ld      (HL),A          ; Save LSB of exponent
2F2F: 23      	        inc     HL
2F30: 71      	NOENED: ld      (HL),C          ; Mark end of buffer
2F31: E1      	        pop     HL              ; Restore code string address
2F32: C9      	        ret
              	
2F33: 017494  	RNGTST: ld      BC,$9474        ; BCDE = 999999.
2F36: 11F723  	        ld      DE,$23F7
2F39: CD3F2D  	        call    CMPNUM          ; Compare numbers
2F3C: B7      	        or      A
2F3D: E1      	        pop     HL              ; Return address to HL
2F3E: E29B2E  	        jp      PO,GTSIXD       ; Too big - Divide by ten
2F41: E9      	        jp      (HL)            ; Otherwise return to caller
              	
2F42: 00000080	HALF:   defb    $00,$00,$00,$80 ; 0.5
              	
2F46: A08601  	POWERS: defb    $A0,$86,$01  ; 100000
2F49: 102700  	        defb    $10,$27,$00  ;  10000
2F4C: E80300  	        defb    $E8,$03,$00  ;   1000
2F4F: 640000  	        defb    $64,$00,$00  ;    100
2F52: 0A0000  	        defb    $0A,$00,$00  ;     10
2F55: 010000  	        defb    $01,$00,$00  ;      1
              	
2F58: 21ED2C  	NEGAFT: ld      HL,INVSGN       ; Negate result
2F5B: E3      	        ex      (SP),HL         ; To be done after caller
2F5C: E9      	        jp      (HL)            ; Return to caller
              	
2F5D: CDF52C  	SQR:    call    STAKFP          ; Put value on stack
2F60: 21422F  	        ld      HL,HALF         ; Set power to 1/2
2F63: CD022D  	        call    PHLTFP          ; Move 1/2 to FPREG
              	
2F66: C1      	POWER:  pop     BC              ; Get base
2F67: D1      	        pop     DE
2F68: CDC42C  	        call    TSTSGN          ; Test sign of power
2F6B: 78      	        ld      A,B             ; Get exponent of base
2F6C: CAAB2F  	        jp      Z,EXP           ; Make result 1 if zero
2F6F: F2762F  	        jp      P,POWER1        ; Positive base - Ok
2F72: B7      	        or      A               ; Zero to negative power?
2F73: CA3F15  	        jp      Z,DZERR         ; Yes - ?/0 Error
2F76: B7      	POWER1: or      A               ; Base zero?
2F77: CA942A  	        jp      Z,SAVEXP        ; Yes - Return zero
2F7A: D5      	        push    DE              ; Save base
2F7B: C5      	        push    BC
2F7C: 79      	        ld      A,C             ; Get MSB of base
2F7D: F67F    	        or      %01111111       ; Get sign status
2F7F: CD102D  	        call    BCDEFP          ; Move power to BCDE
2F82: F2932F  	        jp      P,POWER2        ; Positive base - Ok
2F85: D5      	        push    DE              ; Save power
2F86: C5      	        push    BC
2F87: CD972D  	        call    INT             ; Get integer of power
2F8A: C1      	        pop     BC              ; Restore power
2F8B: D1      	        pop     DE
2F8C: F5      	        push    AF              ; MSB of base
2F8D: CD3F2D  	        call    CMPNUM          ; Power an integer?
2F90: E1      	        pop     HL              ; Restore MSB of base
2F91: 7C      	        ld      A,H             ; but don't affect flags
2F92: 1F      	        rra                     ; Exponent odd or even?
2F93: E1      	POWER2: pop     HL              ; Restore MSB and exponent
2F94: 22CB81  	        ld      (FPREG+2),HL    ; Save base in FPREG
2F97: E1      	        pop     HL              ; LSBs of base
2F98: 22C981  	        ld      (FPREG),HL      ; Save in FPREG
2F9B: DC582F  	        call    C,NEGAFT        ; Odd power - Negate result
2F9E: CCED2C  	        call    Z,INVSGN        ; Negative base - Negate it
2FA1: D5      	        push    DE              ; Save power
2FA2: C5      	        push    BC
2FA3: CD272B  	        call    LOG             ; Get LOG of base
2FA6: C1      	        pop     BC              ; Restore power
2FA7: D1      	        pop     DE
2FA8: CD682B  	        call    FPMULT          ; Multiply LOG by power
              	
2FAB: CDF52C  	EXP:    call    STAKFP          ; Put value on stack
2FAE: 013881  	        ld      BC,$8138        ; BCDE = 1/Ln(2)
2FB1: 113BAA  	        ld      DE,$AA3B
2FB4: CD682B  	        call    FPMULT          ; Multiply value by 1/LN(2)
2FB7: 3ACC81  	        ld      A,(FPEXP)       ; Get exponent
2FBA: FE88    	        cp      $80+8           ; Is it in range?
2FBC: D2A02C  	        jp      NC,OVTST1       ; No - Test for overflow
2FBF: CD972D  	        call    INT             ; Get INT of FPREG
2FC2: C680    	        add     A,$80           ; For excess 128
2FC4: C602    	        add     A,$02           ; Exponent > 126?
2FC6: DAA02C  	        jp      C,OVTST1        ; Yes - Test for overflow
2FC9: F5      	        push    AF              ; Save scaling factor
2FCA: 21162B  	        ld      HL,UNITY        ; Point to 1.
2FCD: CD1E2A  	        call    ADDPHL          ; Add 1 to FPREG
2FD0: CD5F2B  	        call    MULLN2          ; Multiply by LN(2)
2FD3: F1      	        pop     AF              ; Restore scaling factor
2FD4: C1      	        pop     BC              ; Restore exponent
2FD5: D1      	        pop     DE
2FD6: F5      	        push    AF              ; Save scaling factor
2FD7: CD2A2A  	        call    SUBCDE          ; Subtract exponent from FPREG
2FDA: CDED2C  	        call    INVSGN          ; Negate result
2FDD: 21EB2F  	        ld      HL,EXPTAB       ; Coefficient table
2FE0: CD1B30  	        call    SMSER1          ; Sum the series
2FE3: 110000  	        ld      DE,$0000        ; Zero LSBs
2FE6: C1      	        pop     BC              ; Scaling factor
2FE7: 4A      	        ld      C,D             ; Zero MSB
2FE8: C3682B  	        jp      FPMULT          ; Scale result to correct value
              	
2FEB: 08      	EXPTAB: defb    $08             ; Table used by EXP
2FEC: 402E9474	        defb    $40,$2E,$94,$74 ; -1/7! (-1/5040)
2FF0: 704F2E77	        defb    $70,$4F,$2E,$77 ;  1/6! ( 1/720)
2FF4: 6E02887A	        defb    $6E,$02,$88,$7A ; -1/5! (-1/120)
2FF8: E6A02A7C	        defb    $E6,$A0,$2A,$7C ;  1/4! ( 1/24)
2FFC: 50AAAA7E	        defb    $50,$AA,$AA,$7E ; -1/3! (-1/6)
3000: FFFF7F7F	        defb    $FF,$FF,$7F,$7F ;  1/2! ( 1/2)
3004: 00008081	        defb    $00,$00,$80,$81 ; -1/1! (-1/1)
3008: 00000081	        defb    $00,$00,$00,$81 ;  1/0! ( 1/1)
              	
300C: CDF52C  	SUMSER: call    STAKFP          ; Put FPREG on stack
300F: 11662B  	        ld      DE,MULT         ; Multiply by "X"
3012: D5      	        push    DE              ; To be done after
3013: E5      	        push    HL              ; Save address of table
3014: CD102D  	        call    BCDEFP          ; Move FPREG to BCDE
3017: CD682B  	        call    FPMULT          ; Square the value
301A: E1      	        pop     HL              ; Restore address of table
301B: CDF52C  	SMSER1: call    STAKFP          ; Put value on stack
301E: 7E      	        ld      A,(HL)          ; Get number of coefficients
301F: 23      	        inc     HL              ; Point to start of table
3020: CD022D  	        call    PHLTFP          ; Move coefficient to FPREG
3023: 06      	        defb    06H             ; Skip "pop AF"
3024: F1      	SUMLP:  pop     AF              ; Restore count
3025: C1      	        pop     BC              ; Restore number
3026: D1      	        pop     DE
3027: 3D      	        dec     A               ; Cont coefficients
3028: C8      	        ret     Z               ; All done
3029: D5      	        push    DE              ; Save number
302A: C5      	        push    BC
302B: F5      	        push    AF              ; Save count
302C: E5      	        push    HL              ; Save address in table
302D: CD682B  	        call    FPMULT          ; Multiply FPREG by BCDE
3030: E1      	        pop     HL              ; Restore address in table
3031: CD132D  	        call    LOADFP          ; Number at HL to BCDE
3034: E5      	        push    HL              ; Save address in table
3035: CD2D2A  	        call    FPADD           ; Add coefficient to FPREG
3038: E1      	        pop     HL              ; Restore address in table
3039: C32430  	        jp      SUMLP           ; More coefficients
              	
303C: CDC42C  	RND:    call    TSTSGN          ; Test sign of FPREG
303F: 217A80  	        ld      HL,SEED+2       ; Random number seed
3042: FA9D30  	        jp      M,RESEED        ; Negative - Re-seed
3045: 219B80  	        ld      HL,LSTRND       ; Last random number
3048: CD022D  	        call    PHLTFP          ; Move last RND to FPREG
304B: 217A80  	        ld      HL,SEED+2       ; Random number seed
304E: C8      	        ret     Z               ; Return if RND(0)
304F: 86      	        add     A,(HL)          ; Add (SEED)+2)
3050: E607    	        and     %00000111       ; 0 to 7
3052: 0600    	        ld      B,$00
3054: 77      	        ld      (HL),A          ; Re-save seed
3055: 23      	        inc     HL              ; Move to coefficient table
3056: 87      	        add     A,A             ; 4 bytes
3057: 87      	        add     A,A             ; per entry
3058: 4F      	        ld      C,A             ; BC = Offset into table
3059: 09      	        add     HL,BC           ; Point to coefficient
305A: CD132D  	        call    LOADFP          ; Coefficient to BCDE
305D: CD682B  	        call    FPMULT  ;       ; Multiply FPREG by coefficient
3060: 3A7980  	        ld      A,(SEED+1)      ; Get (SEED+1)
3063: 3C      	        inc     A               ; Add 1
3064: E603    	        and     %00000011       ; 0 to 3
3066: 0600    	        ld      B,$00
3068: FE01    	        cp      $01             ; Is it zero?
306A: 88      	        adc     A,B             ; Yes - Make it 1
306B: 327980  	        ld      (SEED+1),A      ; Re-save seed
306E: 21A130  	        ld      HL,RNDTAB-4     ; Addition table
3071: 87      	        add     A,A             ; 4 bytes
3072: 87      	        add     A,A             ; per entry
3073: 4F      	        ld      C,A             ; BC = Offset into table
3074: 09      	        add     HL,BC           ; Point to value
3075: CD1E2A  	        call    ADDPHL          ; Add value to FPREG
3078: CD102D  	RND1:   call    BCDEFP          ; Move FPREG to BCDE
307B: 7B      	        ld      A,E             ; Get LSB
307C: 59      	        ld      E,C             ; LSB = MSB
307D: EE4F    	        xor     %01001111       ; Fiddle around
307F: 4F      	        ld      C,A             ; New MSB
3080: 3680    	        ld      (HL),$80        ; Set exponent
3082: 2B      	        dec     HL              ; Point to MSB
3083: 46      	        ld      B,(HL)          ; Get MSB
3084: 3680    	        ld      (HL),$80        ; Make value -0.5
3086: 217880  	        ld      HL,SEED         ; Random number seed
3089: 34      	        inc     (HL)            ; Count seed
308A: 7E      	        ld      A,(HL)          ; Get seed
308B: D6AB    	        sub     $AB             ; Do it modulo 171
308D: C29430  	        jp      NZ,RND2         ; Non-zero - Ok
3090: 77      	        ld      (HL),A          ; Zero seed
3091: 0C      	        inc     C               ; Fillde about
3092: 15      	        dec     D               ; with the
3093: 1C      	        inc     E               ; number
3094: CD7E2A  	RND2:   call    BNORM           ; Normalise number
3097: 219B80  	        ld      HL,LSTRND       ; Save random number
309A: C31C2D  	        jp      FPTHL           ; Move FPREG to last and return
              	
309D: 77      	RESEED: ld      (HL),A          ; Re-seed random numbers
309E: 2B      	        dec     HL
309F: 77      	        ld      (HL),A
30A0: 2B      	        dec     HL
30A1: 77      	        ld      (HL),A
30A2: C37830  	        jp      RND1            ; Return RND seed
              	
30A5: 68B14668	RNDTAB: defb    $68,$B1,$46,$68 ; Table used by RND
30A9: 99E99269	        defb    $99,$E9,$92,$69
30AD: 10D17568	        defb    $10,$D1,$75,$68
              	
30B1: 21FB30  	COS:    ld      HL,HALFPI       ; Point to PI/2
30B4: CD1E2A  	        call    ADDPHL          ; Add it to PPREG
30B7: CDF52C  	SIN:    call    STAKFP          ; Put angle on stack
30BA: 014983  	        ld      BC,$8349        ; BCDE = 2 PI
30BD: 11DB0F  	        ld      DE,$0FDB
30C0: CD052D  	        call    FPBCDE          ; Move 2 PI to FPREG
30C3: C1      	        pop     BC              ; Restore angle
30C4: D1      	        pop     DE
30C5: CD1A2C  	        call    DVBCDE          ; Divide angle by 2 PI
30C8: CDF52C  	        call    STAKFP          ; Put it on stack
30CB: CD972D  	        call    INT             ; Get INT of result
30CE: C1      	        pop     BC              ; Restore number
30CF: D1      	        pop     DE
30D0: CD2A2A  	        call    SUBCDE          ; Make it 0 <= value < 1
30D3: 21FF30  	        ld      HL,QUARTR       ; Point to 0.25
30D6: CD242A  	        call    SUBPHL          ; Subtract value from 0.25
30D9: CDC42C  	        call    TSTSGN          ; Test sign of value
30DC: 37      	        scf                     ; Flag positive
30DD: F2E730  	        jp      P,SIN1          ; Positive - Ok
30E0: CD1B2A  	        call    ROUND           ; Add 0.5 to value
30E3: CDC42C  	        call    TSTSGN          ; Test sign of value
30E6: B7      	        or      A               ; Flag negative
30E7: F5      	SIN1:   push    AF              ; Save sign
30E8: F4ED2C  	        call    P,INVSGN        ; Negate value if positive
30EB: 21FF30  	        ld      HL,QUARTR       ; Point to 0.25
30EE: CD1E2A  	        call    ADDPHL          ; Add 0.25 to value
30F1: F1      	        pop     AF              ; Restore sign
30F2: D4ED2C  	        call    NC,INVSGN       ; Negative - Make positive
30F5: 210331  	        ld      HL,SINTAB       ; Coefficient table
30F8: C30C30  	        jp      SUMSER          ; Evaluate sum of series
              	
30FB: DB0F4981	HALFPI: defb    $DB,$0F,$49,$81 ; 1.5708 (PI/2)
              	
30FF: 0000007F	QUARTR: defb    $00,$00,$00,$7F ; 0.25
              	
3103: 05      	SINTAB: defb    $05             ; Table used by SIN
3104: BAD71E86	        defb    $BA,$D7,$1E,$86 ; 39.711
3108: 64269987	        defb    $64,$26,$99,$87 ;-76.575
310C: 58342387	        defb    $58,$34,$23,$87 ; 81.602
3110: E05DA586	        defb    $E0,$5D,$A5,$86 ;-41.342
3114: DA0F4983	        defb    $DA,$0F,$49,$83 ;  6.2832
              	
3118: CDF52C  	TAN:    call    STAKFP          ; Put angle on stack
311B: CDB730  	        call    SIN             ; Get SIN of angle
311E: C1      	        pop     BC              ; Restore angle
311F: E1      	        pop     HL
3120: CDF52C  	        call    STAKFP          ; Save SIN of angle
3123: EB      	        ex      DE,HL           ; BCDE = Angle
3124: CD052D  	        call    FPBCDE          ; Angle to FPREG
3127: CDB130  	        call    COS             ; Get COS of angle
312A: C3182C  	        jp      DIV             ; TAN = SIN / COS
              	
312D: CDC42C  	ATN:    call    TSTSGN          ; Test sign of value
3130: FC582F  	        call    M,NEGAFT        ; Negate result after if -ve
3133: FCED2C  	        call    M,INVSGN        ; Negate value if -ve
3136: 3ACC81  	        ld      A,(FPEXP)       ; Get exponent
3139: FE81    	        cp      81H             ; Number less than 1?
313B: DA4A31  	        jp      C,ATN1          ; Yes - Get arc tangnt
313E: 010081  	        ld      BC,$8100        ; BCDE = 1
3141: 51      	        ld      D,C
3142: 59      	        ld      E,C
3143: CD1A2C  	        call    DVBCDE          ; Get reciprocal of number
3146: 21242A  	        ld      HL,SUBPHL       ; Sub angle from PI/2
3149: E5      	        push    HL              ; Save for angle > 1
314A: 215431  	ATN1:   ld      HL,ATNTAB       ; Coefficient table
314D: CD0C30  	        call    SUMSER          ; Evaluate sum of series
3150: 21FB30  	        ld      HL,HALFPI       ; PI/2 - angle in case > 1
3153: C9      	        ret                     ; Number > 1 - Sub from PI/2
              	
3154: 09      	ATNTAB: defb    $09             ; Table used by ATN
3155: 4AD73B78	        defb    $4A,$D7,$3B,$78 ; 1/17
3159: 026E847B	        defb    $02,$6E,$84,$7B ;-1/15
315D: FEC12F7C	        defb    $FE,$C1,$2F,$7C ; 1/13
3161: 74319A7D	        defb    $74,$31,$9A,$7D ;-1/11
3165: 843D5A7D	        defb    $84,$3D,$5A,$7D ; 1/9
3169: C87F917E	        defb    $C8,$7F,$91,$7E ;-1/7
316D: E4BB4C7E	        defb    $E4,$BB,$4C,$7E ; 1/5
3171: 6CAAAA7F	        defb    $6C,$AA,$AA,$7F ;-1/3
3175: 00000081	        defb    $00,$00,$00,$81 ; 1/1
              	
              	
3179: C9      	ARET:   ret                     ; A RETurn instruction
              	
317A: D7      	GETINP: rst     $10             ; input a character
317B: C9      	        ret
              	
317C: E5      	CLS:    push    HL
317D: D5      	        push    DE
317E: 3AE081  	        ld      A,(SCR_MODE)    ; check screen mode
3181: FE02    	        cp      $02             ; G2 mode?
3183: CC5A05  	        call    Z,EMPTYVIDBUF   ; yes, reset video buffer
3186: D1      	        pop     DE
3187: E1      	        pop     HL
3188: 3E0C    	        ld      A,CS            ; ASCII Clear screen
318A: CD5C18  	        call    SND2VID         ; send to screen
318D: C33C3C  	        jp      MONOUT          ; Output character
              	
3190: CD3C27  	WIDTH:  call    GETINT          ; Get integer 0-255
3193: 7B      	        ld      A,E             ; Width to A
3194: 32A280  	        ld      (LWIDTH),A      ; Set width
3197: C9      	        ret
              	
              	
3198: CDF71A  	DEEK:   call    DEINT           ; Get integer -32768 to 32767
319B: D5      	        push    DE              ; Save number
319C: E1      	        pop     HL              ; Number to HL
319D: 46      	RECWRD: ld      B,(HL)          ; Get LSB of contents
319E: 23      	        inc     HL
319F: 7E      	        ld      A,(HL)          ; Get MSB of contents
31A0: C3A022  	        jp      ABPASS          ; Return integer AB
              	
31A3: CDB61E  	DOKE:   call    GETNUM          ; Get a number
31A6: CDF71A  	        call    DEINT           ; Get integer -32768 to 32767
31A9: D5      	        push    DE              ; Save address
31AA: CD1E18  	        call    CHKSYN          ; Make sure ',' follows
31AD: 2C      	        defb    ','
31AE: CDB61E  	        call    GETNUM          ; Get a number
31B1: CDF71A  	        call    DEINT           ; Get integer -32768 to 32767
31B4: E3      	        ex      (SP),HL         ; Save value,get address
31B5: 73      	        ld      (HL),E          ; Save LSB of value
31B6: 23      	        inc     HL
31B7: 72      	        ld      (HL),D          ; Save MSB of value
31B8: E1      	        pop     HL              ; Restore code string address
31B9: C9      	        ret
              	
              	; stop the execution of code for a certain bit of time. The pause
              	; is between $0000 and $FFFF 100ths of second (0~655.5 secs)
31BA: CDB61E  	PAUSE:  call    GETNUM          ; Get a number
31BD: CDF71A  	        call    DEINT           ; Get integer -32768 to 32767
31C0: 7A      	        ld      A,D             ; load D into A
31C1: B3      	        or      E               ; are D & E equal to $00?
31C2: C8      	        ret     Z               ; if yes, then return
31C3: C5      	DIR_PAU:push    BC              ; store BC
31C4: 3ACE81  	        ld      A,(TMRCNT)      ; Load current value of system timer
31C7: 47      	        ld      B,A             ; move it into B
31C8: CD6C1A  	RPTPS:  call    TSTBRK          ; Test for break key
31CB: 3ACE81  	        ld      A,(TMRCNT)      ; Load current value of system timer
31CE: B8      	        cp      B               ; is it the same value?
31CF: 28F7    	        jr      Z,RPTPS         ; yes, so read again
31D1: 47      	        ld      B,A             ; no, so store the new value
31D2: 1B      	        dec     DE              ; decrement interval
31D3: 7A      	        ld      A,D             ; load D into A
31D4: B3      	        or      E               ; check if DE is equal to 0 (if D & e are $00 then result is 0)
31D5: 20F1    	        jr      NZ,RPTPS        ; no, repeat
31D7: C1      	        pop     BC              ; yes, recover BC and continue
31D8: C9      	        ret
              	
              	; change the screen mode. Usage: SCREEN X[,Y][,Z]
              	; where X is: 0=text mode (40x24),
              	; 1=graphic mode 1 (32x24 chars); 2=graphic mode 2 (256x192 pixels);
              	; 3=multicolor mode (64x48 pixels); 4=extended graphic mode 2 (32x24 chars mixed between G1 and G2)
              	; Y is: 0=8x8 sprites, 1=16x16 sprites
              	; Z is: 0=no sprite magnification; 1=sprite magnification x2 (8x8=>16x16, and 16x16=32x32)
              	; (the latters are accepted only in graphic modes G1, G2, G3, and G4)
31D9: AF      	SCREEN: xor     A
31DA: 32F181  	        ld      (TMPBFR2),A     ; sprite size & magnif. byte set to 0
31DD: CD3C27  	        call    GETINT          ; Get integer 0-255
31E0: FE05    	        cp      $05             ; is it a valid mode (0~4)?
31E2: D20C1B  	        jp      NC,FCERR        ; No - Illegal function call Error
31E5: 32EF81  	        ld      (TMPBFR1),A     ; store graphic mode
31E8: A7      	        and     A               ; is it 0 (text mode)?
31E9: CA0532  	        jp      Z,SCVDP         ; yes, ignore other arguments and set mode immediately
31EC: CD4432  	SETVDP: call    CHKSCAR         ; no, check if sprite size follows
31EF: DAF731  	        jp      C,CKMAGN        ; no (set to 0 or missing), so jump over
31F2: 3E02    	        ld      A,$02           ; no, so set sprite size
31F4: 32F181  	        ld      (TMPBFR2),A     ; ...to 16x16
31F7: CD4432  	CKMAGN: call    CHKSCAR         ; check if sprite magnification follows
31FA: DA0532  	        jp      C,SCVDP         ; no (set to 0 or missing), so jump over
31FD: 3AF181  	        ld      A,(TMPBFR2)     ; yes, so retrieve sprite attributes...
3200: F601    	        or      $01             ; ...set sprite magnification to 2x...
3202: 32F181  	        ld      (TMPBFR2),A     ; ...and save flags again
3205: F3      	SCVDP:  di                      ; disable INTs
3206: D5      	        push    DE              ; store DE
3207: E5      	        push    HL              ; store HL
3208: 3AEF81  	        ld      A,(TMPBFR1)     ; recover graphic mode
320B: 5F      	        ld      E,A             ; and store it into E
320C: 3AF181  	        ld      A,(TMPBFR2)     ; recover sprite flags
320F: 57      	        ld      D,A             ; and store them into D
3210: D5      	        push    DE              ; store D & E
3211: CD8003  	        call    initVDP         ; initialize VDP with mode pointed by E
3214: D1      	        pop     DE              ; retrieve D & E
3215: 7B      	        ld      A,E             ; move graphic mode into A
3216: 87      	        add     A,A
3217: 87      	        add     A,A
3218: 87      	        add     A,A             ; multiply A times 8 to get offset of graphic mode
3219: 5F      	        ld      E,A             ; and pass it into E
321A: D5      	        push    DE              ; store sprite flags in E
321B: 1600    	        ld      D,$00           ; reset D
321D: 21380A  	        ld      HL,VDPMODESET+1 ; load address of VDP settings for reg#1
3220: 19      	        add     HL,DE           ; load correct reg#1 setting
3221: D1      	        pop     DE              ; retrieve sprite flags from E
3222: 7E      	        ld      A,(HL)          ; load reg#1 setting
3223: E6FC    	        and     %11111100       ; reset size & magn. bits
3225: B2      	        or      D               ; set size & magn. bits
3226: 5F      	        ld      E,A             ; value into E
3227: 3E01    	        ld      A,$01           ; reg #1
3229: CD3606  	        call    WRITE_VREG      ; send setting to reg #1
322C: 2AAF80  	        ld      HL,(LINEAT)     ; Get current line number
322F: 23      	        inc     HL              ; -1 means direct statement
3230: 7C      	        ld      A,H
3231: B5      	        or      L
3232: CC3808  	        call    Z,CURSOR_ON     ; enable cursor if not in program mode
3235: FB      	        ei                      ; re-enable interrupts
3236: E1      	        pop     HL              ; restore HL
3237: D1      	        pop     DE              ; restore DE
3238: 3ADF81  	        ld      A,(SCR_SIZE_H)  ; check the screen mode by looking at the screen height
323B: FE30    	        cp      $30             ; is it 48 chars or 192 pixels (MC and G2 modes)?
323D: D0      	        ret     NC              ; yes, so exit (in graphics 2 and multicolor no print-on-video)
323E: 3E01    	        ld      A,$01           ; no (we are in Text, G1 or ExG2), so activate the...
3240: 32EB81  	        ld      (PRNTVIDEO),A   ; ...video buffer...
3243: C9      	        ret                     ; ...and return to caller
              	
              	; check an additional argument for SCREEN
3244: 2B      	CHKSCAR:dec     HL              ; dec 'cos GETCHR INCs
3245: CD411A  	        call    GETCHR          ; Get next character
3248: 37      	        scf                     ; set carry flag
3249: C8      	        ret     Z               ; return if nothing follows with Carry=1
324A: CD1E18  	        call    CHKSYN          ; Make sure ',' follows
324D: 2C      	        defb    ','
324E: CD3C27  	        call    GETINT          ; get value
3251: 1F      	        rra                     ; Carry=bit #0
3252: 3F      	        ccf                     ; invert Carry, so Carry=0 if arg. is 1, and Carry=1 otherwise (arg<>1)
3253: C9      	        ret                     ; return
              	
              	
              	; change the colors of the screen - Syntax is COLOR a,b,c where:
              	; a=foreground color / b=background color / c=border color
              	; a,b,c must be in a range between 1 and 15 (0 is transparent and it's not supported)
3254: CD3C27  	COLOR:  call    GETINT          ; get first value
3257: CDFB32  	        call    CHKCLR          ; check if it's in range 1~15
325A: 32EF81  	        ld      (TMPBFR1),A     ; store it
325D: 3AE081  	        ld      A,(SCR_MODE)    ; check screen mode
3260: FE03    	        cp      $03             ; is it multicolor mode?
3262: 200D    	        jr      NZ,CNTCKCL      ; no, continue
3264: 3E0F    	        ld      A,$0F           ; white for...
3266: 32ED81  	        ld      (FRGNDCLR),A    ; ...foreground (even it's not used in MC)
3269: 3AEF81  	        ld      A,(TMPBFR1)     ; yes, so we stop here because in MC mode we just support border color
326C: 32F381  	        ld      (TMPBFR3),A     ; move color into temp buffer 3
326F: 1834    	        jr      CLRMC           ; jump to set color
3271: CD1E18  	CNTCKCL:call    CHKSYN          ; Make sure ',' follows
3274: 2C      	        defb    ','
3275: CD3C27  	        call    GETINT          ; get second value
3278: CDFB32  	        call    CHKCLR          ; check if it's in range 1~15
327B: 32F181  	        ld      (TMPBFR2),A     ; store it
327E: 32EE81  	        ld      (BKGNDCLR),A    ; and set as background color
3281: 3AE081  	        ld      A,(SCR_MODE)    ; check screen mode
3284: A7      	        and     A               ; is it text mode?
3285: 281B    	        jr      Z,CLRTXT        ; yes, stop here because in text mode, background and border colors coincide
3287: CD1E18  	        call    CHKSYN          ; Make sure ',' follows
328A: 2C      	        defb    ','
328B: CD3C27  	        call    GETINT          ; get third value
328E: CDFB32  	        call    CHKCLR          ; check if it's in range 1~15
3291: 32F381  	        ld      (TMPBFR3),A     ; store it
3294: D5      	        push    DE              ; store DE
3295: 3AE081  	        ld      A,(SCR_MODE)    ; check screen mode
3298: FE01    	        cp      $01             ; is it G1 mode?
329A: 2810    	        jr      Z,CLRG1         ; yes, jump over
329C: FE02    	        cp      $02             ; is it G2 mode?
329E: 2815    	        jr      Z,CLRG2         ; yes, jump over
32A0: 181C    	        jr      CLREX2          ; last case can only be ExG2
32A2: CDEE32  	CLRTXT: call    MIXCLRS         ; mix foreground and background color nibbles in 1 byte
32A5: 32F381  	CLRMC:  ld      (TMPBFR3),A     ; store color settings (for MC mode, we only set border color)
32A8: D5      	        push    DE              ; store DE
32A9: F3      	        di                      ; disable INTs
32AA: 182E    	        jr      SETBRCL         ; set colors and exit
32AC: CDEE32  	CLRG1:  call    MIXCLRS         ; mix foreground and background color nibbles in 1 byte
32AF: 1601    	        ld      D,$01           ; repeat 1 time
32B1: 0620    	        ld      B,$20           ; 32 bytes of colors
32B3: 1810    	        jr      LOADCLR         ; load colors
32B5: CDEE32  	CLRG2:  call    MIXCLRS         ; mix foreground and background color nibbles in 1 byte
32B8: 1618    	        ld      D,$18           ; 18 pages of...
32BA: 0600    	        ld      B,$00           ; ...256 bytes each
32BC: 1807    	        jr      LOADCLR         ; load colors
32BE: CDEE32  	CLREX2: call    MIXCLRS         ; mix foreground and background color nibbles in 1 byte
32C1: 1608    	        ld      D,$08           ; 8 pages of...
32C3: 0600    	        ld      B,$00           ; ...256 bytes each
32C5: E5      	LOADCLR:push    HL              ; store HL
32C6: 210020  	        ld      HL,$2000        ; color table start: $2000
32C9: F3      	        di                      ; disable INTs
32CA: CDEC05  	        call    SETVDPADRS
32CD: 0E30    	        ld      C,VDP_DAT       ; VDP data mode
32CF: ED79    	RPTLDCL:out     (C),A           ; after first byte, the VDP autoincrements VRAM pointer
32D1: 00      	        nop
32D2: 00      	        nop
32D3: 10FA    	        djnz    RPTLDCL         ; repeat for 256 bytes (1 page)
32D5: 15      	        dec     D               ; did we fill up all the pages?
32D6: 20F7    	        jr      NZ,RPTLDCL      ; no, repeat
32D8: FB      	        ei
32D9: E1      	        pop     HL              ; retrieve HL
32DA: 87      	SETBRCL:add     A,A             ; move high nibble
32DB: 87      	        add     A,A             ; to right to get the
32DC: 87      	        add     A,A             ; foreground color
32DD: 87      	        add     A,A             ; into the low nibble
32DE: 32ED81  	        ld      (FRGNDCLR),A    ; store foreground color
32E1: 3AF381  	        ld      A,(TMPBFR3)     ; recover border color
32E4: 5F      	        ld      E,A             ; move A into E
32E5: 3E07    	        ld      A,$07           ; VDP register 7
32E7: F3      	        di
32E8: CD3606  	        call    WRITE_VREG      ; send value to VDP: set border color
32EB: FB      	        ei                      ; re-enable INTs
32EC: D1      	        pop     DE              ; retrieve DE
32ED: C9      	        ret                     ; return to caller
              	
              	
              	; mix 2 color nibbles in 1 byte
32EE: 3AF181  	MIXCLRS:ld      A,(TMPBFR2)     ; retrieve background color
32F1: 47      	        ld      B,A             ; move it into B
32F2: 3AEF81  	        ld      A,(TMPBFR1)     ; retrieve foreground color
32F5: 87      	        add     A,A             ; move foreground color into the high nibble of A
32F6: 87      	        add     A,A
32F7: 87      	        add     A,A
32F8: 87      	        add     A,A
32F9: B0      	        or      B               ; put background color into the low nibble of A
32FA: C9      	        ret                     ; return to caller
              	
              	
              	; check if the color is not 0 and into the range 1~15
32FB: A7      	CHKCLR: and     A               ; is it 0?
32FC: CA3C15  	        jp      Z,SNERR         ; yes, raise a SN error
32FF: FE10    	        cp      $10             ; is it in range 1~15?
3301: D23C15  	        jp      NC,SNERR        ; no, raise a SN error
3304: C9      	        ret                     ; param is OK, can return
              	
              	
              	; check if in graphics 2 mode
3305: 3AE081  	CHKG2M: ld      A,(SCR_MODE)    ; check screen mode
3308: FE02    	        cp      $02             ; actually, we can paint only in G2
330A: C2E337  	        jp      NZ,GMERR        ; no G2, print a No Graphics Mode Error
330D: C9      	        ret                     ; return to caller
              	
              	
              	; print a text in screen 2
              	; GPRINT text,x,y[,fc[,bc]]
              	; where "text" is an expression that can be converted into a sequence of ASCII chars,
              	; x & y are the coordinates (0<=x<=32, 0<=y<=23), fc & bc are foreground and background
              	; colors (1~15), resp.
              	; (portions of code are from nippur72)
81F3:         	GX      equ     TMPBFR3
81F5:         	GY      equ     TMPBFR4
81F1:         	TMPCLR  equ     TMPBFR2
81EF:         	MIXCOL  equ     TMPBFR1
81F9:         	CHRPNT  equ     VIDEOBUFF+$02
81FB:         	NUMCHR  equ     VIDEOBUFF+$04
81FD:         	TMPHL   equ     VIDEOBUFF+$06
330E: CD0533  	GPRINT: call    CHKG2M          ; check if in graphic mode 2
3311: 2B      	        dec     HL              ; dec 'cos GETCHR INCs
3312: CD411A  	        call    GETCHR          ; check if something follows
3315: CA3C15  	        jp      Z,SNERR         ; if nothing else, raise a syntax error
3318: 22F781  	        ld      (VIDEOBUFF),HL  ; save current code string pointer
331B: CDC81E  	        call    EVAL            ; Evaluate expression
331E: CDBA1E  	        call    TSTSTR          ; Make sure it's a string
3321: 22FD81  	        ld      (TMPHL),HL
3324: CD0125  	        call    GSTRCU          ; Current string to pool
3327: CD132D  	        call    LOADFP          ; Move string block to BCDE (BC=pointer, E=length)
332A: ED43F981	        ld      (CHRPNT),BC     ; store string pointer
332E: ED53FB81	        ld      (NUMCHR),DE     ; store string lenght
3332: 2AFD81  	        ld      HL,(TMPHL)
3335: CD1E18  	        call    CHKSYN          ; Make sure ',' follows
3338: 2C      	        defb    ','
3339: CD3C27  	        call    GETINT          ; get X coord.
333C: FE20    	        cp      $20             ; is it in rage 0~31?
333E: D20C1B  	        jp      NC,FCERR        ; Illegal function call error
3341: 32F381  	        ld      (GX),A          ; store into temp. buffer
3344: CD1E18  	        call    CHKSYN          ; Make sure ',' follows
3347: 2C      	        defb    ','
3348: CD3C27  	        call    GETINT          ; get Y coord.
334B: FE18    	        cp      $18             ; is it in range 0~23?
334D: D20C1B  	        jp      NC,FCERR        ; Illegal function call error
3350: 32F581  	        ld      (GY),A          ; store into temp. buffer
3353: 11F181  	        ld      DE,TMPCLR
3356: 3AEE81  	        ld      A,(BKGNDCLR)    ; load background color
3359: 12      	        ld      (DE),A          ; store into temp buff
335A: 3AED81  	        ld      A,(FRGNDCLR)    ; load foreground color
335D: 1B      	        dec     DE
335E: 1B      	        dec     DE
335F: 12      	        ld      (DE),A          ; store into temp buff
3360: CDEC33  	        call    CKCOL           ; check color
3363: CA6B33  	        jp      Z,CNTGPT2       ; if anything follows, jump over
3366: 13      	        inc     DE
3367: 13      	        inc     DE
3368: CDEC33  	        call    CKCOL           ; check background color
336B: CDEE32  	CNTGPT2:call    MIXCLRS         ; mix foreground & background colors
336E: 32EF81  	        ld      (MIXCOL),A      ; store mixed colors
3371: E5      	        push    HL              ; store code string address
3372: ED4BF981	        ld      BC,(CHRPNT)     ; retrieve string pointer
3376: ED5BFB81	        ld      DE,(NUMCHR)     ; retrieve string lenght
337A: 1C      	        inc     E               ; Length + 1
337B: CD8033  	        call    GPNT            ; print on G2
337E: E1      	        pop     HL              ; recover HL
337F: C9      	        ret                     ; return to caller
3380: D5      	GPNT:   push    DE              ; store string lenght (E)
              	        ; calculate VRAM address of first char
3381: 3AF381  	        LD      A,(GX)          ; load X
3384: 6F      	        ld      L,A             ;
3385: 2600    	        ld      H,0             ; HL = X
3387: 29      	        add     HL,HL           ;
3388: 29      	        add     HL,HL           ;
3389: 29      	        add     HL,HL           ; HL = X*8
338A: 3AF581  	        ld      A,(GY)          ; load Y
338D: 57      	        ld      D,A             ;
338E: 1E00    	        ld      E,0             ; DE = Y * 256
3390: 19      	        add     HL,DE           ; address = X*8 + Y*256
3391: 22F781  	        ld      (VIDEOBUFF),HL  ; store VRAM address of first VRAM cell
3394: D1      	        pop     DE              ; retrieve # of chars to be printed yet (E)
3395: 1D      	RPGPNT: dec     E               ; Count characters
3396: C8      	        ret     Z               ; End of string - return
3397: D5      	        push    DE              ; store chars counter
              	        ; calculate dest address in color vram
3398: 2AF781  	        ld      HL,(VIDEOBUFF)  ; recover VRAM address 
339B: 110020  	        ld      DE,$2000        ; color map address
339E: 19      	        add     HL,DE           ; HL = $2000 + XY address
339F: F3      	        di                      ; disable INTs
              	        ; send color settings
33A0: CDEC05  	GPNTCOL:call    SETVDPADRS      ; set VRAM address for color cell
33A3: 3AEF81  	        ld      A,(MIXCOL)      ; load color settings
33A6: 0608    	        ld      B,$08           ; repeat for 8 rows
33A8: 0E30    	        ld      C,VDP_DAT       ; VDP data mode
33AA: ED79    	GPNTCO1:out     (C),A           ; send data (VRAM pointer auto-increments)
33AC: 00      	        nop                     ; wait...
33AD: 00      	        nop                     ; ...a...
33AE: 00      	        nop                     ; ...while
33AF: 10F9    	        djnz    GPNTCO1         ; repeat for 8 cells
              	        ; calculate source address
33B1: 2AF981  	        ld      HL,(CHRPNT)     ; load char pointer
33B4: 7E      	        ld      A,(HL)          ; get char
33B5: 23      	        inc     HL              ; increment char pointer
33B6: 22F981  	        ld      (CHRPNT),HL     ; store char pointer
33B9: 6F      	        ld      L,A             ;
33BA: 2600    	        ld      H,0             ; char into HL
33BC: 29      	        add     HL,HL           ;
33BD: 29      	        add     HL,HL           ;
33BE: 29      	        add     HL,HL           ; get offset of char into ROM (charcode * 8)
33BF: 11AD44  	        ld      DE,CHRST88      ; DE = start of 8x8 fonts in ROM
33C2: 19      	        add     HL,DE           ; HL = start of characters in ROM
33C3: EB      	        ex      DE,HL           ; store address into DE
33C4: 2AF781  	GPCPCHR:ld      HL,(VIDEOBUFF)  ; load VRAM address
33C7: CDEC05  	        call    SETVDPADRS      ; send it to VDP
33CA: EB      	        ex      DE,HL           ; restore address into HL
33CB: 0608    	        ld      B,$08           ; repeat for 8 rows
33CD: 0E30    	        ld      C,VDP_DAT       ; VDP data mode
33CF: EDA3    	GPCPCH1:outi                    ; load a byte from ROM and send to VRAM
33D1: 00      	        nop                     ; wait...
33D2: 00      	        nop                     ; ...a...
33D3: 00      	        nop                     ; ...while
33D4: 20F9    	        jr      NZ,GPCPCH1      ; repeat for 8 chars
33D6: FB      	        ei                      ; re-enable INTs
33D7: 110800  	        ld      DE,$0008        ; 8 bytes to go to the next video ell
33DA: 2AF781  	        ld      HL,(VIDEOBUFF)  ; load VRAM address
33DD: 19      	        add     HL,DE           ; get address of next VRAM cell
33DE: 22F781  	        ld      (VIDEOBUFF),HL  ; store new VRAM address
33E1: 110018  	        ld      DE,$1800        ; forbidden address
33E4: CD5F3C  	        call    CMP16           ; check if the printing has gone out of the screen
33E7: D1      	        pop     DE              ; retrieve number of chars to be printed
33E8: D0      	        ret     NC              ; if HL>=$1800 then leave
33E9: C39533  	        jp      RPGPNT          ; otherwise, check if more chars to output
              	        
33EC: 2B      	CKCOL:  dec     HL              ; dec 'cos GETCHR INCs
33ED: CD411A  	        call    GETCHR          ; Get next character
33F0: C8      	        ret     Z               ; return if nothing follows
33F1: CD1E18  	        call    CHKSYN          ; Make sure ',' follows
33F4: 2C      	        defb    ','
33F5: D5      	        push    DE              ; store DE
33F6: CD3C27  	        call    GETINT          ; get value
33F9: CDFB32  	        call    CHKCLR          ; check if color is in range 1~15
33FC: D1      	        pop     DE              ; retrieve DE
33FD: 12      	        ld      (DE),A          ; store color into temp buffer
33FE: C9      	        ret                     ; return to caller
              	        
              	; POINT(x,y): return if a pixel is set (1) or reset (0)
33FF: CD0533  	POINT:  call    CHKG2M          ; check if in graphic mode 2
3402: CD1E18  	        call    CHKSYN          ; make sure "(" follows
3405: 28      	        defb    '('
3406: CD3C27  	        call    GETINT          ; get X coords.
3409: 32EF81  	        ld      (TMPBFR1),A     ; store it into a temp buffer
340C: CD1E18  	        call    CHKSYN          ; Make sure ',' follows
340F: 2C      	        defb    ','
3410: CD3C27  	        call    GETINT          ; get Y coords,
3413: FEC0    	        cp      $C0             ; check if Y is in range 0~191
3415: D20C1B  	        jp      NC,FCERR        ; no, raise an FC error
3418: 32F181  	        ld      (TMPBFR2),A     ; store into a temp buffer
341B: CD1E18  	        call    CHKSYN          ; make sure ")" follows
341E: 29      	        defb    ')'
341F: E5      	        push    HL              ; store current string address - the point after the ")" - ...
3420: FDE1    	        pop     IY              ; ...into IY
3422: CD9134  	        call    XY2HL           ; find HL address of pixel at X,Y
3425: 57      	        ld      D,A             ; store pixel index
3426: F3      	        di                      ; disable INTs
3427: CD0C06  	        call    READ_VIDEO_LOC  ; read contents of VRAM cell addressed by HL
342A: FB      	        ei                      ; re-enable INTs
342B: A2      	        and     D               ; is the pixel ON or OFF? (will be checked later)
342C: E1      	        pop     HL              ; drop original return point
342D: FDE5    	        push    IY              ; load current string address from IY into stack
342F: 11A11F  	        ld      DE,RETNUM       ; Address of Return number from function...
3432: D5      	        push    DE              ; ...saved on stack
3433: 3E00    	        LD      A,$00           ; A=0 (reset A w/o altering flags)
3435: 47      	        LD      B,A             ; and B=0, so integer AB = 0
3436: CAA022  	        jp      Z,ABPASS        ; if pixel is off, return AB=0
3439: 04      	        inc     B               ; otherwise, return AB=1
343A: C3A022  	PNTEND: jp      ABPASS          ; return AB
              	
              	
              	; PLOT X,Y[,color]
              	; plot a pixel in graphic mode 2
343D: CD0533  	PLOT:   call    CHKG2M          ; check if in G2 mode
3440: CD3C27  	        call    GETINT          ; get X coords.
3443: 32EF81  	        ld      (TMPBFR1),A     ; store it into a temp buffer
3446: CD1E18  	        call    CHKSYN          ; Make sure ',' follows
3449: 2C      	        defb    ','
344A: CD3C27  	        call    GETINT          ; get Y coords,
344D: FEC0    	        cp      $C0             ; check if Y is in range 0~191
344F: D20C1B  	        jp      NC,FCERR        ; no, raise an FC error
3452: 32F181  	        ld      (TMPBFR2),A     ; store into a temp buffer
3455: CDCA37  	        call    CLRPRM          ; check if param "color" has been passed
3458: E5      	CNTPLOT:push    HL              ; store HL
3459: C5      	        push    BC              ; store BC
345A: D5      	        push    DE              ; store DE
345B: CD9134  	        call    XY2HL           ; find VRAM address of byte containing pixel at X,Y & return into HL
345E: D28534  	        jp      NC,NOGD         ; if carry is reset, there was an error -> so leave
3461: 57      	        ld      D,A             ; move pixel value into D
3462: 3AF381  	        ld      A,(TMPBFR3)     ; retrieve color
3465: 87      	        add     A,A             ; now we move low nibble
3466: 87      	        add     A,A             ; in the high nibble
3467: 87      	        add     A,A             ; by adding A to itself
3468: 87      	        add     A,A             ; 4 times (this is a shift left 4)
3469: 5F      	        ld      E,A             ; move it into E
346A: F3      	        di                      ; disable INTs
346B: CD0C06  	        call    READ_VIDEO_LOC  ; load original value of VRAM cell pointed by HL
346E: FB      	        ei
346F: B2      	        or      D               ; plot new pixel preserving original pattern
3470: F3      	        di
3471: CD2106  	        call    WRITE_VIDEO_LOC ; write new value into VRAM cell
3474: FB      	        ei
3475: CBEC    	        set     5,H             ; set to write into color VRAM (it's like adding $2000 to HL)
3477: F3      	        di
3478: CD0C06  	        call    READ_VIDEO_LOC  ; load original colors of pixel
347B: FB      	        ei
347C: E60F    	        and     %00001111       ; reset high nibble (the foreground color)
347E: B3      	        or      E               ; set new foreground color
347F: F3      	        di
3480: CD2106  	        call    WRITE_VIDEO_LOC ; write new color settings
3483: FB      	        ei                      ; re-enable INTs
3484: 00      	        nop                     ; wait for INTs to be enabled again
3485: D1      	NOGD:   pop     DE              ; retrieve DE
3486: C1      	        pop     BC              ; retrieve BC
3487: E1      	        pop     HL              ; retrieve HL
3488: C9      	        ret                     ; return to caller
3489: 80402010	PXLSET: defb    $80,$40,$20,$10,$08,$04,$02,$01 ; pixel to be set ON
348D: 08040201	
              	        ; where R(X/8)=> 0=80h, 1=40h, 2=20h, 3=10h, 4=08h, 5=04h, 6=02h, 7=$01
              	
              	
              	; compute the VRAM address of the byte containing the pixel
              	; being pointed by X,Y (TMPBFR1,TMPBFR1)
              	; byte address is returned into HL
              	; pixel is returned into A
3491:         	XY2HL:  ; formula is: ADDRESS=(INT(X/8))*8 + (INT(Y/8))*256 + R(Y/8)
              	        ; where R(Y/8) is the remainder of (Y/8)
              	        ; the pixel to be set is given by R(X/8), and data is taken from the array
3491: 3AF181  	        ld      A,(TMPBFR2)     ; retrieve Y
3494: FEC0    	        cp      $C0             ; Y>=192?
3496: D0      	        ret     NC              ; yes, so leave
3497: 1E08    	        ld      E,$08           ; load E with divisor
3499: 57      	        ld      D,A             ; and store into D (dividend)
349A: CD8E3C  	        call    DIV_8_8         ; get Y/8, D is quotient=INT(Y/8), and A is remainder
349D: 4F      	        ld      C,A             ; store remainder into C
349E: 42      	        ld      B,D             ; B=(INT(Y/8))*256 (we simply copy quotient into B)
349F: 6069    	        ld      HL,BC           ; copy BC into HL: now HL has the VRAM address of the byte being set
34A1: 3AEF81  	        ld      A,(TMPBFR1)     ; retrieve X
34A4: 57      	        ld      D,A             ; and move it into D (dividend)
34A5: CD8E3C  	        call    DIV_8_8         ; get X/8, D is quotient=INT(X/8), and A is remainder
34A8: 4F      	        ld      C,A             ; store remainder into C
34A9: 7A      	        ld      A,D             ; move quotient into A
34AA: 87      	        add     A,A
34AB: 87      	        add     A,A
34AC: 87      	        add     A,A             ; multiply quotient by 8
34AD: 5F      	        ld      E,A             ; store result into E
34AE: 1600    	        ld      D,$00           ; reset D
34B0: 19      	        add     HL,DE           ; add DE to HL, getting the final VRAM address
34B1: EB      	        ex      DE,HL           ; move VRAM address into DE
34B2: 218934  	        ld      HL,PXLSET       ; starting address of table for pixel to draw
34B5: 0600    	        ld      B,$00           ; reset B
34B7: 09      	        add     HL,BC           ; add C (remainder of X/8) to get address of pixel to turn on
34B8: 7E      	        ld      A,(HL)          ; load pixel data
34B9: EB      	        ex      DE,HL           ; retrieve VRAM pattern address into HL
34BA: 37      	        scf                     ; set Carry for normal exit
34BB: C9      	        ret                     ; return to caller
              	
              	
              	; DRAW X1,Y1,X2,Y2[,color]
              	; Draw a line using Bresenham's line algorithm from X1,Y1 to X2,Y2
              	; X1,Y1 can be either less than or greater than X2,Y2 (meaning that)
              	; the drawing will be ever done from X1,Y2 to X2,Y2, regardless of
              	; the values. If color is not specified, the foreground color set
              	; with COLOR will be used 
81EF:         	X1      equ     TMPBFR1
81F1:         	Y1      equ     TMPBFR2
81F7:         	X2      equ     VIDEOBUFF
81F9:         	Y2      equ     VIDEOBUFF+$02
81FB:         	ER      equ     VIDEOBUFF+$04
81FD:         	E2      equ     VIDEOBUFF+$06
81FF:         	SX      equ     VIDEOBUFF+$08
8201:         	SY      equ     VIDEOBUFF+$0A
8203:         	DX      equ     VIDEOBUFF+$0C
8205:         	DY      equ     VIDEOBUFF+$0E
34BC: CD0533  	DRAW:   call    CHKG2M          ; check if in G2 mode
34BF: CDB237  	        call    CLRVDBF         ; clear VIDEOBUFF
34C2: CD3C27  	        call    GETINT          ; get X1 coords.
34C5: 32EF81  	        ld      (X1),A          ; store it into a temp buffer
34C8: CD1E18  	        call    CHKSYN          ; Make sure ',' follows
34CB: 2C      	        defb    ','
34CC: CD3C27  	        call    GETINT          ; get Y1 coords.
34CF: FEC0    	        cp      $C0             ; check if Y1 is in range 0~191
34D1: D20C1B  	        jp      NC,FCERR        ; no, raise an FC error
34D4: 32F181  	        ld      (Y1),A          ; store into a temp buffer
34D7: CD1E18  	        call    CHKSYN          ; Make sure ',' follows
34DA: 2C      	        defb    ','
34DB: CD3C27  	        call    GETINT          ; get X2 coords.
34DE: 32F781  	        ld      (X2),A          ; store it into a temp buffer
34E1: CD1E18  	        call    CHKSYN          ; Make sure ',' follows
34E4: 2C      	        defb    ','
34E5: CD3C27  	        call    GETINT          ; get Y2 coords
34E8: FEC0    	        cp      $C0             ; check if Y2 is in range 0~191
34EA: D20C1B  	        jp      NC,FCERR        ; no, raise an FC error
34ED: 32F981  	        ld      (Y2),A          ; store it into a temp buffer
34F0: CDCA37  	        call    CLRPRM          ; check for arg. "color" and store it into TMPBFR3
34F3: E5      	        push    HL              ; store register we'll use
34F4: D5      	        push    DE              
34F5: C5      	        push    BC
34F6: ED5BEF81	        ld      DE,(X1)         ; load X1 and
34FA: 2AF781  	        ld      HL,(X2)         ; X2
34FD: B7      	        or      A               ; clear CARRY
34FE: ED52    	        sbc     HL,DE           ; DX=X2-X1
3500: CD843C  	        call    absHL           ; DX=ABS(DX)
3503: 220382  	        ld      (DX),HL         ; store DX
3506: 01FFFF  	        ld      BC,$FFFF        ; SX=-1
3509: 2AEF81  	        ld      HL,(X1)
350C: ED5BF781	        ld      DE,(X2)
3510: CD5F3C  	        call    CMP16           ; X1<X2?
3513: F21935  	        jp      P,X1GR          ; no, X1>=X2
3516: 010100  	        ld      BC,$0001        ; yes, so set SX=1
3519: ED43FF81	X1GR:   ld      (SX),BC         ; store SX
351D: ED5BF181	        ld      DE,(Y1)
3521: 2AF981  	        ld      HL,(Y2)
3524: B7      	        or      A               ; clear Carry
3525: ED52    	        sbc     HL,DE           ; DY=Y2-Y1
3527: CD843C  	        call    absHL           ; DY=ABS(DY)
352A: 220582  	        ld      (DY),HL         ; store DY
352D: 01FFFF  	        ld      BC,$FFFF        ; SY=-1
3530: 2AF181  	        ld      HL,(Y1)
3533: ED5BF981	        ld      DE,(Y2)
3537: CD5F3C  	        call    CMP16           ; is Y1<Y2?
353A: F24035  	        jp      P,Y1GR          ; no, Y1>=Y2
353D: 010100  	        ld      BC,$0001        ; yes, so set SY=1
3540: ED430182	Y1GR:   ld      (SY),BC         ; store SY
3544: 2A0582  	        ld      HL,(DY)         ; ER=DY
3547: CD873C  	        call    negHL           ; ER=-DY
354A: 22FB81  	        ld      (ER),HL         ; store ER
354D: 2A0382  	        ld      HL,(DX)
3550: ED5B0582	        ld      DE,(DY)
3554: CD5F3C  	        call    CMP16           ; DX>DY?
3557: CA6335  	        jp      Z,ER2           ; no, DX=DY
355A: FA6335  	        jp      M,ER2           ; no, DX<DY
355D: 2A0382  	        ld      HL,(DX)         ; reload DX
3560: 22FB81  	        ld      (ER),HL         ; yes: DX>DY, so ER=DX
3563: 2AFB81  	ER2:    ld      HL,(ER)         ; load ER
3566: CB2C    	        sra     H               ; right shift (and preserve sign)...
3568: CB1D    	        rr      L               ; ...of HL, so ER=INT(ER/2)
356A: 22FB81  	STRE2:  ld      (ER),HL         ; store ER
356D: CD5834  	RPTDRW: call    CNTPLOT         ; plot first pixel
3570: 2AEF81  	        ld      HL,(X1)
3573: ED5BF781	        ld      DE,(X2)
3577: CD5F3C  	        call    CMP16           ; X1=X2?
357A: 200D    	        jr      NZ,CNTDRW       ; no, continue drawing
357C: 2AF181  	        ld      HL,(Y1)         ; yes, so check
357F: ED5BF981	        ld      DE,(Y2)         ; also Y
3583: CD5F3C  	        call    CMP16           ; Y1=Y2?
3586: CADF35  	        jp      Z,ENDDRAW       ; yes, finished drawing: exit
3589: ED5BFB81	CNTDRW: ld      DE,(ER)
358D: ED53FD81	        ld      (E2),DE         ; E2=ER
3591: 2A0382  	        ld      HL,(DX)
3594: CD873C  	        call    negHL           ; DX=-DX
3597: EB      	        ex      DE,HL           ; invert DE and HL => HL=E2, DE=-DX
3598: CD5F3C  	        call    CMP16           ; E2>-DX?
359B: CAB935  	        jp      Z,DXGR          ; no, E2=-DX: jump
359E: FAB935  	        jp      M,DXGR          ; no, E2<-DX: jump
35A1: 2AFB81  	        ld      HL,(ER)         ; yes
35A4: ED5B0582	        ld      DE,(DY)
35A8: B7      	        or      A               ; clear CARRY
35A9: ED52    	        sbc     HL,DE           ; ER=ER-DY
35AB: 22FB81  	        ld      (ER),HL
35AE: 2AEF81  	        ld      HL,(X1)
35B1: ED5BFF81	        ld      DE,(SX)
35B5: 19      	        add     HL,DE           ; X1=X1+SX (increment X1)
35B6: 22EF81  	        ld      (X1),HL
35B9: 2AFD81  	DXGR:   ld      HL,(E2)
35BC: ED5B0582	        ld      DE,(DY)
35C0: CD5F3C  	        call    CMP16           ; E2<DY?
35C3: F26D35  	        jp      P,RPTDRW        ; no, E2>=DY: so jump over
35C6: 2AFB81  	        ld      HL,(ER)         ; yes
35C9: ED5B0382	        ld      DE,(DX)
35CD: 19      	        add     HL,DE           ; ER=ER+DX
35CE: 22FB81  	        ld      (ER),HL
35D1: 2AF181  	        ld      HL,(Y1)
35D4: ED5B0182	        ld      DE,(SY)
35D8: 19      	        add     HL,DE           ; Y1=Y1+SY (increment Y1)
35D9: 22F181  	        ld      (Y1),HL
35DC: C36D35  	        jp      RPTDRW          ; repeat
35DF: C1      	ENDDRAW:pop     BC              ; retrieve BC
35E0: D1      	        pop     DE              ; retrieve DE
35E1: E1      	        pop     HL              ; retrieve HL
35E2: C9      	        ret                     ; return to caller
              	
              	
              	; CIRCLE X,Y,R[,C]
              	; Draw a circle using Bresenham's circle algorithm with center in X,Y
              	; and radius R, with optional color C. If color is not specified, the
              	; foreground color set with COLOR will be used 
81F7:         	XC      equ     VIDEOBUFF
81F9:         	YC      equ     VIDEOBUFF+$02
81FB:         	RADIUS  equ     VIDEOBUFF+$04
81FD:         	XI      equ     VIDEOBUFF+$06
81FF:         	YI      equ     VIDEOBUFF+$08
8201:         	DC      equ     VIDEOBUFF+$0A
35E3: CD0533  	CIRCLE: call    CHKG2M          ; check if in G2 mode
35E6: CDB237  	        call    CLRVDBF         ; clear VIDEOBUFF
35E9: CD3C27  	        call    GETINT          ; get X coords.
35EC: 32F781  	        ld      (XC),A          ; store it into a temp buffer
35EF: CD1E18  	        call    CHKSYN          ; Make sure ',' follows
35F2: 2C      	        defb    ','
35F3: CD3C27  	        call    GETINT          ; get Y coords,
35F6: 32F981  	        ld      (YC),A          ; store it into a temp buffer
35F9: CD1E18  	        call    CHKSYN          ; Make sure ',' follows
35FC: 2C      	        defb    ','
35FD: CD3C27  	        call    GETINT          ; get radius
3600: 32FB81  	        ld      (RADIUS),A      ; store it into a temp buffer
3603: CDCA37  	        call    CLRPRM          ; check if param "color" has been passed
3606: C5      	        push    BC              ; store BC
3607: D5      	        push    DE              ; store DE
3608: E5      	        push    HL              ; store HL
3609: AF      	        xor     A               ; clear A,
360A: 47      	        ld      B,A             ; B,
360B: 4F      	        ld      C,A             ; C,
360C: 57      	        ld      D,A             ; D,
360D: 67      	        ld      H,A             ; and H
360E: ED43FD81	        ld      (XI),BC         ; clear XI
3612: 3AFB81  	        ld      A,(RADIUS)      ; load RADIUS into A
3615: 6F      	        ld      L,A             ; HL now contains R
3616: 22FF81  	        ld      (YI),HL         ; YI=RADIUS
3619: 29      	        add     HL,HL           ; R*2
361A: EB      	        ex      DE,HL           ; put HL into DE
361B: 210300  	        ld      HL,$0003        ; now HL is 3
361E: AF      	        xor     A               ; clear Carry
361F: ED52    	        sbc     HL,DE           ; HL=>D=3-(2*R)
3621: 220182  	        ld      (DC),HL         ; store D
3624: CD8336  	        call    DRWCRL          ; draw initial point
3627: ED5BFD81	RPTCRL: ld      DE,(XI)         ; load XI
362B: 2AFF81  	        ld      HL,(YI)         ; load YI
362E: CD5F3C  	        call    CMP16           ; is YI<DI?
3631: CA3A36  	        jp      Z,RPTCL1        ; no, YI=XI
3634: F23A36  	        jp      P,RPTCL1        ; no, YI>XI
3637: C37F36  	        jp      ENDCRL          ; yes, so we've finished
363A: 21FD81  	RPTCL1: ld      HL,XI
363D: 34      	        inc     (HL)            ; XI=XI+1
363E: 2A0182  	        ld      HL,(DC)         ; load D
3641: 7C      	        ld      A,H
3642: B5      	        or      L               ; is D=0? Yes, jump over
3643: CA6736  	        jp      Z,DLSZ
3646: CB7C    	        bit     7,H             ; is D<0?
3648: 201D    	        jr      NZ,DLSZ         ; yes, jump over
364A: ED5BFF81	        ld      DE,(YI)         ; D>0
364E: 1B      	        dec     DE              ; so, YI=YI-1
364F: ED53FF81	        ld      (YI),DE         ; store YI
3653: AF      	        xor     A               ; clear Carry
3654: 2AFD81  	        ld      HL,(XI)
3657: ED52    	        sbc     HL,DE           ; HL=XI-YI
3659: 29      	        add     HL,HL
365A: 29      	        add     HL,HL           ; HL=HL*4
365B: 110A00  	        ld      DE,10
365E: 19      	        add     HL,DE           ; HL=HL+10
365F: ED5B0182	        ld      DE,(DC)         ; load D
3663: EB      	        ex      DE,HL           ; invert DE and HL, so that HL=4*(XI-YI)+10 and DE=D
3664: 19      	        add     HL,DE           ; D=D+4*(XI-YI)+10
3665: 180F    	        jr      PLTCRL          ; plot next pixel
3667: 2AFD81  	DLSZ:   ld      HL,(XI)         ; load XI
366A: 29      	        add     HL,HL
366B: 29      	        add     HL,HL           ; XI=XI*4
366C: 110600  	        ld      DE,$0006
366F: 19      	        add     HL,DE
3670: ED5B0182	        ld      DE,(DC)
3674: EB      	        ex      DE,HL           ; HL=D and DE=4*XI+6
3675: 19      	        add     HL,DE           ; D=D+4*XI+6
3676: 220182  	PLTCRL: ld      (DC),HL         ; store new D
3679: CD8336  	        call    DRWCRL          ; plot pixel
367C: C32736  	        jp      RPTCRL          ; repeat
367F: E1      	ENDCRL: pop     HL
3680: D1      	        pop     DE
3681: C1      	        pop     BC
3682: C9      	        ret                     ; return to caller
3683: 2AF781  	DRWCRL: ld      HL,(XC)
3686: ED5BFD81	        ld      DE,(XI)
368A: 19      	        add     HL,DE           ; X=XC+XI
368B: 22EF81  	        ld      (X1),HL         ; store X
368E: CDA237  	        call    VALIDX          ; check if X is valid (0~255)
3691: DAA536  	        jp      C,CNTCL1        ; if Carry is set, X is not valid
3694: 2AF981  	        ld      HL,(YC)
3697: ED5BFF81	        ld      DE,(YI)
369B: 19      	        add     HL,DE           ; Y=YC+YI
369C: 22F181  	        ld      (Y1),HL         ; store Y
369F: CDA737  	        call    VALIDY          ; check if Y is valid (0~191)
36A2: D45834  	        call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
36A5: AF      	CNTCL1: xor     A               ; clear Carry
36A6: 2AF781  	        ld      HL,(XC)
36A9: ED5BFD81	        ld      DE,(XI)
36AD: ED52    	        sbc     HL,DE           ; X=XC-XI
36AF: 22EF81  	        ld      (X1),HL         ; store X
36B2: CDA237  	        call    VALIDX          ; check if X is valid (0~255)
36B5: DAC936  	        jp      C,CNTCL2        ; if Carry is set, X is not valid
36B8: 2AF981  	        ld      HL,(YC)
36BB: ED5BFF81	        ld      DE,(YI)
36BF: 19      	        add     HL,DE           ; Y=YC+YI
36C0: 22F181  	        ld      (Y1),HL         ; store Y
36C3: CDA737  	        call    VALIDY          ; check if Y is valid (0~191)
36C6: D45834  	        call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
36C9: 2AF781  	CNTCL2: ld      HL,(XC)
36CC: ED5BFD81	        ld      DE,(XI)
36D0: 19      	        add     HL,DE           ; X=XC+XI
36D1: 22EF81  	        ld      (X1),HL         ; store X
36D4: CDA237  	        call    VALIDX          ; check if X is valid (0~255)
36D7: DAED36  	        jp      C,CNTCL3        ; if Carry is set, X is not valid
36DA: AF      	        xor     A               ; clear Carry
36DB: 2AF981  	        ld      HL,(YC)
36DE: ED5BFF81	        ld      DE,(YI)
36E2: ED52    	        sbc     HL,DE           ; Y=YC-YI
36E4: 22F181  	        ld      (Y1),HL         ; store Y
36E7: CDA737  	        call    VALIDY          ; check if Y is valid (0~191)
36EA: D45834  	        call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
36ED: AF      	CNTCL3: xor     A               ; clear Carry
36EE: 2AF781  	        ld      HL,(XC)
36F1: ED5BFD81	        ld      DE,(XI)
36F5: ED52    	        sbc     HL,DE           ; X=XC-XI
36F7: 22EF81  	        ld      (X1),HL         ; store X
36FA: CDA237  	        call    VALIDX          ; check if X is valid (0~255)
36FD: DA1337  	        jp      C,CNTCL4        ; if Carry is set, X is not valid
3700: AF      	        xor     A               ; clear Carry
3701: 2AF981  	        ld      HL,(YC)
3704: ED5BFF81	        ld      DE,(YI)
3708: ED52    	        sbc     HL,DE           ; Y=YC-YI
370A: 22F181  	        ld      (Y1),HL         ; store Y
370D: CDA737  	        call    VALIDY          ; check if Y is valid (0~191)
3710: D45834  	        call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
3713: 2AF781  	CNTCL4: ld      HL,(XC)
3716: ED5BFF81	        ld      DE,(YI)
371A: 19      	        add     HL,DE           ; X=XC+YI
371B: 22EF81  	        ld      (X1),HL         ; store X
371E: CDA237  	        call    VALIDX          ; check if X is valid (0~255)
3721: DA3537  	        jp      C,CNTCL5        ; if Carry is set, X is not valid
3724: 2AF981  	        ld      HL,(YC)
3727: ED5BFD81	        ld      DE,(XI)
372B: 19      	        add     HL,DE           ; Y=YC+XI
372C: 22F181  	        ld      (Y1),HL         ; store Y
372F: CDA737  	        call    VALIDY          ; check if Y is valid (0~191)
3732: D45834  	        call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
3735: AF      	CNTCL5: xor     A               ; clear Carry
3736: 2AF781  	        ld      HL,(XC)
3739: ED5BFF81	        ld      DE,(YI)
373D: ED52    	        sbc     HL,DE           ; X=XC-YI
373F: 22EF81  	        ld      (X1),HL         ; store X
3742: CDA237  	        call    VALIDX          ; check if X is valid (0~255)
3745: DA5937  	        jp      C,CNTCL6        ; if Carry is set, X is not valid
3748: 2AF981  	        ld      HL,(YC)
374B: ED5BFD81	        ld      DE,(XI)
374F: 19      	        add     HL,DE           ; Y=YC+XI
3750: 22F181  	        ld      (Y1),HL         ; store Y
3753: CDA737  	        call    VALIDY          ; check if Y is valid (0~191)
3756: D45834  	        call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
3759: 2AF781  	CNTCL6: ld      HL,(XC)
375C: ED5BFF81	        ld      DE,(YI)
3760: 19      	        add     HL,DE           ; X=XC+YI
3761: 22EF81  	        ld      (X1),HL         ; store X
3764: CDA237  	        call    VALIDX          ; check if X is valid (0~255)
3767: DA7D37  	        jp      C,CNTCL7        ; if Carry is set, X is not valid
376A: AF      	        xor     A               ; clear Carry
376B: 2AF981  	        ld      HL,(YC)
376E: ED5BFD81	        ld      DE,(XI)
3772: ED52    	        sbc     HL,DE           ; Y=YC-XI
3774: 22F181  	        ld      (Y1),HL         ; store Y
3777: CDA737  	        call    VALIDY          ; check if Y is valid (0~191)
377A: D45834  	        call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
377D: AF      	CNTCL7: xor     A               ; clear Carry
377E: 2AF781  	        ld      HL,(XC)
3781: ED5BFF81	        ld      DE,(YI)
3785: ED52    	        sbc     HL,DE           ; X=XC-YI
3787: 22EF81  	        ld      (X1),HL         ; store X
378A: CDA237  	        call    VALIDX          ; check if X is valid (0~255)
378D: D8      	        ret     C               ; if Carry is set, X is not valid
378E: AF      	        xor     A               ; clear Carry
378F: 2AF981  	        ld      HL,(YC)
3792: ED5BFD81	        ld      DE,(XI)
3796: ED52    	        sbc     HL,DE           ; Y=YC-XI
3798: 22F181  	        ld      (Y1),HL         ; store Y
379B: CDA737  	        call    VALIDY          ; check if Y is valid (0~191)
379E: D45834  	        call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
37A1: C9      	        ret                     ; return to caller
              	
              	; check if X,Y coordinates are valid: 0<=X<=255 and 0<=Y<=191
              	; input: HL (value to check), can be negative
              	; output: CARRY flag: reset => VALID  //  set => NOT VALID
              	; destroys: A
37A2: AF      	VALIDX: xor     A               ; reset A
37A3: B4      	        or      H               ; check if H is 0 (this means that X is in range 0~255 and not negative)
37A4: C8      	        ret     Z               ; yes, we can return (C is clear)
37A5: 37      	        scf                     ; set Carry flag to raise error
37A6: C9      	        ret                     ; return to caller
              	
37A7: AF      	VALIDY: xor     A               ; reset A
37A8: B4      	        or      H               ; check if H is 0 (this means that Y is in range 0~255 and not negative)
37A9: 2802    	        jr      Z,CNTVALY       ; yes, continue checking
37AB: 37      	        scf                     ; no, raise error by setting Carry flag
37AC: C9      	        ret                     ; return to caller
37AD: 7D      	CNTVALY:ld      A,L
37AE: FEC0    	        cp      $C0             ; is Y<192? Carry is set if Y<192
37B0: 3F      	        ccf                     ; invert Carry, so Carry=0 means OK, Carry=1 means ERROR
37B1: C9      	        ret                     ; return to caller
              	
              	
              	; clear VIDEOBUFF before using it as temp buffer
37B2: AF      	CLRVDBF:xor     A               ; clear A
37B3: C5      	        push    BC              ; store BC
37B4: E5      	        push    HL              ; store HL
37B5: 21EF81  	        ld      HL,TMPBFR1      ; address of 1st cell
37B8: 0606    	        ld      B,$06           ; 6 cells
37BA: 77      	RPTCVB1:ld      (HL),A          ; clear cell
37BB: 23      	        inc     HL              ; next cell
37BC: 10FC    	        djnz    RPTCVB1         ; repeat
37BE: 0628    	        ld      B,$28           ; 40 cells
37C0: 21F781  	        ld      HL,VIDEOBUFF    ; address of 1st cell
37C3: 77      	RPTCVB2:ld      (HL),A          ; clear cell
37C4: 23      	        inc     HL              ; next cell
37C5: 10FC    	        djnz    RPTCVB2         ; repeat
37C7: E1      	        pop     HL              ; retrieve HL
37C8: C1      	        pop     BC              ; retrieve BC
37C9: C9      	        ret                     ; return to caller
              	
              	
              	; check if a color is passed as argument with PLOT, DRAW, and CIRCLE
              	; commands. If not present, the default foreground color will be used
37CA: 3AED81  	CLRPRM: ld      A,(FRGNDCLR)    ; load foreground color
37CD: 32F381  	        ld      (TMPBFR3),A     ; store into temp buffer
37D0: 2B      	        dec     HL              ; dec 'cos GETCHR INCs
37D1: CD411A  	        call    GETCHR          ; Get next character
37D4: C8      	        ret     Z               ; return if nothing follows
37D5: CD1E18  	        call    CHKSYN          ; Make sure ',' follows
37D8: 2C      	        defb    ','
37D9: CD3C27  	        call    GETINT          ; get value
37DC: CDFB32  	        call    CHKCLR          ; check if color is in range 1~15
37DF: 32F381  	        ld      (TMPBFR3),A     ; store color into temp buffer
37E2: C9      	        ret                     ; return to caller
              	
              	
              	; no graphics mode error: raised when a graphics command is invoked
              	; out of graphic 2 mode.
37E3: 1E2A    	GMERR:  ld      E,GM            ; load Graphics Mode Error flag
37E5: C35015  	        jp      ERROR           ; print error
              	
              	
              	; set a serial port: params are PORT,BPS,DATA,PARITY,STOP
              	; PORT=1/2; BPS=1,200~57,600 (see below), DATA=5/6/7/8
              	; PARITY: 0=no parity; 1=ODD parity; 2=EVEN parity;
              	; STOP=0/1/2/3: 0=0 bit; 1=1 bit; 2=1.5 bits; 3=2 bits
              	; PORT 1 acts as a char device; PORT 2 acts as a block device
              	; DATA,PARITY, and STOP are optional: if nothing follows BPS,
              	; they are assumed to be 8,0,1 resp.
81F7:         	PRTNUM  equ     VIDEOBUFF
81F8:         	BPS     equ     VIDEOBUFF+$01
81FA:         	DATABT  equ     BPS+$02
81FB:         	PARBT   equ     DATABT+$01
81FC:         	STPBT   equ     PARBT+$01
81FD:         	SIOBFR  equ     STPBT+$01
37E8: CD3C27  	SERIAL: call    GETINT          ; get port #
37EB: A7      	        and     A               ; is it zero?
37EC: CA0C1B  	        jp      Z,FCERR         ; yes, error
37EF: FE03    	        cp      $03             ; is it 1 or 2?
37F1: D2D239  	        jp      NC,SCERR        ; no, error
37F4: 32F781  	        ld      (PRTNUM),A      ; store port number into a temp buffer
37F7: CD1E18  	        call    CHKSYN          ; Make sure ',' follows
37FA: 2C      	        defb    ','
37FB: CD111B  	        call    ATOH            ; get bps (returned into DE)
37FE: 7A      	        ld      A,D             ; move MSB into A
37FF: B3      	        or      E               ; LSB OR MSB, to check if bps=0
3800: 203A    	        jr      NZ,CNTSER       ; no, continue checking
              	        ; if baud rate is 0, then close the serial comm.
3802: 3AF781  	RSTSER1:ld      A,(PRTNUM)      ; yes, so reset the channel. First, load port number
3805: 3D      	        dec     A               ; subtract 1, so that serial channel is 0=>A and 1=>B
3806: C622    	        add     SIO_CA          ; find correct channel
3808: 4F      	        ld      C,A             ; store serial channel
3809: F3      	        di                      ; disable INTs
380A: AF      	        xor     A               ; reset A
380B: 1601    	        ld      D,$01           ; start from WR1
380D: 0605    	        ld      B,$05           ; 5 registers
380F: ED51    	RPTRSSR:out     (C),D           ; select register
3811: ED79    	        out     (C),A           ; reset register
3813: 14      	        inc     D               ; next register
3814: 10F9    	        djnz    RPTRSSR         ; repeat
3816: 3E30    	        ld      A,%00110000     ; write into WR0: error reset, select WR0
3818: ED79    	        out     (C),A           ; send command to serial channel
381A: 3E18    	        ld      A,%00011000     ; write into WR0: channel reset
381C: ED79    	        out     (C),A           ; send command to serial channel
381E: FB      	        ei                      ; re-enable INTs
381F: E5      	        push    HL              ; store HL
3820: 212E82  	        ld      HL,SERIALS_EN   ; serials enabled status byte
3823: DB01    	        in      A,(PIO_DB)      ; read status LEDs
3825: CB41    	        bit     0,C             ; check serial port
3827: 2009    	        jr      NZ,SRPT2        ; if bit is set, jump to port 2
3829: CBB7    	        res     6,A             ; it's port 1
382B: CBA7    	        res     4,A             ; remove possible error LED
382D: CB86    	        res     0,(HL)          ; disable port 1
382F: C33838  	        jp      SERLED          ; jump over
3832: CBBF    	SRPT2:  res     7,A             ; it's port 2
3834: CBAF    	        res     5,A             ; remove possible error LED
3836: CB8E    	        res     1,(HL)          ; disable port 2
3838: D301    	SERLED: out     (PIO_DB),A      ; send new configuration
383A: E1      	        pop     HL              ; retrieve HL
383B: C9      	        ret                     ; return to caller
              	        ; check if bps=1, meaning reactivate RX on serial
383C: 7A      	CNTSER: ld      A,D
383D: B2      	        or      D               ; check if bps<>1 by first checking D=0
383E: 203B    	        jr      NZ,CNTSER2      ; if not, jump over
3840: 7B      	        ld      A,E             ; then by checking that
3841: FE01    	        cp      $01             ; E=1
3843: 2036    	        jr      NZ,CNTSER2      ; if not, jump over
3845: 3AF781  	        ld      A,(PRTNUM)      ; load port number
3848: FE01    	        cp      $01             ; is it port 1? (currently do NOT support on port 2)
384A: C2D239  	        jp      NZ,SCERR        ; no, raise error and exit 
384D: 57      	        ld      D,A             ; store port on D
384E: 3A2E82  	        ld      A,(SERIALS_EN)  ; load address of serial status cell
3851: A2      	        and     D               ; check status
3852: CAD239  	        jp      Z,SCERR         ; port not open, raise error
3855: F3      	        di                      ; disable INTs
3856: 7A      	        ld      A,D             ; move port # into A
3857: 5F      	        ld      E,A             ; store original A into E
3858: 87      	        add     A
3859: 87      	        add     A               ; move A to left times 2
385A: 57      	        ld      D,A             ; move value into D
385B: 3A2E82  	        ld      A,(SERIALS_EN)  ; load serial status byte
385E: B2      	        or      D               ; re-enable RX
385F: 322E82  	        ld      (SERIALS_EN),A  ; store new serial status
3862: 7B      	        ld      A,E             ; recover port #
3863: 3D      	        dec     A               ; check port
3864: 200A    	        jr      NZ,CNTRX2       ; port is #2
3866: CD8D01  	        call    SIO_A_EI        ; re-enable RX on port 1
3869: DB01    	        in      A,(PIO_DB)      ; load status LEDs
386B: CBA7    	        res     4,A             ; remove error LED
386D: C37738  	        jp      RXEND           ; terminate setting
3870: CD8D01  	CNTRX2: call    SIO_A_EI        ; re-enable RX on port 2 -> CURRENTLY only port 1 is supported
3873: DB01    	        in      A,(PIO_DB)      ; load status LEDs
3875: CBAF    	        res     5,A             ; remove error LED
3877: D301    	RXEND:  out     (PIO_DB),A      ; set new status for LEDs
3879: FB      	        ei                      ; re-enable INTs
387A: C9      	        ret                     ; return to caller
              	        ; set serial port comm.
387B: D5      	CNTSER2:push    DE              ; store BPS
387C: 3AF781  	        ld      A,(PRTNUM)      ; load port number
387F: 57      	        ld      D,A             ; move port # into D
3880: 3A2E82  	        ld      A,(SERIALS_EN)  ; check if serial port is already open
3883: A2      	        and     D               ; by ANDing A with D
3884: D1      	        pop     DE              ; retrieve BPS
3885: CA8D38  	        jp      Z,CNTSER3       ; not open, continue
3888: 1E2E    	        ld      E,SA            ; already open, so raise a "Serial Port Already Error"
388A: C35015  	        jp      ERROR           ; and leave
388D: E5      	CNTSER3:push    HL              ; store HL   
388E: 2100E1  	        ld      HL,$E100        ; check bps. start with HL=57,600
3891: CD5F3C  	        call    CMP16           ; is bps<=57,600?
3894: E1      	        pop     HL              ; but first, recover HL
3895: DAD239  	        jp      C,SCERR         ; no (bps>57,600) then error
3898: ED53F881	        ld      (BPS),DE        ; store bps
389C: 2B      	        dec     HL              ; dec 'cos GETCHR INCs
389D: CD411A  	        call    GETCHR          ; Get next character
38A0: CAD738  	        jp      Z,DEFSER        ; defaults if nothing follows
38A3: CD1E18  	        call    CHKSYN          ; Make sure ',' follows
38A6: 2C      	        defb    ','
38A7: CD3C27  	        call    GETINT          ; get data bits
38AA: FE05    	        cp      $05             ; is it <5?
38AC: DAD239  	        jp      C,SCERR         ; yes, error
38AF: FE09    	        cp      $09             ; is it >=9?
38B1: D20C1B  	        jp      NC,FCERR        ; no, error
38B4: 32FA81  	        ld      (DATABT),A      ; store data bits
38B7: CD1E18  	        call    CHKSYN          ; Make sure ',' follows
38BA: 2C      	        defb    ','
38BB: CD3C27  	        call    GETINT          ; get parity bits
38BE: FE03    	        cp      A,$03           ; check if parity is in range 0~2
38C0: D2D239  	        jp      NC,SCERR        ; no, error
38C3: 32FB81  	        ld      (PARBT),A       ; store parity
38C6: CD1E18  	        call    CHKSYN          ; Make sure ',' follows
38C9: 2C      	        defb    ','
38CA: CD3C27  	        call    GETINT          ; get stop bits
38CD: FE03    	        cp      $03             ; is it >=3?
38CF: D2D239  	        jp      NC,SCERR        ; yes, error
38D2: 32FC81  	        ld      (STPBT),A       ; store stop bits
38D5: 180D    	        jr      SETSER          ; jump to set serial
38D7: 3E08    	DEFSER: ld      A,$08           ; 8 bits for data
38D9: 32FA81  	        ld      (DATABT),A
38DC: AF      	        xor     A               ; no parity bit
38DD: 32FB81  	        ld      (PARBT),A
38E0: 3C      	        inc     A               ; 1 bit for stop
38E1: 32FC81  	        ld      (STPBT),A
              	        ; check if bps are legal
38E4: E5      	SETSER: push    HL              ; store HL 
38E5: D5      	        push    DE              ; store DE
38E6: DDE5    	        push    IX              ; store IX
38E8: DD21AD39	        ld      IX,SUP_BPS      ; allowed BPSs
38EC: 060B    	        ld      B,$0B           ; 11 items
38EE: 0E00    	        ld      C,$00           ; reset pointer
38F0: 2AF881  	CKBPS:  ld      HL,(BPS)        ; load BPS
38F3: DD5E00  	        ld      E,(IX+0)        ; load LSB of item
38F6: DD5601  	        ld      D,(IX+1)        ; load MSB of item
38F9: CD5F3C  	        call    CMP16           ; is it equal?
38FC: CA0939  	        jp      Z,FNDBPS        ; yes, found correspondance
38FF: DD23    	        inc     IX
3901: DD23    	        inc     IX              ; no, go to next entry
3903: 0C      	        inc     C               ; increment pointer
3904: 10EA    	        djnz    CKBPS           ; repeat for 10 entries
3906: C3CE39  	        jp      SCERR1          ; if nothing found, raise an error
3909: 3AF781  	FNDBPS: ld      A,(PRTNUM)      ; check serial port
390C: 3D      	        dec     A               ; is it port 1?
390D: CA1339  	        jp      Z,SET_P1        ; yes, set port 1
3910: C3CE39  	        jp      SCERR1          ; at the moment, only port 1 can be configured
3913:         	SET_P1: ;init CTC CH0: CH0 provides RX/TX clock to SIO port A
              	        ; TO0 output frequency=INPUT CLK/time constant. Time constant is set to get 16 times
              	        ; the requested baud rate. I.e., if bps is 19,200 then time constast is set to 6 because
              	        ; 1,843,200/6 = 307,200 Hz (that is 19,200 x 16)
3913: F3      	        di                      ; disable INTs
3914: 0600    	        ld      B,$00           ; reset B
3916: 21C339  	        ld      HL,CTC_CFG      ; address of first CTC divider
3919: 09      	        add     HL,BC           ; adjust for correct CTC divider
391A: 3E47    	        ld      A,%01000111     ; interrupt off, counter mode, prsc=16 (doesn't matter), ext. start,
              	                                ; start upon loading time constant, time constant follows, sw reset, command word
391C: D310    	        out     (CTC_CH0),A     ; configure CTC channel 0
391E: 7E      	        ld      A,(HL)          ; load CTC divider
391F: D310    	        out     (CTC_CH0),A     ; send divider
              	        ; configure SIO
3921: 21FA02  	        ld      HL,SIO_A_SETS   ; load default settings for SIO
3924: 11FD81  	        ld      DE,SIOBFR       ; into a temp buffer
3927: 010A00  	        ld      BC,$000A        ; 10 items to copy
392A: EDB0    	        ldir                    ; copy SIO settings into TEMP buffer
392C: 3A0282  	        ld      A,(SIOBFR+5)    ; load WR5 setting
392F: 47      	        ld      B,A             ; move it into B
3930: 3AFA81  	        ld      A,(DATABT)      ; load DATA bits
3933: FE05    	        cp      $05             ; is it 5 bits?
3935: 2006    	        jr      NZ,BITS6        ; no, jump over
3937: CBB0    	        res     6,B
3939: CBA8    	        res     5,B             ; set D6 & D5 to 0
393B: 1819    	        jr      SETPAR          ; jump to set parity
393D: FE06    	BITS6:  cp      $06             ; is it 6 bits?
393F: 2006    	        jr      NZ,BITS7        ; no, jump over
3941: CBF0    	        set     6,B
3943: CBA8    	        res     5,B             ; set D6 & D5 to 1,0
3945: 180F    	        jr      SETPAR          ; jump to set parity
3947: FE07    	BITS7:  cp      $07             ; is it 7 bits?
3949: 2007    	        jr      NZ,BITS8        ; no, jump over
394B: CBB0    	        res     6,B
394D: CBE8    	        set     5,B             ; set D6 & D5 to 0,1
394F: C35639  	        jp      SETPAR          ; jump to set parity
3952: CBF0    	BITS8:  set     6,B
3954: CBE8    	        set     5,B             ; set D6 & D5 to 1,1
3956: 78      	SETPAR: ld      A,B
3957: 320282  	        ld      (SIOBFR+5),A    ; save DATA bits
395A: E660    	        and     %01100000       ; filter only D5&D6 bits
395C: 87      	        add     A,A             ; shift left times 1
395D: 322F82  	        ld      (SERABITS),A    ; store for SIO_A_EI & SIO_A_DI functions
3960: 3AFC81  	        ld      A,(STPBT)       ; load STOP bits
3963: 87      	        add     A,A
3964: 87      	        add     A,A             ; 2 left shifts
3965: 47      	        ld      B,A             ; move forming byte into B
3966: 3AFB81  	        ld      A,(PARBT)       ; load PARITY setting
3969: A7      	        and     A               ; is it 0?
396A: CA7539  	        jp      Z,STRPAR        ; yes, jump over
396D: CBC0    	        set     0,B             ; set PARITY on
396F: 3D      	        dec     A               ; is parity ODD?
3970: CA7539  	        jp      Z,STRPAR        ; yes, so jump over
3973: CBC8    	        set     1,B             ; no, it's EVEN so set the corresponding bit
3975: 3A0082  	STRPAR: ld      A,(SIOBFR+3)    ; load WR4 setting
3978: E6F0    	        and     %11110000       ; reset STOP & PARITY bits
397A: B0      	        or      B               ; set new STOP & PARITY bits
397B: 320082  	        ld      (SIOBFR+3),A    ; store new value
              	        ;set up TX and RX:
              	        ; the followings are settings for channel A
397E: 21FD81  	        ld      HL,SIOBFR       ; settings for SIO ch. A
3981: 0606    	        ld      B,$06           ; 6 bytes to send
3983: 0E22    	        ld      C,SIO_CA        ; I/O address of SIO ch.A
3985: EDB3    	        otir                    ; send bytes to SIO
              	        ; the following are settings for channel B (don't need to load HL since settings are contigous)
3987: 0604    	        ld      B,$04           ; other 4 bytes to send
3989: 0E23    	        ld      C,SIO_CB        ; I/O address of SIO ch.B
398B: EDB3    	        otir                    ; send bytes to SIO
              	        ; the following are settings for channel A
398D: 3E01    	        ld      A,$01           ; write into WR0: select WR1
398F: D322    	        out     (SIO_CA),A
3991: 3E18    	        ld      A,%00011000     ; interrupts on every RX char; parity is no special condition;
              	                                ; buffer overrun is special condition
3993: D322    	        out     (SIO_CA),A
3995: CD8D01  	        call    SIO_A_EI        ; enable RX on SIO channel A
3998: 212E82  	EXITSER:ld      HL,SERIALS_EN
399B: CBC6    	        set     0,(HL)          ; set serial port 1 status ON
399D: CBD6    	        set     2,(HL)          ; set serial port 1 RX ON
              	        ; back to normal running
399F: FB      	        ei                      ; re-enable INTs
39A0: DB01    	        in      A,(PIO_DB)      ; load status LEDs
39A2: CBF7    	        set     6,A             ; set status LED on
39A4: CBA7    	        res     4,A             ; set error LED off
39A6: D301    	        out     (PIO_DB),A      ; send new configuration
39A8: DDE1    	        pop     IX              ; retrieve IX
39AA: D1      	        pop     DE              ; retrieve DE
39AB: E1      	        pop     HL              ; retrieve HL
39AC: C9      	        ret                     ; return to caller
              	
              	; allowed bps (Bauds per second)
39AD: 00E10096	SUP_BPS:defw    57600,38400,28800,19200,14400,9600,4800,3600,2400,1200,600
39B1: 8070004B	
39B5: 40388025	
39B9: C012100E	
39BD: 6009B004	
39C1: 5802    	
              	; corresponding CTC divider
39C3: 02030406	CTC_CFG:defb    2,3,4,6,8,12,24,32,48,96,192
39C7: 080C1820	
39CB: 3060C0  	
              	
              	; serial configuration error
39CE: DDE1    	SCERR1: pop     IX              ; retrieve IX
39D0: D1      	        pop     DE              ; retrieve DE
39D1: E1      	        pop     HL              ; retrieve HL
39D2: 1E2C    	SCERR:  ld      E,SC            ; Serial Configuration Error
39D4: C35015  	        jp      ERROR           ; print error
              	
              	; check for direct mode
39D7: E5      	DIRMOD: push    HL              ; Save code string address
39D8: 2AAF80  	        ld      HL,(LINEAT)     ; Get current line number
39DB: 23      	        inc     HL              ; -1 means direct statement
39DC: 7C      	        ld      A,H
39DD: B5      	        or      L
39DE: E1      	        pop     HL              ; Restore code string address
39DF: C2F939  	        jp      NZ,HLPERR       ; raise error if in indirect mode
39E2: C9      	        ret
              	
              	
              	; HELP lists the line program where an error was found
39E3: CDD739  	HELP:   call    DIRMOD          ; check if in direct mode
39E6: E5      	        push    HL              ; store HL
39E7: 2AB180  	        ld      HL,(HLPLN)      ; load HELP line
39EA: 23      	        inc     HL              ; increment HL
39EB: 7C      	        ld      A,H
39EC: B5      	        or      L               ; check if there is a line into the HELP reg.
39ED: E1      	        pop     HL
39EE: CAF939  	        jp      Z,HLPERR        ; no line found, raise error
39F1: ED5BB180	        ld      DE,(HLPLN)      ; recover line
39F5: C1      	        pop     BC              ; remove BC from stack since it's not needed anymore for LIST
39F6: C3AC18  	        jp      LST01H          ; jump to list line
39F9: 1E30    	HLPERR: ld      E,HP            ; HELP call error
39FB: C35015  	        jp      ERROR           ; raise error
              	
              	
              	; KEY command to list/modify function keys
39FE: 2B      	KEY:    dec     HL              ; dec 'cos GETCHR INCs
39FF: CD411A  	        call    GETCHR          ; Get next character
3A02: CA823A  	        jp      Z,LSTKEYS       ; jump if nothing follows
              	                                ; change FN keys
3A05: CD3C27  	        call    GETINT          ; get a number
3A08: A7      	        and     A               ; is it 0?
3A09: 2010    	        jr      NZ,KEYCH        ; no, jump over         
3A0B: E5      	        push    HL              ; yes - reset FN keys to defaults
3A0C: D5      	        push    DE              ; store HL & DE
3A0D: 212C14  	        ld      HL,DEFFNKS      ; pointer to default FN keys texts
3A10: 11B380  	        ld      DE,FNKEYS       ; pointer to destination
3A13: 018000  	        ld      BC,$0080        ; 128 chars to be copied
3A16: EDB0    	        ldir                    ; restore default texts
3A18: D1      	        pop     DE              ; retrieve DE
3A19: E1      	        pop     HL              ; retrieve HL
3A1A: C9      	        ret                     ; return to caller
3A1B: FE09    	KEYCH:  cp      $09             ; is it >= 9?
3A1D: D23C15  	        jp      NC,SNERR        ; yes - syntax error
3A20: 3D      	        dec     A               ; FN key in range 0~7
3A21: 87      	        add     A,A             ; multiply A...
3A22: 87      	        add     A,A             ; ... times 4...
3A23: 87      	        add     A,A             ; ... to get the correct...
3A24: 87      	        add     A,A             ; ... offset fo FN key text
3A25: 32EF81  	        ld      (TMPBFR1),A     ; store FN key offset...
3A28: AF      	        xor     A               ; ...in a...
3A29: 32F081  	        ld      (TMPBFR1+1),A   ; ...16-bit register
3A2C: CD1E18  	        call    CHKSYN          ; Make sure ',' follows
3A2F: 2C      	        defb    ','
3A30: 444D    	        ld      BC,HL           ; copy address into BC
3A32: CDC81E  	        call    EVAL            ; Evaluate expression (in E there is the length)
3A35: E5      	        push    HL              ; store string pointer
3A36: 3A9281  	        ld      A,(TYPE)        ; Get variable type
3A39: B7      	        or      A               ; Is it a string variable?
3A3A: CA3C15  	        jp      Z,SNERR         ; no - syntax error
3A3D: CD0125  	        call    GSTRCU          ; Current string to pool
3A40: CD132D  	        call    LOADFP          ; Move string block data to (BC=pointer, DE=length)
3A43: 7B      	        ld      A,E             ; copy length into A
3A44: FE11    	        cp      $11             ; is length > 16?
3A46: DA4B3A  	        jp      C,DECLN1        ; no, jump over
3A49: 1E10    	        ld      E,$10           ; yes, so set length to 16
3A4B: 3E10    	DECLN1: ld      A,$10           ; calculate how many...
3A4D: 93      	        sub     E               ; ...null chars needed to fill up...
3A4E: 57      	        ld      D,A             ; ...the FN key text
3A4F: C5      	        push    BC              ; store address of string 
3A50: ED4BEF81	        ld      BC,(TMPBFR1)    ; load FN key offset
3A54: 21B380  	        ld      HL,FNKEYS       ; load address of FN keys texts
3A57: 09      	        add     HL,BC           ; get corrected address
3A58: C1      	        pop     BC              ; retrieve address of string chars
3A59: 0A      	CPKEY:  ld      A,(BC)          ; load char from string
3A5A: FE0D    	        cp      CR              ; return?
3A5C: CA693A  	        jp      Z,CPKEY2        ; yes, store char
3A5F: FE7B    	        cp      $7B             ; if char > "z" ?
3A61: D23C15  	        jp      NC,SNERR        ; yes - syntax error
3A64: FE20    	        cp      $20             ; is char < space?
3A66: DA3C15  	        jp      C,SNERR         ; yes - syntax error
3A69: FE61    	CPKEY2: cp      $61             ; is it >= 'a'?
3A6B: DA703A  	        jp      C,CPKEY3        ; no, continue
3A6E: E65F    	        and     %01011111       ; set letters to uppercase
3A70: 77      	CPKEY3: ld      (HL),A          ; store char
3A71: 23      	        inc     HL              ; next string char
3A72: 03      	        inc     BC              ; next free cell
3A73: 1D      	        dec     E               ; decrement E
3A74: 20E3    	        jr      NZ,CPKEY        ; repeat until 0
3A76: AF      	        xor     A               ; null char
3A77: 14      	        inc     D               ; +1 to decrement below
3A78: 15      	CPKEY1: dec     D               ; how many null chars to insert?
3A79: CA803A  	        jp      Z,CPKYEND       ; no more nulls, so exit
3A7C: 77      	        ld      (HL),A          ; store it
3A7D: 23      	        inc     HL              ; next cell
3A7E: 18F8    	        jr      CPKEY1          ; repeat
3A80: E1      	CPKYEND:pop     HL              ; retrieve pointer to string
3A81: C9      	        ret                     ; return to caller
              	                                ; list FN keys
3A82: E5      	LSTKEYS:push    HL              ; Save code string address
3A83: 2AAF80  	        ld      HL,(LINEAT)     ; Get current line number
3A86: 23      	        inc     HL              ; -1 means direct statement
3A87: 7C      	        ld      A,H
3A88: B5      	        or      L
3A89: E1      	        pop     HL              ; Restore code string address
3A8A: C23C15  	        jp      NZ,SNERR        ; raise error if in indirect mode
3A8D: E5      	        push    HL              ; store HL
3A8E: D5      	        push    DE              ; store DE
3A8F: 21B380  	        ld      HL,FNKEYS       ; load starting address of FN keys text
3A92: 0E01    	        ld      C,$01           ; 8 function keys
3A94: 0610    	PRTK4:  ld      B,$10           ; 16 chars each
3A96: 11353B  	PRTK2:  ld      DE,CHKEY1       ; message "KEY "
3A99: CD263B  	        call    PRTCKEY         ; print it
3A9C: 79      	        ld      A,C             ; load FN key
3A9D: C630    	        add     $30             ; get number in ASCI code
3A9F: CD2918  	        call    OUTC            ; print it
3AA2: 113A3B  	        ld      DE,CHKEY2       ; message ": ""
3AA5: CD263B  	        call    PRTCKEY         ; print it
3AA8: 3E01    	        ld      A,$01           ; " opened
3AAA: 32EF81  	        ld      (TMPBFR1),A
3AAD: 7E      	LDKEY:  ld      A,(HL)          ; retrieve char
3AAE: A7      	        and     A               ; is it zero?
3AAF: CAC23A  	        jp      Z,CNTLTK        ; yes, go next char
3AB2: CD0E3B  	        call    OPNQT           ; check if quotes are opened
3AB5: FE22    	        cp      $22             ; check if char is "?
3AB7: CAD73A  	        jp      Z,PRTCHR        ; yes, print "chr$("
3ABA: FE0D    	        cp      CR              ; is it a CR?
3ABC: CAD73A  	        jp      Z,PRTCHR        ; yes, print "chr$("
3ABF: CD2918  	PRTK3:  call    OUTC            ; no, just print it
3AC2: 23      	CNTLTK: inc     HL              ; next char
3AC3: 10E8    	        djnz    LDKEY           ; continue until finished
3AC5: CDFC3A  	        call    CLSQT           ; check if quotes are still open
3AC8: 3E0D    	        ld      A,CR            ; go next line
3ACA: CD2918  	        call    OUTC            ; print it
3ACD: 0C      	        inc     C               ; next FN key
3ACE: 79      	        ld      A,C             ; check if...
3ACF: FE09    	        cp      $09             ; finished keys?
3AD1: DA943A  	        jp      C,PRTK4         ; no, repeat 1 more time
3AD4: D1      	        pop     DE              ; retrieve DE
3AD5: E1      	        pop     HL              ; retrieve HL
3AD6: C9      	        ret                     ; return to caller
              	
3AD7: E5      	PRTCHR: push    HL              ; store HL
3AD8: CDFC3A  	        call    CLSQT           ; check if quotes are closed
3ADB: 3E2B    	        ld      A,'+'           ; '+' char
3ADD: CD2918  	        call    OUTC            ; print it
3AE0: 113D3B  	        ld      DE,CHKEY3       ; address of "CHR$("
3AE3: CD263B  	        call    PRTCKEY         ; print it
3AE6: E1      	        pop     HL              ; recover HL
3AE7: 23      	        inc     HL              ; next char
3AE8: 05      	        dec     B               ; increment char counter
3AE9: 11433B  	        ld      DE,CHKEY4       ; load address of RETURN
3AEC: 7E      	        ld      A,(HL)          ; load char
3AED: FE0D    	        cp      CR              ; is it a RETURN?
3AEF: 2003    	        jr      NZ,PTCHR1       ; no, jump over
3AF1: 11463B  	        ld      DE,CHKEY5       ; yes, load address of "
3AF4: CD263B  	PTCHR1: call    PRTCKEY         ; print it
3AF7: 3E29    	        ld      A,')'           ; char )
3AF9: C3BF3A  	        jp      PRTK3           ; continue
              	
3AFC: F5      	CLSQT:  push    AF              ; store A
3AFD: 3AEF81  	        ld      A,(TMPBFR1)     ; quote status
3B00: A7      	        and     A               ; are they closed?
3B01: 2809    	        jr      Z,CLSQT1        ; if yes, return
3B03: 3E22    	        ld      A,$22           ; no, so close them
3B05: CD2918  	        call    OUTC            ; print "
3B08: AF      	        xor     A               ; set quotes
3B09: 32EF81  	        ld      (TMPBFR1),A     ; as closed
3B0C: F1      	CLSQT1: pop     AF              ; retrieve A
3B0D: C9      	        ret                     ; return to caller
              	
3B0E: F5      	OPNQT:  push    AF              ; store A
3B0F: 3AEF81  	        ld      A,(TMPBFR1)     ; quote status
3B12: A7      	        and     A               ; are they open?
3B13: 200F    	        jr      NZ,OPNQT1       ; if yes, return
3B15: 3E2B    	        ld      A,'+'           ; no, so add '+
3B17: CD2918  	        call    OUTC            ; print it
3B1A: 3E22    	        ld      A,$22           ; and then open quotes
3B1C: CD2918  	        call    OUTC            ; print them
3B1F: 3E01    	        ld      A,$01           ; set quotes
3B21: 32EF81  	        ld      (TMPBFR1),A     ; as opened
3B24: F1      	OPNQT1: pop     AF              ; retrieve A
3B25: C9      	        ret                     ; return to caller
              	
3B26: F5      	PRTCKEY:push    AF              ; store original char
3B27: 1A      	PRTK1:  ld      A,(DE)          ; load char
3B28: A7      	        and     A               ; is it 0?
3B29: CA333B  	        jp      Z,PRTEND        ; yes, finished printing
3B2C: CD2918  	        call    OUTC            ; no, print char
3B2F: 13      	        inc     DE              ; next char
3B30: C3273B  	        jp      PRTK1           ; repeat
3B33: F1      	PRTEND: pop     AF              ; retrieve AF
3B34: C9      	        ret                     ; return to caller
              	
3B35: 4B455920	CHKEY1: defb    "KEY ",0
3B39: 00      	
3B3A: 3A2200  	CHKEY2: defb    ":",34,0
3B3D: 63687224	CHKEY3: defb    "chr$(",0
3B41: 2800    	
3B43: 313300  	CHKEY4: defb    "13",0
3B46: 333400  	CHKEY5: defb    "34",0
              	
              	
              	; HEX$(nn) Convert 16 bit number to Hexadecimal string
3B49: CDB91E  	HEX: 	call	TSTNUM          ; Verify it's a number
3B4C: CDF71A  	        call	DEINT           ; Get integer -32768 to 32767
3B4F: C5      	        push	BC              ; Save contents of BC
3B50: 213082  	        ld      HL,PBUFF        ; load address of PBUFF into HL
3B53: 7A      	        ld      A,D             ; Get MSB into A
3B54: B7      	        or      A               ; OR with LSB to see if param=0
3B55: 280C    	        jr      Z,HEX2          ; Skip output if both high digits are zero
3B57: CD7F3B  	        call    BYT2ASC         ; Convert D to ASCII
3B5A: 78      	        ld      A,B             ; cechk if B
3B5B: FE30    	        cp      '0'             ; is 0
3B5D: 2802    	        jr      Z,HEX1          ; Don't store high digit if zero
3B5F: 70      	        ld      (HL),B          ; Store it to PBUFF
3B60: 23      	        inc     HL              ; Next location
3B61: 71      	HEX1:   ld      (HL),C          ; Store C to PBUFF+1
3B62: 23      	        inc     HL              ; Next location
3B63: 7B      	HEX2:   ld      A,E             ; Get lower byte
3B64: CD7F3B  	        call    BYT2ASC         ; Convert E to ASCII
3B67: 7A      	        ld      A,D
3B68: B7      	        or      A
3B69: 2005    	        jr      NZ,HEX3         ; If upper byte was not zero then always print lower byte
3B6B: 78      	        ld      A,B
3B6C: FE30    	        cp      '0'             ; If high digit of lower byte is zero then don't print
3B6E: 2802    	        jr      Z,HEX4
3B70: 70      	HEX3:   ld      (HL),B          ; to PBUFF+2
3B71: 23      	        inc     HL              ; Next location
3B72: 71      	HEX4:   ld      (HL),C          ; to PBUFF+3
3B73: 23      	        inc     HL              ; PBUFF+4 to zero
3B74: AF      	        xor     A               ; Terminating character
3B75: 77      	        ld      (HL),A          ; Store zero to terminate
3B76: 23      	        inc     HL              ; Make sure PBUFF is terminated
3B77: 77      	        ld      (HL),A          ; Store the double zero there
3B78: C1      	        pop     BC              ; Get BC back
3B79: 213082  	        ld      HL,PBUFF        ; Reset to start of PBUFF
3B7C: C34E23  	        jp      STR1            ; Convert the PBUFF to a string and return it
3B7F: 47      	BYT2ASC	ld      B,A             ; Save original value
3B80: E60F    	        and     $0F             ; Strip off upper nybble
3B82: FE0A    	        cp      $0A             ; 0-9?
3B84: 3802    	        jr      C,ADD30         ; If A-F, add 7 more
3B86: C607    	        add     A,$07           ; Bring value up to ASCII A-F
3B88: C630    	ADD30	add     A,$30           ; And make ASCII
3B8A: 4F      	        ld      C,A             ; Save converted char to C
3B8B: 78      	        ld      A,B             ; Retrieve original value
3B8C: 0F      	        rrca                    ; and Rotate it right
3B8D: 0F      	        rrca
3B8E: 0F      	        rrca
3B8F: 0F      	        rrca
3B90: E60F    	        and     $0F             ; Mask off upper nybble
3B92: FE0A    	        cp      $0A             ; 0-9? < A hex?
3B94: 3802    	        jr      C,ADD301        ; Skip Add 7
3B96: C607    	        add     A,$07           ; Bring it up to ASCII A-F
3B98: C630    	ADD301	add     A,$30           ; And make it full ASCII
3B9A: 47      	        ld      B,A             ; Store high order byte
3B9B: C9      	        ret
              	
              	; Convert "&Hnnnn" to FPREG
              	; Gets a character from (HL) checks for Hexadecimal ASCII numbers "&Hnnnn"
              	; Char is in A, NC if char is ;<=>?@ A-z, CY is set if 0-9
3B9C: EB      	HEXTFP  ex      DE,HL           ; Move code string pointer to DE
3B9D: 210000  	        ld      HL,$0000        ; Zero out the value
3BA0: CDB53B  	        call    GETHEX          ; Check the number for valid hex
3BA3: DAD53B  	        jp      C,HXERR         ; First value wasn't hex, HX error
3BA6: 1805    	        jr      HEXLP1          ; Convert first character
3BA8: CDB53B  	HEXLP   call    GETHEX          ; Get second and addtional characters
3BAB: 381F    	        jr      C,HEXIT         ; Exit if not a hex character
3BAD: 29      	HEXLP1  add     HL,HL           ; Rotate 4 bits to the left
3BAE: 29      	        add     HL,HL
3BAF: 29      	        add     HL,HL
3BB0: 29      	        add     HL,HL
3BB1: B5      	        or      L               ; Add in D0-D3 into L
3BB2: 6F      	        ld      L,A             ; Save new value
3BB3: 18F3    	        jr      HEXLP           ; And continue until all hex characters are in
              	
3BB5: 13      	GETHEX  inc     DE              ; Next location
3BB6: 1A      	        ld      A,(DE)          ; Load character at pointer
3BB7: FE20    	        cp      SPC
3BB9: CAB53B  	        jp      Z,GETHEX        ; Skip spaces
3BBC: D630    	        sub     $30             ; Get absolute value
3BBE: D8      	        ret     C               ; < "0", error
3BBF: FE0A    	        cp      $0A
3BC1: 3805    	        jr      C,NOSUB7        ; Is already in the range 0-9
3BC3: D607    	        sub     $07             ; Reduce to A-F
3BC5: FE0A    	        cp      $0A             ; Value should be $0A-$0F at this point
3BC7: D8      	        ret     C               ; CY set if was :            ; < = > ? @
3BC8: FE10    	NOSUB7  cp      $10             ; > Greater than "F"?
3BCA: 3F      	        ccf
3BCB: C9      	        ret                     ; CY set if it wasn't valid hex
              	
3BCC: EB      	HEXIT   ex      DE,HL           ; Value into DE, Code string into HL
3BCD: 7A      	        ld      A,D             ; Load DE into AC
3BCE: 4B      	        ld      C,E             ; For prep to
3BCF: E5      	        push    HL
3BD0: CD9F22  	        call    ACPASS          ; ACPASS to set AC as integer into FPREG
3BD3: E1      	        pop     HL
3BD4: C9      	        ret
              	
3BD5: 1E26    	HXERR:  ld      E,HX            ; ?HEX Error
3BD7: C35015  	        jp      ERROR
              	
              	; BIN$(NN) Convert integer to a 1-16 char binary string
3BDA: CDB91E  	BIN:    call    TSTNUM          ; Verify it's a number
3BDD: CDF71A  	        call    DEINT           ; Get integer -32768 to 32767
3BE0: C5      	BIN2:   push    BC              ; Save contents of BC
3BE1: 213082  	        ld      HL,PBUFF
3BE4: 0611    	        ld      B,$11           ; One higher than max char count (16+1)
3BE6:         	ZEROSUP:                        ; Suppress leading zeros
3BE6: 05      	        dec     B               ; Max 16 chars
3BE7: 78      	        ld      A,B
3BE8: FE01    	        cp      $01
3BEA: 2808    	        jr      Z,BITOUT        ; Always output at least one character
3BEC: CB13    	        rl      E
3BEE: CB12    	        rl      D
3BF0: 30F4    	        jr      NC,ZEROSUP
3BF2: 1804    	        jr      BITOUT2
3BF4: CB13    	BITOUT: rl      E
3BF6: CB12    	        rl      D               ; Top bit now in carry
3BF8: 3E30    	BITOUT2:ld      A,'0'           ; Char for '0'
3BFA: CE00    	        adc     A,$00           ; If carry set then '0' --> '1'
3BFC: 77      	        ld      (HL),A
3BFD: 23      	        inc     HL
3BFE: 05      	        dec     B
3BFF: 20F3    	        jr      NZ,BITOUT
3C01: AF      	        xor     A               ; Terminating character
3C02: 77      	        ld      (HL),A          ; Store zero to terminate
3C03: 23      	        inc     HL              ; Make sure PBUFF is terminated
3C04: 77      	        ld      (HL),A          ; Store the double zero there
3C05: C1      	        pop     BC
3C06: 213082  	        ld      HL,PBUFF
3C09: C34E23  	        jp      STR1
              	
              	; Convert "&Bnnnn" to FPREG
              	; Gets a character from (HL) checks for Binary ASCII numbers "&Bnnnn"
3C0C: EB      	BINTFP: ex      DE,HL           ; Move code string pointer to DE
3C0D: 210000  	        ld      HL,$0000        ; Zero out the value
3C10: CD293C  	        call    CHKBIN          ; Check the number for valid bin
3C13: DA373C  	        jp      C,BINERR        ; First value wasn't bin, HX error
3C16: D630    	BINIT:  sub     '0'
3C18: 29      	        add     HL,HL           ; Rotate HL left
3C19: B5      	        or      L
3C1A: 6F      	        ld      L,A
3C1B: CD293C  	        call    CHKBIN          ; Get second and addtional characters
3C1E: 30F6    	        jr      NC,BINIT        ; Process if a bin character
3C20: EB      	        ex      DE,HL           ; Value into DE, Code string into HL
3C21: 7A      	        ld      A,D             ; Load DE into AC
3C22: 4B      	        ld      C,E             ; For prep to
3C23: E5      	        push    HL
3C24: CD9F22  	        call    ACPASS          ; ACPASS to set AC as integer into FPREG
3C27: E1      	        pop     HL
3C28: C9      	        ret
              	
              	; Char is in A, NC if char is 0 or 1
3C29: 13      	CHKBIN: inc     DE
3C2A: 1A      	        ld      A,(DE)
3C2B: FE20    	        cp      SPC
3C2D: CA293C  	        jp      Z,CHKBIN        ; Skip spaces
3C30: FE30    	        cp      '0'             ; Set C if < '0'
3C32: D8      	        ret     C
3C33: FE32    	        cp      '2'
3C35: 3F      	        ccf                     ; Set C if > '1'
3C36: C9      	        ret
              	
3C37: 1E28    	BINERR: ld      E,BN            ; ?BIN Error
3C39: C35015  	        jp      ERROR
              	
              	
3C3C: C30800  	MONOUT: jp      $0008           ; output a char
              	
              	
3C3F: 3A2E82  	RESET:  ld      A,(SERIALS_EN)
3C42: E601    	        and     $01             ; is serial port #1 open?
3C44: C40238  	        call    NZ,RSTSER1      ; yes, reset serial 1
3C47: C30000  	        jp      $0000           ; Restart
              	
              	
3C4A: 3E00    	INITST: ld      A,$00           ; Clear break flag
3C4C: 32A980  	        ld      (BRKFLG),A
3C4F: C3E40E  	        jp      INIT
              	
              	
3C52: F5      	TSTBIT: push    AF              ; Save bit mask
3C53: A0      	        and     B               ; Get common bits
3C54: C1      	        pop     BC              ; Restore bit mask
3C55: B8      	        cp      B               ; Same bit set?
3C56: 3E00    	        ld      A,$00           ; Return 0 in A
3C58: C9      	        ret
              	
3C59: CD2918  	OUTNCR: call    OUTC            ; Output character in A
3C5C: C3FA1C  	        jp      PRNTCRLF        ; Output CRLF
              	; ------------------------------------------------------------------------------
              	; LM80C - UTILITY ROUTINES - R1.1
              	; ------------------------------------------------------------------------------
              	; The following code is intended to be used with LM80C Z80-based computer
              	; designed by Leonardo Miliani. More info at
              	; www DOT leonardomiliani DOT com
              	;
              	; *ALS are routines from "Z80 Assembly Language Subroutines" by Lance
              	; A. Leventhal and Winthrop Saville - Ed. Osborne/McGraw-Hill (1983)
              	;
              	; * WKT are routines from WikiTI:
              	; http://wikiti.brandonw.net/index.php?title=WikiTI_Home
              	;
              	; * LAC are routines from Learn@Cemetch
              	; https://learn.cemetech.net/index.php/Main_Page
              	;
              	; ------------------------------------------------------------------------------
              	; Code Revision:
              	; R1.0 - 20200110 - First release: 16-bit comparision/multiplication/negation
              	; R1.1 - 20200413 - Second release: added ABS(HL) 
              	;
              	; ------------------------------------------------------------------------------
              	
              	; compare two 16-bit registers, HL (minuend) and DE (subtrahend)
              	; values can be both signed or unsigned words
              	; inputs: HL, DE
              	; destroys: A,F,HL
              	; returns: if both registers are 2's complement, use Z and S flags;
              	; otherwise:
              	; if HL=DE: Z,P,NC  - Z=1, S=0; C=0
              	; if HL>DE: NZ,P,NC - Z=0, S=0; C=0
              	; if HL<DE: NZ,M,C  - Z=0, S=1; C=1
              	; Source: ALS
              	
3C5F: B7      	CMP16:  or      A           ; clear CARRY
3C60: ED52    	        sbc     HL,DE       ; subtract DE from HL
3C62: E0      	        ret     PO          ; return if no overflow
3C63: 7C      	        ld      A,H         ; overflow - invert SIGN flag
3C64: 1F      	        rra                 ; save CARRY flag in bit 7
3C65: EE40    	        xor     %01000000   ; complement bit 6 (SIGN bit)
3C67: 37      	        scf                 ; ensure a Non-Zero result
3C68: 8F      	        adc     A,A         ; restore CARRY, complemented SIGN
              	                            ; ZERO flag = 0 for sure
3C69: C9      	        ret                 ; return
              	
              	; ----------------------------------------------------------------------
              	
              	; multiply 2 signed/unsigned 16-bit words and return a 16-bit
              	; signed/unsigned product
              	; inputs: HL (multiplicand); DE (multiplier)
              	; destroys: A,F
              	; returns: HL (product)
              	; Source: ALS
              	
              	; initialize partial product, bit count
3C6A: C5      	MUL16:  push    BC
3C6B: 4D      	        ld      C,L         ; BC = multiplier
3C6C: 44      	        ld      B,H
3C6D: 210000  	        ld      HL,0        ; product = 0
3C70: 3E0F    	        ld      A,$0F       ; count = bit lenght - 1 (16-1)
              	        ; shift-and-add algorithm
              	        ; if MSB of multiplier is 1, add multiplicand to partial product
              	        ; shift partial product, multiplier left 1 bit
3C72: CB23    	MLP:    sla     E           ; shift multiplier left 1 bit
3C74: CB12    	        rl      D
3C76: 3001    	        jr      NC,MLP1     ; jump if MSB of multiplier = 0
3C78: 09      	        add     HL,BC       ; add multiplicand to partial product
3C79: 29      	MLP1:   add     HL,HL       ; shift partial product left
3C7A: 3D      	        dec     A
3C7B: 20F5    	        jr      NZ,MLP      ; continue until count = 0
              	        ; add multiplicand one last time if MSB of multiplier is 1
3C7D: B2      	        or      D           ; sign flag = MSB of multiplier
3C7E: F2823C  	        jp      P,EXMUL16   ; exit if MSB of multiplier is 0
3C81: 09      	        add     HL,BC       ; add multiplicand to product
3C82: C1      	EXMUL16:pop     BC
3C83: C9      	        ret
              	
              	; ----------------------------------------------------------------------
              	; absolute value of HL (same applies to other 16-bit register pairs)
              	; also, invert value of HL (or any other 16-bit register, just adjust the code)
              	;
              	; inputs: HL
              	; destroys: A
              	; operation: ABS(HL)
              	; returns: HL with no sign or negated
              	; Source: WKT
              	
3C84: CB7C    	absHL:  bit     7,H
3C86: C8      	        ret     Z
3C87: AF      	negHL:  xor     A
3C88: 95      	        sub     L
3C89: 6F      	        ld      L,A
3C8A: 9F      	        sbc     A,A
3C8B: 94      	        sub     H
3C8C: 67      	        ld      H,A
3C8D: C9      	        ret
              	
              	; ------------------------------------------------------------------------------
              	
              	; 8/8 division
              	; INPUT: D (dividend), E (divisor)
              	; OPERATION: D/E
              	; OUTPUT: D (quotient), A (remainder)
3C8E: AF      	DIV_8_8:    xor     A
3C8F: C5      	            push    BC
3C90: 0608    	            ld      B,08h
3C92: CB22    	DIV_8_8LOOP:sla     D
3C94: 17      	            rla
3C95: BB      	            cp      E
3C96: 3802    	            jr      C,$+4
3C98: 93      	            sub     E
3C99: 14      	            inc     D
3C9A: 10F6    	            djnz    DIV_8_8LOOP
3C9C: C1      	            pop     BC
3C9D: C9      	            ret
              	
              	; ----------------------------------------------------------------------
              	; divide a 16-bit number by an 8-bit number
              	; (16/8 division)
              	;
              	; inputs: HL (Dividend), C (divisor)
              	; destroys: A
              	; OPERATION: HL/C
              	; returns: HL (quotient), A (remainder)
              	; source: WKT
              	
3C9E: AF      	DIV_16_8:   xor     A
3C9F: 0610    	            ld      B,16
3CA1: 29      	DIV_16_8LP: add     HL,HL
3CA2: 17      	            rla
3CA3: 3803    	            jr      C,$+5
3CA5: B9      	            cp      C
3CA6: 3802    	            jr      C,$+4
3CA8: 91      	            sub     C
3CA9: 2C      	            inc     L
3CAA: 10F5    	            djnz    DIV_16_8LP
3CAC: C9      	            ret; ------------------------------------------------------------------------------
              	; LM80C - 6x8 CHARSET - R1.5
              	; ------------------------------------------------------------------------------
              	; The following code is intended to be used with LM80C Z80-based computer
              	; designed by Leonardo Miliani. More info at
              	; www DOT leonardomiliani DOT com
              	; ------------------------------------------------------------------------------
              	; Code Revision:
              	; R1.0 - 20190511 - First revision: ASCII chars (from 0 to 127)
              	; R1.1 - 20190521 - Expanded to 255 chars
              	; R1.2 - 20191209 - Start adding graphic chars to be coherent with 8x8 fonts
              	; R1.3 - 20191226 - Added extended char codes (128-255)
              	; R1.4 - 20200228 - adopted more usual hexadecimal & binary prefixes
              	; R1.5 - 20200524 - New style for char #252
              	; ------------------------------------------------------------------------------
              	;
              	;-------------------------------------------------------------------------------
              	;
              	;               6 x 8    C  H  A  R  S  E  T
              	;
              	;-------------------------------------------------------------------------------
              	;
              	;       6X8 CHARS, DESIGNED FOR TEXT BUT USABLE IN GRAPHICS 1 MODE TOO
              	;       UPDATE: NOW GRAPHICS 1 MODE HAS ITS OWN CHAR SET
              	
3CAD:         	CHRST68 equ $
3CAD: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 0 (null char)
3CB1: 00000000	
3CB5: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 1 F1
3CB9: 00000000	
3CBD: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 2 F2
3CC1: 00000000	
3CC5: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 3 CTRL-C
3CC9: 00000000	
3CCD: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 4 F3
3CD1: 00000000	
3CD5: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 5 F4
3CD9: 00000000	
3CDD: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 6 F5
3CE1: 00000000	
3CE5: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 7 (bell)
3CE9: 00000000	
3CED: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 8 (backspace)
3CF1: 00000000	
3CF5: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 9 (H. tab)
3CF9: 00000000	
3CFD: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 10 (line feed)
3D01: 00000000	
3D05: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 11 
3D09: 00000000	
3D0D: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 12 Form feed (clear screen)
3D11: 00000000	
3D15: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 13 (carriage return)
3D19: 00000000	
3D1D: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 14 CTRL
3D21: 00000000	
3D25: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 15 CTRL-O
3D29: 00000000	
3D2D: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 16 C=/Graphic key
3D31: 00000000	
3D35: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 17 CTRL-Q
3D39: 00000000	
3D3D: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 18 CTRL-R
3D41: 00000000	
3D45: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 19 CTRL-S
3D49: 00000000	
3D4D: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 20 SHIFT
3D51: 00000000	
3D55: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 21 CTRL-U
3D59: 00000000	
3D5D: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 22 F6
3D61: 00000000	
3D65: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 23 F7
3D69: 00000000	
3D6D: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 24 HELP
3D71: 00000000	
3D75: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 25 (home)
3D79: 00000000	
3D7D: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 26
3D81: 00000000	
3D85: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 27 (escape)
3D89: 00000000	
3D8D: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 28 (cursor left)
3D91: 00000000	
3D95: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 29 (cursor right)
3D99: 00000000	
3D9D: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 30 (cursor up)
3DA1: 00000000	
3DA5: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 31 (cursor down)
3DA9: 00000000	
3DAD: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 32: space
3DB1: 00000000	
3DB5: 20202020	        defb $20,$20,$20,$20,$20,$00,$20,$00 ; char 33: !
3DB9: 20002000	
3DBD: 50500000	        defb $50,$50,$00,$00,$00,$00,$00,$00 ; char 34: "
3DC1: 00000000	
3DC5: 5050F850	        defb $50,$50,$f8,$50,$f8,$50,$50,$00 ; char 35: #
3DC9: F8505000	
3DCD: 2078A070	        defb $20,$78,$a0,$70,$28,$f0,$20,$00 ; char 36: $
3DD1: 28F02000	
3DD5: C0C81020	        defb $c0,$c8,$10,$20,$40,$98,$18,$00 ; char 37: %
3DD9: 40981800	
3DDD: 6090A040	        defb $60,$90,$a0,$40,$a8,$90,$68,$00 ; char 38: &
3DE1: A8906800	
3DE5: 60204000	        defb $60,$20,$40,$00,$00,$00,$00,$00 ; char 39: '
3DE9: 00000000	
3DED: 10204040	        defb $10,$20,$40,$40,$40,$20,$10,$00 ; char 40: (
3DF1: 40201000	
3DF5: 40201010	        defb $40,$20,$10,$10,$10,$20,$40,$00 ; char 41: )
3DF9: 10204000	
3DFD: 0020A870	        defb $00,$20,$a8,$70,$a8,$20,$00,$00 ; char 42: *
3E01: A8200000	
3E05: 002020F8	        defb $00,$20,$20,$f8,$20,$20,$00,$00 ; char 43: +
3E09: 20200000	
3E0D: 00000000	        defb $00,$00,$00,$00,$60,$20,$40,$00 ; char 44: ,
3E11: 60204000	
3E15: 000000F8	        defb $00,$00,$00,$f8,$00,$00,$00,$00 ; char 45: -
3E19: 00000000	
3E1D: 00000000	        defb $00,$00,$00,$00,$00,$60,$60,$00 ; char 46: .
3E21: 00606000	
3E25: 00081020	        defb $00,$08,$10,$20,$40,$80,$00,$00 ; char 47: /
3E29: 40800000	
3E2D: 708898A8	        defb $70,$88,$98,$a8,$c8,$88,$70,$00 ; char 48: 0
3E31: C8887000	
3E35: 20602020	        defb $20,$60,$20,$20,$20,$20,$70,$00 ; char 49: 1
3E39: 20207000	
3E3D: 70880810	        defb $70,$88,$08,$10,$20,$40,$f8,$00 ; char 50: 2
3E41: 2040F800	
3E45: F8102010	        defb $f8,$10,$20,$10,$08,$88,$70,$00 ; char 51: 3
3E49: 08887000	
3E4D: 10305090	        defb $10,$30,$50,$90,$f8,$10,$10,$00 ; char 52: 4
3E51: F8101000	
3E55: F880F008	        defb $f8,$80,$f0,$08,$08,$88,$70,$00 ; char 53: 5
3E59: 08887000	
3E5D: 304080F0	        defb $30,$40,$80,$f0,$88,$88,$70,$00 ; char 54: 6
3E61: 88887000	
3E65: F8081020	        defb $f8,$08,$10,$20,$40,$40,$40,$00 ; char 55: 7
3E69: 40404000	
3E6D: 70888870	        defb $70,$88,$88,$70,$88,$88,$70,$00 ; char 56: 8
3E71: 88887000	
3E75: 70888878	        defb $70,$88,$88,$78,$08,$10,$60,$00 ; char 57: 9
3E79: 08106000	
3E7D: 00303000	        defb $00,$30,$30,$00,$30,$30,$00,$00 ; char 58: :
3E81: 30300000	
3E85: 00303000	        defb $00,$30,$30,$00,$30,$10,$20,$00 ; char 59: ;
3E89: 30102000	
3E8D: 10204080	        defb $10,$20,$40,$80,$40,$20,$10,$00 ; char 60: <
3E91: 40201000	
3E95: 0000F800	        defb $00,$00,$f8,$00,$f8,$00,$00,$00 ; char 61: =
3E99: F8000000	
3E9D: 40201008	        defb $40,$20,$10,$08,$10,$20,$40,$00 ; char 62: >
3EA1: 10204000	
3EA5: 70880810	        defb $70,$88,$08,$10,$20,$00,$20,$00 ; char 63: ?
3EA9: 20002000	
3EAD: 70880868	        defb $70,$88,$08,$68,$a8,$a8,$70,$00 ; char 64: @
3EB1: A8A87000	
3EB5: 70888888	        defb $70,$88,$88,$88,$f8,$88,$88,$00 ; char 65: A
3EB9: F8888800	
3EBD: F08888F0	        defb $f0,$88,$88,$f0,$88,$88,$f0,$00 ; char 66: B
3EC1: 8888F000	
3EC5: 70888080	        defb $70,$88,$80,$80,$80,$88,$70,$00 ; char 67: C
3EC9: 80887000	
3ECD: E0908888	        defb $e0,$90,$88,$88,$88,$90,$e0,$00 ; char 68: D
3ED1: 8890E000	
3ED5: F88080F0	        defb $f8,$80,$80,$f0,$80,$80,$f8,$00 ; char 69: E
3ED9: 8080F800	
3EDD: F88080F0	        defb $f8,$80,$80,$f0,$80,$80,$80,$00 ; char 70: F
3EE1: 80808000	
3EE5: 708880B8	        defb $70,$88,$80,$b8,$88,$88,$78,$00 ; char 71: G
3EE9: 88887800	
3EED: 888888F8	        defb $88,$88,$88,$f8,$88,$88,$88,$00 ; char 72: H
3EF1: 88888800	
3EF5: 70202020	        defb $70,$20,$20,$20,$20,$20,$70,$00 ; char 73: I
3EF9: 20207000	
3EFD: 38101010	        defb $38,$10,$10,$10,$10,$90,$60,$00 ; char 74: J
3F01: 10906000	
3F05: 8890A0C0	        defb $88,$90,$a0,$c0,$a0,$90,$88,$00 ; char 75: K
3F09: A0908800	
3F0D: 80808080	        defb $80,$80,$80,$80,$80,$80,$f8,$00 ; char 76: L
3F11: 8080F800	
3F15: 88D8A8A8	        defb $88,$d8,$a8,$a8,$88,$88,$88,$00 ; char 77: M
3F19: 88888800	
3F1D: 88C8A898	        defb $88,$c8,$a8,$98,$88,$88,$88,$00 ; char 78: N
3F21: 88888800	
3F25: 70888888	        defb $70,$88,$88,$88,$88,$88,$70,$00 ; char 79: O
3F29: 88887000	
3F2D: F08888F0	        defb $f0,$88,$88,$f0,$80,$80,$80,$00 ; char 80: P
3F31: 80808000	
3F35: 70888888	        defb $70,$88,$88,$88,$a8,$90,$68,$00 ; char 81: Q
3F39: A8906800	
3F3D: F08888F0	        defb $f0,$88,$88,$f0,$a0,$90,$88,$00 ; char 82: R
3F41: A0908800	
3F45: 78808070	        defb $78,$80,$80,$70,$08,$08,$f0,$00 ; char 83: S
3F49: 0808F000	
3F4D: F8202020	        defb $f8,$20,$20,$20,$20,$20,$20,$00 ; char 84: T
3F51: 20202000	
3F55: 88888888	        defb $88,$88,$88,$88,$88,$88,$70,$00 ; char 85: U
3F59: 88887000	
3F5D: 88888888	        defb $88,$88,$88,$88,$88,$50,$20,$00 ; char 86: V
3F61: 88502000	
3F65: 88888888	        defb $88,$88,$88,$88,$a8,$a8,$50,$00 ; char 87: W
3F69: A8A85000	
3F6D: 88885020	        defb $88,$88,$50,$20,$50,$88,$88,$00 ; char 88: X
3F71: 50888800	
3F75: 88888850	        defb $88,$88,$88,$50,$20,$20,$20,$00 ; char 89: Y
3F79: 20202000	
3F7D: F8081020	        defb $f8,$08,$10,$20,$40,$80,$f8,$00 ; char 90: Z
3F81: 4080F800	
3F85: 70404040	        defb $70,$40,$40,$40,$40,$40,$70,$00 ; char 91: [
3F89: 40407000	
3F8D: 00804020	        defb $00,$80,$40,$20,$10,$08,$00,$00 ; char 92: \
3F91: 10080000	
3F95: 70101010	        defb $70,$10,$10,$10,$10,$10,$70,$00 ; char 93: ]
3F99: 10107000	
3F9D: 20508800	        defb $20,$50,$88,$00,$00,$00,$00,$00 ; char 94: ^
3FA1: 00000000	
3FA5: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$FC ; char 95: _ (underscore)
3FA9: 000000FC	
3FAD: 40201000	        defb $40,$20,$10,$00,$00,$00,$00,$00 ; char 96: `
3FB1: 00000000	
3FB5: 00007008	        defb $00,$00,$70,$08,$78,$88,$78,$00 ; char 97: a
3FB9: 78887800	
3FBD: 808080B0	        defb $80,$80,$80,$b0,$c8,$88,$f0,$00 ; char 98: b
3FC1: C888F000	
3FC5: 00007080	        defb $00,$00,$70,$80,$80,$88,$70,$00 ; char 99: c
3FC9: 80887000	
3FCD: 08080868	        defb $08,$08,$08,$68,$98,$88,$78,$00 ; char 100: d
3FD1: 98887800	
3FD5: 00007088	        defb $00,$00,$70,$88,$f8,$80,$70,$00 ; char 101: e
3FD9: F8807000	
3FDD: 304840E0	        defb $30,$48,$40,$e0,$40,$40,$40,$00 ; char 102: f
3FE1: 40404000	
3FE5: 00007888	        defb $00,$00,$78,$88,$78,$08,$70,$00 ; char 103: g
3FE9: 78087000	
3FED: 8080B0C8	        defb $80,$80,$b0,$c8,$88,$88,$88,$00 ; char 104: h
3FF1: 88888800	
3FF5: 00200020	        defb $00,$20,$00,$20,$20,$20,$20,$00 ; char 105: i
3FF9: 20202000	
3FFD: 00100030	        defb $00,$10,$00,$30,$10,$90,$60,$00 ; char 106: j
4001: 10906000	
4005: 808090A0	        defb $80,$80,$90,$a0,$c0,$a0,$90,$00 ; char 107: k
4009: C0A09000	
400D: 60202020	        defb $60,$20,$20,$20,$20,$20,$70,$00 ; char 108: l
4011: 20207000	
4015: 0000D0A8	        defb $00,$00,$d0,$a8,$a8,$88,$88,$00 ; char 109: m
4019: A8888800	
401D: 0000B0C8	        defb $00,$00,$b0,$c8,$88,$88,$88,$00 ; char 110: n
4021: 88888800	
4025: 00007088	        defb $00,$00,$70,$88,$88,$88,$70,$00 ; char 111: o
4029: 88887000	
402D: 0000F088	        defb $00,$00,$f0,$88,$f0,$80,$80,$00 ; char 112: p
4031: F0808000	
4035: 00007888	        defb $00,$00,$78,$88,$78,$08,$08,$00 ; char 113: q
4039: 78080800	
403D: 0000B0C8	        defb $00,$00,$b0,$c8,$80,$80,$80,$00 ; char 114: r
4041: 80808000	
4045: 00007080	        defb $00,$00,$70,$80,$70,$08,$f0,$00 ; char 115: s
4049: 7008F000	
404D: 4040E040	        defb $40,$40,$e0,$40,$40,$48,$30,$00 ; char 116: t
4051: 40483000	
4055: 00008888	        defb $00,$00,$88,$88,$88,$98,$68,$00 ; char 117: u
4059: 88986800	
405D: 00008888	        defb $00,$00,$88,$88,$88,$50,$20,$00 ; char 118: v
4061: 88502000	
4065: 00008888	        defb $00,$00,$88,$88,$a8,$a8,$50,$00 ; char 119: w
4069: A8A85000	
406D: 00008850	        defb $00,$00,$88,$50,$20,$50,$88,$00 ; char 120: x
4071: 20508800	
4075: 00008898	        defb $00,$00,$88,$98,$68,$08,$70,$00 ; char 121: y
4079: 68087000	
407D: 0000F810	        defb $00,$00,$f8,$10,$20,$40,$f8,$00 ; char 122: z
4081: 2040F800	
4085: 10202040	        defb $10,$20,$20,$40,$20,$20,$10,$00 ; char 123: {
4089: 20201000	
408D: 20202020	        defb $20,$20,$20,$20,$20,$20,$20,$00 ; char 124: |
4091: 20202000	
4095: 20101008	        defb $20,$10,$10,$08,$10,$10,$20,$00 ; char 125: }
4099: 10102000	
409D: 00285000	        defb $00,$28,$50,$00,$00,$00,$00,$00 ; char 126: ~
40A1: 00000000	
40A5: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 127: (delete) - here end the standard ASCII (0-127)
40A9: 00000000	
40AD: 7884CC84	        defb %01111000,%10000100,%11001100,%10000100,%10110100,%10000100,%01111000,%00000000 ; char 128 (open face)
40B1: B4847800	
40B5: 78FCB4FC	        defb %01111000,%11111100,%10110100,%11111100,%10110100,%11001100,%01111000,%00000000 ; char 129 (full face)
40B9: B4CC7800	
40BD: 48FCFCFC	        defb %01001000,%11111100,%11111100,%11111100,%11111100,%01111000,%00110000,%00000000 ; char 130 (hearts)
40C1: FC783000	
40C5: 002070F8	        defb %00000000,%00100000,%01110000,%11111000,%11111000,%01110000,%00100000,%00000000 ; char 131 (diamonds)
40C9: F8702000	
40CD: 7020A8F8	        defb %01110000,%00100000,%10101000,%11111000,%10101000,%00100000,%01110000,%00000000 ; char 132 (clubs)
40D1: A8207000	
40D5: 2070F8F8	        defb %00100000,%01110000,%11111000,%11111000,%10101000,%00100000,%01110000,%00000000 ; char 133 (spades)
40D9: A8207000	
40DD: 303030FC	        defb %00110000,%00110000,%00110000,%11111100,%11111100,%00110000,%00110000,%00110000 ; char 134 
40E1: FC303030	
40E5: 0000003C	        defb %00000000,%00000000,%00000000,%00111100,%00111100,%00110000,%00110000,%00110000 ; char 135 
40E9: 3C303030	
40ED: 000000F0	        defb %00000000,%00000000,%00000000,%11110000,%11110000,%00110000,%00110000,%00110000 ; char 136 
40F1: F0303030	
40F5: 303030F0	        defb %00110000,%00110000,%00110000,%11110000,%11110000,%00000000,%00000000,%00000000 ; char 137 
40F9: F0000000	
40FD: 3030303C	        defb %00110000,%00110000,%00110000,%00111100,%00111100,%00000000,%00000000,%00000000 ; char 138 
4101: 3C000000	
4105: 303030FC	        defb %00110000,%00110000,%00110000,%11111100,%11111100,%00000000,%00000000,%00000000 ; char 139 
4109: FC000000	
410D: 3030303C	        defb %00110000,%00110000,%00110000,%00111100,%00111100,%00110000,%00110000,%00110000 ; char 140 
4111: 3C303030	
4115: 000000FC	        defb %00000000,%00000000,%00000000,%11111100,%11111100,%00110000,%00110000,%00110000 ; char 141 
4119: FC303030	
411D: 303030F0	        defb %00110000,%00110000,%00110000,%11110000,%11110000,%00110000,%00110000,%00110000 ; char 142 
4121: F0303030	
4125: 000000FC	        defb %00000000,%00000000,%00000000,%11111100,%11111100,%00000000,%00000000,%00000000 ; char 143 
4129: FC000000	
412D: 30303030	        defb %00110000,%00110000,%00110000,%00110000,%00110000,%00110000,%00110000,%00110000 ; char 144 
4131: 30303030	
4135: 0C1C1838	        defb %00001100,%00011100,%00011000,%00111000,%01110000,%01100000,%11100000,%11000000 ; char 145 
4139: 7060E0C0	
413D: C0E06070	        defb %11000000,%11100000,%01100000,%01110000,%00111000,%00011000,%00011100,%00001100 ; char 146 
4141: 38181C0C	
4145: CCCC7830	        defb %11001100,%11001100,%01111000,%00110000,%00110000,%01111000,%11001100,%11001100 ; char 147 
4149: 3078CCCC	
414D: 202020FC	        defb %00100000,%00100000,%00100000,%11111100,%00100000,%00100000,%00100000,%00100000 ; char 148 
4151: 20202020	
4155: 0000003C	        defb %00000000,%00000000,%00000000,%00111100,%00100000,%00100000,%00100000,%00100000 ; char 149 
4159: 20202020	
415D: 000000E0	        defb %00000000,%00000000,%00000000,%11100000,%00100000,%00100000,%00100000,%00100000 ; char 150 
4161: 20202020	
4165: 202020E0	        defb %00100000,%00100000,%00100000,%11100000,%00000000,%00000000,%00000000,%00000000 ; char 151 
4169: 00000000	
416D: 2020203C	        defb %00100000,%00100000,%00100000,%00111100,%00000000,%00000000,%00000000,%00000000 ; char 152 
4171: 00000000	
4175: 202020FC	        defb %00100000,%00100000,%00100000,%11111100,%00000000,%00000000,%00000000,%00000000 ; char 153 
4179: 00000000	
417D: 2020203C	        defb %00100000,%00100000,%00100000,%00111100,%00100000,%00100000,%00100000,%00100000 ; char 154 
4181: 20202020	
4185: 000000FC	        defb %00000000,%00000000,%00000000,%11111100,%00100000,%00100000,%00100000,%00100000 ; char 155 
4189: 20202020	
418D: 202020E0	        defb %00100000,%00100000,%00100000,%11100000,%00100000,%00100000,%00100000,%00100000 ; char 156 
4191: 20202020	
4195: 000000FC	        defb %00000000,%00000000,%00000000,%11111100,%00000000,%00000000,%00000000,%00000000 ; char 157 
4199: 00000000	
419D: 20202020	        defb %00100000,%00100000,%00100000,%00100000,%00100000,%00100000,%00100000,%00100000 ; char 158 
41A1: 20202020	
41A5: 04080810	        defb %00000100,%00001000,%00001000,%00010000,%00100000,%01000000,%01000000,%10000000 ; char 159 
41A9: 20404080	
41AD: 80404020	        defb %10000000,%01000000,%01000000,%00100000,%00010000,%00001000,%00001000,%00000100 ; char 160 
41B1: 10080804	
41B5: 84484830	        defb %10000100,%01001000,%01001000,%00110000,%00110000,%01001000,%01001000,%10000100 ; char 161 
41B9: 30484884	
41BD: 00000000	        defb %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%11111100,%11111100 ; char 162 
41C1: 0000FCFC	
41C5: 00000000	        defb %00000000,%00000000,%00000000,%00000000,%11111100,%11111100,%11111100,%11111100 ; char 163 
41C9: FCFCFCFC	
41CD: 0000FCFC	        defb %00000000,%00000000,%11111100,%11111100,%11111100,%11111100,%11111100,%11111100 ; char 164 
41D1: FCFCFCFC	
41D5: FCFC0000	        defb %11111100,%11111100,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 165 
41D9: 00000000	
41DD: FCFCFCFC	        defb %11111100,%11111100,%11111100,%11111100,%00000000,%00000000,%00000000,%00000000 ; char 166 
41E1: 00000000	
41E5: FCFCFCFC	        defb %11111100,%11111100,%11111100,%11111100,%11111100,%11111100,%00000000,%00000000 ; char 167 
41E9: FCFC0000	
41ED: 80808080	        defb %10000000,%10000000,%10000000,%10000000,%10000000,%10000000,%10000000,%10000000 ; char 168 
41F1: 80808080	
41F5: E0E0E0E0	        defb %11100000,%11100000,%11100000,%11100000,%11100000,%11100000,%11100000,%11100000 ; char 169 
41F9: E0E0E0E0	
41FD: F8F8F8F8	        defb %11111000,%11111000,%11111000,%11111000,%11111000,%11111000,%11111000,%11111000 ; char 170 
4201: F8F8F8F8	
4205: 04040404	        defb %00000100,%00000100,%00000100,%00000100,%00000100,%00000100,%00000100,%00000100 ; char 171 
4209: 04040404	
420D: 1C1C1C1C	        defb %00011100,%00011100,%00011100,%00011100,%00011100,%00011100,%00011100,%00011100 ; char 172 
4211: 1C1C1C1C	
4215: 7C7C7C7C	        defb %01111100,%01111100,%01111100,%01111100,%01111100,%01111100,%01111100,%01111100 ; char 173 
4219: 7C7C7C7C	
421D: FC848484	        defb %11111100,%10000100,%10000100,%10000100,%10000100,%10000100,%10000100,%11111100 ; char 174 
4221: 848484FC	
4225: 00000000	        defb %00000000,%00000000,%00000000,%00000000,%11100000,%11100000,%11100000,%11100000 ; char 175 
4229: E0E0E0E0	
422D: 00000000	        defb %00000000,%00000000,%00000000,%00000000,%00011100,%00011100,%00011100,%00011100 ; char 176 
4231: 1C1C1C1C	
4235: 1C1C1C1C	        defb %00011100,%00011100,%00011100,%00011100,%00000000,%00000000,%00000000,%00000000 ; char 177 
4239: 00000000	
423D: E0E0E0E0	        defb %11100000,%11100000,%11100000,%11100000,%00000000,%00000000,%00000000,%00000000 ; char 178 
4241: 00000000	
4245: E0E0E0E0	        defb %11100000,%11100000,%11100000,%11100000,%00011100,%00011100,%00011100,%00011100 ; char 179 
4249: 1C1C1C1C	
424D: 1C1C1C1C	        defb %00011100,%00011100,%00011100,%00011100,%11100000,%11100000,%11100000,%11100000 ; char 180 
4251: E0E0E0E0	
4255: 78787878	        defb %01111000,%01111000,%01111000,%01111000,%01111000,%01111000,%01111000,%01111000 ; char 181 
4259: 78787878	
425D: CCCCCCCC	        defb %11001100,%11001100,%11001100,%11001100,%11001100,%11001100,%11001100,%11001100 ; char 182 
4261: CCCCCCCC	
4265: FCFC0000	        defb %11111100,%11111100,%00000000,%00000000,%00000000,%00000000,%11111100,%11111100 ; char 183 
4269: 0000FCFC	
426D: 0000FCFC	        defb %00000000,%00000000,%11111100,%11111100,%11111100,%11111100,%00000000,%00000000 ; char 184 
4271: FCFC0000	
4275: 3030CCCC	        defb %00110000,%00110000,%11001100,%11001100,%00110000,%00110000,%11001100,%11001100 ; char 185 
4279: 3030CCCC	
427D: 54A854A8	        defb %01010100,%10101000,%01010100,%10101000,%01010100,%10101000,%01010100,%10101000 ; char 186 
4281: 54A854A8	
4285: 643098CC	        defb %01100100,%00110000,%10011000,%11001100,%01100100,%00110000,%10011000,%11001100 ; char 187 
4289: 643098CC	
428D: CC643098	        defb %11001100,%01100100,%00110000,%10011000,%11001100,%01100100,%00110000,%10011000 ; char 188 
4291: CC643098	
4295: 3098CC64	        defb %00110000,%10011000,%11001100,%01100100,%00110000,%10011000,%11001100,%01100100 ; char 189 
4299: 3098CC64	
429D: 64CC9830	        defb %01100100,%11001100,%10011000,%00110000,%01100100,%11001100,%10011000,%00110000 ; char 190 
42A1: 64CC9830	
42A5: 2020F820	        defb %00100000,%00100000,%11111000,%00100000,%00100000,%00000000,%11111000,%00000000 ; char 191 (±)
42A9: 2000F800	
42AD: C0300830	        defb %11000000,%00110000,%00001000,%00110000,%11000000,%00000000,%11111000,%00000000 ; char 192 (≥)
42B1: C000F800	
42B5: 18608060	        defb %00011000,%01100000,%10000000,%01100000,%00011000,%00000000,%11111000,%00000000 ; char 193 (≤)
42B9: 1800F800	
42BD: 3C202020	        defb %00111100,%00100000,%00100000,%00100000,%10100000,%01100000,%00100000,%00000000 ; char 194 (square root)
42C1: A0602000	
42C5: 30484830	        defb %00110000,%01001000,%01001000,%00110000,%00000000,%00000000,%00000000,%00000000 ; char 195 (°)
42C9: 00000000	
42CD: 60103040	        defb %01100000,%00010000,%00110000,%01000000,%01110000,%00000000,%00000000,%00000000 ; char 196 (²)
42D1: 70000000	
42D5: 000054A8	        defb %00000000,%00000000,%01010100,%10101000,%00000000,%11111100,%00000000,%00000000 ; char 197
42D9: 00FC0000	
42DD: 0054A800	        defb %00000000,%01010100,%10101000,%00000000,%01010100,%10101000,%00000000,%00000000 ; char 198 (≈)
42E1: 54A80000	
42E5: 0080C0E0	        defb %00000000,%10000000,%11000000,%11100000,%11100000,%11000000,%10000000,%00000000 ; char 199
42E9: E0C08000	
42ED: FC783000	        defb %11111100,%01111000,%00110000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 200
42F1: 00000000	
42F5: 00040C1C	        defb %00000000,%00000100,%00001100,%00011100,%00011100,%00001100,%00000100,%00000000 ; char 201
42F9: 1C0C0400	
42FD: 00000000	        defb %00000000,%00000000,%00000000,%00000000,%00000000,%00110000,%01111000,%11111100 ; char 202 
4301: 003078FC	
4305: 2070F820	        defb %00100000,%01110000,%11111000,%00100000,%00100000,%00100000,%00100000,%00000000 ; char 203 (up arrow)
4309: 20202000	
430D: 3C1C1C24	        defb %00111100,%00011100,%00011100,%00100100,%01000000,%10000000,%00000000,%00000000 ; char 204 (up right arrow)
4311: 40800000	
4315: 001018FC	        defb %00000000,%00010000,%00011000,%11111100,%00011000,%00010000,%00000000,%00000000 ; char 205 (right arrow)
4319: 18100000	
431D: 00008040	        defb %00000000,%00000000,%10000000,%01000000,%00100100,%00011100,%00011100,%00111100 ; char 206 (down right arrow)
4321: 241C1C3C	
4325: 00202020	        defb %00000000,%00100000,%00100000,%00100000,%00100000,%11111000,%01110000,%00100000 ; char 207 (down arrow)
4329: 20F87020	
432D: 00000408	        defb %00000000,%00000000,%00000100,%00001000,%10010000,%11100000,%11100000,%11110000 ; char 208 (down left arrow)
4331: 90E0E0F0	
4335: 002060FC	        defb %00000000,%00100000,%01100000,%11111100,%01100000,%00100000,%00000000,%00000000 ; char 209 (left arrow)
4339: 60200000	
433D: F0E0E090	        defb %11110000,%11100000,%11100000,%10010000,%00001000,%00000100,%00000000,%00000000 ; char 210 (up left arrow)
4341: 08040000	
4345: 3844F040	        defb %00111000,%01000100,%11110000,%01000000,%11110000,%01000100,%00111000,%00000000 ; char 211 (euro)
4349: F0443800	
434D: 000478A8	        defb %00000000,%00000100,%01111000,%10101000,%00101000,%00101000,%00101000,%00000000 ; char 212 (greek pi)
4351: 28282800	
4355: 00000000	        defb %00000000,%00000000,%00000000,%00000000,%00011100,%00100000,%00100000,%00100000 ; char 213
4359: 1C202020	
435D: 00000000	        defb %00000000,%00000000,%00000000,%00000000,%11100000,%00010000,%00010000,%00010000 ; char 214
4361: E0101010	
4365: 101010E0	        defb %00010000,%00010000,%00010000,%11100000,%00000000,%00000000,%00000000,%00000000 ; char 215
4369: 00000000	
436D: 2020201C	        defb %00100000,%00100000,%00100000,%00011100,%00000000,%00000000,%00000000,%00000000 ; char 216
4371: 00000000	
4375: 0000001C	        defb %00000000,%00000000,%00000000,%00011100,%00111100,%00110000,%00110000,%00110000 ; char 217
4379: 3C303030	
437D: 000000E0	        defb %00000000,%00000000,%00000000,%11100000,%11110000,%00110000,%00110000,%00110000 ; char 218
4381: F0303030	
4385: 303030F0	        defb %00110000,%00110000,%00110000,%11110000,%11100000,%00000000,%00000000,%00000000 ; char 219
4389: E0000000	
438D: 3030303C	        defb %00110000,%00110000,%00110000,%00111100,%00011100,%00000000,%00000000,%00000000 ; char 220
4391: 1C000000	
4395: 00304848	        defb %00000000,%00110000,%01001000,%01001000,%01001000,%00110000,%00000000,%00000000 ; char 221
4399: 48300000	
439D: 00307878	        defb %00000000,%00110000,%01111000,%01111000,%01111000,%00110000,%00000000,%00000000 ; char 222
43A1: 78300000	
43A5: 003078FC	        defb %00000000,%00110000,%01111000,%11111100,%11111100,%01111000,%00110000,%00000000 ; char 223
43A9: FC783000	
43AD: FCF8F0E0	        defb %11111100,%11111000,%11110000,%11100000,%11100000,%11000000,%10000000,%10000000 ; char 224
43B1: E0C08080	
43B5: FC7C3C1C	        defb %11111100,%01111100,%00111100,%00011100,%00011100,%00001100,%00000100,%00000100 ; char 225
43B9: 1C0C0404	
43BD: 04040C1C	        defb %00000100,%00000100,%00001100,%00011100,%00011100,%00111100,%01111100,%11111100 ; char 226
43C1: 1C3C7CFC	
43C5: 8080C0E0	        defb %10000000,%10000000,%11000000,%11100000,%11100000,%11110000,%11111000,%11111100 ; char 227
43C9: E0F0F8FC	
43CD: 00040CD8	        defb %00000000,%00000100,%00001100,%11011000,%11110000,%11100000,%11000000,%00000000 ; char 228 (checkmark)
43D1: F0E0C000	
43D5: 00CC7830	        defb %00000000,%11001100,%01111000,%00110000,%01111000,%11001100,%00000000,%00000000 ; char 229 (x)
43D9: 78CC0000	
43DD: 70888888	        defb %01110000,%10001000,%10001000,%10001000,%01110000,%00100000,%01110000,%00100000 ; char 230 (female)
43E1: 70207020	
43E5: 001C0C74	        defb %00000000,%00011100,%00001100,%01110100,%10010000,%10010000,%01100000,%00000000 ; char 231 (male)
43E9: 90906000	
43ED: F8848484	        defb %11111000,%10000100,%10000100,%10000100,%10000100,%10000100,%10000100,%11111100 ; char 232 (new doc)
43F1: 848484FC	
43F5: 00F0FC84	        defb %00000000,%11110000,%11111100,%10000100,%10000100,%10000100,%10000100,%11111100 ; char 233 (folder)
43F9: 848484FC	
43FD: 3078FC48	        defb %00110000,%01111000,%11111100,%01001000,%01001000,%01001000,%01001000,%01111000 ; char 234 (trash bin)
4401: 48484878	
4405: FC848484	        defb %11111100,%10000100,%10000100,%10000100,%11111100,%10110100,%10110100,%11111100 ; char 235 (floppy disk)
4409: FCB4B4FC	
440D: 0000D4D8	        defb %00000000,%00000000,%11010100,%11011000,%11010100,%11010100,%00000000,%00000000 ; char 236 (OK)
4411: D4D40000	
4415: 3078FC78	        defb %00110000,%01111000,%11111100,%01111000,%01111000,%01001000,%01001000,%01001000 ; char 237 (home)
4419: 78484848	
441D: 7884A4A4	        defb %01111000,%10000100,%10100100,%10100100,%10110100,%10000100,%01111000,%00000000 ; char 238 (clock)
4421: B4847800	
4425: 000008F4	        defb %00000000,%00000000,%00001000,%11110100,%10101000,%10000000,%00000000,%00000000 ; char 239 (key)
4429: A8800000	
442D: 203078B0	        defb %00100000,%00110000,%01111000,%10110000,%10100000,%10001000,%01110000,%00000000 ; char 240 (undo)
4431: A0887000	
4435: 00FCCCB4	        defb %00000000,%11111100,%11001100,%10110100,%10000100,%10000100,%11111100,%00000000 ; char 241 (letter)
4439: 8484FC00	
443D: 609090F0	        defb %01100000,%10010000,%10010000,%11110000,%11110000,%11110000,%11110000,%00000000 ; char 242 (lock)
4441: F0F0F000	
4445: 081414F0	        defb %00001000,%00010100,%00010100,%11110000,%11110000,%11110000,%11110000,%00000000 ; char 243 (unlock)
4449: F0F0F000	
444D: FCFC84B4	        defb %11111100,%11111100,%10000100,%10110100,%10010100,%10010100,%10000100,%11111100 ; char 244 (calendar)
4451: 949484FC	
4455: 00043858	        defb %00000000,%00000100,%00111000,%01011000,%01101000,%01110000,%10000000,%00000000 ; char 245 (diameter)
4459: 68708000	
445D: 78848484	        defb %01111000,%10000100,%10000100,%10000100,%01101100,%00011000,%00001000,%00000000 ; char 246 (baloon)
4461: 6C180800	
4465: 30282828	        defb %00110000,%00101000,%00101000,%00101000,%00100000,%01100000,%11100000,%01000000 ; char 247 (note)
4469: 2060E040	
446D: 2068E4E4	        defb %00100000,%01101000,%11100100,%11100100,%11100100,%01101000,%00100000,%00000000 ; char 248 (audio on)
4471: E4682000	
4475: 2060E0E0	        defb %00100000,%01100000,%11100000,%11100000,%11100000,%01100000,%00100000,%00000000 ; char 249 (audio off)
4479: E0602000	
447D: 80C0E0F0	        defb %10000000,%11000000,%11100000,%11110000,%11111000,%11111100,%11110000,%10010000 ; char 250 (pointer)
4481: F8FCF090	
4485: 7884B4A4	        defb %01111000,%10000100,%10110100,%10100100,%10110100,%10000100,%01111000,%00000000 ; char 251 (©)
4489: B4847800	
448D: 304840E0	        defb %00110000,%01001000,%01000000,%11100000,%01000000,%01000100,%10111000,%00000000 ; char 252 (£)
4491: 4044B800	
4495: 7884F048	        defb %01111000,%10000100,%11110000,%01001000,%01001000,%00111100,%10000100,%01111000 ; char 253 (§)
4499: 483C8478	
449D: 00002000	        defb %00000000,%00000000,%00100000,%00000000,%11111000,%00000000,%00100000,%00000000 ; char 254 (÷)
44A1: F8002000	
44A5: FCFCFCFC	        defb %11111100,%11111100,%11111100,%11111100,%11111100,%11111100,%11111100,%11111100 ; char 255 (cursor)
44A9: FCFCFCFC	
              	        ; here ends the ASCII table
              	; ------------------------------------------------------------------------------
              	; LM80C - 8x8 CHARSET - R1.8
              	; ------------------------------------------------------------------------------
              	; The following code is intended to be used with LM80C Z80-based computer
              	; designed by Leonardo Miliani. More info at
              	; www DOT leonardomiliani DOT com
              	; ------------------------------------------------------------------------------
              	; Code Revision:
              	; R1.0 - 20190615 - First revision: ASCII chars (from 0 to 255) - actually, they are 6x8 pixels
              	; R1.1 - 20190616 - Converted to 8x8 pixels
              	; R1.2 - 20191013 - Added new graphic chars and reorganized previous ones
              	; R1.3 - 20191015 - More graphic chars
              	; R1.4 - 20191202 - Fixed char 11/12, added new special chars
              	; R1.5 - 20191210 - Changed several graphic chars
              	; R1.6 - 20200125 - Removed double chars, changed with new ones
              	; R1.7 - 20200228 - adopted more usual hexadecimal & binary prefixes
              	; R1.8 - 20200524 - New style for char #252
              	; ------------------------------------------------------------------------------
              	;
              	;-------------------------------------------------------------------------------
              	;
              	;               8 x 8    C  H  A  R  S  E  T
              	;
              	;-------------------------------------------------------------------------------
              	;
              	;       8X8 CHARS, DESIGNED FOR GRAPHICS 1 MODE
              	
44AD:         	CHRST88 equ $
44AD: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 0 (null char)
44B1: 00000000	
44B5: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 1 F1
44B9: 00000000	
44BD: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 2 F2
44C1: 00000000	
44C5: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 3 CTRL-C
44C9: 00000000	
44CD: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 4 F3
44D1: 00000000	
44D5: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 5 F4
44D9: 00000000	
44DD: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 6 F5
44E1: 00000000	
44E5: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 7 (bell)
44E9: 00000000	
44ED: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 8 (backspace)
44F1: 00000000	
44F5: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 9 (H. tab)
44F9: 00000000	
44FD: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 10 (line feed)
4501: 00000000	
4505: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 11 
4509: 00000000	
450D: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 12 Form feed (clear screen)
4511: 00000000	
4515: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 13 (carriage return)
4519: 00000000	
451D: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 14 CTRL
4521: 00000000	
4525: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 15 CTRL-O
4529: 00000000	
452D: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 16 C=/Graphic key
4531: 00000000	
4535: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 17 CTRL-Q
4539: 00000000	
453D: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 18 CTRL-R
4541: 00000000	
4545: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 19 CTRL-S
4549: 00000000	
454D: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 20 SHIFT
4551: 00000000	
4555: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 21 CTRL-U
4559: 00000000	
455D: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 22 F6
4561: 00000000	
4565: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 23 F7
4569: 00000000	
456D: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 24 HELP
4571: 00000000	
4575: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 25 (home)
4579: 00000000	
457D: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 26
4581: 00000000	
4585: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 27 (escape)
4589: 00000000	
458D: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 28 (cursor left)
4591: 00000000	
4595: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 29 (cursor right)
4599: 00000000	
459D: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 30 (cursor up)
45A1: 00000000	
45A5: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 31 (cursor down)
45A9: 00000000	
45AD: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 32 - space
45B1: 00000000	
45B5: 10101010	        defb %00010000,%00010000,%00010000,%00010000,%00010000,%00000000,%00010000,%00000000 ; char 33 - !
45B9: 10001000	
45BD: 28282800	        defb %00101000,%00101000,%00101000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 34 - "
45C1: 00000000	
45C5: 2828FE28	        defb %00101000,%00101000,%11111110,%00101000,%11111110,%00101000,%00101000,%00000000 ; char 35 - #
45C9: FE282800	
45CD: 103C5038	        defb %00010000,%00111100,%01010000,%00111000,%00010100,%01111000,%00010000,%00000000 ; char 36 - $
45D1: 14781000	
45D5: 00626408	        defb %00000000,%01100010,%01100100,%00001000,%00010000,%00100110,%01000110,%00000000 ; char 37 - %
45D9: 10264600	
45DD: 00304830	        defb %00000000,%00110000,%01001000,%00110000,%01001010,%01000100,%00111010,%00000000 ; char 38 - &
45E1: 4A443A00	
45E5: 08102000	        defb %00001000,%00010000,%00100000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 39 - '
45E9: 00000000	
45ED: 08102020	        defb %00001000,%00010000,%00100000,%00100000,%00100000,%00010000,%00001000,%00000000 ; char 40 - (
45F1: 20100800	
45F5: 20100808	        defb %00100000,%00010000,%00001000,%00001000,%00001000,%00010000,%00100000,%00000000 ; char 41 - )
45F9: 08102000	
45FD: 00105438	        defb %00000000,%00010000,%01010100,%00111000,%00111000,%01010100,%00010000,%00000000 ; char 42 - *
4601: 38541000	
4605: 0010107C	        defb %00000000,%00010000,%00010000,%01111100,%00010000,%00010000,%00000000,%00000000 ; char 43 - +
4609: 10100000	
460D: 00000000	        defb %00000000,%00000000,%00000000,%00000000,%00000000,%00011000,%00001000,%00010000 ; char 44 - ,
4611: 00180810	
4615: 0000007C	        defb %00000000,%00000000,%00000000,%01111100,%00000000,%00000000,%00000000,%00000000 ; char 45 - -
4619: 00000000	
461D: 00000000	        defb %00000000,%00000000,%00000000,%00000000,%00000000,%00011000,%00011000,%00000000 ; char 46 - .
4621: 00181800	
4625: 00020408	        defb %00000000,%00000010,%00000100,%00001000,%00010000,%00100000,%01000000,%00000000 ; char 47 - /
4629: 10204000	
462D: 38444C54	        defb %00111000,%01000100,%01001100,%01010100,%01100100,%01000100,%00111000,%00000000 ; char 48 - 0
4631: 64443800	
4635: 10305010	        defb %00010000,%00110000,%01010000,%00010000,%00010000,%00010000,%01111100,%00000000 ; char 49 - 1
4639: 10107C00	
463D: 38440408	        defb %00111000,%01000100,%00000100,%00001000,%00010000,%00100000,%01111100,%00000000 ; char 50 - 2
4641: 10207C00	
4645: 7C081008	        defb %01111100,%00001000,%00010000,%00001000,%00000100,%01000100,%00111000,%00000000 ; char 51 - 3
4649: 04443800	
464D: 08182848	        defb %00001000,%00011000,%00101000,%01001000,%01111100,%00001000,%00001000,%00000000 ; char 52 - 4
4651: 7C080800	
4655: 7C407804	        defb %01111100,%01000000,%01111000,%00000100,%00000100,%01000100,%00111000,%00000000 ; char 53 - 5
4659: 04443800	
465D: 38444078	        defb %00111000,%01000100,%01000000,%01111000,%01000100,%01000100,%00111000,%00000000 ; char 54 - 6
4661: 44443800	
4665: 7C040810	        defb %01111100,%00000100,%00001000,%00010000,%00100000,%00100000,%00100000,%00000000 ; char 55 - 7
4669: 20202000	
466D: 38444438	        defb %00111000,%01000100,%01000100,%00111000,%01000100,%01000100,%00111000,%00000000 ; char 56 - 8
4671: 44443800	
4675: 3844443C	        defb %00111000,%01000100,%01000100,%00111100,%00000100,%01000100,%00111000,%00000000 ; char 57 - 9
4679: 04443800	
467D: 00181800	        defb %00000000,%00011000,%00011000,%00000000,%00011000,%00011000,%00000000,%00000000 ; char 58 - :
4681: 18180000	
4685: 00181800	        defb %00000000,%00011000,%00011000,%00000000,%00011000,%00001000,%00010000,%00000000 ; char 59 - ;
4689: 18081000	
468D: 04081020	        defb %00000100,%00001000,%00010000,%00100000,%00010000,%00001000,%00000100,%00000000 ; char 60 - <
4691: 10080400	
4695: 00007E00	        defb %00000000,%00000000,%01111110,%00000000,%01111110,%00000000,%00000000,%00000000 ; char 61 - =
4699: 7E000000	
469D: 20100804	        defb %00100000,%00010000,%00001000,%00000100,%00001000,%00010000,%00100000,%00000000 ; char 62 - >
46A1: 08102000	
46A5: 38440408	        defb %00111000,%01000100,%00000100,%00001000,%00010000,%00000000,%00010000,%00000000 ; char 63 - ?
46A9: 10001000	
46AD: 7884BCAC	        defb %01111000,%10000100,%10111100,%10101100,%10111000,%10000000,%10000100,%01111000 ; char 64 - @
46B1: B8808478	
46B5: 38444444	        defb %00111000,%01000100,%01000100,%01000100,%01111100,%01000100,%01000100,%00000000 ; char 65 - A
46B9: 7C444400	
46BD: 78444478	        defb %01111000,%01000100,%01000100,%01111000,%01000100,%01000100,%01111000,%00000000 ; char 66 - B
46C1: 44447800	
46C5: 38444040	        defb %00111000,%01000100,%01000000,%01000000,%01000000,%01000100,%00111000,%00000000 ; char 67 - C
46C9: 40443800	
46CD: 78444444	        defb %01111000,%01000100,%01000100,%01000100,%01000100,%01000100,%01111000,%00000000 ; char 68 - D
46D1: 44447800	
46D5: 7C404070	        defb %01111100,%01000000,%01000000,%01110000,%01000000,%01000000,%01111100,%00000000 ; char 69 - E
46D9: 40407C00	
46DD: 7C404070	        defb %01111100,%01000000,%01000000,%01110000,%01000000,%01000000,%01000000,%00000000 ; char 70 - F
46E1: 40404000	
46E5: 38444040	        defb %00111000,%01000100,%01000000,%01000000,%01011100,%01000100,%00111000,%00000000 ; char 71 - G
46E9: 5C443800	
46ED: 4444447C	        defb %01000100,%01000100,%01000100,%01111100,%01000100,%01000100,%01000100,%00000000 ; char 72 - H
46F1: 44444400	
46F5: 38101010	        defb %00111000,%00010000,%00010000,%00010000,%00010000,%00010000,%00111000,%00000000 ; char 73 - I
46F9: 10103800	
46FD: 3C040404	        defb %00111100,%00000100,%00000100,%00000100,%00000100,%01000100,%00111000,%00000000 ; char 74 - J
4701: 04443800	
4705: 44444870	        defb %01000100,%01000100,%01001000,%01110000,%01001000,%01000100,%01000100,%00000000 ; char 75 - K
4709: 48444400	
470D: 40404040	        defb %01000000,%01000000,%01000000,%01000000,%01000000,%01000000,%01111100,%00000000 ; char 76 - L
4711: 40407C00	
4715: 42665A42	        defb %01000010,%01100110,%01011010,%01000010,%01000010,%01000010,%01000010,%00000000 ; char 77 - M
4719: 42424200	
471D: 4464544C	        defb %01000100,%01100100,%01010100,%01001100,%01000100,%01000100,%01000100,%00000000 ; char 78 - N
4721: 44444400	
4725: 38444444	        defb %00111000,%01000100,%01000100,%01000100,%01000100,%01000100,%00111000,%00000000 ; char 79 - O
4729: 44443800	
472D: 78444444	        defb %01111000,%01000100,%01000100,%01000100,%01111000,%01000000,%01000000,%00000000 ; char 80 - P
4731: 78404000	
4735: 38444444	        defb %00111000,%01000100,%01000100,%01000100,%01010100,%01001000,%00110100,%00000000 ; char 81 - Q
4739: 54483400	
473D: 78444444	        defb %01111000,%01000100,%01000100,%01000100,%01111000,%01001000,%01000100,%00000000 ; char 82 - R
4741: 78484400	
4745: 3C404038	        defb %00111100,%01000000,%01000000,%00111000,%00000100,%00000100,%01111000,%00000000 ; char 83 - S
4749: 04047800	
474D: 7C101010	        defb %01111100,%00010000,%00010000,%00010000,%00010000,%00010000,%00010000,%00000000 ; char 84 - T
4751: 10101000	
4755: 44444444	        defb %01000100,%01000100,%01000100,%01000100,%01000100,%01000100,%00111000,%00000000 ; char 85 - U
4759: 44443800	
475D: 44444444	        defb %01000100,%01000100,%01000100,%01000100,%01000100,%00101000,%00010000,%00000000 ; char 86 - V
4761: 44281000	
4765: 42424242	        defb %01000010,%01000010,%01000010,%01000010,%01011010,%01011010,%00100100,%00000000 ; char 87 - W
4769: 5A5A2400	
476D: 44442810	        defb %01000100,%01000100,%00101000,%00010000,%00101000,%01000100,%01000100,%00000000 ; char 88 - X
4771: 28444400	
4775: 44444428	        defb %01000100,%01000100,%01000100,%00101000,%00010000,%00010000,%00010000,%00000000 ; char 89 - Y
4779: 10101000	
477D: 7C040810	        defb %01111100,%00000100,%00001000,%00010000,%00100000,%01000000,%01111100,%00000000 ; char 90 - Z
4781: 20407C00	
4785: 38202020	        defb %00111000,%00100000,%00100000,%00100000,%00100000,%00100000,%00111000,%00000000 ; char 91 - [
4789: 20203800	
478D: 00402010	        defb %00000000,%01000000,%00100000,%00010000,%00001000,%00000100,%00000010,%00000000 ; char 92 - \
4791: 08040200	
4795: 38080808	        defb %00111000,%00001000,%00001000,%00001000,%00001000,%00001000,%00111000,%00000000 ; char 93 - ]
4799: 08083800	
479D: 10284400	        defb %00010000,%00101000,%01000100,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 94 - ^
47A1: 00000000	
47A5: 00000000	        defb %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%01111110,%00000000 ; char 95 _ (underscore)
47A9: 00007E00	
47AD: 20100800	        defb %00100000,%00010000,%00001000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 96 - `
47B1: 00000000	
47B5: 00003804	        defb %00000000,%00000000,%00111000,%00000100,%00111100,%01000100,%00111100,%00000000 ; char 97 - a
47B9: 3C443C00	
47BD: 40404078	        defb %01000000,%01000000,%01000000,%01111000,%01000100,%01000100,%01111000,%00000000 ; char 98 - b
47C1: 44447800	
47C5: 00003840	        defb %00000000,%00000000,%00111000,%01000000,%01000000,%01000100,%00111000,%00000000 ; char 99 - c
47C9: 40443800	
47CD: 0404043C	        defb %00000100,%00000100,%00000100,%00111100,%01000100,%01000100,%00111100,%00000000 ; char 100 - d
47D1: 44443C00	
47D5: 00003844	        defb %00000000,%00000000,%00111000,%01000100,%01111100,%01000000,%00111000,%00000000 ; char 101 - e
47D9: 7C403800	
47DD: 18242070	        defb %00011000,%00100100,%00100000,%01110000,%00100000,%00100000,%00100000,%00000000 ; char 102 - f
47E1: 20202000	
47E5: 00003C44	        defb %00000000,%00000000,%00111100,%01000100,%01000100,%00111100,%00000100,%00111000 ; char 103 - g
47E9: 443C0438	
47ED: 40405864	        defb %01000000,%01000000,%01011000,%01100100,%01000100,%01000100,%01000100,%00000000 ; char 104 - h
47F1: 44444400	
47F5: 00100010	        defb %00000000,%00010000,%00000000,%00010000,%00010000,%00010000,%00010000,%00000000 ; char 105 - i
47F9: 10101000	
47FD: 08001808	        defb %00001000,%00000000,%00011000,%00001000,%00001000,%00001000,%01001000,%00110000 ; char 106 - j
4801: 08084830	
4805: 40404850	        defb %01000000,%01000000,%01001000,%01010000,%01100000,%01010000,%01001000,%00000000 ; char 107 - k
4809: 60504800	
480D: 30101010	        defb %00110000,%00010000,%00010000,%00010000,%00010000,%00010000,%00111000,%00000000 ; char 108 - l
4811: 10103800	
4815: 0000546A	        defb %00000000,%00000000,%01010100,%01101010,%01001010,%01000010,%01000010,%00000000 ; char 109 - m
4819: 4A424200	
481D: 00005864	        defb %00000000,%00000000,%01011000,%01100100,%01000100,%01000100,%01000100,%00000000 ; char 110 - n
4821: 44444400	
4825: 00003844	        defb %00000000,%00000000,%00111000,%01000100,%01000100,%01000100,%00111000,%00000000 ; char 111: o
4829: 44443800	
482D: 00007844	        defb %00000000,%00000000,%01111000,%01000100,%01000100,%01111000,%01000000,%01000000 ; char 112: p
4831: 44784040	
4835: 00003C44	        defb %00000000,%00000000,%00111100,%01000100,%01000100,%00111100,%00000100,%00000100 ; char 113: q
4839: 443C0404	
483D: 00005864	        defb %00000000,%00000000,%01011000,%01100100,%01000000,%01000000,%01000000,%00000000 ; char 114: r
4841: 40404000	
4845: 00003840	        defb %00000000,%00000000,%00111000,%01000000,%00111000,%00000100,%01111000,%00000000 ; char 115: s
4849: 38047800	
484D: 20207020	        defb %00100000,%00100000,%01110000,%00100000,%00100000,%00100100,%00011000,%00000000 ; char 116: t
4851: 20241800	
4855: 00004444	        defb %00000000,%00000000,%01000100,%01000100,%01000100,%01001100,%00110100,%00000000 ; char 117: u
4859: 444C3400	
485D: 00004444	        defb %00000000,%00000000,%01000100,%01000100,%01000100,%00101000,%00010000,%00000000 ; char 118: v
4861: 44281000	
4865: 00004444	        defb %00000000,%00000000,%01000100,%01000100,%01010100,%01010100,%00101000,%00000000 ; char 119: w
4869: 54542800	
486D: 00004428	        defb %00000000,%00000000,%01000100,%00101000,%00010000,%00101000,%01000100,%00000000 ; char 120: x
4871: 10284400	
4875: 00004444	        defb %00000000,%00000000,%01000100,%01000100,%01001100,%00110100,%00000100,%00111000 ; char 121: y
4879: 4C340438	
487D: 00007C08	        defb %00000000,%00000000,%01111100,%00001000,%00010000,%00100000,%01111100,%00000000 ; char 122: z
4881: 10207C00	
4885: 18202040	        defb %00011000,%00100000,%00100000,%01000000,%00100000,%00100000,%00011000,%00000000 ; char 123: {
4889: 20201800	
488D: 10101010	        defb %00010000,%00010000,%00010000,%00010000,%00010000,%00010000,%00010000,%00000000 ; char 124: |
4891: 10101000	
4895: 30080804	        defb %00110000,%00001000,%00001000,%00000100,%00001000,%00001000,%00110000,%00000000 ; char 125: }
4899: 08083000	
489D: 20540800	        defb %00100000,%01010100,%00001000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 126: ~
48A1: 00000000	
48A5: 00000000	        defb %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 127 (delete) - end the standard ASCII (0-127)
48A9: 00000000	
48AD: 3C42A581	        defb %00111100,%01000010,%10100101,%10000001,%10100101,%10011001,%01000010,%00111100 ; char 128 (open face)
48B1: A599423C	
48B5: 3C7EDBFF	        defb %00111100,%01111110,%11011011,%11111111,%11011011,%11100111,%01111110,%00111100 ; char 129 (full face)
48B9: DBE77E3C	
48BD: 6CFEFEFE	        defb %01101100,%11111110,%11111110,%11111110,%01111100,%00111000,%00010000,%00000000 ; char 130 (hearts)
48C1: 7C381000	
48C5: 10387CFE	        defb %00010000,%00111000,%01111100,%11111110,%01111100,%00111000,%00010000,%00000000 ; char 131 (diamonds)
48C9: 7C381000	
48CD: 103854FE	        defb %00010000,%00111000,%01010100,%11111110,%01010100,%00010000,%01111100,%00000000 ; char 132 (clus)
48D1: 54107C00	
48D5: 10387CFE	        defb %00010000,%00111000,%01111100,%11111110,%11010110,%00010000,%01111100,%00000000 ; char 133 (spades)
48D9: D6107C00	
48DD: 181818FF	        defb %00011000,%00011000,%00011000,%11111111,%11111111,%00011000,%00011000,%00011000 ; char 134
48E1: FF181818	
48E5: 0000001F	        defb %00000000,%00000000,%00000000,%00011111,%00011111,%00011000,%00011000,%00011000 ; char 135
48E9: 1F181818	
48ED: 000000F8	        defb %00000000,%00000000,%00000000,%11111000,%11111000,%00011000,%00011000,%00011000 ; char 136
48F1: F8181818	
48F5: 181818F8	        defb %00011000,%00011000,%00011000,%11111000,%11111000,%00000000,%00000000,%00000000 ; char 137
48F9: F8000000	
48FD: 1818181F	        defb %00011000,%00011000,%00011000,%00011111,%00011111,%00000000,%00000000,%00000000 ; char 138
4901: 1F000000	
4905: 181818FF	        defb %00011000,%00011000,%00011000,%11111111,%11111111,%00000000,%00000000,%00000000 ; char 139
4909: FF000000	
490D: 1818181F	        defb %00011000,%00011000,%00011000,%00011111,%00011111,%00011000,%00011000,%00011000 ; char 140
4911: 1F181818	
4915: 000000FF	        defb %00000000,%00000000,%00000000,%11111111,%11111111,%00011000,%00011000,%00011000 ; char 141
4919: FF181818	
491D: 181818F8	        defb %00011000,%00011000,%00011000,%11111000,%11111000,%00011000,%00011000,%00011000 ; char 142
4921: F8181818	
4925: 000000FF	        defb %00000000,%00000000,%00000000,%11111111,%11111111,%00000000,%00000000,%00000000 ; char 143
4929: FF000000	
492D: 18181818	        defb %00011000,%00011000,%00011000,%00011000,%00011000,%00011000,%00011000,%00011000 ; char 144
4931: 18181818	
4935: 03070E1C	        defb %00000011,%00000111,%00001110,%00011100,%00111000,%01110000,%11100000,%11000000 ; char 145
4939: 3870E0C0	
493D: C0E07038	        defb %11000000,%11100000,%01110000,%00111000,%00011100,%00001110,%00000111,%00000011 ; char 146
4941: 1C0E0703	
4945: C3E77E3C	        defb %11000011,%11100111,%01111110,%00111100,%00111100,%01111110,%11100111,%11000011 ; char 147
4949: 3C7EE7C3	
494D: 101010FF	        defb %00010000,%00010000,%00010000,%11111111,%00010000,%00010000,%00010000,%00010000 ; char 148
4951: 10101010	
4955: 0000001F	        defb %00000000,%00000000,%00000000,%00011111,%00010000,%00010000,%00010000,%00010000 ; char 149
4959: 10101010	
495D: 000000F0	        defb %00000000,%00000000,%00000000,%11110000,%00010000,%00010000,%00010000,%00010000 ; char 150
4961: 10101010	
4965: 101010F0	        defb %00010000,%00010000,%00010000,%11110000,%00000000,%00000000,%00000000,%00000000 ; char 151
4969: 00000000	
496D: 1010101F	        defb %00010000,%00010000,%00010000,%00011111,%00000000,%00000000,%00000000,%00000000 ; char 152
4971: 00000000	
4975: 101010FF	        defb %00010000,%00010000,%00010000,%11111111,%00000000,%00000000,%00000000,%00000000 ; char 153
4979: 00000000	
497D: 1010101F	        defb %00010000,%00010000,%00010000,%00011111,%00010000,%00010000,%00010000,%00010000 ; char 154
4981: 10101010	
4985: 000000FF	        defb %00000000,%00000000,%00000000,%11111111,%00010000,%00010000,%00010000,%00010000 ; char 155
4989: 10101010	
498D: 101010F0	        defb %00010000,%00010000,%00010000,%11110000,%00010000,%00010000,%00010000,%00010000 ; char 156
4991: 10101010	
4995: 000000FF	        defb %00000000,%00000000,%00000000,%11111111,%00000000,%00000000,%00000000,%00000000 ; char 157
4999: 00000000	
499D: 10101010	        defb %00010000,%00010000,%00010000,%00010000,%00010000,%00010000,%00010000,%00010000 ; char 158
49A1: 10101010	
49A5: 01020408	        defb %00000001,%00000010,%00000100,%00001000,%00010000,%00100000,%01000000,%10000000 ; char 159
49A9: 10204080	
49AD: 80402010	        defb %10000000,%01000000,%00100000,%00010000,%00001000,%00000100,%00000010,%00000001 ; char 160
49B1: 08040201	
49B5: 81422418	        defb %10000001,%01000010,%00100100,%00011000,%00011000,%00100100,%01000010,%10000001 ; char 161
49B9: 18244281	
49BD: 00000000	        defb %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%11111111,%11111111 ; char 162
49C1: 0000FFFF	
49C5: 00000000	        defb %00000000,%00000000,%00000000,%00000000,%11111111,%11111111,%11111111,%11111111 ; char 163
49C9: FFFFFFFF	
49CD: 0000FFFF	        defb %00000000,%00000000,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111 ; char 164
49D1: FFFFFFFF	
49D5: FFFF0000	        defb %11111111,%11111111,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 165
49D9: 00000000	
49DD: FFFFFFFF	        defb %11111111,%11111111,%11111111,%11111111,%00000000,%00000000,%00000000,%00000000 ; char 166
49E1: 00000000	
49E5: FFFFFFFF	        defb %11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%00000000,%00000000 ; char 167
49E9: FFFF0000	
49ED: C0C0C0C0	        defb %11000000,%11000000,%11000000,%11000000,%11000000,%11000000,%11000000,%11000000 ; char 168
49F1: C0C0C0C0	
49F5: F0F0F0F0	        defb %11110000,%11110000,%11110000,%11110000,%11110000,%11110000,%11110000,%11110000 ; char 169
49F9: F0F0F0F0	
49FD: FCFCFCFC	        defb %11111100,%11111100,%11111100,%11111100,%11111100,%11111100,%11111100,%11111100 ; char 170
4A01: FCFCFCFC	
4A05: 03030303	        defb %00000011,%00000011,%00000011,%00000011,%00000011,%00000011,%00000011,%00000011 ; char 171
4A09: 03030303	
4A0D: 0F0F0F0F	        defb %00001111,%00001111,%00001111,%00001111,%00001111,%00001111,%00001111,%00001111 ; char 172
4A11: 0F0F0F0F	
4A15: 3F3F3F3F	        defb %00111111,%00111111,%00111111,%00111111,%00111111,%00111111,%00111111,%00111111 ; char 173
4A19: 3F3F3F3F	
4A1D: FF818181	        defb %11111111,%10000001,%10000001,%10000001,%10000001,%10000001,%10000001,%11111111 ; char 174
4A21: 818181FF	
4A25: 00000000	        defb %00000000,%00000000,%00000000,%00000000,%11110000,%11110000,%11110000,%11110000 ; char 175
4A29: F0F0F0F0	
4A2D: 00000000	        defb %00000000,%00000000,%00000000,%00000000,%00001111,%00001111,%00001111,%00001111 ; char 176
4A31: 0F0F0F0F	
4A35: 0F0F0F0F	        defb %00001111,%00001111,%00001111,%00001111,%00000000,%00000000,%00000000,%00000000 ; char 177
4A39: 00000000	
4A3D: F0F0F0F0	        defb %11110000,%11110000,%11110000,%11110000,%00000000,%00000000,%00000000,%00000000 ; char 178
4A41: 00000000	
4A45: F0F0F0F0	        defb %11110000,%11110000,%11110000,%11110000,%00001111,%00001111,%00001111,%00001111 ; char 179
4A49: 0F0F0F0F	
4A4D: 0F0F0F0F	        defb %00001111,%00001111,%00001111,%00001111,%11110000,%11110000,%11110000,%11110000 ; char 180
4A51: F0F0F0F0	
4A55: 3C3C3C3C	        defb %00111100,%00111100,%00111100,%00111100,%00111100,%00111100,%00111100,%00111100 ; char 181
4A59: 3C3C3C3C	
4A5D: C3C3C3C3	        defb %11000011,%11000011,%11000011,%11000011,%11000011,%11000011,%11000011,%11000011 ; char 182
4A61: C3C3C3C3	
4A65: FFFF0000	        defb %11111111,%11111111,%00000000,%00000000,%00000000,%00000000,%11111111,%11111111 ; char 183
4A69: 0000FFFF	
4A6D: 0000FFFF	        defb %00000000,%00000000,%11111111,%11111111,%11111111,%11111111,%00000000,%00000000 ; char 184
4A71: FFFF0000	
4A75: 3333CCCC	        defb %00110011,%00110011,%11001100,%11001100,%00110011,%00110011,%11001100,%11001100 ; char 185
4A79: 3333CCCC	
4A7D: 55AA55AA	        defb %01010101,%10101010,%01010101,%10101010,%01010101,%10101010,%01010101,%10101010 ; char 186
4A81: 55AA55AA	
4A85: 663399CC	        defb %01100110,%00110011,%10011001,%11001100,%01100110,%00110011,%10011001,%11001100 ; char 187
4A89: 663399CC	
4A8D: CC993366	        defb %11001100,%10011001,%00110011,%01100110,%11001100,%10011001,%00110011,%01100110 ; char 188
4A91: CC993366	
4A95: 3399CC66	        defb %00110011,%10011001,%11001100,%01100110,%00110011,%10011001,%11001100,%01100110 ; char 189
4A99: 3399CC66	
4A9D: 66CC9933	        defb %01100110,%11001100,%10011001,%00110011,%01100110,%11001100,%10011001,%00110011 ; char 190
4AA1: 66CC9933	
4AA5: 10107C10	        defb %00010000,%00010000,%01111100,%00010000,%00010000,%00000000,%01111100,%00000000 ; char 191 (±)
4AA9: 10007C00	
4AAD: 60180618	        defb %01100000,%00011000,%00000110,%00011000,%01100000,%00000000,%01111110,%00000000 ; char 192 (≥)
4AB1: 60007E00	
4AB5: 06186018	        defb %00000110,%00011000,%01100000,%00011000,%00000110,%00000000,%01111110,%00000000 ; char 193 (≤)
4AB9: 06007E00	
4ABD: 3E202020	        defb %00111110,%00100000,%00100000,%00100000,%10100000,%01100000,%00100000,%00000000 ; char 194 (square root)
4AC1: A0602000	
4AC5: 30484830	        defb %00110000,%01001000,%01001000,%00110000,%00000000,%00000000,%00000000,%00000000 ; char 195 (°)
4AC9: 00000000	
4ACD: 60103040	        defb %01100000,%00010000,%00110000,%01000000,%01110000,%00000000,%00000000,%00000000 ; char 196 (²)
4AD1: 70000000	
4AD5: 00002A54	        defb %00000000,%00000000,%00101010,%01010100,%00000000,%01111110,%00000000,%00000000 ; char 197 
4AD9: 007E0000	
4ADD: 0054A800	        defb %00000000,%01010100,%10101000,%00000000,%01010100,%10101000,%00000000,%00000000 ; char 198 (≈)
4AE1: 54A80000	
4AE5: 80C0E0F0	        defb %10000000,%11000000,%11100000,%11110000,%11100000,%11000000,%10000000,%00000000 ; char 199
4AE9: E0C08000	
4AED: FE7C3810	        defb %11111110,%01111100,%00111000,%00010000,%00000000,%00000000,%00000000,%00000000 ; char 200
4AF1: 00000000	
4AF5: 0103070F	        defb %00000001,%00000011,%00000111,%00001111,%00000111,%00000011,%00000001,%00000000 ; char 201
4AF9: 07030100	
4AFD: 00000000	        defb %00000000,%00000000,%00000000,%00000000,%00010000,%00111000,%01111100,%11111110 ; char 202
4B01: 10387CFE	
4B05: 10387C10	        defb %00010000,%00111000,%01111100,%00010000,%00010000,%00010000,%00010000,%00000000 ; char 203 (up arrow)
4B09: 10101000	
4B0D: 1E0E0E12	        defb %00011110,%00001110,%00001110,%00010010,%00100000,%01000000,%00000000,%00000000 ; char 204 (up right arrow)
4B11: 20400000	
4B15: 00080CFE	        defb %00000000,%00001000,%00001100,%11111110,%00001100,%00001000,%00000000,%00000000 ; char 205 (right arrow)
4B19: 0C080000	
4B1D: 00402012	        defb %00000000,%01000000,%00100000,%00010010,%00001110,%00001110,%00011110,%00000000 ; char 206 (down right arrow)
4B21: 0E0E1E00	
4B25: 10101010	        defb %00010000,%00010000,%00010000,%00010000,%01111100,%00111000,%00010000,%00000000 ; char 207 (down arrow)
4B29: 7C381000	
4B2D: 00040890	        defb %00000000,%00000100,%00001000,%10010000,%11100000,%11100000,%11110000,%00000000 ; char 208 (down left arrow)
4B31: E0E0F000	
4B35: 002060FE	        defb %00000000,%00100000,%01100000,%11111110,%01100000,%00100000,%00000000,%00000000 ; char 209 (left arrow)
4B39: 60200000	
4B3D: F0E0E090	        defb %11110000,%11100000,%11100000,%10010000,%00001000,%00000100,%00000000,%00000000 ; char 210 (up left arrow)
4B41: 08040000	
4B45: 3844F040	        defb %00111000,%01000100,%11110000,%01000000,%11110000,%01000100,%00111000,%00000000 ; char 211 (euro)
4B49: F0443800	
4B4D: 00027CA8	        defb %00000000,%00000010,%01111100,%10101000,%00101000,%00101000,%00101000,%00000000 ; char 212 (greek pi)
4B51: 28282800	
4B55: 00000007	        defb %00000000,%00000000,%00000000,%00000111,%00001000,%00010000,%00010000,%00010000 ; char 213
4B59: 08101010	
4B5D: 000000C0	        defb %00000000,%00000000,%00000000,%11000000,%00100000,%00010000,%00010000,%00010000 ; char 214
4B61: 20101010	
4B65: 101020C0	        defb %00010000,%00010000,%00100000,%11000000,%00000000,%00000000,%00000000,%00000000 ; char 215
4B69: 00000000	
4B6D: 10100807	        defb %00010000,%00010000,%00001000,%00000111,%00000000,%00000000,%00000000,%00000000 ; char 216
4B71: 00000000	
4B75: 00000007	        defb %00000000,%00000000,%00000000,%00000111,%00001111,%00011100,%00011000,%00011000 ; char 217
4B79: 0F1C1818	
4B7D: 000000E0	        defb %00000000,%00000000,%00000000,%11100000,%11110000,%00111000,%00011000,%00011000 ; char 218
4B81: F0381818	
4B85: 181838F0	        defb %00011000,%00011000,%00111000,%11110000,%11100000,%00000000,%00000000,%00000000 ; char 219
4B89: E0000000	
4B8D: 18181C0F	        defb %00011000,%00011000,%00011100,%00001111,%00000111,%00000000,%00000000,%00000000 ; char 220
4B91: 07000000	
4B95: 003C4242	        defb %00000000,%00111100,%01000010,%01000010,%01000010,%01000010,%00111100,%00000000 ; char 221
4B99: 42423C00	
4B9D: 003C7E7E	        defb %00000000,%00111100,%01111110,%01111110,%01111110,%01111110,%00111100,%00000000 ; char 222
4BA1: 7E7E3C00	
4BA5: 00183C7E	        defb %00000000,%00011000,%00111100,%01111110,%01111110,%00111100,%00011000,%00000000 ; char 223
4BA9: 7E3C1800	
4BAD: FFFEFCF8	        defb %11111111,%11111110,%11111100,%11111000,%11110000,%11100000,%11000000,%10000000 ; char 224
4BB1: F0E0C080	
4BB5: FF7F3F1F	        defb %11111111,%01111111,%00111111,%00011111,%00001111,%00000111,%00000011,%00000001 ; char 225
4BB9: 0F070301	
4BBD: 0103070F	        defb %00000001,%00000011,%00000111,%00001111,%00011111,%00111111,%01111111,%11111111 ; char 226
4BC1: 1F3F7FFF	
4BC5: 80C0E0F0	        defb %10000000,%11000000,%11100000,%11110000,%11111000,%11111100,%11111110,%11111111 ; char 227
4BC9: F8FCFEFF	
4BCD: 0002066C	        defb %00000000,%00000010,%00000110,%01101100,%01111000,%01110000,%01100000,%00000000 ; char 228 (checkmark)
4BD1: 78706000	
4BD5: 00663C18	        defb %00000000,%01100110,%00111100,%00011000,%00111100,%01100110,%00000000,%00000000 ; char 229 (x)
4BD9: 3C660000	
4BDD: 38444444	        defb %00111000,%01000100,%01000100,%01000100,%00111000,%00010000,%00111000,%00010000 ; char 230 (female)
4BE1: 38103810	
4BE5: 07033D44	        defb %00000111,%00000011,%00111101,%01000100,%01000100,%01000100,%00111000,%00000000 ; char 231 (male)
4BE9: 44443800	
4BED: 78444242	        defb %01111000,%01000100,%01000010,%01000010,%01000010,%01000010,%01000010,%01111110 ; char 232 (new doc)
4BF1: 4242427E	
4BF5: 00F8FF81	        defb %00000000,%11111000,%11111111,%10000001,%10000001,%10000001,%10000001,%11111111 ; char 233 (folder)
4BF9: 818181FF	
4BFD: 107CFE54	        defb %00010000,%01111100,%11111110,%01010100,%01010100,%01010100,%01010100,%01111100 ; char 234 (trash bin)
4C01: 5454547C	
4C05: FF818181	        defb %11111111,%10000001,%10000001,%10000001,%10111101,%10101101,%10101101,%11111111 ; char 235 (floppy disk)
4C09: BDADADFF	
4C0D: 00EAAAAC	        defb %00000000,%11101010,%10101010,%10101100,%10101100,%10101010,%11101010,%00000000 ; char 236 (OK)
4C11: ACAAEA00	
4C15: 187EFF7E	        defb %00011000,%01111110,%11111111,%01111110,%01111110,%01100110,%01100110,%01100110 ; char 237 (home)
4C19: 7E666666	
4C1D: 3C429191	        defb %00111100,%01000010,%10010001,%10010001,%10011101,%10000001,%01000010,%00111100 ; char 238 (clock)
4C21: 9D81423C	
4C25: 000205FD	        defb %00000000,%00000010,%00000101,%11111101,%10100101,%10100010,%00000000,%00000000 ; char 239 (key)
4C29: A5A20000	
4C2D: 080C3E4C	        defb %00001000,%00001100,%00111110,%01001100,%01001000,%01000010,%01000010,%00111100 ; char 240 (undo)
4C31: 4842423C	
4C35: 00FFC3A5	        defb %00000000,%11111111,%11000011,%10100101,%10011001,%10000001,%11111111,%00000000 ; char 241 (letter)
4C39: 9981FF00	
4C3D: 3844447C	        defb %00111000,%01000100,%01000100,%01111100,%01111100,%01111100,%01111100,%00000000 ; char 242 (lock)
4C41: 7C7C7C00	
4C45: 060909F8	        defb %00000110,%00001001,%00001001,%11111000,%11111000,%11111000,%11111000,%00000000 ; char 243 (unlock)
4C49: F8F8F800	
4C4D: FFFF81AD	        defb %11111111,%11111111,%10000001,%10101101,%10100101,%10100101,%10000001,%11111111 ; char 244 (calendar)
4C51: A5A581FF	
4C55: 011A244A	        defb %00000001,%00011010,%00100100,%01001010,%01010010,%00100100,%01011000,%10000000 ; char 245 (diameter)
4C59: 52245880	
4C5D: 7E818181	        defb %01111110,%10000001,%10000001,%10000001,%10000001,%01110110,%00001100,%00000100 ; char 246 (baloon)
4C61: 81760C04	
4C65: 0C0A0A0A	        defb %00001100,%00001010,%00001010,%00001010,%00001000,%00011000,%00111000,%00010000 ; char 247 (note)
4C69: 08183810	
4C6D: 1231F5F5	        defb %00010010,%00110001,%11110101,%11110101,%11110101,%11110101,%00110001,%00010010 ; char 248 (audio on)
4C71: F5F53112	
4C75: 1030F0F0	        defb %00010000,%00110000,%11110000,%11110000,%11110000,%11110000,%00110000,%00010000 ; char 249 (audio off)
4C79: F0F03010	
4C7D: 40607078	        defb %01000000,%01100000,%01110000,%01111000,%01111100,%01111110,%01111000,%01001000 ; char 250 (pointer)
4C81: 7C7E7848	
4C85: 3C4299A1	        defb %00111100,%01000010,%10011001,%10100001,%10100001,%10011001,%01000010,%00111100 ; char 251 (©)
4C89: A199423C	
4C8D: 18242078	        defb %00011000,%00100100,%00100000,%01111000,%00100000,%00100010,%01011100,%00000000 ; char 252 (£)
4C91: 20225C00	
4C95: 3C427824	        defb %00111100,%01000010,%01111000,%00100100,%00100100,%00011110,%01000010,%00111100 ; char 253 (§)
4C99: 241E423C	
4C9D: 00001000	        defb %00000000,%00000000,%00010000,%00000000,%01111100,%00000000,%00010000,%00000000 ; char 254 (÷)
4CA1: 7C001000	
4CA5: FFFFFFFF	        defb %11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111 ; char 255 (cursor)
4CA9: FFFFFFFF	
              	
              	; ------------------------------------------------------------------------------
              	; LM80C - LOGO CHARSET - R1.1
              	; ------------------------------------------------------------------------------
              	; The following code is intended to be used with LM80C Z80-based computer
              	; designed by Leonardo Miliani. More info at
              	; www DOT leonardomiliani DOT com
              	; ------------------------------------------------------------------------------
              	; Code Revision:
              	; R1.0 - 20200124 - First revision: logo chars
              	; R1.1 - 20200229 - Adopted usual hexadecimal & binary prefixes
              	; ------------------------------------------------------------------------------
              	
4CAD:         	LOGOFONT:   equ $
4CAD: 00000000	            defb %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000 ; 0
4CB1: 00000000	
4CB5: FFFFFFFF	            defb %11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111 ; 1
4CB9: FFFFFFFF	
4CBD: FFFFFFFF	            defb %11111111,%11111111,%11111111,%11111111,%00000000,%00000000,%00000000,%00000000 ; 2
4CC1: 00000000	
4CC5: 0F0F0F0F	            defb %00001111,%00001111,%00001111,%00001111,%00001111,%00001111,%00001111,%00001111 ; 3
4CC9: 0F0F0F0F	
4CCD: 00000000	            defb %00000000,%00000000,%00000000,%00000000,%11111111,%11111111,%11111111,%11111111 ; 4
4CD1: FFFFFFFF	
4CD5: F0F0F0F0	            defb %11110000,%11110000,%11110000,%11110000,%11110000,%11110000,%11110000,%11110000 ; 5
4CD9: F0F0F0F0	
4CDD: 00000000	            defb %00000000,%00000000,%00000000,%00000000,%00001111,%00001111,%00001111,%00001111 ; 6
4CE1: 0F0F0F0F	
4CE5: 00000000	            defb %00000000,%00000000,%00000000,%00000000,%11110000,%11110000,%11110000,%11110000 ; 7
4CE9: F0F0F0F0	
4CED: F0F0F0F0	            defb %11110000,%11110000,%11110000,%11110000,%00000000,%00000000,%00000000,%00000000 ; 8
4CF1: 00000000	
4CF5: 0F0F0F0F	            defb %00001111,%00001111,%00001111,%00001111,%00000000,%00000000,%00000000,%00000000 ; 9
4CF9: 00000000	
4CFD: 000000FC	            defb %00000000,%00000000,%00000000,%11111100,%11111111,%00000111,%00000011,%00000000 ; 10
4D01: FF070300	
4D05: 0000003F	            defb %00000000,%00000000,%00000000,%00111111,%11111111,%11100000,%11000000,%00000000 ; 11
4D09: FFE0C000	
4D0D: 18181F19	            defb %00011000,%00011000,%00011111,%00011001,%00011001,%00011111,%00011000,%00011000 ; 12
4D11: 191F1818	
4D15: 1818F898	            defb %00011000,%00011000,%11111000,%10011000,%10011000,%11111000,%00011000,%00011000 ; 13
4D19: 98F81818	
4D1D: 18181C1F	            defb %00011000,%00011000,%00011100,%00011111,%00001111,%00000000,%00000000,%00000000 ; 14
4D21: 0F000000	
4D25: 0000000F	            defb %00000000,%00000000,%00000000,%00001111,%00011111,%00011100,%00011000,%00011000 ; 15
4D29: 1F1C1818	
4D2D: 000000F0	            defb %00000000,%00000000,%00000000,%11110000,%11111000,%00111000,%00011000,%00011000 ; 16
4D31: F8381818	
4D35: 181838F8	            defb %00011000,%00011000,%00111000,%11111000,%11110000,%00000000,%00000000,%00000000 ; 17
4D39: F0000000	
4D3D: 000000FF	            defb %00000000,%00000000,%00000000,%11111111,%11111111,%00000000,%00000000,%00000000 ; 18
4D41: FF000000	
4D45: 0F0F0F0F	            defb %00001111,%00001111,%00001111,%00001111,%11111111,%11111111,%11111111,%11111111 ; 19
4D49: FFFFFFFF	
4D4D: F0F0F0F0	            defb %11110000,%11110000,%11110000,%11110000,%11111111,%11111111,%11111111,%11111111 ; 20
4D51: FFFFFFFF	
4D55: FFFFFFFF	            defb %11111111,%11111111,%11111111,%11111111,%11110000,%11110000,%11110000,%11110000 ; 21
4D59: F0F0F0F0	
4D5D: FFFFFFFF	            defb %11111111,%11111111,%11111111,%11111111,%00001111,%00001111,%00001111,%00001111 ; 22
4D61: 0F0F0F0F	
4D65: 00307878	            defb %00000000,%00110000,%01111000,%01111000,%00110000,%00000000,%00000000,%00000000 ; 23
4D69: 30000000	
              	            ; ------------------------------------------------------------------------------
              	; LM80C - FIRMWARE - R3.13.3
              	; ------------------------------------------------------------------------------
              	; The following code is intended to be used with LM80C Z80-based computer
              	; designed by Leonardo Miliani. More info at
              	; www DOT leonardomiliani DOT com
              	; ------------------------------------------------------------------------------
              	; Coding/Editing/Compiling:
              	; Original init code for MC68B05 by Grant Searle
              	; Original SIO/CTC/PIO init code by Mario Blunk
              	; NASCOM BASIC originally modified by Gran Searle
              	; Code modified and adapted for LM80C by Leonardo Miliani
              	;
              	; Edited with Atom Editor
              	;
              	; Compiled with ZASM assembler 4.2.4
              	; https://k1.spdns.de/Develop/Projects/zasm-4.0/Distributions/
              	; ------------------------------------------------------------------------------
              	; Copyright notes:
              	; Parts of the code (c) Grant Searle - free for non commercial use
              	; Please include this advice and the note to the attribution of the original
              	; version to Grant Searle if you intend to redistribuite it
              	; http://searle.hostei.com/grant/index.html
              	; eMail: home.micros01@btinternet.com
              	;
              	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
              	; Parts of the code (c) Mario Blunk
              	; http://www.train­z.de
              	;
              	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
              	; NASCOM ROM BASIC Ver 4.7, (C) 1978 Microsoft
              	; Scanned from source published in 80-BUS NEWS from Vol 2, Issue 3
              	; (May-June 1983) to Vol 3, Issue 3 (May-June 1984)
              	; Adapted for the freeware Zilog Macro Assembler 2.10 to produce
              	; the original ROM code (checksum A934H). PA
              	;
              	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
              	; The following code is intended to be used with LM80C Z80-based computer
              	; designed by Leonardo Miliani. Code and computer schematics are released under
              	; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
              	; kind of warranty: you can use them at your own risk.
              	; You are free to use them for any non-commercial use: you are only asked to
              	; maintain the copyright notices, include this advice and the note to the 
              	; attribution of the original version to Leonardo Miliani, if you intend to
              	; redistribuite them.
              	; https://www.leonardomiliani.com
              	; 
              	; Please support me by visiting the following links:
              	; Main project page: https://www.leonardomiliani.com
              	; Schematics and code: https://github.com/leomil72/LM80C
              	; Videos about the computer: https://www.youtube.com/user/leomil72/videos
              	; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
              	; ------------------------------------------------------------------------------
              	
              	
              	; ------------------------------------------------------------------------------
              	; this line instructs the assembler to prepare a file for a ROM target
              	; meaning that blank cells will be filled up with $FF
              	#target rom
              	
              	; this line instructs the assembler to compile taking account that code
              	; starts at $0000 (the address reached by Z80 upon reset)
0000:         	#code BOOT, $0000
              	
              	
              	; END OF ASSEMBLY SOURCE
              	#end
              	
              	;-------------------------------------------------------------------------------


; +++ segments +++

#CODE          = $0000 =     0,  size = $4D6D = 19821
#CODE BOOT     = $0000 =     0,  size = $0000 =     0

; +++ global symbols +++

ABPASS           = $22A0 =  8864          rom.asm:4647
ABS              = $2CE9 = 11497          rom.asm:6248
ACCSUM           = $1AD6 =  6870          rom.asm:3515 (unused)
ACPASS           = $229F =  8863          rom.asm:4646
ADD30            = $3B88 = 15240          rom.asm:8301
ADD301           = $3B98 = 15256          rom.asm:8312
ADDEXP           = $2C82 = 11394          rom.asm:6183
ADDIG            = $2E28 = 11816          rom.asm:6473
ADDNEWLINE       = $096E =  2414          rom.asm:1410
ADDPHL           = $2A1E = 10782          rom.asm:5791
ADRS1            = $81F1 = 33265          rom.asm:5139
ADRS2            = $81F5 = 33269          rom.asm:5141
ALLFOL           = $256E =  9582          rom.asm:5095
ANTVLU           = $1DDB =  7643          rom.asm:3925
ARET             = $3179 = 12665          rom.asm:6913 (unused)
ARLDSV           = $21AA =  8618          rom.asm:4486
ARREND           = $81BF = 33215          rom.asm:2035
ARRLP            = $2439 =  9273          rom.asm:4886
ASC              = $253F =  9535          rom.asm:5065
ASCTFP           = $2DCB = 11723          rom.asm:6419
ASPCS            = $1D3C =  7484          rom.asm:3847
ATHOME           = $0602 =  1538          rom.asm:900
ATN              = $312D = 12589          rom.asm:6884
ATN1             = $314A = 12618          rom.asm:6896
ATNTAB           = $3154 = 12628          rom.asm:6901
ATOH             = $1B11 =  6929          rom.asm:3548
A_RTS_OFF        = $0165 =   357          rom.asm:198
A_RTS_ON         = $0173 =   371          rom.asm:209
BACKSPACE        = $076B =  1899          rom.asm:1121
BADINP           = $1D5F =  7519          rom.asm:3859
BAKSTK           = $14C5 =  5317          rom.asm:2620
BAKTMP           = $251F =  9503          rom.asm:5043
BASTXT           = $8133 = 33075          rom.asm:2011
BCDEFP           = $2D10 = 11536          rom.asm:6277
BEEPOFF          = $052C =  1324          rom.asm:767
BFREE            = $0F7A =  3962          rom.asm:2204
BIN              = $3BDA = 15322          rom.asm:8361
BIN2             = $3BE0 = 15328          rom.asm:8363 (unused)
BINERR           = $3C37 = 15415          rom.asm:8422
BINIT            = $3C16 = 15382          rom.asm:8397
BINTFP           = $3C0C = 15372          rom.asm:8393
BITOUT           = $3BF4 = 15348          rom.asm:8375
BITOUT2          = $3BF8 = 15352          rom.asm:8377
BITS6            = $393D = 14653          rom.asm:7983
BITS7            = $3947 = 14663          rom.asm:7988
BITS8            = $3952 = 14674          rom.asm:7993
BKGNDCLR         = $81EE = 33262          rom.asm:2062
BKSP             = $0008 =     8          rom.asm:1960
BN               = $0028 =    40          rom.asm:2113
BNMSG            = $1351 =  4945          rom.asm:2528
BNORM            = $2A7E = 10878          rom.asm:5850
BNPTR            = $13CD =  5069          rom.asm:2555 (unused)
BNRMLP           = $2A81 = 10881          rom.asm:5853
BOOT             = $0000 =     0  BOOT    rom.asm:9251 (unused)
BOOT_end         = $0000 =     0  BOOT    rom.asm:9251 (unused)
BOOT_size        = $0000 =     0  BOOT    rom.asm:9251 (unused)
BPS              = $81F8 = 33272          rom.asm:7804
BRK              = $1A84 =  6788          rom.asm:3472
BRKFLG           = $80A9 = 32937          rom.asm:2005
BRKLIN           = $81B3 = 33203          rom.asm:2029
BRKMSG           = $14BF =  5311          rom.asm:2618
BRKRET           = $0F71 =  3953          rom.asm:2200
BS               = $0010 =    16          rom.asm:2101
BSERR            = $21DD =  8669          rom.asm:4517
BSMSG            = $1280 =  4736          rom.asm:2516
BSPTR            = $13B5 =  5045          rom.asm:2543 (unused)
BUFFER           = $8136 = 33078          rom.asm:2012
BYT2ASC          = $3B7F = 15231          rom.asm:8296
BYTSFT           = $2BB6 = 11190          rom.asm:6061
CFEVAL           = $2140 =  8512          rom.asm:4417
CH3_TIMER        = $0237 =   567          rom.asm:349
CHABFREMPTY      = $01C8 =   456          rom.asm:263
CHAR2VID         = $06AE =  1710          rom.asm:1019
CHARINTOBFR      = $0136 =   310          rom.asm:167
CHARTY           = $20EE =  8430          rom.asm:4373
CHASNDDTN        = $8223 = 33315          rom.asm:2073
CHBSNDDTN        = $8225 = 33317          rom.asm:2074
CHCKYPOS         = $0791 =  1937          rom.asm:1140
CHCKYPOS2        = $07FC =  2044          rom.asm:1200
CHCSNDDTN        = $8227 = 33319          rom.asm:2075
CHECKALT         = $0C86 =  3206          rom.asm:1720
CHECKCTRL        = $0C94 =  3220          rom.asm:1726
CHECKKBD         = $0CA2 =  3234          rom.asm:1732
CHECKWARM        = $02BB =   699          rom.asm:417
CHEKFN           = $2337 =  9015          rom.asm:4739
CHKALT           = $0D1A =  3354          rom.asm:1792
CHKBIN           = $3C29 = 15401          rom.asm:8412
CHKBKSP          = $06D8 =  1752          rom.asm:1039
CHKCLR           = $32FB = 13051          rom.asm:7149
CHKCR            = $06CF =  1743          rom.asm:1035
CHKCRSDWN        = $06FC =  1788          rom.asm:1055
CHKCRSLFT        = $06E1 =  1761          rom.asm:1043
CHKCRSR          = $0246 =   582          rom.asm:359
CHKCRSRGT        = $06F3 =  1779          rom.asm:1051
CHKCRSUP         = $06EA =  1770          rom.asm:1047
CHKCS            = $06C6 =  1734          rom.asm:1031
CHKCTRL          = $0D11 =  3345          rom.asm:1788
CHKEY1           = $3B35 = 15157          rom.asm:8254
CHKEY2           = $3B3A = 15162          rom.asm:8255
CHKEY3           = $3B3D = 15165          rom.asm:8256
CHKEY4           = $3B43 = 15171          rom.asm:8257
CHKEY5           = $3B46 = 15174          rom.asm:8258
CHKFNK           = $0D4D =  3405          rom.asm:1817
CHKG2M           = $3305 = 13061          rom.asm:7157
CHKINK           = $29FD = 10749          rom.asm:5770
CHKLF            = $0705 =  1797          rom.asm:1059
CHKLN            = $0CFD =  3325          rom.asm:1779
CHKLTR           = $1AE3 =  6883          rom.asm:3524
CHKSCAR          = $3244 = 12868          rom.asm:7045
CHKSNDCH         = $0C0B =  3083          rom.asm:1646
CHKSTK           = $14F9 =  5369          rom.asm:2657
CHKSUM           = $80A6 = 32934          rom.asm:2003
CHKSYN           = $181E =  6174          rom.asm:3127
CHKTYP           = $1EBB =  7867          rom.asm:4040
CHKYPOS          = $07B8 =  1976          rom.asm:1161
CHR              = $2550 =  9552          rom.asm:5077
CHR4VID          = $81EC = 33260          rom.asm:2060
CHRPNT           = $81F9 = 33273          rom.asm:7173
CHRST68          = $3CAD = 15533          rom.asm:8610
CHRST88          = $44AD = 17581          rom.asm:8895
CIRCLE           = $35E3 = 13795          rom.asm:7554
CKBPS            = $38F0 = 14576          rom.asm:7943
CKCOL            = $33EC = 13292          rom.asm:7288
CKINCHAR         = $0224 =   548          rom.asm:330
CKMAGN           = $31F7 = 12791          rom.asm:6998
CLEAR            = $1B36 =  6966          rom.asm:3572
CLEARVIDBUF      = $05F5 =  1525          rom.asm:893
CLOTST           = $186A =  6250          rom.asm:3174
CLREG            = $1688 =  5768          rom.asm:2900
CLREX2           = $32BE = 12990          rom.asm:7105
CLRG1            = $32AC = 12972          rom.asm:7097
CLRG2            = $32B5 = 12981          rom.asm:7101
CLRG2PTNTBL      = $0595 =  1429          rom.asm:831
CLRMC            = $32A5 = 12965          rom.asm:7093
CLRPRM           = $37CA = 14282          rom.asm:7777
CLRPSGREGS       = $0BA9 =  2985          rom.asm:1591
CLRPTR           = $1663 =  5731          rom.asm:2880
CLRTABLE         = $0555 =  1365          rom.asm:798
CLRTXT           = $32A2 = 12962          rom.asm:7092
CLRVDBF          = $37B2 = 14258          rom.asm:7757
CLR_RAM_REG      = $09EF =  2543          rom.asm:1447
CLS              = $317C = 12668          rom.asm:6918
CLSQT            = $3AFC = 15100          rom.asm:8220
CLSQT1           = $3B0C = 15116          rom.asm:8228
CMP16            = $3C5F = 15455          rom.asm:8483
CMPFP            = $2D59 = 11609          rom.asm:6335
CMPLG1           = $2054 =  8276          rom.asm:4279
CMPLOG           = $2052 =  8274          rom.asm:4278
CMPNUM           = $2D3F = 11583          rom.asm:6318
CMPRES           = $2096 =  8342          rom.asm:4327
CMPSTR           = $207E =  8318          rom.asm:4307
CMP_A            = $29D6 = 10710          rom.asm:5751
CN               = $0020 =    32          rom.asm:2109
CNMSG            = $1311 =  4881          rom.asm:2524
CNPTR            = $13C5 =  5061          rom.asm:2551 (unused)
CNT1INS          = $2648 =  9800          rom.asm:5222
CNTCHKSND        = $0C46 =  3142          rom.asm:1681
CNTCKCL          = $3271 = 12913          rom.asm:7071
CNTCL1           = $36A5 = 13989          rom.asm:7641
CNTCL2           = $36C9 = 14025          rom.asm:7654
CNTCL3           = $36ED = 14061          rom.asm:7667
CNTCL4           = $3713 = 14099          rom.asm:7681
CNTCL5           = $3735 = 14133          rom.asm:7693
CNTCL6           = $3759 = 14169          rom.asm:7706
CNTCL7           = $377D = 14205          rom.asm:7719
CNTDRW           = $3589 = 13705          rom.asm:7508
CNTEND           = $1D04 =  7428          rom.asm:3817
CNTFNK           = $0DA8 =  3496          rom.asm:1867
CNTGPT2          = $336B = 13163          rom.asm:7213
CNTKBCK          = $0D47 =  3399          rom.asm:1815
CNTLGC           = $2013 =  8211          rom.asm:4233
CNTLTK           = $3AC2 = 15042          rom.asm:8189
CNTNULL          = $08FE =  2302          rom.asm:1353
CNTNULL2         = $0928 =  2344          rom.asm:1375
CNTPLOT          = $3458 = 13400          rom.asm:7345
CNTRX2           = $3870 = 14448          rom.asm:7884
CNTRXCHA         = $0120 =   288          rom.asm:151
CNTSER           = $383C = 14396          rom.asm:7855
CNTSER2          = $387B = 14459          rom.asm:7891
CNTSER3          = $388D = 14477          rom.asm:7900
CNTTXA           = $0201 =   513          rom.asm:302
CNTVALY          = $37AD = 14253          rom.asm:7750
CNTWTSP          = $1981 =  6529          rom.asm:3308
CNTZIN           = $267F =  9855          rom.asm:5245
CNVNUM           = $2DD7 = 11735          rom.asm:6425
COLD             = $0ED0 =  3792          rom.asm:2119
COLDSTART        = $02B3 =   691          rom.asm:414
COLOR            = $3254 = 12884          rom.asm:7060
COMMAN           = $80A3 = 32931          rom.asm:2000
COMPL            = $2ADE = 10974          rom.asm:5924
CONCAT           = $24B4 =  9396          rom.asm:4976
CONEXP           = $2E07 = 11783          rom.asm:6449
CONPOS           = $2A7B = 10875          rom.asm:5848
CONT             = $1ABD =  6845          rom.asm:3502
CONTAD           = $81B9 = 33209          rom.asm:2032
CONTCRSLFT       = $07A2 =  1954          rom.asm:1148
CONTCRSRGT       = $080F =  2063          rom.asm:1210
CONTROLKEYS      = $822D = 33325          rom.asm:2080
CONT_POS_CURS    = $068E =  1678          rom.asm:996
CONVAR           = $1FA6 =  8102          rom.asm:4164
CORW             = $02A7 =   679          rom.asm:409
COS              = $30B1 = 12465          rom.asm:6832
COUNTER          = $02EF =   751          rom.asm:447
CPDEHL           = $1818 =  6168          rom.asm:3120
CPKEY            = $3A59 = 14937          rom.asm:8134
CPKEY1           = $3A78 = 14968          rom.asm:8151
CPKEY2           = $3A69 = 14953          rom.asm:8141
CPKEY3           = $3A70 = 14960          rom.asm:8144
CPKYEND          = $3A80 = 14976          rom.asm:8156
CPYLIT           = $175D =  5981          rom.asm:3019
CR               = $000D =    13          rom.asm:1963
CRARLP           = $21FD =  8701          rom.asm:4537
CREARY           = $21E2 =  8674          rom.asm:4520
CRESTR           = $1C3D =  7229          rom.asm:3715
CRGRETURN        = $08D0 =  2256          rom.asm:1329
CRNCLP           = $16BE =  5822          rom.asm:2927
CRSDN            = $001F =    31          rom.asm:1977
CRSLFT           = $001C =    28          rom.asm:1974
CRSRGT           = $001D =    29          rom.asm:1975
CRSR_STATE       = $81E9 = 33257          rom.asm:2057
CRSUP            = $001E =    30          rom.asm:1976
CRTMST           = $2370 =  9072          rom.asm:4772
CRTST            = $237C =  9084          rom.asm:4783
CRTSTE           = $2392 =  9106          rom.asm:4797
CRUNCH           = $16B5 =  5813          rom.asm:2923
CS               = $000C =    12          rom.asm:1962
CSTART           = $0EDD =  3805          rom.asm:2125
CTC0IV           = $81D2 = 33234          rom.asm:2043
CTC1IV           = $81D5 = 33237          rom.asm:2044
CTC2IV           = $81D8 = 33240          rom.asm:2045
CTC3IV           = $81DB = 33243          rom.asm:2046
CTCCONF          = $032E =   814          rom.asm:505
CTC_CFG          = $39C3 = 14787          rom.asm:8049
CTC_CH0          = $0010 =    16          rom.asm:36
CTC_CH1          = $0011 =    17          rom.asm:37
CTC_CH2          = $0012 =    18          rom.asm:38
CTC_CH3          = $0013 =    19          rom.asm:39
CTLOFG           = $80A5 = 32933          rom.asm:2002
CTRLC            = $0003 =     3          rom.asm:1958
CTRLG            = $0007 =     7          rom.asm:1959
CTRLO            = $000F =    15          rom.asm:1964
CTRLQ            = $0011 =    17          rom.asm:1965
CTRLR            = $0012 =    18          rom.asm:1966
CTRLS            = $0013 =    19          rom.asm:1967
CTRLU            = $0015 =    21          rom.asm:1968
CTSNDC           = $28A9 = 10409          rom.asm:5584
CUROPR           = $81AA = 33194          rom.asm:2023
CURPOS           = $8190 = 33168          rom.asm:2014
CURSORDOWN       = $0818 =  2072          rom.asm:1218
CURSORLEFT       = $077E =  1918          rom.asm:1131
CURSORRIGHT      = $07E3 =  2019          rom.asm:1187
CURSORUP         = $07CA =  1994          rom.asm:1172
CURSOR_OFF       = $084E =  2126          rom.asm:1251
CURSOR_ON        = $0838 =  2104          rom.asm:1238
CUR_POS          = $81EF = 33263          rom.asm:1326
DATA             = $1BE4 =  7140          rom.asm:3667
DATABT           = $81FA = 33274          rom.asm:7805
DATFLG           = $8193 = 33171          rom.asm:2017
DATLIN           = $81AE = 33198          rom.asm:2025
DATSNR           = $1536 =  5430          rom.asm:2699
DC               = $8201 = 33281          rom.asm:7553
DCBCDE           = $2D90 = 11664          rom.asm:6378
DD               = $0012 =    18          rom.asm:2102
DDERR            = $1545 =  5445          rom.asm:2707
DDMSG            = $128E =  4750          rom.asm:2517
DDPTR            = $13B7 =  5047          rom.asm:2544 (unused)
DECLN1           = $3A4B = 14923          rom.asm:8126
DEC_D            = $04EC =  1260          rom.asm:726
DEC_E            = $02ED =   749          rom.asm:446
DEEK             = $3198 = 12696          rom.asm:6935
DEF              = $22B4 =  8884          rom.asm:4660
DEFFNKS          = $142C =  5164          rom.asm:2601
DEFSER           = $38D7 = 14551          rom.asm:7930
DEFSIZ           = $2205 =  8709          rom.asm:4541
DEINT            = $1AF7 =  6903          rom.asm:3535
DEL              = $007F =   127          rom.asm:1972
DELCHR           = $178D =  6029          rom.asm:3049
DEPINT           = $1AF1 =  6897          rom.asm:3533
DETHL4           = $2D1F = 11551          rom.asm:6289
DETHLB           = $2D21 = 11553          rom.asm:6290
DIGTXT           = $2ED1 = 11985          rom.asm:6571
DIM              = $20C0 =  8384          rom.asm:4353
DIMRET           = $20B7 =  8375          rom.asm:4348
DINPOS           = $184D =  6221          rom.asm:3154
DINT             = $2BBB = 11195          rom.asm:6069
DIRMOD           = $39D7 = 14807          rom.asm:8059
DIR_PAU          = $31C3 = 12739          rom.asm:6964 (unused)
DIV              = $2C18 = 11288          rom.asm:6110
DIV1             = $806B = 32875          rom.asm:1991
DIV10            = $2C0C = 11276          rom.asm:6105
DIV2             = $806F = 32879          rom.asm:1992
DIV3             = $8073 = 32883          rom.asm:1993
DIV4             = $8076 = 32886          rom.asm:1994
DIVLP            = $2C3F = 11327          rom.asm:6134
DIVSUP           = $806A = 32874          rom.asm:1990
DIV_16_8         = $3C9E = 15518          rom.asm:8575
DIV_16_8LP       = $3CA1 = 15521          rom.asm:8577
DIV_8_8          = $3C8E = 15502          rom.asm:8552
DIV_8_8LOOP      = $3C92 = 15506          rom.asm:8555
DLSZ             = $3667 = 13927          rom.asm:7614
DOAGN            = $16A1 =  5793          rom.asm:2913
DOCOM            = $1D09 =  7433          rom.asm:3821
DODEL            = $176D =  5997          rom.asm:3033
DOEBIT           = $2F11 = 12049          rom.asm:6614
DOFN             = $22E1 =  8929          rom.asm:4688
DOKE             = $31A3 = 12707          rom.asm:6943
DOSPC            = $1D37 =  7479          rom.asm:3844
DOTAB            = $1D22 =  7458          rom.asm:3833
DPOINT           = $2E03 = 11779          rom.asm:6447
DRAW             = $34BC = 13500          rom.asm:7435
DRWCRL           = $3683 = 13955          rom.asm:7629
DTSTR            = $2380 =  9088          rom.asm:4786
DVBCDE           = $2C1A = 11290          rom.asm:6112
DX               = $8203 = 33283          rom.asm:7433
DXGR             = $35B9 = 13753          rom.asm:7525
DY               = $8205 = 33285          rom.asm:7434
DZ               = $0014 =    20          rom.asm:2103
DZERR            = $153F =  5439          rom.asm:2703
DZMSG            = $12A3 =  4771          rom.asm:2518
DZPTR            = $13B9 =  5049          rom.asm:2545 (unused)
E2               = $81FD = 33277          rom.asm:7430
ECHDEL           = $1781 =  6017          rom.asm:3042
ECHO_CHAR        = $02C5 =   709          rom.asm:423
EDIGIT           = $2E4A = 11850          rom.asm:6496
EMPTINS          = $25E7 =  9703          rom.asm:5180
EMPTSNDBFR       = $0BA5 =  2981          rom.asm:1588
EMPTVRM          = $09E6 =  2534          rom.asm:1439
EMPTYCHABFR      = $01BA =   442          rom.asm:256
EMPTYG2          = $0583 =  1411          rom.asm:823
EMPTYMC          = $05B4 =  1460          rom.asm:849
EMPTYVIDBUF      = $055A =  1370          rom.asm:802
EMPTY_VRAM       = $09DB =  2523          rom.asm:1432
ENDBUF           = $1764 =  5988          rom.asm:3025
ENDCON           = $2E16 = 11798          rom.asm:6459
ENDCRL           = $367F = 13951          rom.asm:7625
ENDCTRLCK        = $0CE8 =  3304          rom.asm:1768
ENDDIM           = $2264 =  8804          rom.asm:4610
ENDDRAW          = $35DF = 13791          rom.asm:7538
ENDINK           = $2A0F = 10767          rom.asm:5781
ENDINK2          = $2A18 = 10776          rom.asm:5788 (unused)
ENDINP           = $1CF0 =  7408          rom.asm:3808
ENDNAM           = $20E2 =  8418          rom.asm:4369
ENDPRG           = $1A93 =  6803          rom.asm:3482
ENDTMR           = $2279 =  8825          rom.asm:4623
ENDTXT           = $81F3 = 33267          rom.asm:1328
ENDVDPSET        = $0489 =  1161          rom.asm:671
ENFMEM           = $1502 =  5378          rom.asm:2663
ER               = $81FB = 33275          rom.asm:7429
ER2              = $3563 = 13667          rom.asm:7495
ERASECLRTBL      = $0508 =  1288          rom.asm:743
ERRIN            = $1574 =  5492          rom.asm:2731
ERRINT           = $1AB7 =  6839          rom.asm:3498
ERRLIN           = $81B7 = 33207          rom.asm:2031
ERRMSG           = $14AE =  5294          rom.asm:2614
ERROR            = $1550 =  5456          rom.asm:2715
ERRORS           = $120B =  4619          rom.asm:2507 (unused)
ERRTBL           = $13A5 =  5029          rom.asm:2534
ESC              = $001B =    27          rom.asm:1970
EVAL             = $1EC8 =  7880          rom.asm:4048
EVAL1            = $1ECB =  7883          rom.asm:4050
EVAL2            = $1ED4 =  7892          rom.asm:4054
EVAL3            = $1ED7 =  7895          rom.asm:4055
EVLPAR           = $1F8D =  8077          rom.asm:4150
EVNOT            = $20A0 =  8352          rom.asm:4335
EXCUTE           = $1A21 =  6689          rom.asm:3402
EXG2MD           = $044B =  1099          rom.asm:639
EXITCHAR2VID     = $0739 =  1849          rom.asm:1085
EXITCURSORDOWN   = $0835 =  2101          rom.asm:1232
EXITCURSORLEFT   = $07A5 =  1957          rom.asm:1149
EXITCURSORRGHT   = $0815 =  2069          rom.asm:1212
EXITCURSORUP     = $07E1 =  2017          rom.asm:1182
EXITCURSOR_ON    = $084C =  2124          rom.asm:1247
EXITGM           = $1516 =  5398          rom.asm:2679
EXITSER          = $3998 = 14744          rom.asm:8032 (unused)
EXMUL16          = $3C82 = 15490          rom.asm:8523
EXP              = $2FAB = 12203          rom.asm:6701
EXPLP            = $2DF5 = 11765          rom.asm:6439
EXPTAB           = $2FEB = 12267          rom.asm:6729
EXPTEN           = $2F23 = 12067          rom.asm:6624
EXTIG            = $1E37 =  7735          rom.asm:3973
EXTXA            = $0215 =   533          rom.asm:313
FANDT            = $1E60 =  7776          rom.asm:3991
FC               = $0008 =     8          rom.asm:2097
FCERR            = $1B0C =  6924          rom.asm:3545
FCMSG            = $1244 =  4676          rom.asm:2512
FCPTR            = $13AD =  5037          rom.asm:2539 (unused)
FDTLP            = $1E47 =  7751          rom.asm:3975
FINDEL           = $2240 =  8768          rom.asm:4582
FINDKEY          = $0CFB =  3323          rom.asm:1778
FLASHCURSOR      = $0747 =  1863          rom.asm:1098
FLGDIF           = $2CCF = 11471          rom.asm:6231
FLGREL           = $2CD6 = 11478          rom.asm:6237
FNARG            = $81C5 = 33221          rom.asm:2038
FNCTAB           = $0FC3 =  4035          rom.asm:2221
FNDARY           = $21B0 =  8624          rom.asm:4490
FNDBPS           = $3909 = 14601          rom.asm:7953
FNDELP           = $2245 =  8773          rom.asm:4587
FNDEND           = $1636 =  5686          rom.asm:2843
FNDNUM           = $2739 = 10041          rom.asm:5359
FNDTOK           = $1943 =  6467          rom.asm:3273
FNDVAR           = $2127 =  8487          rom.asm:4401
FNDWRD           = $16E8 =  5864          rom.asm:2947
FNKEYS           = $80B3 = 32947          rom.asm:2010
FNKEYSORD        = $0DC8 =  3528          rom.asm:1886
FNOFST           = $1FB7 =  8119          rom.asm:4174
FNRGNM           = $81C3 = 33219          rom.asm:2037
FNTHR            = $2135 =  8501          rom.asm:4409
FNVAL            = $1FE8 =  8168          rom.asm:4200
FOPRND           = $1F00 =  7936          rom.asm:4076
FOR              = $1988 =  6536          rom.asm:3313
FORFLG           = $81B0 = 33200          rom.asm:2026
FORFND           = $19B8 =  6584          rom.asm:3341
FORSLP           = $199C =  6556          rom.asm:3322
FPADD            = $2A2D = 10797          rom.asm:5799
FPBCDE           = $2D05 = 11525          rom.asm:6268
FPEXP            = $81CC = 33228          rom.asm:2040
FPINT            = $2D6C = 11628          rom.asm:6355
FPMULT           = $2B68 = 11112          rom.asm:6010
FPREG            = $81C9 = 33225          rom.asm:2039
FPROND           = $2AC5 = 10949          rom.asm:5900
FPSINT           = $1AEB =  6891          rom.asm:3531
FPTHL            = $2D1C = 11548          rom.asm:6288
FRE              = $227E =  8830          rom.asm:4629
FRENUM           = $229A =  8858          rom.asm:4641
FRGNDCLR         = $81ED = 33261          rom.asm:2061
FRMEVL           = $1FA9 =  8105          rom.asm:4165
FWVER            = $00D0 =   208          rom.asm:134 (unused)
G1MD             = $03CA =   970          rom.asm:578
G2MD             = $0406 =  1030          rom.asm:609
GARBGE           = $2401 =  9217          rom.asm:4859
GARBLP           = $2404 =  9220          rom.asm:4860
GETCHR           = $1A41 =  6721          rom.asm:3425
GETCMD           = $15A3 =  5539          rom.asm:2755
GETHEX           = $3BB5 = 15285          rom.asm:8334
GETINP           = $317A = 12666          rom.asm:6915
GETINT           = $273C = 10044          rom.asm:5360
GETLEN           = $2534 =  9524          rom.asm:5057
GETLIN           = $179E =  6046          rom.asm:3057
GETLN            = $1B12 =  6930          rom.asm:3549
GETNUM           = $1EB6 =  7862          rom.asm:4037
GETNXT           = $1703 =  5891          rom.asm:2962
GETSTR           = $24FE =  9470          rom.asm:5023
GETVAR           = $20C5 =  8389          rom.asm:4356
GM               = $002A =    42          rom.asm:2114
GMERR            = $37E3 = 14307          rom.asm:7792
GMMSG            = $135C =  4956          rom.asm:2529
GMNCR            = $17F5 =  6133          rom.asm:3099
GMPRT            = $13CF =  5071          rom.asm:2556 (unused)
GNXARY           = $2438 =  9272          rom.asm:4885
GOFUNC           = $1FF0 =  8176          rom.asm:4204
GOSUB            = $1B90 =  7056          rom.asm:3618
GOTO             = $1BA1 =  7073          rom.asm:3630
GPCPCH1          = $33CF = 13263          rom.asm:7272
GPCPCHR          = $33C4 = 13252          rom.asm:7267 (unused)
GPNT             = $3380 = 13184          rom.asm:7222
GPNTCO1          = $33AA = 13226          rom.asm:7249
GPNTCOL          = $33A0 = 13216          rom.asm:7245 (unused)
GPRINT           = $330E = 13070          rom.asm:7176
GRBARY           = $2458 =  9304          rom.asm:4904
GRBDON           = $23D9 =  9177          rom.asm:4834
GRBLP            = $2412 =  9234          rom.asm:4866
GSTRCU           = $2501 =  9473          rom.asm:5024
GSTRDE           = $2505 =  9477          rom.asm:5026
GSTRHL           = $2504 =  9476          rom.asm:5025
GTFLNM           = $2543 =  9539          rom.asm:5067 (unused)
GTFNAM           = $20CA =  8394          rom.asm:4359
GTLNLP           = $1B15 =  6933          rom.asm:3550
GTSIXD           = $2E9B = 11931          rom.asm:6540
GTVLUS           = $1DB3 =  7603          rom.asm:3903
GX               = $81F3 = 33267          rom.asm:7169
GY               = $81F5 = 33269          rom.asm:7170
HALF             = $2F42 = 12098          rom.asm:6645
HALFPI           = $30FB = 12539          rom.asm:6863
HELLOWRLD        = $02DF =   735          rom.asm:438
HELP             = $39E3 = 14819          rom.asm:8070
HEX              = $3B49 = 15177          rom.asm:8262
HEX1             = $3B61 = 15201          rom.asm:8275
HEX2             = $3B63 = 15203          rom.asm:8277
HEX3             = $3B70 = 15216          rom.asm:8285
HEX4             = $3B72 = 15218          rom.asm:8287
HEXIT            = $3BCC = 15308          rom.asm:8349
HEXLP            = $3BA8 = 15272          rom.asm:8324
HEXLP1           = $3BAD = 15277          rom.asm:8326
HEXTFP           = $3B9C = 15260          rom.asm:8319
HL2XY            = $069D =  1693          rom.asm:1007
HLPERR           = $39F9 = 14841          rom.asm:8081
HLPLN            = $80B1 = 32945          rom.asm:2009
HOME             = $0019 =    25          rom.asm:1969
HP               = $0030 =    48          rom.asm:2117
HPMSG            = $139B =  5019          rom.asm:2532
HPPTR            = $13D5 =  5077          rom.asm:2559 (unused)
HX               = $0026 =    38          rom.asm:2112
HXERR            = $3BD5 = 15317          rom.asm:8357
HXMSG            = $1346 =  4934          rom.asm:2527
HXPTR            = $13CB =  5067          rom.asm:2554 (unused)
ID               = $0016 =    22          rom.asm:2104
IDMSG            = $12B4 =  4788          rom.asm:2519
IDPTR            = $13BB =  5051          rom.asm:2546 (unused)
IDTEST           = $2329 =  9001          rom.asm:4729
IF               = $1C73 =  7283          rom.asm:3748
IFGO             = $1C81 =  7297          rom.asm:3755
IFJMP            = $1A28 =  6696          rom.asm:3405
INCHL            = $2D1A = 11546          rom.asm:6285
INCLEN           = $1849 =  6217          rom.asm:3152
INCTMR3          = $0240 =   576          rom.asm:355
INDFND           = $14DF =  5343          rom.asm:2639
INEWLN           = $15FE =  5630          rom.asm:2803
INIT             = $0EE4 =  3812          rom.asm:2129
INITAB           = $13D7 =  5079          rom.asm:2563
INITBE           = $14AE =  5294          rom.asm:2610
INITST           = $3C4A = 15434          rom.asm:8435
INIT_HW          = $025A =   602          rom.asm:376
INKEY            = $29CB = 10699          rom.asm:5746
INKEY2           = $29E5 = 10725          rom.asm:5759
INMSG            = $14B5 =  5301          rom.asm:2615
INP              = $26F9 =  9977          rom.asm:5328
INPBIN           = $1E05 =  7685          rom.asm:3947
INPBRK           = $1A90 =  6800          rom.asm:3480
INPORT           = $80A0 = 32928          rom.asm:1998
INPSUB           = $809F = 32927          rom.asm:1997
INPUT            = $1D70 =  7536          rom.asm:3867
INRNG            = $2EA4 = 11940          rom.asm:6545
INSTR            = $2590 =  9616          rom.asm:5147
INT              = $2D97 = 11671          rom.asm:6386
INTVAR           = $1672 =  5746          rom.asm:2891
INVSGN           = $2CED = 11501          rom.asm:6250
ITMSEP           = $1DF6 =  7670          rom.asm:3938
JSTZER           = $2F2D = 12077          rom.asm:6630
KBDNPT           = $8229 = 33321          rom.asm:2076
KBMAP            = $0DD0 =  3536          rom.asm:1889
KBMAP_ALT        = $0E50 =  3664          rom.asm:1909
KBMAP_CTRL       = $0E90 =  3728          rom.asm:1919
KBMAP_SFT        = $0E10 =  3600          rom.asm:1899
KBTMP            = $822A = 33322          rom.asm:2077
KEY              = $39FE = 14846          rom.asm:8086
KEYBOARD         = $0C66 =  3174          rom.asm:1704
KEYCH            = $3A1B = 14875          rom.asm:8102
KILFOR           = $1EA6 =  7846          rom.asm:4028
KILIN            = $1798 =  6040          rom.asm:3054
LASTKEYPRSD      = $822C = 33324          rom.asm:2079
LCRFLG           = $8191 = 33169          rom.asm:2015
LDCLRTBEX2       = $0480 =  1152          rom.asm:664
LDCLRTBMD1       = $03FD =  1021          rom.asm:602
LDCOLSTOEMPTY    = $0574 =  1396          rom.asm:813
LDFNKEYCHR       = $0D94 =  3476          rom.asm:1857
LDG1             = $1523 =  5411          rom.asm:2685
LDG1ND           = $1534 =  5428          rom.asm:2695
LDKEY            = $3AAD = 15021          rom.asm:8180
LDREGVLS         = $0A0C =  2572          rom.asm:1466
LEDLIGHT         = $02E9 =   745          rom.asm:444
LEFT             = $2560 =  9568          rom.asm:5085
LEN              = $2530 =  9520          rom.asm:5055
LET              = $1BFB =  7163          rom.asm:3683
LETNUM           = $1C4E =  7246          rom.asm:3725
LETSTR           = $1C16 =  7190          rom.asm:3696
LF               = $000A =    10          rom.asm:1961
LFRGNM           = $26EF =  9967          rom.asm:5319
LINEAT           = $80AF = 32943          rom.asm:2008
LINEIN           = $2E56 = 11862          rom.asm:6506
LINFND           = $15E7 =  5607          rom.asm:2789
LIST             = $187D =  6269          rom.asm:3186
LISTLP           = $1900 =  6400          rom.asm:3235
LM80CLOGO        = $0A5F =  2655          rom.asm:1551
LNS1             = $81EF = 33263          rom.asm:5138
LNS2             = $81F3 = 33267          rom.asm:5140
LOADCHARSET      = $0A16 =  2582          rom.asm:1475
LOADCLR          = $32C5 = 12997          rom.asm:7108
LOADFP           = $2D13 = 11539          rom.asm:6278
LOADLOGOCHRS     = $0534 =  1332          rom.asm:773
LOADMAP          = $0D21 =  3361          rom.asm:1795
LOADNEXTCOL      = $0880 =  2176          rom.asm:1278
LOAD_CRSR_POS    = $0679 =  1657          rom.asm:985
LOCATE           = $280F = 10255          rom.asm:5494
LOG              = $2B27 = 11047          rom.asm:5978
LOGOFONT         = $4CAD = 19629          rom.asm:9165
LOGTAB           = $2B1A = 11034          rom.asm:5973
LOKFOR           = $14C9 =  5321          rom.asm:2622
LOOPST           = $81AC = 33196          rom.asm:2024
LS               = $001C =    28          rom.asm:2107
LSMSG            = $12E6 =  4838          rom.asm:2522
LSPTR            = $13C1 =  5057          rom.asm:2549 (unused)
LST01            = $18A9 =  6313          rom.asm:3203
LST01H           = $18AC =  6316          rom.asm:3204
LST03            = $18E6 =  6374          rom.asm:3224
LST04            = $18C3 =  6339          rom.asm:3212 (unused)
LST05            = $18F4 =  6388          rom.asm:3231
LST06            = $18CA =  6346          rom.asm:3214
LST07            = $1925 =  6437          rom.asm:3255
LST08            = $1922 =  6434          rom.asm:3254
LSTALL           = $18CE =  6350          rom.asm:3216
LSTBIN           = $81B1 = 33201          rom.asm:2027
LSTCSRSTA        = $81EA = 33258          rom.asm:2058
LSTKEYS          = $3A82 = 14978          rom.asm:8159
LSTLP2           = $1931 =  6449          rom.asm:3264
LSTLP3           = $1934 =  6452          rom.asm:3265
LSTRAM           = $8194 = 33172          rom.asm:2018
LSTRND           = $809B = 32923          rom.asm:1996
LTSTND           = $1E10 =  7696          rom.asm:3952
LVINSTR          = $2675 =  9845          rom.asm:5240
LVKBRDCHK        = $0D7B =  3451          rom.asm:1838
LVKBRDCHK2       = $0D77 =  3447          rom.asm:1836
LVRXCHA          = $0131 =   305          rom.asm:159
LWIDTH           = $80A2 = 32930          rom.asm:1999
MAKINT           = $273F = 10047          rom.asm:5361
MAKNUM           = $2EC0 = 11968          rom.asm:6560
MANLP            = $2DDF = 11743          rom.asm:6431
MATCH            = $1735 =  5941          rom.asm:2994
MCMD             = $0428 =  1064          rom.asm:624
MEMMSG           = $0FB8 =  4024          rom.asm:2210
MID              = $2690 =  9872          rom.asm:5257
MID1             = $2566 =  9574          rom.asm:5089
MIDNUM           = $26F4 =  9972          rom.asm:5322
MINCDE           = $2A6D = 10861          rom.asm:5834
MINUS            = $1F95 =  8085          rom.asm:4155
MIXCLRS          = $32EE = 13038          rom.asm:7137
MIXCOL           = $81EF = 33263          rom.asm:7172
MKTMST           = $236D =  9069          rom.asm:4771
MLDBLP           = $2DB8 = 11704          rom.asm:6407
MLDEBC           = $2DB0 = 11696          rom.asm:6402
MLOOP            = $0F12 =  3858          rom.asm:2147
MLP              = $3C72 = 15474          rom.asm:8512
MLP1             = $3C79 = 15481          rom.asm:8516
MLSP10           = $2CAD = 11437          rom.asm:6211
MNGSNDS          = $0C01 =  3073          rom.asm:1642
MNOASK           = $0F0F =  3855          rom.asm:2146
MO               = $0024 =    36          rom.asm:2111
MOD              = $2BC3 = 11203          rom.asm:6079
MOMSG            = $1336 =  4918          rom.asm:2526
MONOUT           = $3C3C = 15420          rom.asm:8426
MOPTR            = $13C9 =  5065          rom.asm:2553 (unused)
MORDT            = $1E1C =  7708          rom.asm:3957
MORINP           = $17A7 =  6055          rom.asm:3062
MOVBUF           = $161D =  5661          rom.asm:2824
MOVCRS           = $0652 =  1618          rom.asm:963
MOVDIR           = $173D =  5949          rom.asm:3002
MOVLP            = $14EE =  5358          rom.asm:2649
MOVSTR           = $14EB =  5355          rom.asm:2646
MOVUP            = $14E8 =  5352          rom.asm:2645
MRPRNT           = $1C93 =  7315          rom.asm:3762
MSGTXT1          = $033A =   826          rom.asm:510
MSGTXT2          = $0366 =   870          rom.asm:512
MSIZE            = $0EFF =  3839          rom.asm:2140
MUL16            = $3C6A = 15466          rom.asm:8504
MUL8LP           = $2B93 = 11155          rom.asm:6033
MULLN2           = $2B5F = 11103          rom.asm:6004
MULT             = $2B66 = 11110          rom.asm:6008
MULT8            = $2B8A = 11146          rom.asm:6027
MULTEN           = $2E21 = 11809          rom.asm:6467
MULVAL           = $823D = 33341          rom.asm:2086
MVCRS2LFT        = $07A7 =  1959          rom.asm:1153
MVSTPT           = $1C45 =  7237          rom.asm:3719
NEDMOR           = $1DAF =  7599          rom.asm:3901
NEGAFT           = $2F58 = 12120          rom.asm:6654
NEW              = $1662 =  5730          rom.asm:2879
NEWCRSRCOORD     = $065B =  1627          rom.asm:969
NEXITM           = $1D46 =  7494          rom.asm:3853
NEXT             = $1E6B =  7787          rom.asm:3996
NEXT1            = $1E6E =  7790          rom.asm:3997
NF               = $0000 =     0          rom.asm:2093
NFERR            = $1542 =  5442          rom.asm:2705
NFMSG            = $120B =  4619          rom.asm:2508
NFPTR            = $13A5 =  5029          rom.asm:2535 (unused)
NLLCR            = $0000 =     0          rom.asm:1957
NM1              = $2768 = 10088          rom.asm:5385
NMI              = $274D = 10061          rom.asm:5372
NMI2             = $2779 = 10105          rom.asm:5393
NMIDINT          = $2784 = 10116          rom.asm:5402
NMIEINT          = $277D = 10109          rom.asm:5398
NMIFLG           = $80A8 = 32936          rom.asm:2004
NMIINT           = $2787 = 10119          rom.asm:5403
NMIUSR           = $8061 = 32865          rom.asm:1986
NMIVR1           = $2793 = 10131          rom.asm:5414
NOBEEP           = $0BD3 =  3027          rom.asm:1611
NOBPDAT          = $0BEF =  3055          rom.asm:1625
NOCHNG           = $172D =  5933          rom.asm:2989
NOENED           = $2F30 = 12080          rom.asm:6633
NOGD             = $3485 = 13445          rom.asm:7374
NOISUP           = $292E = 10542          rom.asm:5652
NOKEYPRSD        = $0CEC =  3308          rom.asm:1770
NOLIN            = $1AA6 =  6822          rom.asm:3491
NOMADD           = $2BA4 = 11172          rom.asm:6044
NOMLAD           = $2DC6 = 11718          rom.asm:6415
NOPMPT           = $1D8A =  7562          rom.asm:3879
NORMAL           = $2A98 = 10904          rom.asm:5869
NOS1             = $2958 = 10584          rom.asm:5670
NOS2             = $296B = 10603          rom.asm:5683
NOS3             = $2984 = 10628          rom.asm:5702
NOSPC            = $1724 =  5924          rom.asm:2984
NOSUB7           = $3BC8 = 15304          rom.asm:8345
NOSWAP           = $2A47 = 10823          rom.asm:5815
NOSYSPR          = $27C5 = 10181          rom.asm:5443
NOTAMP           = $1F6A =  8042          rom.asm:4136
NOTFULL          = $0141 =   321          rom.asm:173
NOTRDWRAP        = $01E2 =   482          rom.asm:281
NOTSTR           = $20FD =  8445          rom.asm:4381
NOTWRAP          = $014D =   333          rom.asm:179
NOXOR            = $271F = 10015          rom.asm:5345
NSCFOR           = $210D =  8461          rom.asm:4389
NULFLG           = $80A4 = 32932          rom.asm:2001
NUMASC           = $2E69 = 11881          rom.asm:6516
NUMCHR           = $81FB = 33275          rom.asm:7174
NXTARY           = $21C4 =  8644          rom.asm:4502
NXTBYT           = $1713 =  5907          rom.asm:2974
NXTCHAR          = $0A29 =  2601          rom.asm:1486
NXTCHR           = $1754 =  5972          rom.asm:3014
NXTDAT           = $81C1 = 33217          rom.asm:2036
NXTDTA           = $1BE3 =  7139          rom.asm:3665
NXTITM           = $1DA7 =  7591          rom.asm:3896
NXTLN            = $195B =  6491          rom.asm:3286
NXTOPR           = $81B5 = 33205          rom.asm:2030
NXTSTL           = $1BEA =  7146          rom.asm:3670
NXTSTT           = $1BED =  7149          rom.asm:3673
OD               = $0006 =     6          rom.asm:2096
ODMSG            = $1238 =  4664          rom.asm:2511
ODPTR            = $13AB =  5035          rom.asm:2538 (unused)
OKMSG            = $14BA =  5306          rom.asm:2617
OM               = $000C =    12          rom.asm:2099
OMERR            = $1511 =  5393          rom.asm:2674
OMMSG            = $1263 =  4707          rom.asm:2514
OMPTR            = $13B1 =  5041          rom.asm:2541 (unused)
ON               = $1C55 =  7253          rom.asm:3731
ONGO             = $1C64 =  7268          rom.asm:3739
ONGOLP           = $1C65 =  7269          rom.asm:3740
ONJMP            = $1A29 =  6697          rom.asm:3407
OPNPAR           = $1EC4 =  7876          rom.asm:4046
OPNQT            = $3B0E = 15118          rom.asm:8231
OPNQT1           = $3B24 = 15140          rom.asm:8241
OPRND            = $1F3F =  7999          rom.asm:4119
OS               = $001A =    26          rom.asm:2106
OSMSG            = $12D2 =  4818          rom.asm:2521
OSPTR            = $13BF =  5055          rom.asm:2548 (unused)
OTKLN            = $1795 =  6037          rom.asm:3053
OTPORT           = $8068 = 32872          rom.asm:1989
OUTC             = $1829 =  6185          rom.asm:3135
OUTEXP           = $2F21 = 12065          rom.asm:6623
OUTIT            = $180F =  6159          rom.asm:3113
OUTNBS           = $1812 =  6162          rom.asm:3115
OUTNCR           = $3C59 = 15449          rom.asm:8447
OUTSUB           = $8067 = 32871          rom.asm:1988
OUTWRD           = $194D =  6477          rom.asm:3279
OV               = $000A =    10          rom.asm:2098
OVERR            = $154B =  5451          rom.asm:2711
OVMSG            = $125A =  4698          rom.asm:2513
OVPTR            = $13AF =  5039          rom.asm:2540 (unused)
OVTST1           = $2CA0 = 11424          rom.asm:6203
OVTST2           = $2CA5 = 11429          rom.asm:6206
OVTST3           = $2CA6 = 11430          rom.asm:6207
PADD             = $2E45 = 11845          rom.asm:6492
PAND             = $2009 =  8201          rom.asm:4226
PAND1            = $202E =  8238          rom.asm:4249 (unused)
PARBT            = $81FB = 33275          rom.asm:7806
PASSA            = $22AF =  8879          rom.asm:4656
PAUSE            = $31BA = 12730          rom.asm:6959
PBUFF            = $8230 = 33328          rom.asm:2085
PEEK             = $27D5 = 10197          rom.asm:5455
PEND             = $1A8B =  6795          rom.asm:3477
PHLTFP           = $2D02 = 11522          rom.asm:6267
PIO_CA           = $0002 =     2          rom.asm:32 (unused)
PIO_CB           = $0003 =     3          rom.asm:33
PIO_DA           = $0000 =     0          rom.asm:30 (unused)
PIO_DB           = $0001 =     1          rom.asm:31
PKEPRMS          = $27E9 = 10217          rom.asm:5470
PLOT             = $343D = 13373          rom.asm:7335
PLTCRL           = $3676 = 13942          rom.asm:7622
PLUCDE           = $2AD2 = 10962          rom.asm:5911
PNORM            = $2AA0 = 10912          rom.asm:5877
PNT2VD           = $0D74 =  3444          rom.asm:1835
PNTEND           = $343A = 13370          rom.asm:7330 (unused)
POINT            = $33FF = 13311          rom.asm:7301
POKE             = $27FF = 10239          rom.asm:5480
POPAF            = $23F3 =  9203          rom.asm:4849
POPHL            = $251D =  9501          rom.asm:5040
POPHRT           = $2BB4 = 11188          rom.asm:6058
POPNOK           = $1595 =  5525          rom.asm:2747
POR              = $200C =  8204          rom.asm:4228
POR1             = $2033 =  8243          rom.asm:4254
POS              = $22AC =  8876          rom.asm:4655
POSINT           = $1AEE =  6894          rom.asm:3532
POS_CURSOR       = $0648 =  1608          rom.asm:957
POS_TB_CRS_32    = $097B =  2427          rom.asm:1422
POS_TB_CRS_40    = $09AB =  2475          rom.asm:1426
POUT             = $2705 =  9989          rom.asm:5333
POWER            = $2F66 = 12134          rom.asm:6662
POWER1           = $2F76 = 12150          rom.asm:6670
POWER2           = $2F93 = 12179          rom.asm:6688
POWERS           = $2F46 = 12102          rom.asm:6647
PRINT            = $1C97 =  7319          rom.asm:3764
PRITAB           = $11ED =  4589          rom.asm:2475
PRNTCRLF         = $1CFA =  7418          rom.asm:3813
PRNTFNK          = $0DBB =  3515          rom.asm:1877
PRNTFNKEY        = $0D7C =  3452          rom.asm:1840
PRNTHL           = $2E5E = 11870          rom.asm:6510
PRNTLP           = $1C9A =  7322          rom.asm:3765
PRNTNB           = $1CDD =  7389          rom.asm:3797
PRNTOK           = $1596 =  5526          rom.asm:2750
PRNTRETURN       = $095A =  2394          rom.asm:1399
PRNTST           = $1CE1 =  7393          rom.asm:3799
PRNTVIDEO        = $81EB = 33259          rom.asm:2059
PRNUMS           = $23BD =  9149          rom.asm:4818
PROCES           = $17C0 =  6080          rom.asm:3073
PROGND           = $81BB = 33211          rom.asm:2033
PROGST           = $8240 = 33344          rom.asm:2087
PROMPT           = $16A5 =  5797          rom.asm:2916
PRS              = $23BE =  9150          rom.asm:4819
PRS1             = $23C1 =  9153          rom.asm:4820
PRSLP            = $23C8 =  9160          rom.asm:4823
PRTCHR           = $3AD7 = 15063          rom.asm:8202
PRTCKEY          = $3B26 = 15142          rom.asm:8244
PRTEND           = $3B33 = 15155          rom.asm:8251
PRTK1            = $3B27 = 15143          rom.asm:8245
PRTK2            = $3A96 = 14998          rom.asm:8171 (unused)
PRTK3            = $3ABF = 15039          rom.asm:8188
PRTK4            = $3A94 = 14996          rom.asm:8170
PRTNUM           = $81F7 = 33271          rom.asm:7803
PSG_DAT          = $0041 =    65          rom.asm:53
PSG_REG          = $0040 =    64          rom.asm:52
PSUB             = $2A28 = 10792          rom.asm:5796
PT               = $81F7 = 33271          rom.asm:5142
PT1              = $81F9 = 33273          rom.asm:5143
PT2              = $81FB = 33275          rom.asm:5144
PTCHR1           = $3AF4 = 15092          rom.asm:8216
PTLN             = $1591 =  5521          rom.asm:2744
PTRLP            = $162A =  5674          rom.asm:2833
PUTBUF           = $17FB =  6139          rom.asm:3102
PUTCHRBUF        = $0D67 =  3431          rom.asm:1830
PUTCHRBUF1       = $0DAE =  3502          rom.asm:1870
PUTCRSCHR        = $0767 =  1895          rom.asm:1116
PUTCTL           = $1800 =  6144          rom.asm:3104
PUTFID           = $19FD =  6653          rom.asm:3379
PXLSET           = $3489 = 13449          rom.asm:7378
PXOR             = $2011 =  8209          rom.asm:4231
PXOR1            = $203B =  8251          rom.asm:4260
QTSTLP           = $2383 =  9091          rom.asm:4788
QTSTR            = $237D =  9085          rom.asm:4784
QUARTR           = $30FF = 12543          rom.asm:6865
RADIUS           = $81FB = 33275          rom.asm:7550
RAWPRINT         = $0229 =   553          rom.asm:336
READ             = $1DA2 =  7586          rom.asm:3893
READFG           = $81B2 = 33202          rom.asm:2028
READKBLN         = $0C51 =  3153          rom.asm:1690
READ_VIDEO_LOC   = $060C =  1548          rom.asm:907
READ_VSTAT       = $0641 =  1601          rom.asm:950
RECWRD           = $319D = 12701          rom.asm:6938 (unused)
REDO             = $1D4D =  7501          rom.asm:3857
REM              = $1BE6 =  7142          rom.asm:3668
RESDIV           = $2C52 = 11346          rom.asm:6147
RESEED           = $309D = 12445          rom.asm:6821
RESET            = $3C3F = 15423          rom.asm:8429
RESTMR           = $0329 =   809          rom.asm:500
RESTNL           = $1A66 =  6758          rom.asm:3448
RESTOR           = $1A51 =  6737          rom.asm:3437
RESZER           = $2A93 = 10899          rom.asm:5865
RETADR           = $2174 =  8564          rom.asm:4449
RETINT           = $2CDB = 11483          rom.asm:6239
RETLIN           = $1BDE =  7134          rom.asm:3662
RETNAD           = $1739 =  5945          rom.asm:2998
RETNUL           = $2177 =  8567          rom.asm:4453
RETNUM           = $1FA1 =  8097          rom.asm:4160
RETREL           = $2CCD = 11469          rom.asm:6229
RETURN           = $1BBF =  7103          rom.asm:3646
RG               = $0004 =     4          rom.asm:2095
RGMSG            = $1223 =  4643          rom.asm:2510
RGPTR            = $13A9 =  5033          rom.asm:2537 (unused)
RIGHT            = $2686 =  9862          rom.asm:5250
RIGHT1           = $2564 =  9572          rom.asm:5087
RINPUT           = $80AA = 32938          rom.asm:2006
RLTLP            = $1EE4 =  7908          rom.asm:4062
RND              = $303C = 12348          rom.asm:6768
RND1             = $3078 = 12408          rom.asm:6799
RND2             = $3094 = 12436          rom.asm:6817
RNDTAB           = $30A5 = 12453          rom.asm:6828
RNGTST           = $2F33 = 12083          rom.asm:6637
RONDB            = $2AB4 = 10932          rom.asm:5889
RONDUP           = $2AB3 = 10931          rom.asm:5888
ROUND            = $2A1B = 10779          rom.asm:5790
RP2INST          = $261F =  9759          rom.asm:5204
RPGPNT           = $3395 = 13205          rom.asm:7236
RPT100           = $0516 =  1302          rom.asm:750
RPT101           = $04BD =  1213          rom.asm:698
RPT102           = $04C0 =  1216          rom.asm:700
RPT103           = $04D6 =  1238          rom.asm:713
RPT104           = $04DE =  1246          rom.asm:717
RPTCL1           = $363A = 13882          rom.asm:7592
RPTCRL           = $3627 = 13863          rom.asm:7586
RPTCVB1          = $37BA = 14266          rom.asm:7762
RPTCVB2          = $37C3 = 14275          rom.asm:7767
RPTDRW           = $356D = 13677          rom.asm:7499
RPTEMPTYBUF      = $057A =  1402          rom.asm:817
RPTEMPTYROW      = $08C4 =  2244          rom.asm:1314
RPTFLL1          = $05E2 =  1506          rom.asm:877
RPTINST          = $25F8 =  9720          rom.asm:5187
RPTKBDRD         = $0CA6 =  3238          rom.asm:1734
RPTLDCL          = $32CF = 13007          rom.asm:7113
RPTNLLSRC        = $08EE =  2286          rom.asm:1343
RPTNLLSRC2       = $0919 =  2329          rom.asm:1367
RPTPS            = $31C8 = 12744          rom.asm:6967
RPTRSSR          = $380F = 14351          rom.asm:7830
RPTWLCMBP        = $0BD9 =  3033          rom.asm:1614
RPVOLCG          = $2884 = 10372          rom.asm:5557
RSCALE           = $2E3F = 11839          rom.asm:6490
RST00            = $0000 =     0          rom.asm:75 (unused)
RST08            = $0008 =     8          rom.asm:81 (unused)
RST10            = $0010 =    16          rom.asm:96 (unused)
RST18            = $0018 =    24          rom.asm:102 (unused)
RSTCHRCRS        = $0670 =  1648          rom.asm:979
RSTPSG           = $0BB0 =  2992          rom.asm:1594
RSTSER1          = $3802 = 14338          rom.asm:7822
RSTSTR           = $26A9 =  9897          rom.asm:5270
RSTVDPRAMREG     = $09F5 =  2549          rom.asm:1450
RUN              = $1B7C =  7036          rom.asm:3609
RUNCNT           = $1A01 =  6657          rom.asm:3383
RUNFST           = $166E =  5742          rom.asm:2888
RUNLIN           = $1BA0 =  7072          rom.asm:3629
RXA              = $01CD =   461          rom.asm:270
RXA_EXIT         = $01F3 =   499          rom.asm:288
RXEND            = $3877 = 14455          rom.asm:7887
RX_CHA_AVAIL     = $0100 =   256          rom.asm:138
RZINSTR          = $266A =  9834          rom.asm:5235
SA               = $002E =    46          rom.asm:2116
SAMSG            = $1382 =  4994          rom.asm:2531
SAPTR            = $13D3 =  5075          rom.asm:2558 (unused)
SAVEXP           = $2A94 = 10900          rom.asm:5866
SAVSTP           = $19F4 =  6644          rom.asm:3372
SAVSTR           = $2358 =  9048          rom.asm:4755
SBSCPT           = $2182 =  8578          rom.asm:4459
SC               = $002C =    44          rom.asm:2115
SCALE            = $2AF2 = 10994          rom.asm:5943
SCALLP           = $2AF4 = 10996          rom.asm:5944
SCALMI           = $2E0A = 11786          rom.asm:6452
SCALPL           = $2E20 = 11808          rom.asm:6466
SCERR            = $39D2 = 14802          rom.asm:8055
SCERR1           = $39CE = 14798          rom.asm:8052
SCMSG            = $136D =  4973          rom.asm:2530
SCNEND           = $248F =  9359          rom.asm:4945
SCPTLP           = $2188 =  8584          rom.asm:4463
SCPTR            = $13D1 =  5073          rom.asm:2557 (unused)
SCREEN           = $31D9 = 12761          rom.asm:6986
SCROLLNXTRW      = $086E =  2158          rom.asm:1270
SCROLLUP         = $0855 =  2133          rom.asm:1258
SCR_CURS_X       = $81E4 = 33252          rom.asm:2052
SCR_CURS_Y       = $81E5 = 33253          rom.asm:2053
SCR_CUR_NX       = $81E6 = 33254          rom.asm:2054
SCR_CUR_NY       = $81E7 = 33255          rom.asm:2055
SCR_MODE         = $81E0 = 33248          rom.asm:2050
SCR_NAM_TB       = $81E2 = 33250          rom.asm:2051
SCR_ORG_CHR      = $81E8 = 33256          rom.asm:2056
SCR_SIZE_H       = $81DF = 33247          rom.asm:2049
SCR_SIZE_W       = $81DE = 33246          rom.asm:2048
SCVDP            = $3205 = 12805          rom.asm:7003
SEARCH           = $1701 =  5889          rom.asm:2960
SEED             = $8078 = 32888          rom.asm:1995
SENDCHRPTRNS     = $0A2D =  2605          rom.asm:1488
SENDSND          = $0BD6 =  3030          rom.asm:1612
SERABITS         = $822F = 33327          rom.asm:2084
SERBUF_START     = $8000 = 32768          rom.asm:63
SERIAL           = $37E8 = 14312          rom.asm:7809
SERIALS_EN       = $822E = 33326          rom.asm:2083
SERLED           = $3838 = 14392          rom.asm:7851
SER_BUFSIZE      = $0058 =    88          rom.asm:59
SER_EMPTYSIZE    = $0005 =     5          rom.asm:61
SER_FULLSIZE     = $0050 =    80          rom.asm:60
SETBEEP          = $0520 =  1312          rom.asm:759
SETBRCL          = $32DA = 13018          rom.asm:7121
SETCRSRY         = $072E =  1838          rom.asm:1080
SETCSRCOORDS     = $072F =  1839          rom.asm:1081
SETIO            = $2729 = 10025          rom.asm:5352
SETLIT           = $174B =  5963          rom.asm:3010
SETNAMETABLE     = $05D9 =  1497          rom.asm:872
SETPAR           = $3956 = 14678          rom.asm:7995
SETPTR           = $1625 =  5669          rom.asm:2830
SETSER           = $38E4 = 14564          rom.asm:7937
SETSNDREG        = $0BF7 =  3063          rom.asm:1629
SETTOP           = $0F36 =  3894          rom.asm:2172
SETVDP           = $31EC = 12780          rom.asm:6994 (unused)
SETVDPADRS       = $05EC =  1516          rom.asm:886
SET_GFX_MODE     = $09FA =  2554          rom.asm:1457
SET_GFX_MODE2    = $0A02 =  2562          rom.asm:1461
SET_P1           = $3913 = 14611          rom.asm:7957
SFTPRG           = $15EF =  5615          rom.asm:2793
SGN              = $2CD3 = 11475          rom.asm:6236
SGNEXP           = $1FF9 =  8185          rom.asm:4212
SGNRES           = $81CD = 33229          rom.asm:2041
SHOW_LOGO        = $0494 =  1172          rom.asm:679
SHRITE           = $2B01 = 11009          rom.asm:5952
SHRLP            = $2B04 = 11012          rom.asm:5954
SHRT1            = $2B08 = 11016          rom.asm:5958
SIGNON           = $0F87 =  3975          rom.asm:2206
SIGNS            = $2D2A = 11562          rom.asm:6298
SIN              = $30B7 = 12471          rom.asm:6834
SIN1             = $30E7 = 12519          rom.asm:6854
SINTAB           = $3103 = 12547          rom.asm:6867
SIOBFR           = $81FD = 33277          rom.asm:7808
SIO_A_DI         = $0181 =   385          rom.asm:219
SIO_A_EI         = $018D =   397          rom.asm:228
SIO_A_SETS       = $02FA =   762          rom.asm:457
SIO_B_SETS       = $0300 =   768          rom.asm:463 (unused)
SIO_CA           = $0022 =    34          rom.asm:42
SIO_CB           = $0023 =    35          rom.asm:43
SIO_DA           = $0020 =    32          rom.asm:44
SIO_DB           = $0021 =    33          rom.asm:45 (unused)
SIXDIG           = $2E86 = 11910          rom.asm:6530
SMPVAR           = $2423 =  9251          rom.asm:4873
SMSER1           = $301B = 12315          rom.asm:6746
SN               = $0002 =     2          rom.asm:2094
SND1             = $28F2 = 10482          rom.asm:5618
SND2VID          = $185C =  6236          rom.asm:3165
SNDCHRTOBFR      = $093B =  2363          rom.asm:1383
SNDCLRSET        = $05CF =  1487          rom.asm:863
SNDKEYTOBFR      = $0D55 =  3413          rom.asm:1822
SNDLOGPT         = $054B =  1355          rom.asm:789
SNDOVR           = $2927 = 10535          rom.asm:5648
SNDREGCFG        = $0BBD =  3005          rom.asm:1603
SNERR            = $153C =  5436          rom.asm:2701
SNMSG            = $121C =  4636          rom.asm:2509
SNPTR            = $13A7 =  5031          rom.asm:2536 (unused)
SOUND            = $289B = 10395          rom.asm:5575
SPC              = $0020 =    32          rom.asm:1971
SPCFST           = $2E77 = 11895          rom.asm:6522
SPCLP            = $1D3E =  7486          rom.asm:3849
SPEC_RX_CONDITON = $019B =   411          rom.asm:241
SQR              = $2F5D = 12125          rom.asm:6658
SRCHLIN          = $1969 =  6505          rom.asm:3292
SRCHLN           = $1642 =  5698          rom.asm:2852
SRCHLP           = $1645 =  5701          rom.asm:2853
SREG             = $2841 = 10305          rom.asm:5522
SRPT2            = $3832 = 14386          rom.asm:7848
SRTINK           = $29F9 = 10745          rom.asm:5768
SRTTXT           = $81F1 = 33265          rom.asm:1327
SSTAT            = $29B7 = 10679          rom.asm:5733
SSTSA            = $24EB =  9451          rom.asm:5005
ST               = $001E =    30          rom.asm:2108
STACK            = $813B = 33083          rom.asm:2013
STAKFP           = $2CF5 = 11509          rom.asm:6256
STALL            = $1A7A =  6778          rom.asm:3465
STARTB           = $0ED6 =  3798          rom.asm:2122
STARTEMPTY       = $05CB =  1483          rom.asm:861
STKTHS           = $1F28 =  7976          rom.asm:4103
STLOOK           = $82A4 = 33444          rom.asm:2088
STMSG            = $12F6 =  4854          rom.asm:2523
STOP             = $1A89 =  6793          rom.asm:3475
STORED           = $1B59 =  7001          rom.asm:3589
STPBT            = $81FC = 33276          rom.asm:7807
STPOOL           = $2466 =  9318          rom.asm:4910
STPTR            = $13C3 =  5059          rom.asm:2550 (unused)
STR              = $2348 =  9032          rom.asm:4748
STR1             = $234E =  9038          rom.asm:4750
STRADD           = $2469 =  9321          rom.asm:4912
STRBOT           = $81A8 = 33192          rom.asm:2022
STRE2            = $356A = 13674          rom.asm:7498 (unused)
STRENT           = $1DF9 =  7673          rom.asm:3940
STRPAR           = $3975 = 14709          rom.asm:8011
STRSPC           = $80AD = 32941          rom.asm:2007
STTLIN           = $1CE8 =  7400          rom.asm:3803
SUBCDE           = $2A2A = 10794          rom.asm:5798
SUBPHL           = $2A24 = 10788          rom.asm:5794
SUMLP            = $3024 = 12324          rom.asm:6751
SUMSER           = $300C = 12300          rom.asm:6739
SUPTLZ           = $2F05 = 12037          rom.asm:6607
SUP_BPS          = $39AD = 14765          rom.asm:8047
SVNAM2           = $20E1 =  8417          rom.asm:4368
SVSTAD           = $2376 =  9078          rom.asm:4776
SX               = $81FF = 33279          rom.asm:7431
SY               = $8201 = 33281          rom.asm:7432
SYS              = $27A7 = 10151          rom.asm:5431
SYSRET           = $27D3 = 10195          rom.asm:5450
TAN              = $3118 = 12568          rom.asm:6874
TEMPSTACK        = $818D = 33165          rom.asm:69
TESTALT          = $0CD5 =  3285          rom.asm:1759
TESTCTRL         = $0CE2 =  3298          rom.asm:1765
TESTOS           = $23F5 =  9205          rom.asm:4852
TESTR            = $23D7 =  9175          rom.asm:4832
TF               = $81FF = 33279          rom.asm:5146
TM               = $0018 =    24          rom.asm:2105
TMERR            = $154E =  5454          rom.asm:2713
TMMSG            = $12C3 =  4803          rom.asm:2520
TMPBFR1          = $81EF = 33263          rom.asm:2063
TMPBFR2          = $81F1 = 33265          rom.asm:2064
TMPBFR3          = $81F3 = 33267          rom.asm:2065
TMPBFR4          = $81F5 = 33269          rom.asm:2066
TMPCLR           = $81F1 = 33265          rom.asm:7171
TMPHL            = $81FD = 33277          rom.asm:7175
TMPKEYBFR        = $822B = 33323          rom.asm:2078
TMPSTR           = $81A4 = 33188          rom.asm:2021
TMPTR            = $13BD =  5053          rom.asm:2547 (unused)
TMR              = $2268 =  8808          rom.asm:4616
TMRCNT           = $81CE = 33230          rom.asm:2042
TMSTPL           = $8198 = 33176          rom.asm:2020
TMSTPT           = $8196 = 33174          rom.asm:2019
TOPOOL           = $255C =  9564          rom.asm:5082
TOSTRA           = $24F4 =  9460          rom.asm:5014
TP               = $81FD = 33277          rom.asm:5145
TRYAGN           = $2EE0 = 12000          rom.asm:6580
TSALP            = $24F5 =  9461          rom.asm:5015
TSTBIT           = $3C52 = 15442          rom.asm:8440 (unused)
TSTBRK           = $1A6C =  6764          rom.asm:3454
TSTMEM           = $0F24 =  3876          rom.asm:2160
TSTNUM           = $1EB9 =  7865          rom.asm:4038
TSTOPL           = $239E =  9118          rom.asm:4804
TSTRED           = $2040 =  8256          rom.asm:4266
TSTREM           = $174E =  5966          rom.asm:3011
TSTSGN           = $2CC4 = 11460          rom.asm:6224
TSTSPC           = $196F =  6511          rom.asm:3299
TSTSTR           = $1EBA =  7866          rom.asm:4039
TTYLIN           = $179E =  6046          rom.asm:3058
TXA              = $01F7 =   503          rom.asm:296
TXA_EXIT         = $0210 =   528          rom.asm:310
TXTMD            = $03A5 =   933          rom.asm:559 (unused)
TX_EMP           = $0218 =   536          rom.asm:319
TYPE             = $8192 = 33170          rom.asm:2016
UF               = $0022 =    34          rom.asm:2110
UFERR            = $1548 =  5448          rom.asm:2709
UFMSG            = $1320 =  4896          rom.asm:2525
UFPTR            = $13C7 =  5063          rom.asm:2552 (unused)
UL               = $000E =    14          rom.asm:2100
ULERR            = $1BBA =  7098          rom.asm:3643
ULMSG            = $1271 =  4721          rom.asm:2515
ULPTR            = $13B3 =  5043          rom.asm:2542 (unused)
UNITY            = $2B16 = 11030          rom.asm:5971
UPDATA           = $1A67 =  6759          rom.asm:3449
USR              = $8064 = 32868          rom.asm:1987
VAL              = $26C0 =  9920          rom.asm:5289
VAL1             = $26DE =  9950          rom.asm:5309
VAL2             = $26E8 =  9960          rom.asm:5313
VAL3             = $26EB =  9963          rom.asm:5314
VALIDX           = $37A2 = 14242          rom.asm:7739
VALIDY           = $37A7 = 14247          rom.asm:7745
VAREND           = $81BD = 33213          rom.asm:2034
VDPMODESET       = $0A37 =  2615          rom.asm:1502
VDPMODESET1      = $0A3F =  2623          rom.asm:1511 (unused)
VDPMODESET2      = $0A47 =  2631          rom.asm:1521 (unused)
VDPMODESETEX2    = $0A57 =  2647          rom.asm:1541 (unused)
VDPMODESETMC     = $0A4F =  2639          rom.asm:1531 (unused)
VDP_DAT          = $0030 =    48          rom.asm:48
VDP_SET          = $0032 =    50          rom.asm:49
VIDEOBUFF        = $81F7 = 33271          rom.asm:2067
VIDTMP1          = $821F = 33311          rom.asm:2068
VIDTMP2          = $8221 = 33313          rom.asm:2069
VOLCH            = $2890 = 10384          rom.asm:5564
VOLUME           = $2862 = 10338          rom.asm:5542
VPEEK            = $27DC = 10204          rom.asm:5460
VPOKE            = $2804 = 10244          rom.asm:5485
VREG             = $2990 = 10640          rom.asm:5711
VSTAT            = $29AC = 10668          rom.asm:5726
WAIT             = $270B =  9995          rom.asm:5336
WAITLP           = $2720 = 10016          rom.asm:5346
WARM             = $0ED3 =  3795          rom.asm:2120
WARMST           = $0F6E =  3950          rom.asm:2199
WIDTH            = $3190 = 12688          rom.asm:6929
WLCBPDAT         = $0BE7 =  3047          rom.asm:1624
WLCMBEEP         = $0BCD =  3021          rom.asm:1609
WORDS            = $1007 =  4103          rom.asm:2260
WORDTB           = $1187 =  4487          rom.asm:2374
WRITEBUF         = $08A9 =  2217          rom.asm:1299
WRITE_VIDEO_LOC  = $0621 =  1569          rom.asm:924
WRITE_VREG       = $0636 =  1590          rom.asm:941
WRKSPC           = $805E = 32862          rom.asm:1985
WRTSND           = $297B = 10619          rom.asm:5693
WRTSNDREG        = $0BFC =  3068          rom.asm:1634
WTSPC            = $1975 =  6517          rom.asm:3302
X1               = $81EF = 33263          rom.asm:7425
X1GR             = $3519 = 13593          rom.asm:7471
X2               = $81F7 = 33271          rom.asm:7427
XC               = $81F7 = 33271          rom.asm:7548
XI               = $81FD = 33277          rom.asm:7551
XY2HL            = $3491 = 13457          rom.asm:7386
Y1               = $81F1 = 33265          rom.asm:7426
Y1GR             = $3540 = 13632          rom.asm:7484
Y2               = $81F9 = 33273          rom.asm:7428
YC               = $81F9 = 33273          rom.asm:7549
YI               = $81FF = 33279          rom.asm:7552
ZDATA            = $0083 =   131          rom.asm:2439
ZDINT            = $00BF =   191          rom.asm:2459 (unused)
ZDIV             = $00BD =   189          rom.asm:2457 (unused)
ZEND             = $0080 =   128          rom.asm:2437
ZEQUAL           = $00C5 =   197          rom.asm:2462
ZERARY           = $2223 =  8739          rom.asm:4562
ZERBYT           = $14B9 =  5305          rom.asm:2616
ZEROLP           = $2166 =  8550          rom.asm:4440
ZEROSUP          = $3BE6 = 15334          rom.asm:8366
ZFN              = $00B5 =   181          rom.asm:2448
ZFOR             = $0081 =   129          rom.asm:2438
ZGOSUB           = $008C =   140          rom.asm:2441
ZGOTO            = $0088 =   136          rom.asm:2440
ZGTR             = $00C4 =   196          rom.asm:2461
ZINSTR           = $00DE =   222          rom.asm:2468
ZLEFT            = $00E6 =   230          rom.asm:2469
ZLTH             = $00C6 =   198          rom.asm:2463
ZMINUS           = $00BB =   187          rom.asm:2455
ZMOD             = $00BE =   190          rom.asm:2458 (unused)
ZNEW             = $00B2 =   178          rom.asm:2444
ZNOT             = $00B8 =   184          rom.asm:2451
ZONELP           = $1D17 =  7447          rom.asm:3827
ZOR              = $00C3 =   195          rom.asm:2460
ZPLUS            = $00BA =   186          rom.asm:2454
ZPOINT           = $00DD =   221          rom.asm:2466
ZPRINT           = $00AC =   172          rom.asm:2443
ZREM             = $008E =   142          rom.asm:2442
ZSGN             = $00C7 =   199          rom.asm:2465
ZSPC             = $00B6 =   182          rom.asm:2449
ZSTEP            = $00B9 =   185          rom.asm:2452
ZTAB             = $00B3 =   179          rom.asm:2446
ZTHEN            = $00B7 =   183          rom.asm:2450
ZTIMES           = $00BC =   188          rom.asm:2456 (unused)
ZTO              = $00B4 =   180          rom.asm:2447
_end             = $4D6D = 19821          rom.asm:73 (unused)
_size            = $4D6D = 19821          rom.asm:73 (unused)
absHL            = $3C84 = 15492          rom.asm:8536
basicStarted     = $805D = 32861          rom.asm:67
bufWrap          = $0058 =    88          rom.asm:68
initCTC          = $0304 =   772          rom.asm:472
initPSG          = $0B9F =  2975          rom.asm:1585
initVDP          = $0380 =   896          rom.asm:539
negHL            = $3C87 = 15495          rom.asm:8538
serBufUsed       = $805C = 32860          rom.asm:66
serInPtr         = $8058 = 32856          rom.asm:64
serRdPtr         = $805A = 32858          rom.asm:65


total time: 0.1298 sec.
no errors
