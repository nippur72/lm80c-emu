              	; --------------------------------------
              	; zasm: assemble "rom.asm"
              	; date: 2020-05-02 12:36:26
              	; --------------------------------------


              	; 
              	; ------------------------------------------------------------------------------
              	; LM80C - BOOTLOADER - R3.9
              	; ------------------------------------------------------------------------------
              	; The following code is intended to be used with LM80C Z80-based computer
              	; designed by Leonardo Miliani. Code and computer schematics are released under
              	; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
              	; kind of warranty: you can use them at your own risk.
              	; You are free to use them for any non-commercial use: you are only asked to
              	; maintain the copyright notices, include this advice and the note to the 
              	; attribution of the original version to Leonardo Miliani, if you intend to
              	; redistribuite them.
              	; https://www.leonardomiliani.com
              	; 
              	; Please support me by visiting the following links:
              	; Main project page: https://www.leonardomiliani.com
              	; Schematics and code: https://github.com/leomil72/LM80C
              	; Videos about the computer: https://www.youtube.com/user/leomil72/videos
              	; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
              	; ------------------------------------------------------------------------------
              	
              	; ADDRESS DECODING (bits A6/A5/A4)
              	; 0000xxxx : PIO
              	; 0001xxxx : CTC
              	; 0010xxxx : SIO
              	; 0011xxxx : VDP
              	; 0100xxxx : PSG
              	
              	; label defining for PIO (Parallel Input/Output)
0000:         	PIO_DA          equ %00000000
0001:         	PIO_DB          equ %00000001
0002:         	PIO_CA          equ %00000010
0003:         	PIO_CB          equ %00000011
              	
              	; label defining for CTC (Counter Timer Circuit)
0010:         	CTC_CH0         equ %00010000
0011:         	CTC_CH1         equ %00010001
0012:         	CTC_CH2         equ %00010010
0013:         	CTC_CH3         equ %00010011
              	
              	;label defining for SIO (Serial Input/Output)
0022:         	SIO_CA          equ %00100010
0023:         	SIO_CB          equ %00100011
0020:         	SIO_DA          equ %00100000
0021:         	SIO_DB          equ %00100001
              	
              	;label defining for VDP (Video Display Processor)
0030:         	VDP_DAT         equ %00110000
0032:         	VDP_SET         equ %00110010
              	
              	; label defining for PSG (Programmable Sound Generator)
0040:         	PSG_REG         equ %01000000
0041:         	PSG_DAT         equ %01000001
              	
              	; Interrupt-driven serial I/O interface lead by the Z80 SIO to run modified
              	; NASCOM Basic 4.7 - Full input buffering with incoming data hardware handshaking
              	; Handshake shows full before the buffer is totally filled to allow run-on from the sender
              	
0058:         	SER_BUFSIZE     equ     $58
0050:         	SER_FULLSIZE    equ     $50
0005:         	SER_EMPTYSIZE   equ     $05
              	
8000:         	SERBUF_START    equ     $8000           ; RAM starts here
8058:         	serInPtr        equ     SERBUF_START + SER_BUFSIZE
805A:         	serRdPtr        equ     serInPtr+2
805C:         	serBufUsed      equ     serRdPtr+2
805D:         	basicStarted    equ     serBufUsed+1
0058:         	bufWrap         equ     (SERBUF_START + SER_BUFSIZE) & $FF
818D:         	TEMPSTACK       equ     CURPOS - 3      ; top of BASIC line input buffer so is "free ram" when BASIC resets
              	
              	;------------------------------------------------------------------------------
              	; BASE MEMORY - RESET LOCATION - $0000
              	; the CPU jumps to 0000h after a reset
0000:         	                org     $0000
0000: F3      	RST00:          di                      ; be sure that INTs are disabled
0001: C35102  	                jp      INIT_HW         ; jump to system initialization
              	
              	;------------------------------------------------------------------------------
              	; send a character over serial
0004: FFFFFFFF	                org     $0008
0008: C3F201  	RST08:          jp      TXA
              	
              	;------------------------------------------------------------------------------
              	; interrupt vector when SIO has a char available in its buffer
000B: FF      	                org     $000C
000C: 0001    	                defw    RX_CHA_AVAIL
              	
              	;------------------------------------------------------------------------------
              	; interrupt vector for SIO special conditions (i.e. buf overrun)
              	                org     $000E
000E: 9601    	                defw    SPEC_RX_CONDITON
              	
              	;------------------------------------------------------------------------------
              	; receive a character over serial
              	                org     $0010
0010: C3C801  	RST10:          jp      RXA
              	
              	;------------------------------------------------------------------------------
              	; check serial status
              	
0013: FFFFFFFF	                org     $0018
0017: FF      	
0018: C31F02  	RST18:          jp      CKINCHAR
              	
              	;------------------------------------------------------------------------------
              	; interrupt vectors for CTC 
001B: FFFFFFFF	                org     $0040               ; for CH0 Timer - unused
001F: FF...   	
0040: D281    	                defw    CTC0IV
              	                
              	                org     $0042               ; for CH1 Timer - unused
0042: D581    	                defw    CTC1IV
              	                
              	                org     $0044               ; for CH2 timer - unused
0044: D881    	                defw    CTC2IV
              	                
              	                org     $0046               ; for CH3 Timer - used for 100ths/s counter
0046: DB81    	                defw    CTC3IV
              	
              	;------------------------------------------------------------------------------
              	; interrupt routine for NMI
0048: FFFFFFFF	                org     $0066
004C: FF...   	
0066: C36180  	                jp      NMIUSR              ; jump to execute NMI service routine
              	
              	;------------------------------------------------------------------------------
              	
0069: FFFFFFFF	                org     $00A0
006D: FF...   	
00A0: 4C4D3830	                defb    $4C,$4D,$38,$30,$43,$20,$43,$4F
00A4: 4320434F	
00A8: 4C4F5200	                defb    $4C,$4F,$52,$00,$00,$00,$00,$00
00AC: 00000000	
00B0: 434F4D50	                defb    $43,$4F,$4D,$50,$55,$54,$45,$52
00B4: 55544552	
00B8: 20283230	                defb    $20,$28,$32,$30,$32,$30,$29,$00
00BC: 32302900	
00C0: 44657369	                defb    $44,$65,$73,$69,$67,$6E,$65,$64
00C4: 676E6564	
00C8: 20627900	                defb    $20,$62,$79,$00,$00,$00,$00,$00
00CC: 00000000	
00D0: 4C656F6E	                defb    $4C,$65,$6F,$6E,$61,$72,$64,$6F
00D4: 6172646F	
00D8: 204D696C	                defb    $20,$4D,$69,$6C,$69,$61,$6E,$69
00DC: 69616E69	
00E0: 46572033	FWVER:          defm    'FW 3.9',$20,__date__,$20,__time__,$00
00E4: 2E392032	
00E8: 3032302D	
00EC: 30352D30	
00F0: 32203132	
00F4: 3A33363A	
00F8: 323600  	
              	;------------------------------------------------------------------------------
              	; interrupt driven routine to get chars from Z80 SIO
00FB: FFFFFFFF	                org     $0100
00FF: FF      	
0100: F5      	RX_CHA_AVAIL:   push    AF              ; store A
0101: E5      	                push    HL              ; and HL
0102: CD6001  	                call    A_RTS_OFF       ; disable RTS line
0105: DB20    	                in      A,(SIO_DA)      ; read char from RX buffer into A
0107: 322B82  	                ld      (TMPKEYBFR),A   ; store it into the temp key buffer
010A: CD3301  	                call    CHARINTOBFR     ; sub-routine to put the char into the input buffer
010D: 3A2B82  	                ld      A,(TMPKEYBFR)   ; retrieve char
0110: 32EC81  	                ld      (CHR4VID),A     ; write into buffer for video printing
0113: FE0D    	                cp      CR              ; is it RETURN?
0115: CA1D01  	                jp      Z,CNTRXCHA      ; yes, continue
0118: FE20    	                cp      $20             ; is it another control char (code < 32)?
011A: DA2E01  	                jp      C,LVRXCHA       ; yes, leave w/o printing it on video nor sending back to serial
011D: F5      	CNTRXCHA:       push    AF              ; store char
011E: AF      	                xor     A
011F: 322982  	                ld      (KBDNPT),A      ; a char from serial is like a char printed by BASIC
0122: 3AEB81  	                ld      A,(PRNTVIDEO)   ; load status of print-on-video
0125: FE01    	                cp      $01             ; is the print on video on?
0127: CCA206  	                call    Z,CHAR2VID      ; yes, print on screen
012A: F1      	                pop     AF              ; retrieve char
012B: CDF201  	                call    TXA             ; send back to serial
012E: E1      	LVRXCHA:        pop     HL              ; retrieve HL
012F: F1      	                pop     AF              ; and A
0130: FB      	                ei                      ; re-enable interrupts
0131: ED4D    	                reti                    ; and exit
              	
              	; put a char into the input buffer, char is into A
              	; this sub is called both from the ISR "RX_CHA_AVAIL" and when
              	; the RETURN key is pressed on the keyboard
0133: F5      	CHARINTOBFR:    push    AF              ; store it
0134: 3A5C80  	                ld      A,(serBufUsed)  ; load buffer size
0137: FE58    	                cp      SER_BUFSIZE     ; if buffer is not full
0139: 2002    	                jr      NZ,NOTFULL      ; then store the char
013B: F1      	                pop     AF              ; else drop it
013C: C9      	                ret                     ; and exit
013D: 2A5880  	NOTFULL:        ld      HL,(serInPtr)   ; buffer is not full, can store the char
0140: 23      	                inc     HL              ; load pointer to find first free cell
0141: 7D      	                ld      A,L             ; only check low byte because buffer<256
0142: FE58    	                cp      bufWrap         ; check if the pointer is at the last cell
0144: 2003    	                jr      NZ,NOTWRAP      ; if not then continue
0146: 210080  	                ld      HL,SERBUF_START ; else load the address of the first cell
0149: 225880  	NOTWRAP:        ld      (serInPtr),HL   ; store the new pointer
014C: F1      	                pop     AF              ; then recover the char
014D: 77      	                ld      (HL),A          ; and store it in the appropriate cell
014E: 3A5C80  	                ld      A,(serBufUsed)  ; load the size of the input buffer
0151: 3C      	                inc     A               ; increment it
0152: 325C80  	                ld      (serBufUsed),A  ; and store the new size
0155: FE50    	                cp      SER_FULLSIZE    ; check if input buffer is full
0157: D8      	                ret     C               ; exit if buffer is not full
0158: 3A2E82  	                ld      A,(SERIALS_EN)  ; check if serial 1 is open
015B: 1F      	                rra                     ; bit 0 into Carry: if Carry is 1 then serial 0 is open and...
015C: DC6001  	                call    C,A_RTS_OFF     ; ...stop receiving further chars
015F: C9      	                ret
              	
              	;-------------------------------------------------------------------------------
              	; Z80 SIO MANAGEMENT
              	;-------------------------------------------------------------------------------
              	; disable RTS:
              	; by resetting RTS bit (set to 0), the RTS line is disabled (HIGH)
0160: F5      	A_RTS_OFF:      push    AF              ; store A
0161: 3E05    	                ld      A,%00000101     ; write into WR0: select WR5
0163: D322    	                out     (SIO_CA),A
0165: 3A2F82  	                ld      A,(SERABITS)    ; load data bits
0168: F628    	                or      %00101000       ; TX enable; RTS disable
016A: D322    	                out     (SIO_CA),A      ; send setting
016C: F1      	                pop     AF              ; retrieve A
016D: C9      	                ret                     ; exit
              	
              	; enable RTS
              	; by setting RTS bit (set to 1), the RTS line is enabled (LOW)
016E: F5      	A_RTS_ON:       push    AF              ; store A
016F: 3E05    	                ld      A,%00000101     ; write into WR0: select WR5
0171: D322    	                out     (SIO_CA),A
0173: 3A2F82  	                ld      A,(SERABITS)    ; load data bits
0176: F62A    	                or      %00101010       ; TX enable; RTS enable
0178: D322    	                out     (SIO_CA),A      ; send setting
017A: F1      	                pop     AF              ; retrieve A
017B: C9      	                ret                     ; return
              	
              	; disable SIO RX channel A
017C: F5      	SIO_A_DI:       push    AF              ; store A
017D: 3E03    	                ld      A,%00000011     ; write into WR0: select WR3
017F: D322    	                out     (SIO_CA),A
0181: 3A2F82  	                ld      A,(SERABITS)    ; load the serial bits; RX disabled; auto enable is OFF
0184: D322    	                out     (SIO_CA),A
0186: F1      	                pop     AF              ; retrieve A
0187: C9      	                ret                     ; return
              	
              	; enable SIO RX channel A
0188: F5      	SIO_A_EI:       push    AF              ; store A
0189: 3E03    	                ld      A,%00000011     ; write into WR0: select WR3
018B: D322    	                out     (SIO_CA),A      ; select register
018D: 3A2F82  	                ld      A,(SERABITS)    ; load the serial data bits
0190: CBC7    	                set     0,A             ; set RX enabled; auto enable is OFF
0192: D322    	                out     (SIO_CA),A      ; send setting to SIO
0194: F1      	                pop     AF              ; retrieve A
0195: C9      	                ret
              	
              	
              	; special SIO condition (i.e., buffer overrun)
              	; if buffer overruns then show an error, empty the RX buffer and send
              	; a break char
0196:         	SPEC_RX_CONDITON:
0196: F5      	                push    AF
0197: E5      	                push    HL
0198: CD6001  	                call    A_RTS_OFF       ; disable RTS
019B: CD7C01  	                call    SIO_A_DI        ; disable RX on ch. A
019E: 3A2E82  	                ld      A,(SERIALS_EN)  ; load serial status
01A1: CB97    	                res     2,A             ; disable RX on port 1
01A3: 322E82  	                ld      (SERIALS_EN),A  ; store new serial status 
01A6: DB01    	                in      A,(PIO_DB)      ; read status LEDs
01A8: CBE7    	                set     4,A             ; set 5th pin ON
01AA: D301    	                out     (PIO_DB),A      ; send new setting
01AC: 3E30    	                ld      A,%00110000     ; write into WR0: error reset, select WR0
01AE: D322    	                out     (SIO_CA),A      ; send command to SIO
01B0: 3E03    	                ld      A,CTRLC
01B2: CD3301  	                call    CHARINTOBFR     ; send CTRL-C to BASIC
01B5: AF      	EMPTYCHABFR:    xor     A
01B6: D322    	                out     (SIO_CA),A      ; write to WR0, select RR0
01B8: DB22    	                in      A,(SIO_CA)      ; read RR0 register
01BA: E601    	                and     $01             ; check if input buffer if empty
01BC: CAC301  	                jp      Z,CHABFREMPTY   ; if yes (bit 0 = 0) then leave
01BF: DB20    	                in      A,(SIO_DA)      ; read chars
01C1: 18F2    	                jr      EMPTYCHABFR     ; repeat
01C3: E1      	CHABFREMPTY:    pop     HL
01C4: F1      	                pop     AF
01C5: FB      	                ei                      ; re-enable interrupts
01C6: ED4D    	                reti                    ; return from interrupt
              	
              	;------------------------------------------------------------------------------
              	; retrieve a char from the input buffer
01C8: 3A5C80  	RXA:            ld      A,(serBufUsed)  ; load the buffer size
01CB: A7      	                and     A               ; check if it's 0 (empty)
01CC: CAC801  	                jp      Z,RXA           ; if it's empty, wait for a char
01CF: F3      	                di                      ; disable interrupts
01D0: E5      	                push    HL              ; store HL
01D1: 2A5A80  	                ld      HL,(serRdPtr)   ; load pointer to first available char
01D4: 23      	                inc     HL              ; increment it (go to the next char)
01D5: 7D      	                ld      A,L             ; check if the end of the buffer has been reached
01D6: FE58    	                cp      bufWrap         ; (only check low byte because buffer<256)
01D8: 2003    	                jr      NZ,NOTRDWRAP    ; if not, jump straight
01DA: 210080  	                ld      HL,SERBUF_START ; else reload the starting address of the buffer
01DD: 225A80  	NOTRDWRAP:      ld      (serRdPtr),HL   ; store new pointer to the next char to read
01E0: 3A5C80  	                ld      A,(serBufUsed)  ; load buffer size
01E3: 3D      	                dec     A               ; decrement it
01E4: 325C80  	                ld      (serBufUsed),A  ; and store the new size
01E7: FE05    	                cp      SER_EMPTYSIZE   ; check if input buffer can be considered empty
01E9: 3003    	                jr      NC,RXA_EXIT     ; if not empty yet, then exit
01EB: CD6E01  	                call    A_RTS_ON        ; else re-enable receiving chars
01EE: 7E      	RXA_EXIT:       ld      A,(HL)          ; recover the char and return it into A
01EF: E1      	                pop     HL              ; retrieve HL
01F0: FB      	                ei                      ; re-enable interrupts
01F1: C9      	                ret                     ; return
              	
              	;------------------------------------------------------------------------------
              	; sends a char over the serial (trick for INTs from WikiTI)
              	; char is into A
01F2: F5      	TXA:            push    AF              ; store AF
01F3: C5      	                push    BC              ; store BC
01F4: 47      	                ld      B,A             ; store char
01F5: ED57    	                ld      A,I             ; when loading I into A, P/V is set to the value of IFF (P/V is set if INTs enabled)
01F7: EAFC01  	                jp      PE,CNTTXA       ; if set, jump over
01FA: ED57    	                ld      A,I             ; if not set, test again to fix "false negative" from interrupt occurring at first test
01FC: F5      	CNTTXA:         push    AF              ; store current P/V flag
01FD: F3      	                di                      ; disable INTs
01FE: 3A2E82  	                ld      A,(SERIALS_EN)  ; load serial status
0201: FE05    	                cp      %00000101       ; check if serial 1 is open and RX/TX is enabled 
0203: 2006    	                jr      NZ,TXA_EXIT     ; no, jump over
0205: 78      	                ld      A,B             ; retrieve char
0206: D320    	                out     (SIO_DA),A      ; send char to the SIO
0208: CD1302  	                call    TX_EMP          ; wait for outgoing char to be sent
020B: F1      	TXA_EXIT:       pop     AF              ; retrieve P/V flag
020C: E21002  	                jp      PO,EXTXA        ; if P is reset, INTs were disabled so we can leave right now
020F: FB      	                ei                      ; INTs were enabled, so re-enable interrupts
0210: C1      	EXTXA:          pop     BC              ; retrieve BC
0211: F1      	                pop     AF              ; retrieve AF
0212: C9      	                ret                     ; return
              	
              	;------------------------------------------------------------------------------
              	; wait until outgoing serial has been sent
0213: 97      	TX_EMP:         sub     A               ; set A to 0
0214: 3C      	                inc     A               ; set A to 1
0215: D322    	                out     (SIO_CA),A      ; write to WR0, select RR1
0217: DB22    	                in      A,(SIO_CA)      ; read RR1 register
0219: CB47    	                bit     0,A             ; check if all chars have been sent
021B: CA1302  	                jp      Z,TX_EMP        ; if not (bit 0 = 0) then retrieve
021E: C9      	                ret                     ; else exit
              	
              	
              	;------------------------------------------------------------------------------
              	; check if there is some chars into the buffer
021F: 3A5C80  	CKINCHAR        ld      A,(serBufUsed)  ; load char in buffer
0222: A7      	                and     A               ; compare to 0
0223: C9      	                ret                     ; return
              	
              	;------------------------------------------------------------------------------
              	; print a text from memory, and terminate when $00 is found
0224: 7E      	RAWPRINT:       ld      A,(HL)          ; load character from memory cell pointed by HL
0225: B7      	                or      A               ; is it $00 (end string)?
0226: C8      	                ret     Z               ; Yes, then return
0227: 32EC81  	                ld      (CHR4VID),A     ; store char
022A: F3      	                di
022B: CDA206  	                call    CHAR2VID        ; and send it to screen
022E: FB      	                ei
022F: 23      	                inc     HL              ; and select the next one
0230: 18F2    	                jr      RAWPRINT        ; repeat
              	
              	;-------------------------------------------------
              	; Interrupt service routine (ISR) for CH3 timer
              	; this is used to increment the 100ths of a second counter and for cursor flashing
0232: F5      	CH3_TIMER:      push    AF              ; save regs. A,
0233: C5      	                push    BC              ; BC,
0234: D5      	                push    DE              ; DE,
0235: E5      	                push    HL              ; HL
0236: 21CE81  	                ld      HL,TMRCNT       ; load starting address of the timer
0239: 0604    	                ld      B,$04           ; 4 bytes to check
023B: 34      	INCTMR3:        inc     (HL)            ; increment timer
023C: 2003    	                jr      NZ,CHKCRSR      ; if not zero then exit (finished increment)
023E: 23      	                inc     HL              ; if yes, there was an overflow, so increment next byte
023F: 10FA    	                djnz    INCTMR3         ; repeat for 4 bytes
0241: CD3B07  	CHKCRSR:        call    FLASHCURSOR     ; call the flashing cursor routine
0244: CDF50B  	                call    MNGSNDS         ; call the tone managemenet
0247: CD560C  	                call    KEYBOARD        ; read the keyboard inputs
024A: E1      	                pop     HL              ; retrieve HL,
024B: D1      	                pop     DE              ; DE,
024C: C1      	                pop     BC              ; BC,
024D: F1      	                pop     AF              ; and A
024E: FB      	                ei                      ; re-enable interrupts
024F: ED4D    	                reti                    ; exit from ISR
              	
              	;------------------------------------------------------------------------------
              	;------------------------------------------------------------------------------
              	; HARDWARE INITIALISATION
              	; first run - setup HW & SW
              	;
0251: 218D81  	INIT_HW:        ld      HL,TEMPSTACK    ; load temp stack pointer
0254: F9      	                ld      SP,HL           ; set stack to temp stack pointer
0255: 210080  	                ld      HL,SERBUF_START ; set beginning of input buffer
0258: 225880  	                ld      (serInPtr),HL   ; for incoming chars to store into buffer
025B: 225A80  	                ld      (serRdPtr),HL   ; and for chars to be read from buffer
025E: AF      	                xor     A               ; reset A
025F: 325C80  	                ld      (serBufUsed),A  ; actual buffer size is 0
0262: 322E82  	                ld      (SERIALS_EN),A  ; set serial ports status to OFF
0265: CDD602  	                call    HELLOWRLD       ; little serial blink with LEDs
0268: CDFB02  	                call    initCTC         ; configure CTC, then...
026B: CD930B  	                call    initPSG         ; ...configure PSG
026E: CD8804  	                call    SHOW_LOGO       ; show computer logo
0271: 1E01    	                ld      E,$01           ; E chooses the video mode: 1:graphics 1
0273: CD7403  	                call    initVDP         ; set video display
0276: AF      	                xor     A
0277: ED47    	                ld      I,A             ; set high byte of interrupt vectors to point to page 0
0279: ED5E    	                im      2               ; interrupt mode 2
027B: FB      	                ei                      ; enable interrupts
              	                ; print system messages
027C: AF      	                xor     A               ; A=0 so...
027D: 322982  	                ld      (KBDNPT),A      ; ...inputs don't come from keyboard
0280: 3C      	                inc     A               ; A=1...
0281: 32EB81  	                ld      (PRNTVIDEO),A   ; ...to activate the print-on-video
0284: 213103  	                ld      HL,MSGTXT1      ; sign-on message
0287: CD2402  	                call    RAWPRINT        ; print message
028A: CD2C08  	                call    CURSOR_ON       ; enable cursor
028D: 3A5D80  	                ld      A,(basicStarted); check if BASIC is already started
0290: FE59    	                cp      'Y'             ; to see if this is a power-up
0292: 2016    	                jr      NZ,COLDSTART    ; if not, then do a COLD start
0294: 215A03  	                ld      HL,MSGTXT2      ; message to choose kind of start
0297: CD2402  	                call    RAWPRINT        ; print message
029A: AF      	                xor     A
029B: 32EB81  	                ld      (PRNTVIDEO),A   ; disable print-on-video
029E: CDC801  	CORW:           call    RXA             ; look for a pressed key
02A1: E6DF    	                and     %11011111       ; only UPPERCASE char
02A3: FE43    	                cp      'C'             ; cold start?
02A5: 200B    	                jr      NZ,CHECKWARM    ; no, let's check for warm start
02A7: CDBC02  	                call    ECHO_CHAR       ; echoes the char
02AA: 3E59    	COLDSTART:      ld      A,'Y'           ; yes, set the "BASIC started" flag
02AC: 325D80  	                ld      (basicStarted),A
02AF: C3BE0E  	                jp      COLD            ; start BASIC COLD
02B2: FE57    	CHECKWARM:      cp      'W'
02B4: 20E8    	                jr      NZ,CORW         ; char not recognized, wait again
02B6: CDBC02  	                call    ECHO_CHAR       ; echoes the char
02B9: C3C10E  	                jp      WARM            ; start BASIC WARM
              	
              	;-------------------------------------------------------------------------------
02BC: 32EC81  	ECHO_CHAR:      ld      (CHR4VID),A     ; set char for video printing
02BF: AF      	                xor     A
02C0: 322982  	                ld      (KBDNPT),A      ; input is not from keyboard
02C3: F3      	                di                      ; disable INTs
02C4: CDA206  	                call    CHAR2VID        ; echoes back the pressed key,
02C7: 3E0D    	                ld      A,CR            ; then set a CR
02C9: 32EC81  	                ld      (CHR4VID),A     ; set char for video printing
02CC: CDA206  	                call    CHAR2VID        ; and send it to screen
02CF: FB      	                ei                      ; re-enable INTs
02D0: 3E01    	                ld      A,$01
02D2: 32EB81  	                ld      (PRNTVIDEO),A   ; re-enable video printing
02D5: C9      	                ret                     ; return to caller
              	                
              	;-------------------------------------------------------------------------------
              	; little serial blink with LEDs
02D6: 0E09    	HELLOWRLD:      ld      C,$09           ; 8 LEDs to be turned off + 1 more step to turn off the last LED
02D8: 3ECF    	                ld      A,%11001111     ; set mode 3 (mode control)
02DA: D303    	                out     (PIO_CB),A      ; for PIO port B
02DC: AF      	                xor     A               ; set pins to OUTPUT
02DD: D303    	                out     (PIO_CB),A      ; for port B
02DF: 3C      	                inc     A               ; LSB on
02E0: D301    	LEDLIGHT:       out     (PIO_DB),A      ; turn LEDs on/off for a "Supercar" sequence
02E2: 1E20    	                ld      E,$20           ; little delay
02E4: 0600    	DEC_E:          ld      B,$00           ; count to 256
02E6: 10FE    	COUNTER:        djnz    COUNTER         ; decrement inner counter
02E8: 1D      	                dec     E               ; decrement outer counter
02E9: 20F9    	                jr      NZ,DEC_E        ; finish delay
02EB: CB27    	                sla     A               ; shift reg.A to left 1 bit
02ED: 0D      	                dec     C               ; next LED
02EE: 20F0    	                jr      NZ,LEDLIGHT     ; all LEDs done? no, repeat
02F0: C9      	                ret                     ; return to caller
              	
              	;-------------------------------------------------------------------------------
              	; Z80 SIO default settings for channel A
02F1: 30      	SIO_A_SETS:     defb    %00110000       ; write into WR0: error reset, select WR0
02F2: 18      	                defb    %00011000       ; write into WR0: channel reset
02F3: 04      	                defb    %00000100       ; write into WR0: select WR4
02F4: 44      	                defb    %01000100       ; write into WR4: presc. 16x, 1 stop bit, no parity
02F5: 05      	                defb    %00000101       ; write into WR0: select WR5
02F6: E8      	                defb    %11101000       ; write into WR5: DTR on, TX 8 bits, BREAK off, TX on, RTS off
02F7: 01      	SIO_B_SETS:     defb    %00000001       ; write into WR0: select WR1
02F8: 04      	                defb    %00000100       ; write into WR1: status affects interrupt vectors
02F9: 02      	                defb    %00000010       ; write into WR0: select WR2
02FA: 00      	                defb    %00000000       ; write into WR2: set interrupt vector, but bits D3/D2/D1 of this vector
              	                                        ; will be affected by the channel & condition that raised the interrupt
              	                                        ; (see datasheet): in our example, 0x0C for Ch.A receiving A char, 0x0E
              	                                        ; for special conditions
              	;------------------------------------------------------------------------------
              	; Z80 CTC setting up
02FB:         	initCTC:
02FB: 212503  	                ld      HL,CTCCONF      ; CTC configuration
02FE: 11D281  	                ld      DE,CTC0IV       ; CTC interrupt vector table
0301: 010C00  	                ld      BC,$000C        ; 12 bytes
0304: EDB0    	                ldir                    ; copy data
              	;CH0, CH1, & CH2 disabled
0306: 3E03    	                ld      A,%00000011     ; interrupt off, timer mode, prescaler=16, don't care ext. TRG edge,
              	                                        ; start timer on loading constant, no time constant follows, software reset, command word
0308: D310    	                out     (CTC_CH0),A     ; set CH0
030A: D311    	                out     (CTC_CH1),A     ; set CH1
030C: D312    	                out     (CTC_CH2),A     ; set CH2
              	
              	;init CH3
              	;CH3 divides CPU CLK by 144*256 providing an interrupt signal at 100 Hz (1/100 sec).
              	;f = CPU_CLK/(144*256) => 3,686,400 / ( 36,864 ) => 100Hz
030E: 3EA7    	                ld      A,%10100111     ; interrupt on; timer mode; prescaler=256; don't care ext; automatic trigger;
              	                                        ; time constant follows; cont. operation; command word
0310: D313    	                out     (CTC_CH3),A     ; send to CH3
0312: 3E90    	                ld      A,$90           ; time constant - 90$ (144d)
0314: D313    	                out     (CTC_CH3),A     ; send to CH3
0316: 3E40    	                ld      A,%01000000     ; D7..D3 provide the first part of the int vector (in our case, $0100), followed by
              	                                        ; D2..D1, provided by the CTC (they point to the channel), D0=interrupt word
              	                                        ; so int vector is 01000xx00
0318: D310    	                out     (CTC_CH0),A     ; send to CTC
              	                ; reset cells of 100ths of a second counter
031A: AF      	                xor     A               ; reset A
031B: 21CE81  	                ld      HL,TMRCNT       ; load TMR pointer
031E: 0604    	                ld      B,$04           ; 4 memory cells
0320: 77      	RESTMR:         ld      (HL),A          ; reset n-cell of TMR
0321: 23      	                inc     HL              ; next cell
0322: 10FC    	                djnz    RESTMR          ; repeat for 4 cells
0324: C9      	                ret
              	
0325: FBED4D  	CTCCONF:        defb    $FB,$ED,$4D     ; CTC0 interrupt vector (ei; reti)
0328: FBED4D  	                defb    $FB,$ED,$4D     ; CTC1 interrupt vector (ei; reti)
032B: FBED4D  	                defb    $FB,$ED,$4D     ; CTC2 interrupt vector (ei; reti)
032E: C33202  	                jp      CH3_TIMER       ; CTC3 interrupt vector (sys tick timer)
              	;------------------------------------------------------------------------------
0331: 4C4D3830	MSGTXT1:        defm    "LM80C by Leonardo Miliani",CR
0335: 43206279	
0339: 204C656F	
033D: 6E617264	
0341: 6F204D69	
0345: 6C69616E	
0349: 690D    	
034B: 4669726D	                defm    "Firmware R3.9",CR,0
034F: 77617265	
0353: 2052332E	
0357: 390D00  	
035A: 0D      	MSGTXT2:        defb    CR
035B: 3C433E6F	                defm    "<C>old or <W>arm start? ",0
035F: 6C64206F	
0363: 72203C57	
0367: 3E61726D	
036B: 20737461	
036F: 72743F20	
0373: 00      	
              	; ------------------------------------------------------------------------------
              	; LM80C - VDP ROUTINES - R3.9
              	; ------------------------------------------------------------------------------
              	; The following code is intended to be used with LM80C Z80-based computer
              	; designed by Leonardo Miliani. Code and computer schematics are released under
              	; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
              	; kind of warranty: you can use them at your own risk.
              	; You are free to use them for any non-commercial use: you are only asked to
              	; maintain the copyright notices, include this advice and the note to the 
              	; attribution of the original version to Leonardo Miliani, if you intend to
              	; redistribuite them.
              	; https://www.leonardomiliani.com
              	; 
              	; Please support me by visiting the following links:
              	; Main project page: https://www.leonardomiliani.com
              	; Schematics and code: https://github.com/leomil72/LM80C
              	; Videos about the computer: https://www.youtube.com/user/leomil72/videos
              	; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
              	; ------------------------------------------------------------------------------
              	;
              	;------------------------------------------------------------------------------
              	; VDP INITIALISATION
              	; initialize VDP for a specific graphics mode
              	; INPUT: E -> contains the graphics mode:
              	; 0=text; 1=graphics 1; 2=graphics 2; 3=multicolor; 4=extended graphics 2
0374: D5      	initVDP:        push    DE              ; store E
0375: CDCF09  	                call    EMPTY_VRAM      ; reset VRAM
0378: CDEE09  	                call    SET_GFX_MODE    ; load register settings
037B: CDE309  	                call    EMPTY_RAM       ; reset RAM registers
037E: D1      	                pop     DE              ; restore reg. E
037F: AF      	                xor     A               ; reset A
0380: 47      	                ld      B,A             ; reset B (will be used later)
0381: 7B      	                ld      A,E             ; move E into A
0382: 32E081  	                ld      (SCR_MODE),A    ; store screen mode
0385: FE01    	                cp      $01             ; is it graphics 1 (A=1)?
0387: CABE03  	                jp      Z,G1MD          ; yes, jump over
038A: FE02    	                cp      $02             ; is it graphics 2 (A=2)?
038C: CAFA03  	                jp      Z,G2MD          ; yes, jump over
038F: FE03    	                cp      $03             ; is it multicolor (A=3)?
0391: CA1C04  	                jp      Z,MCMD          ; yes, jump over
0394: FE04    	                cp      $04             ; is it extended graphics 2 (A=4)?
0396: CA3F04  	                jp      Z,EXG2MD        ; yes, jump over; otherwise, it must be $00 so we assume that it's text mode
              	
              	                ; LOAD VDP SETTINGS FOR SELECTED VIDEO MODE:
              	                ; TEXT MODE (G0)
0399:         	TXTMD:          ; load charset
0399: 60      	                ld      H,B
039A: 68      	                ld      L,B             ; HL=first pattern cell $0000
039B: CD0A0A  	                call    LOADCHARSET     ; load patterns into VRAM
              	                ; set cursor & video overlay
039E: AF      	                xor     A               ; reset A
039F: 32E481  	                ld      (SCR_CURS_X),A  ; set cursor position at X=0
03A2: 32E581  	                ld      (SCR_CURS_Y),A  ; and Y=0
03A5: 3E05    	                ld      A,$05           ; light blue
03A7: 32EE81  	                ld      (BKGNDCLR),A    ; set background/border color
03AA: 3E28    	                ld      A,$28
03AC: 32DE81  	                ld      (SCR_SIZE_W),A  ; screen width = 40 cols
03AF: 3E18    	                ld      A,$18
03B1: 32DF81  	                ld      (SCR_SIZE_H),A  ; screen height = 24 rows
03B4: 110008  	                ld      DE,$0800
03B7: ED53E281	                ld      (SCR_NAM_TB),DE ; set name table address
03BB: C37D04  	                jp      ENDVDPSET       ; execute the rest of the video setting
              	
              	                ; GRAPHICS 1 MODE (G1)
03BE:         	G1MD:           ; load pattern table
03BE: 68      	                ld      L,B
03BF: 60      	                ld      H,B             ; HL=first pattern cell $0000
03C0: CD0A0A  	                call    LOADCHARSET     ; load patterns into VRAM
              	                ; set cursor & video overlay
03C3: AF      	                xor     A               ; position cursor
03C4: 32E481  	                ld      (SCR_CURS_X),A  ; at X=0
03C7: 32E581  	                ld      (SCR_CURS_Y),A  ; and Y=0
03CA: 3E20    	                ld      A,$20
03CC: 32DE81  	                ld      (SCR_SIZE_W),A  ; screen width = 32 cols
03CF: 3E18    	                ld      A,$18
03D1: 32DF81  	                ld      (SCR_SIZE_H),A  ; screen height = 24 rows
03D4: 110018  	                ld      DE,$1800
03D7: ED53E281	                ld      (SCR_NAM_TB),DE ; set name table address
              	                ; load color table
03DB: 210020  	                ld      HL,$2000        ; color table start: $2000
03DE: CDE005  	                call    SETVDPADRS
03E1: 3E01    	                ld      A,$01           ; foreground color...
03E3: 32ED81  	                ld      (FRGNDCLR),A    ; ...set to black
03E6: 3E0F    	                ld      A,$0F           ; background color...
03E8: 32EE81  	                ld      (BKGNDCLR),A    ; ...set to white
03EB: 3E1F    	                ld      A,$1F           ; reg.A loaded with colors for chars: bloack pixels on white background
03ED: 0620    	                ld      B,$20           ; 32 bytes of colors
03EF: 0E30    	                ld      C,VDP_DAT       ; VDP data mode
03F1: ED79    	LDCLRTBMD1:     out     (C),A           ; after first byte, the VDP autoincrements VRAM pointer
03F3: 00      	                nop
03F4: 00      	                nop
03F5: 10FA    	                djnz    LDCLRTBMD1      ; repeat for 32 bytes
03F7: C37D04  	                jp      ENDVDPSET       ; execute the rest of the video setting
              	
              	                ; GRAPHICS 2 MODE (G2)
03FA: AF      	G2MD:           xor     A               ; position cursor
03FB: 32E481  	                ld      (SCR_CURS_X),A  ; at X=0
03FE: 32E581  	                ld      (SCR_CURS_Y),A  ; and Y=0
0401: 32DE81  	                ld      (SCR_SIZE_W),A  ; screen width = 256 pixels (0=256)
0404: 3C      	                inc     A               ; black on...
0405: 32ED81  	                ld      (FRGNDCLR),A    ; ...foreground
0408: 3E0F    	                ld      A,$0F           ; white on...
040A: 32EE81  	                ld      (BKGNDCLR),A    ; ...background
040D: 3EC0    	                ld      A,$C0
040F: 32DF81  	                ld      (SCR_SIZE_H),A  ; screen height = 192 pixels
0412: 110018  	                ld      DE,$1800
0415: ED53E281	                ld      (SCR_NAM_TB),DE ; set name table address
0419: C37D04  	                jp      ENDVDPSET       ; execute the rest of the video setting
              	
              	                ; MULTICOLOR MODE (G3)
041C: AF      	MCMD:           xor     A               ; position cursor
041D: 32E481  	                ld      (SCR_CURS_X),A  ; at X=0
0420: 32E581  	                ld      (SCR_CURS_Y),A  ; and Y=0
0423: 3E0F    	                ld      A,$0F           ; white color for...
0425: 32EE81  	                ld      (BKGNDCLR),A    ; ...background and...
0428: 32ED81  	                ld      (FRGNDCLR),A    ; ...foreground (even this is not used in MC)
042B: 3E40    	                ld      A,$40
042D: 32DE81  	                ld      (SCR_SIZE_W),A  ; screen width = 64 blocks
0430: 3E30    	                ld      A,$30
0432: 32DF81  	                ld      (SCR_SIZE_H),A  ; screen height = 48 blocks
0435: 110008  	                ld      DE,$0800
0438: ED53E281	                ld      (SCR_NAM_TB),DE ; set name table address
043C: C37D04  	                jp      ENDVDPSET       ; execute the rest of the video setting
              	
              	                ; EXTENDED GRAPHICS 2 (G4)
043F:         	EXG2MD:         ; load pattern table
043F: 60      	                ld      H,B
0440: 68      	                ld      L,B             ; HL=first pattern cell $0000
0441: CD0A0A  	                call    LOADCHARSET     ; load patterns into VRAM
              	                ; set cursor & video overlay
0444: AF      	                xor     A               ; position cursor
0445: 32E481  	                ld      (SCR_CURS_X),A  ; at X=0
0448: 32E581  	                ld      (SCR_CURS_Y),A  ; and Y=0
044B: 3E20    	                ld      A,$20
044D: 32DE81  	                ld      (SCR_SIZE_W),A  ; screen width = 32 cols
0450: 3E18    	                ld      A,$18
0452: 32DF81  	                ld      (SCR_SIZE_H),A  ; screen height = 24 rows
0455: 110038  	                ld      DE,$3800
0458: ED53E281	                ld      (SCR_NAM_TB),DE ; set name table address
              	                 ; load color table
045C: 210020  	                ld      HL,$2000        ; color table start: $2000
045F: CDE005  	                call    SETVDPADRS
0462: 3E01    	                ld      A,$01           ; foreground color is...
0464: 32ED81  	                ld      (FRGNDCLR),A    ; ...set to black
0467: 3E0F    	                ld      A,$0F           ; whitefor...
0469: 32EE81  	                ld      (BKGNDCLR),A    ; ...background
046C: 3E1F    	                ld      A,$1F           ; reg.A loaded with colors for chars: bloack pixels on white background
046E: 1608    	                ld      D,$08           ; 8 pages of 
0470: 0600    	                ld      B,$00           ; 256 bytes of colors (total of 2,048 cells)
0472: 0E30    	                ld      C,VDP_DAT       ; VDP data mode
0474: ED79    	LDCLRTBEX2:     out     (C),A           ; after first byte, the VDP autoincrements VRAM pointer
0476: 00      	                nop
0477: 00      	                nop
0478: 10FA    	                djnz    LDCLRTBEX2      ; repeat for 256 bytes
047A: 15      	                dec     D               ; did we fill up all the cells?
047B: 20F7    	                jr      NZ,LDCLRTBEX2   ; no, repeat
              	                ; LAST VDP SETTINGS
047D: CD4208  	ENDVDPSET:      call    CURSOR_OFF      ; disable cursor
0480: CD4E05  	                call    EMPTYVIDBUF     ; empty video buffer
0483: AF      	                xor     A
0484: 32E881  	                ld      (SCR_ORG_CHR),A ; store byte used tochar used to empty the video buffer
0487: C9      	                ret                     ; return to caller
              	
              	
              	; show initial logo
0488: CDCF09  	SHOW_LOGO:      call    EMPTY_VRAM      ; reset VRAM
              	                ; set VDP for G2 mode
048B: 0607    	                ld      B,$07           ; set only the first 7 registers
048D: 111000  	                ld      DE,$0010        ; load settings for G2 mode
0490: CDF609  	                call    SET_GFX_MODE2   ; load register settings
0493: 1601    	                ld      D,$01           ; backdrop color set to black
0495: ED51    	                out     (C),D           ; send data to VDP
0497: ED79    	                out     (C),A           ; indicate the register to send data to
              	                ; set name table 
0499: 210018  	                ld      HL,$1800        ; name table address
049C: CDCD05  	                call    SETNAMETABLE    ; set name table (load names into table)
049F: CDFC04  	                call    ERASECLRTBL     ; erase color table (set foreground & background to black)
              	                ; set colors for logo
04A2: 210028  	                ld      HL,$2800        ; 2nd page of color table
04A5: CDE005  	                call    SETVDPADRS
04A8: 0605    	                ld      B,5             ; 5 bands
04AA: 214905  	                ld      HL,CLRTABLE
04AD: 0E30    	                ld      C,VDP_DAT
04AF: 1E08    	                ld      E,$08           ; 8 pixels each pattern        
04B1: 1640    	RPT101:         ld      D,$40           ; 64 chars each band
04B3: 7E      	                ld      A,(HL)
04B4: ED79    	RPT102:         out     (C),A
04B6: 00      	                nop
04B7: 1D      	                dec     E
04B8: 20FA    	                jr      NZ,RPT102
04BA: 1E08    	                ld      E,$08
04BC: 15      	                dec     D
04BD: 20F5    	                jr      NZ,RPT102
04BF: 23      	                inc     HL
04C0: 10EF    	                djnz    RPT101
              	                ; set pattern table
04C2: 210008  	                ld      HL,$0800        ; address of first cell of 2nd area of pattern table
04C5: 11530A  	                ld      DE,LM80CLOGO    ; pointer to logo pattern
04C8: 0600    	                ld      B,$00           ; 256 bytes, 8 rows
04CA: CD2805  	RPT103:         call    LOADLOGOCHRS
04CD: 13      	                inc     DE              ; next logo pattern
04CE: 10FA    	                djnz    RPT103
04D0: 0620    	                ld      B,$20           ; repeat for another 2 rows
04D2: CD2805  	RPT104:         call    LOADLOGOCHRS
04D5: 13      	                inc     DE              ; next logo pattern
04D6: 10FA    	                djnz    RPT104
              	                ; show logo/message, play a beep and wait a while
04D8: 0602    	                ld      B,$02
04DA: AF      	                xor     A
04DB: 57      	                ld      D,A             ; 256 times
04DC: 5F      	                ld      E,A             ; x 256 times
04DD: 32EF81  	                ld      (TMPBFR1),A     ; sound flag set to 0
04E0: 00      	DEC_D:          nop                     ; does nothing...
04E1: 00      	                nop
04E2: 00      	                nop
04E3: 00      	                nop
04E4: 00      	                nop
04E5: 00      	                nop
04E6: 1D      	                dec     E               ; decrement E
04E7: 20F7    	                jr      NZ,DEC_D        ; repeat until $00
04E9: 7A      	                ld      A,D
04EA: FE40    	                cp      $40             ; ...equal to 64
04EC: CC1405  	                call    Z,SETBEEP       ; if yes, start sound
04EF: 15      	                dec     D
04F0: 20EE    	                jr      NZ,DEC_D        ; repeat
04F2: 3AEF81  	                ld      A,(TMPBFR1)
04F5: FE02    	                cp      $02
04F7: C42005  	                call    NZ,BEEPOFF
04FA: 10E4    	                djnz    DEC_D
04FC:         	ERASECLRTBL:    ; erase color table
04FC: 3E11    	                ld      A,$11           ; foreground and background set to black
04FE: 160A    	                ld      D,$0A           ; 10 pages
0500: 0600    	                ld      B,$00           ; 256 color cells per page
0502: 210028  	                ld      HL,$2800        ; first cell of 2nd color table
0505: CDE005  	                call    SETVDPADRS      ; send address
0508: 0E30    	                ld      C,VDP_DAT       ; VDP address for passing data
050A: ED79    	RPT100:         out     (C),A           ; send data
050C: 00      	                nop
050D: 00      	                nop                     ; little delay
050E: 10FA    	                djnz    RPT100          ; repeat for entire page
0510: 15      	                dec     D
0511: 20F7    	                jr      NZ,RPT100       ; repeat for all the pages ($0A00 cells)
0513: C9      	                ret                     ; return to caller
              	
              	; play a beep
0514: 3AEF81  	SETBEEP:        ld      A,(TMPBFR1)     ; check the already-beeped flag?
0517: B7      	                or      A               ; is it 0?
0518: C0      	                ret     NZ              ; no, exit
0519: 3C      	                inc     A               ; flag to 1
051A: 32EF81  	                ld      (TMPBFR1),A     ; set sound
051D: C3C10B  	                jp      WLCMBEEP        ; play a beep & return
              	
              	; beep off
0520: 3E02    	BEEPOFF:        ld      A,$02           ; flag for sound off
0522: 32EF81  	                ld      (TMPBFR1),A     ; set flag
0525: C3C70B  	                jp      NOBEEP          ; stop beep and return
              	
              	
              	; used to load the chars that will compose the logo of the splash screen
0528: 1A      	LOADLOGOCHRS:   ld      A,(DE)          ; load a pattern char of the logo
0529: 87      	                add     A,A
052A: 87      	                add     A,A
052B: 87      	                add     A,A             ; multiply times 8 to get the offset
052C: C5      	                push    BC
052D: D5      	                push    DE              ; store BC and DE
052E: E5      	                push    HL              ; store VRAM address to write to
052F: 217B4A  	                ld      HL,LOGOFONT     ; start of logo font data
0532: 5F      	                ld      E,A
0533: 1600    	                ld      D,$00           ; put offset (A) into DE
0535: 19      	                add     HL,DE           ; get address of pattern data
0536: EB      	                ex      DE,HL           ; move address into DE
0537: E1      	                pop     HL              ; retrieve VRAM address
0538: 0608    	                ld      B,$08           ; 8 bytes per pattern
053A: CDE005  	                call    SETVDPADRS      ; set VDP address
053D: 0E30    	                ld      C,VDP_DAT
053F: 1A      	SNDLOGPT:       ld      A,(DE)          ; load data from RAM
0540: ED79    	                out     (C),A           ; and send to VRAM
0542: 13      	                inc     DE              ; next byte into RAM
0543: 23      	                inc     HL              ; next byte into VRAM (used in future iterations)
0544: 10F9    	                djnz    SNDLOGPT        ; repeat 8 times
0546: D1      	                pop     DE
0547: C1      	                pop     BC              ; retrieve BC & DE
0548: C9      	                ret                     ; return to caller
              	
0549:         	CLRTABLE:       equ $
0549: 181B1314	                defb    $18,$1B,$13,$14,$1D ; colors of background bands of the logo
054D: 1D      	
              	                
              	; empty video buffer
054E: 3AE081  	EMPTYVIDBUF:    ld      A,(SCR_MODE)    ; check screen mode
0551: FE02    	                cp      $02             ; is it G2 mode?
0553: CA7705  	                jp      Z,EMPTYG2       ; yes, jump over
0556: FE03    	                cp      $03             ; is it MC mode?
0558: CAA805  	                jp      Z,EMPTYMC       ; yes, jump over
055B: 3ADF81  	                ld      A,(SCR_SIZE_H)  ; load height of screen
055E: 47      	                ld      B,A             ; move rows into B
055F: AF      	                xor     A               ; filling char is $00
0560: 2AE281  	                ld      HL,(SCR_NAM_TB) ; load the name table address
0563: CDE005  	                call    SETVDPADRS      ; send address to VDP
0566: 0E30    	                ld      C,VDP_DAT       ; VDP address for passing data
0568: 5F      	LDCOLSTOEMPTY:  ld      E,A             ; store filling char into E
0569: 3ADE81  	                ld      A,(SCR_SIZE_W)  ; load # of cols to empty into A
056C: 57      	                ld      D,A             ; move A into D
056D: 7B      	                ld      A,E             ; recover filling char
056E: ED79    	RPTEMPTYBUF:    out     (C),A           ; write empty byte into VRAM
0570: 00      	                nop
0571: 15      	                dec     D               ; decr. D
0572: 20FA    	                jr      NZ,RPTEMPTYBUF  ; repeat for the # of cols
0574: 10F2    	                djnz    LDCOLSTOEMPTY   ; repeat for the # of rows
0576: C9      	                ret                     ; return to caller
0577: 2AE281  	EMPTYG2:        ld      HL,(SCR_NAM_TB) ; yes, additional setup for G2 - load G2 name table address (usually $1800)
057A: CDCD05  	                call    SETNAMETABLE    ; set name table
057D: 210000  	                ld      HL,$0000        ; set pattern table
0580: CDE005  	                call    SETVDPADRS      ; send address to VDP
0583: AF      	                xor     A               ; empty pattern
0584: 1618    	                ld      D,$18           ; 6144 ($1800) cell to clean, 24 pages ($18)
0586: 47      	                ld      B,A             ; 256 bytes for page
0587: 0E30    	                ld      C,VDP_DAT       ; VDP data mode
0589: ED79    	CLRG2PTNTBL:    out     (C),A           ; clear pattern
058B: 00      	                nop                     ; little delay
058C: 00      	                nop
058D: 10FA    	                djnz    CLRG2PTNTBL     ; repeat for 1 page
058F: 15      	                dec     D               ; next page
0590: 20F7    	                jr      NZ,CLRG2PTNTBL  ; repeat
0592: 210020  	                ld      HL,$2000        ; load the color table address
0595: CDE005  	                call    SETVDPADRS      ; send address to VDP
0598: 3AED81  	                ld      A,(FRGNDCLR)    ; load foreground
059B: 87      	                add     A,A
059C: 87      	                add     A,A
059D: 87      	                add     A,A
059E: 87      	                add     A,A             ; move to high nibble
059F: 57      	                ld      D,A             ; store into D
05A0: 3AEE81  	                ld      A,(BKGNDCLR)    ; load background color
05A3: B2      	                or      D               ; combine with background color
05A4: 1618    	                ld      D,$18           ; 6144 ($1800) cells to fill, so 24 pages ($18)
05A6: 1817    	                jr      STARTEMPTY
05A8: 210008  	EMPTYMC:        ld      HL,$0800        ; MC name table
05AB: CDCD05  	                call    SETNAMETABLE    ; set name table
05AE: 210000  	                ld      HL,$0000        ; color table address
05B1: CDE005  	                call    SETVDPADRS      ; send address to VDP
05B4: 3AEE81  	                ld      A,(BKGNDCLR)    ; load background
05B7: 57      	                ld      D,A             ; store into D
05B8: 87      	                add     A,A
05B9: 87      	                add     A,A
05BA: 87      	                add     A,A
05BB: 87      	                add     A,A             ; move to high nibble
05BC: B2      	                or      D               ; set background color for high and low nibble
05BD: 1608    	                ld      D,$08           ; 2048 ($0800) cells to fill, so 8 pages ($08)
05BF: 0E30    	STARTEMPTY:     ld      C,VDP_DAT       ; VDP address for passing data
05C1: 0600    	                ld      B,$00           ; 256 bytes each page ($00=256)
05C3: ED79    	SNDCLRSET:      out     (C),A           ; send color setting
05C5: 00      	                nop                     ; wait a while
05C6: 00      	                nop
05C7: 10FA    	                djnz    SNDCLRSET       ; repeat for 1 page
05C9: 15      	                dec     D               ; have we filled all the pages?
05CA: 20F7    	                jr      NZ,SNDCLRSET    ; no, repeat
05CC: C9      	                ret                     ; return to caller
              	
              	; set name table for G2 mode (patterns from $00 to $FF for each of the 3 areas of the screen)
05CD: CDE005  	SETNAMETABLE:   call    SETVDPADRS      ; send address to VDP
05D0: 0E30    	                ld      C,VDP_DAT       ; VDP address for passing data
05D2: 1603    	                ld      D,$03           ; 3 pages to fill into VRAM (768 cells)
05D4: AF      	                xor     A               ; starting char name #0 (chars go from 0 to 255)
05D5: 47      	                ld      B,A             ; reset B
05D6: ED79    	RPTFLL1:        out     (C),A           ; send name to VRAM
05D8: 00      	                nop
05D9: 3C      	                inc     A               ; increment # of name
05DA: 10FA    	                djnz    RPTFLL1         ; repeat for 256 cells (1 page)
05DC: 15      	                dec     D               ; did we fill all the pages?
05DD: 20F7    	                jr      NZ,RPTFLL1      ; no, continue
05DF: C9      	                ret                     ; return to caller
              	
              	; set an address into VRAM: address is in HL
05E0: 0E32    	SETVDPADRS:     ld      C,VDP_SET       ; VDP address mode
05E2: CBF4    	                set     6,H             ; set bit #6 of address, to write to VRAM
05E4: ED69    	                out     (C),L           ; send low and...
05E6: ED61    	                out     (C),H           ; ...high byte of the first cell
05E8: C9      	                ret                     ; return to caller
              	
              	; clear the video buffer and position the cursor at 0,0
05E9: CD4E05  	CLEARVIDBUF:    call    EMPTYVIDBUF     ; clear video buffer
05EC: AF      	                xor     A               ; reset A
05ED: 32E481  	                ld      (SCR_CURS_X),A  ; cursor X to 0
05F0: 32E581  	                ld      (SCR_CURS_Y),A  ; cursor Y to 0
05F3: C33C06  	                jp      POS_CURSOR      ; position cursor & return to caller
              	
              	; HOME: position the cursor at coords. 0,0 
05F6: AF      	ATHOME:         xor     A               ; position cursor at 0,0 by storing...
05F7: 32E781  	                ld      (SCR_CUR_NY),A  ; ...new Y...
05FA: 32E681  	                ld      (SCR_CUR_NX),A  ; ...and new X
05FD: C34606  	                jp      MOVCRS          ; move cursor to new location & return to caller
              	
              	; load the char or byte at the VRAM position set by HL
              	; value is returned into A
0600: C5      	READ_VIDEO_LOC: push    BC              ; store BC
0601: 0E32    	                ld      C,VDP_SET       ; VDP setting mode
0603: 44      	                ld      B,H
0604: CBB8    	                res     7,B
0606: CBB0    	                res     6,B
0608: ED69    	                out     (C),L           ; low byte then...
060A: ED41    	                out     (C),B           ; high byte
060C: 0E30    	                ld      C,VDP_DAT       ; VDP data mode
060E: 00      	                nop                     ; wait...
060F: 00      	                nop                     ; ...a while
0610: 00      	                nop
0611: ED78    	                in      A,(C)           ; read byte at current VRAM location
0613: C1      	                pop     BC              ; restore BC
0614: C9      	                ret                     ; return to caller
              	
              	; write a byte at the VRAM position pointed by HL
              	; value is in A
0615: C5      	WRITE_VIDEO_LOC:push    BC              ; store BC
0616: 0E32    	                ld      C,VDP_SET       ; VDP setting mode
0618: 44      	                ld      B,H             ; copy H into B
0619: CBB8    	                res     7,B
061B: CBF0    	                set     6,B             ; write to VRAM
061D: ED69    	                out     (C),L           ; low byte then...
061F: ED41    	                out     (C),B           ; high byte of VRAM address
0621: 0E30    	                ld      C,VDP_DAT       ; VDP data mode
0623: 00      	                nop                     ; wait...
0624: 00      	                nop                     ; ...a while
0625: 00      	                nop
0626: ED79    	                out     (C),A           ; write byte into VRAM
0628: C1      	                pop     BC              ; restore BC
0629: C9      	                ret                     ; return to caller
              	
              	; write a value into a specific VDP register
              	; value is in E, register is in A
062A: C5      	WRITE_VREG:     push    BC              ; store BC
062B: C680    	                add     A,$80           ; set VDP to write to registers
062D: 0E32    	                ld      C,VDP_SET       ; VDP setting mode
062F: ED59    	                out     (C),E           ; send data to VDP
0631: ED79    	                out     (C),A           ; select the destination register
0633: C1      	                pop     BC              ; restore BC
0634: C9      	                ret                     ; return to caller
              	
              	; read VDP status register and return value into A
0635: C5      	READ_VSTAT:     push    BC              ; store BC
0636: 0E32    	                ld      C,VDP_SET       ; VDP register access
0638: ED78    	                in      A,(C)           ; read status register
063A: C1      	                pop     BC              ; restore BC
063B: C9      	                ret                     ; return to caller
              	
              	; position the cursor at the current coordinates, preserving underlying char
063C: CD6D06  	POS_CURSOR:     call    LOAD_CRSR_POS   ; load the VRAM address of cursor into HL
063F: CD0006  	                call    READ_VIDEO_LOC  ; load the current char at the cursor position (return in A)
0642: 32E881  	                ld      (SCR_ORG_CHR),A ; store the current char
0645: C9      	                ret
              	
              	; move cursor to new X,Y coordinates
0646: CD6406  	MOVCRS:         call    RSTCHRCRS       ; restore the char in the current cursor position
0649: CD4F06  	                call    NEWCRSRCOORD    ; set new cursor's coordinates
064C: C33C06  	                jp      POS_CURSOR      ; position cursor into new location & return to caller
              	
              	
              	; set new cursor's coordinates:
064F: 3AE681  	NEWCRSRCOORD:   ld      A,(SCR_CUR_NX)  ; load new X
0652: 32E481  	                ld      (SCR_CURS_X),A  ; write new X
0655: 3AE781  	                ld      A,(SCR_CUR_NY)  ; load new Y
0658: 32E581  	                ld      (SCR_CURS_Y),A  ; write new Y
065B: 3EFF    	                ld      A,$FF           ; delete new values
065D: 32E681  	                ld      (SCR_CUR_NX),A  ; of X
0660: 32E781  	                ld      (SCR_CUR_NY),A  ; and Y
0663: C9      	                ret
              	
              	; recover char under the cursor and prints it onto the screen
0664: CD6D06  	RSTCHRCRS:      call    LOAD_CRSR_POS   ; recover old cursor position
0667: 3AE881  	                ld      A,(SCR_ORG_CHR) ; recover old char
066A: C31506  	                jp      WRITE_VIDEO_LOC ; write char into VRAM & return
              	
              	; retrieve cursor position from either current coordinates or next place
              	; return address position into HL
066D: 3AE581  	LOAD_CRSR_POS:  ld      A,(SCR_CURS_Y)  ; load cursor Y
0670: 6F      	                ld      L,A             ; move it into reg.L
0671: AF      	                xor     A               ; reset A
0672: 67      	                ld      H,A             ; reset H
0673: 47      	                ld      B,A             ; reset B
0674: 29      	                add     HL,HL           ; create offset (each address is 2-bytes long so we need to double HL)
0675: 119F09  	                ld      DE,POS_TB_CRS_40; load position table address of cursor for 40 cols
0678: 3ADE81  	                ld      A,(SCR_SIZE_W)  ; load screen width
067B: FE28    	                cp      $28             ; is it 40 cols?
067D: 2803    	                jr      Z,CONT_POS_CURS ; yes, jump over
067F: 116F09  	                ld      DE,POS_TB_CRS_32; no, load position table address of cursor for 32 cols
0682: 19      	CONT_POS_CURS:  add     HL,DE           ; the correct starting address of the required row is now into HL
0683: 5E23562B	                ld      DE,(HL)         ; load starting address of the required row into DE
0687: 2AE281  	                ld      HL,(SCR_NAM_TB) ; load starting address of name table
068A: 19      	                add     HL,DE           ; starting address of the current row into name table
068B: 3AE481  	                ld      A,(SCR_CURS_X)  ; load cursor X
068E: 4F      	                ld      C,A             ; transfer A into C
068F: 09      	                add     HL,BC           ; add X offset: now HL contains the address of the current cursor position
0690: C9      	                ret
              	
              	; find X,Y coordinates of a screen address pointed in VRAM by HL
              	; return them into L & A for X,Y
0691: D5      	HL2XY:          push    DE              ; store DE
0692: ED5BE281	                ld      DE,(SCR_NAM_TB) ; load starting address of name table into DE
0696: AF      	                xor     A               ; clear Carry
0697: ED52    	                sbc     HL,DE           ; find position relative to screen (from 0,0)
0699: D1      	                pop     DE
069A: 3ADE81  	                ld      A,(SCR_SIZE_W)  ; load screen width
069D: 4F      	                ld      C,A             ; move it into C
069E: CD6C3A  	                call    DIV_16_8        ; divide position by C: return Y into L and X into A
06A1: C9      	                ret                     ; return to caller
              	
              	;-------------------------------------------------------------------------------
              	; send current char to video buffer
06A2: F5      	CHAR2VID:       push    AF              ; store AF
06A3: C5      	                push    BC              ; store BC
06A4: D5      	                push    DE              ; store DE
06A5: E5      	                push    HL              ; store HL
06A6: 3AE981  	                ld      A,(CRSR_STATE)  ; store cursor state...
06A9: F5      	                push    AF              ; into stack
06AA: CD4208  	                call    CURSOR_OFF      ; cursor off
06AD: 3AEC81  	                ld      A,(CHR4VID)     ; recover char
06B0: FE19    	                cp      HOME            ; is it HOME char ($19?)
06B2: 2006    	                jr      NZ,CHKCS        ; no, check over
06B4: CDF605  	                call    ATHOME          ; yes, move the cursor to 0,0
06B7: C32D07  	                jp      EXITCHAR2VID    ; exit
06BA: FE0C    	CHKCS:          cp      CS              ; is it the CLEAR char ($0C)?
06BC: 2005    	                jr      NZ,CHKCR        ; no, check over
06BE: CDE905  	                call    CLEARVIDBUF     ; yes, clear video buffer and position cursor at 0,0
06C1: 186A    	                jr      EXITCHAR2VID    ; exit
06C3: FE0D    	CHKCR:          cp      CR              ; is it a carriage return ($0D)?
06C5: 2005    	                jr      NZ,CHKBKSP      ; no, jump over
06C7: CDC408  	                call    CRGRETURN       ; yes, go to the beginning of the next line
06CA: 1861    	                jr      EXITCHAR2VID    ; exit
06CC: FE08    	CHKBKSP:        cp      BKSP            ; is it the backspace ($08)?
06CE: 2005    	                jr      NZ,CHKCRSLFT    ; no, jump over
06D0: CD5F07  	                call    BACKSPACE       ; move cursor left 1 position
06D3: 1858    	                jr      EXITCHAR2VID    ; exit
06D5: FE1C    	CHKCRSLFT:      cp      CRSLFT          ; is it cursor left?
06D7: 2005    	                jr      NZ,CHKCRSUP     ; no, jump over
06D9: CD7207  	                call    CURSORLEFT      ; move cursor left...
06DC: 184F    	                jr      EXITCHAR2VID    ; ...and exit
06DE: FE1E    	CHKCRSUP:       cp      CRSUP           ; is it cursor up?
06E0: 2005    	                jr      NZ,CHKCRSRGT    ; no, jump over
06E2: CDBE07  	                call    CURSORUP        ; move cursor up...
06E5: 1846    	                jr      EXITCHAR2VID    ; ...and exit
06E7: FE1D    	CHKCRSRGT:      cp      CRSRGT          ; is it cursor right?
06E9: 2005    	                jr      NZ,CHKCRSDWN    ; no, jump over
06EB: CDD707  	                call    CURSORRIGHT     ; move cursor right...
06EE: 183D    	                jr      EXITCHAR2VID    ; ...and exit
06F0: FE1F    	CHKCRSDWN:      cp      CRSDN           ; is it cursor down?
06F2: 2005    	                jr      NZ,CHKLF        ; no, jump over
06F4: CD0C08  	                call    CURSORDOWN      ; move cursor up...
06F7: 1834    	                jr      EXITCHAR2VID    ; ...and exit
06F9: FE0A    	CHKLF:          cp      LF              ; is it a line feed ($0A)?
06FB: 2830    	                jr      Z,EXITCHAR2VID  ; CURRENTLY WE DON'T PRINT LF, WE JUST USE CR TO SUBSTITUTE CR+LF COMBINATION
06FD: CD6D06  	                call    LOAD_CRSR_POS   ; recover position of cursor
0700: 3AEC81  	                ld      A,(CHR4VID)     ; recover char to print
0703: CD1506  	                call    WRITE_VIDEO_LOC ; write A into VRAM at (HL)
0706: 3AE581  	                ld      A,(SCR_CURS_Y)  ; load cursor Y into A
0709: 5F      	                ld      E,A             ; store cursor Y into E
070A: 3AE481  	                ld      A,(SCR_CURS_X)  ; load cursor X
070D: 3C      	                inc     A               ; move 1 step to right
070E: 21DE81  	                ld      HL,SCR_SIZE_W   ; cell that keeps the width of screen
0711: BE      	                cp      (HL)            ; have we reached the most right position?
0712: 200F    	                jr      NZ,SETCSRCOORDS ; no, go over
0714: 1C      	                inc     E               ; yes, increment cursor Y (go to next line)
0715: 7B      	                ld      A,E             ; move cursor Y into A
0716: 21DF81  	                ld      HL,SCR_SIZE_H   ; cell that keeps the height of screen
0719: BE      	                cp      (HL)            ; have we reached the bottom of the screen?
071A: 2006    	                jr      NZ,SETCRSRY     ; no, jump over
071C: D5      	                push    DE
071D: CD4908  	                call    SCROLLUP        ; scroll screen up
0720: D1      	                pop     DE
0721: 1D      	                dec     E               ; decrement 1 row, to set cursor Y on the last line
0722: AF      	SETCRSRY:       xor     A               ; then set cursor X to 0 (go to beginning of line)
0723: 32E481  	SETCSRCOORDS:   ld      (SCR_CURS_X),A  ; store current cursor X
0726: 7B      	                ld      A,E             ; recover Y
0727: 32E581  	                ld      (SCR_CURS_Y),A  ; store current cursor Y
072A: CD3C06  	                call    POS_CURSOR      ; position cursor to new location
072D: AF      	EXITCHAR2VID:   xor     A               ; reset char
072E: 32EC81  	                ld      (CHR4VID),A     ; to be sent to screen
0731: F1      	                pop     AF              ; recover cursor state
0732: A7      	                and     A               ; was it off (A=0)?
0733: C42C08  	                call    NZ,CURSOR_ON    ; no, set cursor on
0736: E1      	                pop     HL              ; restore HL
0737: D1      	                pop     DE              ; restore DE
0738: C1      	                pop     BC              ; restore BC
0739: F1      	                pop     AF              ; restore AF
073A: C9      	                ret                     ; return to caller
              	
              	; flash the cursor at the current position
              	; (this sub-routine is called by CH3 timer ISR)
073B: 3AE981  	FLASHCURSOR:    ld      A,(CRSR_STATE)  ; now, check the cursor
073E: A7      	                and     A               ; cursor off (A=0)?
073F: C8      	                ret     Z               ; yes, return
0740: 3ACE81  	                ld      A,(TMRCNT)      ; no, load the first byte of the 100ths of A second's counter
0743: E620    	                and     $20             ; check if it's time to flash the cursor (check bit #6)
0745: 21EA81  	                ld      HL,LSTCSRSTA    ; load address of cell that stores the last cursor state
0748: 46      	                ld      B,(HL)          ; load last state
0749: B8      	                cp      B               ; compare current state with last state
074A: C8      	                ret     Z               ; same state, no change required - exit
074B: 77      	                ld      (HL),A          ; save new state
074C: F5      	                push    AF              ; store A (keep state for later use)
074D: CD6D06  	                call    LOAD_CRSR_POS   ; load current cursor position into HL
0750: F1      	                pop     AF              ; recover current state
0751: 06FF    	                ld      B,$FF           ; cursor char
0753: FE20    	                cp      $20             ; is the cursor on video (A == $20)?
0755: 2804    	                jr      Z,PUTCRSCHR     ; yes, jump over
0757: 3AE881  	                ld      A,(SCR_ORG_CHR) ; no, load the original char
075A: 47      	                ld      B,A             ; move char into B
075B: 78      	PUTCRSCHR:      ld      A,B             ; recover char from B
075C: C31506  	                jp      WRITE_VIDEO_LOC ; print cursor/char at the current position & return
              	
              	
              	; delete the char at the left of the cursor
075F: CD9B07  	BACKSPACE:      call    MVCRS2LFT       ; prepare to move cursor to left
0762: CD6406  	                call    RSTCHRCRS       ; restore char under the cursor
0765: CD4F06  	                call    NEWCRSRCOORD    ; set new cursor's coordinates
0768: CD6D06  	                call    LOAD_CRSR_POS   ; find address of new video cell
076B: AF      	                xor     A               ; null char
076C: CD1506  	                call    WRITE_VIDEO_LOC ; write into video cell
076F: C33C06  	                jp      POS_CURSOR      ; position cursor and return
              	
              	
              	; move cursor to left
0772: F5      	CURSORLEFT:     push    AF              ; store A
0773: 3AE481  	                ld      A,(SCR_CURS_X)  ; load cursor X into A
0776: A7      	                and     A               ; is it at the most left of the screen (X=0)?
0777: 280C    	                jr      Z,CHCKYPOS      ; yes, check Y position
0779: 3D      	                dec     A               ; no, decrement X
077A: 32E681  	                ld      (SCR_CUR_NX),A  ; store new X
077D: 3AE581  	                ld      A,(SCR_CURS_Y)  ; load current cursor Y
0780: 32E781  	                ld      (SCR_CUR_NY),A  ; no move over Y axis
0783: 1811    	                jr      CONTCRSLFT      ; go on moving cursor
0785: 3AE581  	CHCKYPOS:       ld      A,(SCR_CURS_Y)  ; load cursor Y
0788: A7      	                and     A               ; is it at the most top of the screen (Y=0)?
0789: 280E    	                jr      Z,EXITCURSORLEFT; yes, exit doing nothing
078B: 3D      	                dec     A               ; no, decrement Y
078C: 32E781  	                ld      (SCR_CUR_NY),A  ; store new Y
078F: 3ADE81  	                ld      A,(SCR_SIZE_W)  ; load current screen width
0792: 3D      	                dec     A               ; cursor to the most right position (width-0)
0793: 32E681  	                ld      (SCR_CUR_NX),A  ; set new cursor X
0796: CD4606  	CONTCRSLFT:     call    MOVCRS          ; move cursor into new position
0799: F1      	EXITCURSORLEFT: pop     AF              ; restore A
079A: C9      	                ret                     ; return to caller
              	
              	; move cursor 1 position to the left
079B: 3AE481  	MVCRS2LFT:      ld      A,(SCR_CURS_X)  ; load cursor X into A
079E: A7      	                and     A               ; is it at the most left of the screen (X=0)?
079F: 280B    	                jr      Z,CHKYPOS       ; yes, check Y position
07A1: 3D      	                dec     A               ; no, decrement X
07A2: 32E681  	                ld      (SCR_CUR_NX),A  ; store new X
07A5: 3AE581  	                ld      A,(SCR_CURS_Y)  ; load current cursor Y
07A8: 32E781  	                ld      (SCR_CUR_NY),A  ; no move over Y axis
07AB: C9      	                ret                     ; go on moving cursor
07AC: 3AE581  	CHKYPOS:        ld      A,(SCR_CURS_Y)  ; load cursor Y
07AF: A7      	                and     A               ; is it at the most top of the screen (Y=0)?
07B0: 28E7    	                jr      Z,EXITCURSORLEFT; yes, exit doing nothing
07B2: 3D      	                dec     A               ; no, decrement Y
07B3: 32E781  	                ld      (SCR_CUR_NY),A  ; store new Y
07B6: 3ADE81  	                ld      A,(SCR_SIZE_W)  ; load current screen width
07B9: 3D      	                dec     A               ; cursor to the most right position (width-1)
07BA: 32E681  	                ld      (SCR_CUR_NX),A  ; set new cursor X
07BD: C9      	                ret                     ; return to caller
              	
              	; move cursor up
07BE: F5      	CURSORUP:       push    AF              ; store A
07BF: 3AE581  	                ld      A,(SCR_CURS_Y)  ; load cursor Y into A
07C2: A7      	                and     A               ; is it at the most top of the screen (Y=0)?
07C3: 2810    	                jr      Z,EXITCURSORUP  ; yes, exit doing nothing
07C5: 3D      	                dec     A               ; no, decrement Y
07C6: 32E781  	                ld      (SCR_CUR_NY),A  ; store new Y
07C9: 3AE481  	                ld      A,(SCR_CURS_X)  ; load current cursor X
07CC: 32E681  	                ld      (SCR_CUR_NX),A  ; set new cursor X
07CF: CD6406  	                call    RSTCHRCRS       ; restore char under the cursor and print it
07D2: CD4606  	                call    MOVCRS          ; move cursor into new position
07D5: F1      	EXITCURSORUP:   pop     AF              ; restore A
07D6: C9      	                ret                     ; return to caller
              	
              	
              	; move cursor to right
07D7: F5      	CURSORRIGHT:    push    AF              ; store A
07D8: C5      	                push    BC              ; store B
07D9: 3ADE81  	                ld      A,(SCR_SIZE_W)  ; load current screen width (in text modes it's 32 or 40)
07DC: 3D      	                dec     A               ; decrement it (most right can only be 31 or 39)
07DD: 47      	                ld      B,A             ; move A into B
07DE: 3AE481  	                ld      A,(SCR_CURS_X)  ; load cursor X into A    
07E1: B8      	                cp      B               ; is cursor at the most right position on the screen?
07E2: 300C    	                jr      NC,CHCKYPOS2    ; yes, so jump to check Y position
07E4: 3C      	                inc     A               ; no, so increment X
07E5: 32E681  	                ld      (SCR_CUR_NX),A  ; store new X
07E8: 3AE581  	                ld      A,(SCR_CURS_Y)  ; load current cursor Y
07EB: 32E781  	                ld      (SCR_CUR_NY),A  ; no move over Y axis
07EE: 1813    	                jr      CONTCRSRGT      ; go on moving cursor
07F0: 3ADF81  	CHCKYPOS2:      ld      A,(SCR_SIZE_H)  ; load screen height
07F3: 3D      	                dec     A               ; decrement it (last row can only be 23)
07F4: 47      	                ld      B,A             ; move bottom into B
07F5: 3AE581  	                ld      A,(SCR_CURS_Y)  ; load cursor Y into A
07F8: B8      	                cp      B               ; is the cursor at the bottom of the screen?
07F9: 300E    	                jr      NC,EXITCURSORRGHT; yes, exit doing nothing
07FB: 3C      	                inc     A               ; no, increment Y
07FC: 32E781  	                ld      (SCR_CUR_NY),A  ; store new Y
07FF: AF      	                xor     A               ; move cursor to top left
0800: 32E681  	                ld      (SCR_CUR_NX),A  ; store new X
0803: CD6406  	CONTCRSRGT:     call    RSTCHRCRS       ; restore char under the cursor and print it
0806: CD4606  	                call    MOVCRS          ; move cursor into new position
0809: C1      	EXITCURSORRGHT: pop     BC              ; retrieve BC
080A: F1      	                pop     AF              ; restore A
080B: C9      	                ret                     ; return to caller
              	
              	
              	; move cursor down
080C: F5      	CURSORDOWN:     push    AF              ; store A
080D: C5      	                push    BC              ; store B
080E: 3ADF81  	                ld      A,(SCR_SIZE_H)  ; load current screen height (in text modes it's 24)
0811: 3D      	                dec     A               ; decrement it (positions can only vary between 0 and 23)
0812: 47      	                ld      B,A             ; move X into B
0813: 3AE581  	                ld      A,(SCR_CURS_Y)  ; load cursor Y into A             
0816: B8      	                cp      B               ; is current cursor position < 23?
0817: 3010    	                jr      NC,EXITCURSORDOWN; no, exit doing nothing
0819: 3C      	                inc     A               ; yes, increment Y
081A: 32E781  	                ld      (SCR_CUR_NY),A  ; store new Y
081D: 3AE481  	                ld      A,(SCR_CURS_X)  ; load current cursor X
0820: 32E681  	                ld      (SCR_CUR_NX),A  ; set new cursor X
0823: CD6406  	                call    RSTCHRCRS       ; restore char under the cursor and print it
0826: CD4606  	                call    MOVCRS          ; move cursor into new position
0829: C1      	EXITCURSORDOWN: pop     BC              ; retrieve BC
082A: F1      	                pop     AF              ; retrieve A
082B: C9      	                ret                     ; return to caller
              	
              	
              	; set cursor on (visible on screen)
082C: F5      	CURSOR_ON:      push    AF              ; store AF
082D: 3AE981  	                ld      A,(CRSR_STATE)  ; load cursor state
0830: FE01    	                cp      $01             ; is it on?
0832: 280C    	                jr      Z,EXITCURSOR_ON ; yes, so nothing to do
0834: 3ADF81  	                ld      A,(SCR_SIZE_H)  ; check the video mode
0837: FE30    	                cp      $30             ; graphics 2 or 3 (if value>=48)?
0839: 3005    	                jr      NC,EXITCURSOR_ON; yes, so exit (no cursor in graphics 2 or 3)
083B: 3E01    	                ld      A,$01           ; cursor state ON
083D: 32E981  	                ld      (CRSR_STATE),A  ; set state
0840: F1      	EXITCURSOR_ON:  pop     AF              ; restore AF
0841: C9      	                ret                     ; return to caller
              	
              	; set cursor off (invisible on screen)
0842: F5      	CURSOR_OFF:     push    AF              ; store AF
0843: AF      	                xor     A               ; cursor state OFF
0844: 32E981  	                ld      (CRSR_STATE),A  ; set state
0847: F1      	                pop     AF              ; restore AF
0848: C9      	                ret
              	
              	; scroll the screen 1 row up
0849: AF      	SCROLLUP:       xor     A
084A: 32EB81  	                ld      (PRNTVIDEO),A
084D: 2AE281  	                ld      HL,(SCR_NAM_TB) ; start address of the name table
0850: 221F82  	                ld      (VIDTMP1),HL    ; store address of the destination row (1st row of the screen)
0853: 3ADE81  	                ld      A,(SCR_SIZE_W)  ; load the screen width
0856: 5F      	                ld      E,A             ; move width into E
0857: 1600    	                ld      D,$00           ; reset D
0859: 19      	                add     HL,DE           ; HL now contains the address of the source row (2nd row of the screen)
085A: 222182  	                ld      (VIDTMP2),HL    ; store address of source row
085D: 3ADF81  	                ld      A,(SCR_SIZE_H)  ; load the screen height
0860: 3D      	                dec     A               ; decrement the # of rows: now, A contains the # of rows to be moved
0861: 47      	                ld      B,A             ; move # of rows into B
0862: 3ADE81  	SCROLLNXTRW:    ld      A,(SCR_SIZE_W)  ; (re)load the screen width
0865: 5F      	                ld      E,A             ; move width into E
0866: 2A2182  	                ld      HL,(VIDTMP2)    ; load source address
0869: 0E32    	                ld      C,VDP_SET       ; VDP setting mode
086B: ED69    	                out     (C),L           ; low byte of source
086D: ED61    	                out     (C),H           ; high byte of source
086F: 21F781  	                ld      HL,VIDEOBUFF    ; load address of the first cell of the video buffer
0872: 0E30    	                ld      C,VDP_DAT       ; VDP data mode
0874: ED78    	LOADNEXTCOL:    in      A,(C)           ; load char
0876: 77      	                ld      (HL),A          ; store char
0877: 23      	                inc     HL              ; next cell of the buffer
0878: 1D      	                dec     E               ; count the chars to be read
0879: 20F9    	                jr      NZ,LOADNEXTCOL  ; repeat until we read the entire row
087B: 3ADE81  	                ld      A,(SCR_SIZE_W)  ; reload the screen width
087E: 5F      	                ld      E,A             ; move # of rows into E
087F: 1600    	                ld      D,$00           ; reset D
0881: 2A1F82  	                ld      HL,(VIDTMP1)    ; load address of destination row
0884: E5      	                push    HL              ; store HL
0885: 2A2182  	                ld      HL,(VIDTMP2)    ; current source will be..
0888: 221F82  	                ld      (VIDTMP1),HL    ; ..new destination
088B: 19      	                add     HL,DE           ; address of new
088C: 222182  	                ld      (VIDTMP2),HL    ; source row
088F: E1      	                pop     HL              ; restore address of current destination row
0890: CBF4    	                set     6,H             ; writing mode
0892: 0E32    	                ld      C,VDP_SET       ; VDP setting mode
0894: ED69    	                out     (C),L           ; low byte
0896: ED61    	                out     (C),H           ; high byte of address
0898: 21F781  	                ld      HL,VIDEOBUFF    ; video buffer address
089B: 0E30    	                ld      C,VDP_DAT       ; VDP data mode
089D: 7E      	WRITEBUF:       ld      A,(HL)          ; load char
089E: ED79    	                out     (C),A           ; send char
08A0: 23      	                inc     HL              ; increment buffer index
08A1: 1D      	                dec     E               ; next row
08A2: 20F9    	                jr      NZ,WRITEBUF     ; repeat until 0
08A4: 10BC    	                djnz    SCROLLNXTRW     ; repeat for the entire screen
08A6: 3ADE81  	                ld      A,(SCR_SIZE_W)  ; reload screen width
08A9: 47      	                ld      B,A             ; cells to empty into B
08AA: AF      	                xor     A               ; null char
08AB: 0E32    	                ld      C,VDP_SET       ; VDP set mode
08AD: 2A1F82  	                ld      HL,(VIDTMP1)    ; load address of the last row
08B0: CBF4    	                set     6,H             ; writing mode
08B2: ED69    	                out     (C),L           ; low byte then..
08B4: ED61    	                out     (C),H           ; high byte of address
08B6: 0E30    	                ld      C,VDP_DAT       ; VDP data mode
08B8: ED79    	RPTEMPTYROW:    out     (C),A           ; empty cell
08BA: 00      	                nop                     ; delay
08BB: 00      	                nop
08BC: 10FA    	                djnz    RPTEMPTYROW     ; repeat until the last row has been cleaned
08BE: 3E01    	                ld      A,$01
08C0: 32EB81  	                ld      (PRNTVIDEO),A   ; set print-on-video on
08C3: C9      	                ret                     ; return to caller
              	
              	; carriage return: first, it looks for char $00 at the beginning of the line (look for the first null char),
              	; then it starts sendind every char it finds on the screen to the terminal buffer of the BASIC interpreter
              	; until another null char is found. Finally, move to the next line and position the cursor at the beginning
              	; of the row (equivalent to CR+LF), then gets back control to the screen editor to let it interpret the line
81EF:         	CUR_POS         equ     TMPBFR1         ; cursor position
81F1:         	SRTTXT          equ     TMPBFR2         ; start of text line
81F3:         	ENDTXT          equ     TMPBFR3         ; end of text line
08C4:         	CRGRETURN:      ; preliminary: disable cursor if on, and retrieve char under it
08C4: 3AE981  	                ld      A,(CRSR_STATE)  ; recover cursor state
08C7: 32F581  	                ld      (TMPBFR4),A     ; store status
08CA: A7      	                and     A               ; is cursor on?
08CB: C44208  	                call    NZ,CURSOR_OFF   ; yes, so set cursor off
08CE: CD6406  	                call    RSTCHRCRS       ; restore char under it
              	                ; first, check if cursor if off, so that we just interpret return as a new line command
08D1: 3A2982  	                ld      A,(KBDNPT)      ; check if input from keyboad
08D4: A7      	                and     A               ; if 0, input is not from keyboard...
08D5: CA4E09  	                jp      Z,PRNTRETURN    ; ...so just print a carriage return; otherwise, interpret the return
              	                ; first part: look for the beginning of the text line on screen
08D8: CD6D06  	                call    LOAD_CRSR_POS   ; load cursor position into HL
08DB: 22EF81  	                ld      (CUR_POS),HL    ; store it
08DE: ED5BE281	                ld      DE,(SCR_NAM_TB) ; load VRAM address of top-left cell of screen ("home")
08E2: E5      	RPTNLLSRC:      push    HL
08E3: CD2D3A  	                call    CMP16           ; check if at "home"
08E6: E1      	                pop     HL
08E7: CAF208  	                jp      Z,CNTNULL       ; yes, exit because there is nothing before
08EA: 2B      	                dec     HL              ; go 1 step back
08EB: CD0006  	                call    READ_VIDEO_LOC  ; read char of current position
08EE: A7      	                and     A               ; is it $00 (null char)?
08EF: 20F1    	                jr      NZ,RPTNLLSRC    ; no, continue searching
08F1: 23      	                inc     HL              ; move 1 step forward to go back to the last cell with something in
              	                ; second part: look for the ending of the text on screen
08F2: 22F181  	CNTNULL:        ld      (SRTTXT),HL     ; store beginning of text
08F5: 3ADF81  	                ld      A,(SCR_SIZE_H)
08F8: 5F      	                ld      E,A             ; load screen height into DE
08F9: 3ADE81  	                ld      A,(SCR_SIZE_W)
08FC: 6F      	                ld      L,A             ; load screen width into HL
08FD: AF      	                xor     A
08FE: 67      	                ld      H,A
08FF: 57      	                ld      D,A
0900: CD383A  	                call    MUL16           ; multiply HL times DE to get the screen size
0903: ED5BE281	                ld      DE,(SCR_NAM_TB) ; load screen name table start address into DE
0907: 19      	                add     HL,DE           ; get the address...
0908: 2B      	                dec     HL              ; ...of the "last" video cell
0909: EB      	                ex      DE,HL           ; store address into DE
090A: 2AEF81  	                ld      HL,(CUR_POS)    ; retrieve original cursor position
090D: E5      	RPTNLLSRC2:     push    HL
090E: CD2D3A  	                call    CMP16           ; check if at last position on screen (bottom right corner)
0911: E1      	                pop     HL
0912: CA1C09  	                jp      Z,CNTNULL2      ; if yes, exit because these is nothing after
0915: 23      	                inc     HL              ; 1 more step forward
0916: CD0006  	                call    READ_VIDEO_LOC  ; read char of current position
0919: A7      	                and     A               ; is it $00 (null char)?
091A: 20F1    	                jr      NZ,RPTNLLSRC2   ; no, continue searching
091C: 22F381  	CNTNULL2:       ld      (ENDTXT),HL     ; store ending of text line
091F: ED5BF181	                ld      DE,(SRTTXT)     ; load beginning of text line
0923: A7      	                and     A               ; clear Carry
0924: ED52    	                sbc     HL,DE           ; how many chars?
0926: 2826    	                jr      Z,PRNTRETURN    ; no chars found (HL-DE=0), so just print return & leave
              	                ;---    central part: send the text on the screen to the interpreter
0928: 2AF181  	                ld      HL,(SRTTXT)     ; load beginning of text line
092B: ED5BF381	                ld      DE,(ENDTXT)     ; load ending of text line
092F: CD0006  	SNDCHRTOBFR:    call    READ_VIDEO_LOC  ; read char
0932: E5      	                push    HL
0933: CD3301  	                call    CHARINTOBFR     ; send char to buffer
0936: E1      	                pop     HL
0937: 23      	                inc     HL              ; go to next char
0938: E5      	                push    HL              ; store HL
0939: CD2D3A  	                call    CMP16           ; check if DE=HL (finish chars)
093C: E1      	                pop     HL
093D: 20F0    	                jr      NZ,SNDCHRTOBFR  ; no, repeat
093F: 3E0D    	                ld      A,CR            ; yes, so now send carriage return
0941: CD3301  	                call    CHARINTOBFR     ; send to buffer
0944: 2AF381  	                ld      HL,(ENDTXT)     ; recover address of last char of input text
0947: CD9106  	                call    HL2XY           ; retrieve X,Y from address
094A: 7D      	                ld      A,L             ; move Y into A (we don't need X anymore)
094B: 32E581  	                ld      (SCR_CURS_Y),A  ; store new Y
              	                ;---    final part: go at the beginning of a new line on the screen
094E: AF      	PRNTRETURN:     xor     A               ; move to col 0
094F: 32E481  	                ld      (SCR_CURS_X),A  ; store new X
0952: 3AE581  	                ld      A,(SCR_CURS_Y)  ; load cursor Y into A
0955: 3C      	                inc     A               ; new row
0956: 21DF81  	                ld      HL,SCR_SIZE_H   ; load address of cell that keeps screen height
0959: BE      	                cp      (HL)            ; is the cursor over the bottom of the screen?
095A: 3806    	                jr      C,ADDNEWLINE    ; no, jump over
095C: 3D      	                dec     A               ; yes, so come back 1 row, then...
095D: F5      	                push    AF              ; (store A)
095E: CD4908  	                call    SCROLLUP        ; ...scroll the screen before to...
0961: F1      	                pop     AF              ; (retrieve A)
0962: 32E581  	ADDNEWLINE:     ld      (SCR_CURS_Y),A  ; ...store new Y
0965: 3AF581  	                ld      A,(TMPBFR4)     ; retrieve cursor state
0968: A7      	                and     A               ; was it off (A=0)?
0969: C42C08  	                call    NZ,CURSOR_ON    ; no, set cursor on
096C: C33C06  	                jp      POS_CURSOR      ; position cursor to new location & return to caller
              	
              	; ------------------------------------------------------------------------------
              	                ; this table contains the values of the offsets to be added to
              	                ; the starting address of the name table to find the correct
              	                ; value of the first cell of the corresponding row
              	                ; (by doing so, it's faster than doing a multipication)
              	                ; table for graphics 1 text mode: 32 cols
096F: 00002000	POS_TB_CRS_32   defw    $0000,$0020,$0040,$0060,$0080,$00A0,$00C0,$00E0
0973: 40006000	
0977: 8000A000	
097B: C000E000	
097F: 00012001	                defw    $0100,$0120,$0140,$0160,$0180,$01A0,$01C0,$01E0
0983: 40016001	
0987: 8001A001	
098B: C001E001	
098F: 00022002	                defw    $0200,$0220,$0240,$0260,$0280,$02A0,$02C0,$02E0
0993: 40026002	
0997: 8002A002	
099B: C002E002	
              	                ; table for pure text mode: 40 cols
099F: 00002800	POS_TB_CRS_40   defw    $0000,$0028,$0050,$0078,$00A0,$00C8,$00F0,$0118
09A3: 50007800	
09A7: A000C800	
09AB: F0001801	
09AF: 40016801	                defw    $0140,$0168,$0190,$01B8,$01E0,$0208,$0230,$0258
09B3: 9001B801	
09B7: E0010802	
09BB: 30025802	
09BF: 8002A802	                defw    $0280,$02A8,$02D0,$02F8,$0320,$0348,$0370,$0398
09C3: D002F802	
09C7: 20034803	
09CB: 70039803	
              	
              	; ------------------------------------------------------------------------------
              	; reset VRAM
09CF: AF      	EMPTY_VRAM:     xor     A               ; reg.A cleared: we fill up VRAM with $00
09D0: 67      	                ld      H,A
09D1: 6F      	                ld      L,A             ; reset HL
09D2: CDE005  	                call    SETVDPADRS      ; set address of first VRAM cell to $0000
09D5: 0640    	                ld      B,$40           ; $40 pages of RAM...
09D7: 57      	                ld      D,A             ; ...each one with $100 cells (tot. $4000 bytes)
09D8: 0E30    	                ld      C,VDP_DAT       ; VDP data mode
09DA: ED79    	EMPTVRM:        out     (C),A           ; after first byte, the VDP autoincrements VRAM pointer
09DC: 14      	                inc     D               ; next cell
09DD: 00      	                nop
09DE: 20FA    	                jr      NZ,EMPTVRM      ; repeat until page is fully cleared
09E0: 10F8    	                djnz    EMPTVRM         ; repeat for $40 pages
09E2: C9      	                ret                     ; return to caller
              	
              	; empty video registers in SRAM
09E3: 21DE81  	EMPTY_RAM:      ld      HL,SCR_SIZE_W   ; address of first register
09E6: AF      	                xor     A               ; $00 to clean the registers
09E7: 0645    	                ld      B,CHASNDDTN-SCR_SIZE_W; how many bytes to clean (this is calculated dinamically
              	                                        ; since we can add/remove some registers)
09E9: 77      	RSTVDPRAMREG:   ld      (HL),A          ; reset register
09EA: 23      	                inc     HL              ; next register
09EB: 10FC    	                djnz    RSTVDPRAMREG    ; repeat
09ED: C9      	                ret                     ; return to caller
              	
              	; ------------------------------------------------------------------------------
              	; set a specific graphics mode, passed into reg. E
09EE: 0608    	SET_GFX_MODE:   ld      B,$08           ; 8 registers means 8 bytes..
09F0: CB23    	                sla     E               ; multiply E by 8..
09F2: CB23    	                sla     E               ; so that reg. E can point..
09F4: CB23    	                sla     E               ; to the correct settings
09F6: 1600    	SET_GFX_MODE2:  ld      D,$00           ; reset D
09F8: 212B0A  	                ld      HL,VDPMODESET   ; pointer to register settings | <= here points the SHOW_LOGO sub-routine
09FB: 19      	                add     HL,DE           ; add offset to get the correct set of values for the required mode
09FC: 3E80    	                ld      A,$80           ; start with REG0 ($80+register number)
09FE: 0E32    	                ld      C,VDP_SET       ; VDP set
0A00: 56      	LDREGVLS:       ld      D,(HL)          ; load register's value
0A01: ED51    	                out     (C),D           ; send data to VDP
0A03: ED79    	                out     (C),A           ; indicate the register to send data to
0A05: 3C      	                inc     A               ; next register
0A06: 23      	                inc     HL              ; next value
0A07: 10F7    	                djnz    LDREGVLS        ; repeat for 8 registers
0A09: C9      	                ret
              	
              	; ------------------------------------------------------------------------------
0A0A:         	LOADCHARSET:    ; reg. A contains the video mode
              	                ; reg. HL contains address of pattern table into VRAM
0A0A: 0600    	                ld      B,$00           ; 0=256 chars to load (complete charset)
0A0C: CBF4    	                set     $06,H           ; add $4000 to address to indicate that we want to write into VRAM
0A0E: 0E32    	                ld      C,VDP_SET       ; load VDP address into C
0A10: ED69    	                out     (C),L           ; send low byte of address
0A12: ED61    	                out     (C),H           ; send high byte
0A14: 217B3A  	                ld      HL,CHRST68      ; starting address of 6x8 charset into ROM
0A17: A7      	                and     A               ; is it text mode (A=0)?
0A18: 2803    	                jr      Z,NXTCHAR       ; yes, so jump to load chars into VRAM
0A1A: 217B42  	                ld      HL,CHRST88      ; no, so we change and load the 8x8 charset
0A1D: 1608    	NXTCHAR:        ld      D,$08           ; 8 bytes per pattern char
0A1F: 0E30    	                ld      C,VDP_DAT       ; VDP data mode
0A21: 7E      	SENDCHRPTRNS:   ld      A,(HL)          ; load byte to send to VDP
0A22: ED79    	                out     (C),A           ; write byte into VRAM
0A24: 23      	                inc     HL              ; inc byte pointer
0A25: 15      	                dec     D               ; 8 bytes sents (0 char)?
0A26: 20F9    	                jr      NZ,SENDCHRPTRNS ; no, continue
0A28: 10F3    	                djnz    NXTCHAR         ; yes, decrement chars counter and continue for all the chars
0A2A: C9      	                ret                     ; return to caller
              	
              	;------------------------------------------------------------------------------
              	; NAME TABLE:       buffer video - contains the chars to be shown on video
              	; PATTERN TABLE:    charset - contains the chars/tiles to be loaded into the name table
              	; COLOR TABLE:      color settings for chars/tiles
              	
              	                ; VDP register settings for a text display
0A2B: 00      	VDPMODESET      defb    %00000000       ; reg.0: external video off
0A2C: D0      	                defb    %11010000       ; reg.1: 16K VRAM, video on, int. off, text mode (40x24)
0A2D: 02      	                defb    $02             ; reg.2: name table set to $0800 ($02x$400)
0A2E: 00      	                defb    $00             ; reg.3: not used in text mode
0A2F: 00      	                defb    $00             ; reg.4: pattern table set to $0000
0A30: 00      	                defb    $00             ; reg.5: not used in text mode
0A31: 00      	                defb    $00             ; reg.6: not used in text mode
0A32: F5      	                defb    $f5             ; reg.7: white text on light blue background
              	
0A33:         	VDPMODESET1     ; VDP register settings for a graphics 1 mode
0A33: 00      	                defb    %00000000       ; reg.0: ext. video off
0A34: C0      	                defb    %11000000       ; reg.1: 16K Vram; video on, int off, graphics mode 1, sprite size 8x8, sprite magn. 0
0A35: 06      	                defb    $06             ; reg.2: name table address: $1800
0A36: 80      	                defb    $80             ; reg.3: color table address: $2000
0A37: 00      	                defb    $00             ; reg.4: pattern table address: $0000
0A38: 36      	                defb    $36             ; reg.5: sprite attr. table address: $1B00
0A39: 07      	                defb    $07             ; reg.6: sprite pattern table addr.: $3800
0A3A: 05      	                defb    $05             ; reg.7: backdrop color (light blue)
              	
0A3B:         	VDPMODESET2     ; VDP register settings for a graphics 2 mode
0A3B: 02      	                defb    %00000010       ; reg.0: graphics 2 mode, ext. video dis.
0A3C: C0      	                defb    %11000000       ; reg.1: 16K VRAM, video on, INT off, sprite size 8x8, sprite magn. 0
0A3D: 06      	                defb    $06             ; reg.2: name table addr.: $1800
0A3E: FF      	                defb    $FF             ; reg.3: color table addr.: $2000
0A3F: 03      	                defb    $03             ; reg.4: pattern table addr.: $0000
0A40: 36      	                defb    $36             ; reg.5: sprite attr. table addr.: $1B00
0A41: 07      	                defb    $07             ; reg.6: sprite pattern table addr.: $3800
0A42: 05      	                defb    $05             ; reg.7: backdrop color: light blue
              	
0A43:         	VDPMODESETMC    ; VDP register settings for a multicolor mode
0A43: 00      	                defb    %00000000       ; reg.0: ext. video dis.
0A44: CB      	                defb    %11001011       ; reg.1: 16K VRAM, video on, INT off, multicolor mode, sprite size 8x8, sprite magn. 0
0A45: 02      	                defb    $02             ; reg.2: name table addr.: $0800
0A46: 00      	                defb    $00             ; reg.3: don't care
0A47: 00      	                defb    $00             ; reg.4: pattern table addr.: $0000
0A48: 36      	                defb    $36             ; reg.5: sprite attr. table addr.: $1B00
0A49: 07      	                defb    $07             ; reg.6: sprite pattern table addr.: $3800
0A4A: 0F      	                defb    $0F             ; reg.7: backdrop color (white)
              	
0A4B:         	VDPMODESETEX2   ; VDP register settings for an extended graphics 2 mode
0A4B: 02      	                defb    %00000010       ; reg.0: graphics 2 mode, ext. video dis.
0A4C: C0      	                defb    %11000000       ; reg.1: 16K VRAM, video on, INT off, sprite size 8x8, sprite magn. 0
0A4D: 0E      	                defb    $0E             ; reg.2: name table addr.: $3800
0A4E: 9F      	                defb    $9F             ; reg.3: color table addr.: $2000
0A4F: 00      	                defb    $00             ; reg.4: pattern table addr.: $0000
0A50: 76      	                defb    $76             ; reg.5: sprite attr. table addr.: $3B00
0A51: 03      	                defb    $03             ; reg.6: sprite pattern table addr.: $1800
0A52: 05      	                defb    $05             ; reg.7: backdrop color: light blue
              	
0A53:         	LM80CLOGO       ; patterns to compose the splash screen logo
0A53: 00000000	                defb    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0A57: 00...   	
0A73: 00000F0A	                defb    0,0,15,10,11,16,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0A77: 0B100000	
0A7B: 00000000	
0A7F: 00...   	
0A93: 00000D17	                defb    0,0,13,23,0,12,0,0,0,1,0,0,0,20,0,0,6,5,6,21,22,7,6,21,22,7,6,1,1,7,0,0
0A97: 000C0000	
0A9B: 00010000	
0A9F: 00140000	
0AA3: 06050615	
0AA7: 16070615	
0AAB: 16070601	
0AAF: 01070000	
0AB3: 00000D00	                defb    0,0,13,0,0,12,0,0,0,1,0,0,0,1,20,6,1,5,3,5,3,5,3,5,3,5,3,5,3,5,0,0
0AB7: 000C0000	
0ABB: 00010000	
0ABF: 00011406	
0AC3: 01050305	
0AC7: 03050305	
0ACB: 03050305	
0ACF: 03050000	
0AD3: 00000D00	                defb    0,0,13,0,0,12,0,0,0,1,0,0,0,1,1,1,1,5,9,20,19,8,3,5,19,5,3,5,0,0,0,0
0AD7: 000C0000	
0ADB: 00010000	
0ADF: 00010101	
0AE3: 01050914	
0AE7: 13080305	
0AEB: 13050305	
0AEF: 00000000	
0AF3: 00000D00	                defb    0,0,13,0,0,12,0,0,0,1,0,0,0,1,0,8,3,5,6,21,22,7,3,1,22,5,3,5,0,0,0,0
0AF7: 000C0000	
0AFB: 00010000	
0AFF: 00010008	
0B03: 03050615	
0B07: 16070301	
0B0B: 16050305	
0B0F: 00000000	
0B13: 00000D00	                defb    0,0,13,0,0,12,0,0,0,1,0,0,0,1,0,0,3,5,3,5,3,5,3,5,3,5,3,5,3,5,0,0
0B17: 000C0000	
0B1B: 00010000	
0B1F: 00010000	
0B23: 03050305	
0B27: 03050305	
0B2B: 03050305	
0B2F: 03050000	
0B33: 00000D00	                defb    0,0,13,0,0,12,0,0,0,1,4,4,0,1,0,0,3,5,9,20,19,8,9,20,19,8,9,1,1,8,0,0
0B37: 000C0000	
0B3B: 00010404	
0B3F: 00010000	
0B43: 03050914	
0B47: 13080914	
0B4B: 13080901	
0B4F: 01080000	
0B53: 00000E12	                defb    0,0,14,18,18,17,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0B57: 12110000	
0B5B: 00000000	
0B5F: 00...   	
0B73: 00000000	                defb    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0; ------------------------------------------------------------------------------
0B77: 00...   	
              	; LM80C - PSG ROUTINES - R3.9
              	; ------------------------------------------------------------------------------
              	; The following code is intended to be used with LM80C Z80-based computer
              	; designed by Leonardo Miliani. Code and computer schematics are released under
              	; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
              	; kind of warranty: you can use them at your own risk.
              	; You are free to use them for any non-commercial use: you are only asked to
              	; maintain the copyright notices, include this advice and the note to the 
              	; attribution of the original version to Leonardo Miliani, if you intend to
              	; redistribuite them.
              	; https://www.leonardomiliani.com
              	; 
              	; Please support me by visiting the following links:
              	; Main project page: https://www.leonardomiliani.com
              	; Schematics and code: https://github.com/leomil72/LM80C
              	; Videos about the computer: https://www.youtube.com/user/leomil72/videos
              	; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
              	; ------------------------------------------------------------------------------
              	;
              	; ------------------------------------------------------------------------------
              	
              	;------------------------------------------------------------------------------
              	; configure the PSG
0B93: 212382  	initPSG:        ld      HL,CHASNDDTN    ; starting address of sound & keyboard RAM registers
0B96: 060A    	                ld      B,$0A           ; # of PSG sound & keyboard registers
0B98: AF      	                xor     A               ; reset A
0B99: 77      	EMPTSNDBFR:     ld      (HL),A          ; reset RAM register
0B9A: 23      	                inc     HL              ; next register
0B9B: 10FC    	                djnz    EMPTSNDBFR      ; repeat
0B9D: 0610    	CLRPSGREGS:     ld      B,$10           ; 16 registers to set
0B9F: 21B10B  	                ld      HL,SNDREGCFG    ; starting address of register settings
0BA2: 1600    	                ld      D,$00           ; first register
0BA4: 7A      	RSTPSG:         ld      A,D             ; register value
0BA5: CDEB0B  	                call    SETSNDREG       ; select register
0BA8: 7E      	                ld      A,(HL)          ; load value
0BA9: CDF00B  	                call    WRTSNDREG       ; write to register
0BAC: 14      	                inc     D               ; next register
0BAD: 23      	                inc     HL              ; next value
0BAE: 10F4    	                djnz    RSTPSG          ; repeat for each register
0BB0: C9      	                ret                     ; return to caller
              	
0BB1: 00000000	SNDREGCFG:      defb $00,$00,$00,$00,$00,$00,$00,%01111111
0BB5: 0000007F	
0BB9: 00000000	                defb $00,$00,$00,$00,$00,$00,$ff,$ff
0BBD: 0000FFFF	
              	                ; reg. 7: set I/O ch.A to OUTPUT, I/O ch.B to INPUT; set noise to OFF; set audio to OFF
              	
              	
              	; routines to play a welcome beep on channel C (tone 4010) and to shut it off
0BC1: 21DB0B  	WLCMBEEP:       ld      HL,WLCBPDAT     ; data address
0BC4: C3CA0B  	                jp      SENDSND
0BC7: 21E30B  	NOBEEP:         ld      HL,NOBPDAT      ; data address
0BCA: C5      	SENDSND:        push    BC
0BCB: 0604    	                ld      B,$04           ; 4 pairs
0BCD: 7E      	RPTWLCMBP:      ld      A,(HL)          ; read register #
0BCE: CDEB0B  	                call    SETSNDREG
0BD1: 23      	                inc     HL              ; next cell
0BD2: 7E      	                ld      A,(HL)          ; read value
0BD3: CDF00B  	                call    WRTSNDREG
0BD6: 23      	                inc     HL
0BD7: 10F4    	                djnz    RPTWLCMBP       ; repeat
0BD9: C1      	                pop     BC
0BDA: C9      	                ret                     ; return to caller
              	
0BDB: 077B0456	WLCBPDAT:       defb    $07,%01111011,$04,$56,$05,$00,$0A,$0F
0BDF: 05000A0F	
0BE3: 04000500	NOBPDAT:        defb    $04,$00,$05,$00,$0A,$00,$07,%01111111
0BE7: 0A00077F	
              	
              	
              	; select register on PSG
0BEB: 0E40    	SETSNDREG:      ld      C,PSG_REG       ; PSG register port
0BED: ED79    	                out     (C),A           ; set register
0BEF: C9      	                ret                     ; return to caller
              	
              	; send data to PSG
0BF0: 0E41    	WRTSNDREG:      ld      C,PSG_DAT       ; PSG data port
0BF2: ED79    	                out     (C),A           ; send data
0BF4: C9      	                ret                     ; return to caller
              	
              	; manage the sounds' duration: each time this subroutine is called, it
              	; decrements the single sound durations (measured in ms) and eventually
              	; shut off the audio channel whose counter has reached 0.
              	; (this sub-routine is called by CH3 timer ISR)
0BF5: DDE5    	MNGSNDS:        push    IX              ; store IX
0BF7: DD212382	                ld      IX,CHASNDDTN    ; starting address of tones duration
0BFB: 0603    	                ld      B,$03           ; 3 channels to check
0BFD: 2601    	                ld      H,$01           ; mixer channels: A=>bit 1, B=>bit 2, C=>bit 3
0BFF: DD5E00  	CHKSNDCH:       ld      E,(IX+0)        ; load LSB into E
0C02: DD5601  	                ld      D,(IX+1)        ; load MSB into D
0C05: 7B      	                ld      A,E             ; load E into A
0C06: B2      	                or      D               ; check that DE=0
0C07: 282D    	                jr      Z,CNTCHKSND     ; yes, jump over
0C09: 1B      	                dec     DE              ; no, so decrement DE
0C0A: 7B      	                ld      A,E             ; reload E into A...
0C0B: DD7300  	                ld      (IX+0),E        ; store new...
0C0E: DD7201  	                ld      (IX+1),D        ; ...duration and...
0C11: B2      	                or      D               ; ...do another check to see if DE=0
0C12: 2022    	                jr      NZ,CNTCHKSND    ; no, so jump over
              	                                        ; if yes, let's shut down the corresponding channel
              	                                        ; to shut down a tone we set 0 into tone register
              	                                        ; and disable the channel into mixer
0C14: 3E03    	                ld      A,$03           ; three channels
0C16: 90      	                sub     B               ; find current channel (0->A, 1->B, 2->C)
0C17: 87      	                add     A,A             ; and find first register (A=>0, B=>2, C=>4)
0C18: 0E40    	                ld      C,PSG_REG       ; PSG register selector port
0C1A: ED79    	                out     (C),A           ; select first tone register of channel
0C1C: 2E00    	                ld      L,$00           ; value 0 into L
0C1E: 0E41    	                ld      C,PSG_DAT       ; PSG data selector port
0C20: ED69    	                out     (C),L           ; write 0 into register
0C22: 0E40    	                ld      C,PSG_REG       ; PSG register selector port
0C24: 3C      	                inc     A               ; next tone register
0C25: ED79    	                out     (C),A           ; select second tone register of channel
0C27: 0E41    	                ld      C,PSG_DAT       ; PSG data selector port
0C29: ED69    	                out     (C),L           ; write 0 into register
0C2B: 3E07    	                ld      A,$07           ; mixer register
0C2D: 0E40    	                ld      C,PSG_REG       ; PSG register selector port
0C2F: ED79    	                out     (C),A           ; set mixer register
0C31: ED78    	                in      A,(C)           ; load current value
0C33: B4      	                or      H               ; set off the channel into the mixer (remember that 1=OFF)
0C34: ED79    	                out     (C),A           ; send new value for the mixer
0C36: DD23    	CNTCHKSND:      inc     IX              ; set for...
0C38: DD23    	                inc     IX              ; ...next channel...
0C3A: CB24    	                sla     H               ; shift left H 1 bit
0C3C: 10C1    	                djnz    CHKSNDCH        ; repeat for 3 channels
0C3E: DDE1    	                pop     IX              ; restore IX
0C40: C9      	                ret                     ; return to caller
              	
              	; read a specific row of the keyboard matrix, set by A
              	; return read into A
0C41: C5      	READKBLN:       push    BC
0C42: 060E    	                ld      B,$0E           ; reg #14
0C44: 0E40    	                ld      C,PSG_REG       ; PSG register port
0C46: ED41    	                out     (C),B           ; select reg #14
0C48: 0E41    	                ld      C,PSG_DAT       ; PSG data port
0C4A: ED79    	                out     (C),A           ; activate SHIFT row
0C4C: 060F    	                ld      B,$0F           ; register #15 (port B)
0C4E: 0E40    	                ld      C,PSG_REG       ; PSG register port
0C50: ED41    	                out     (C),B           ; select reg. 15 (port B)
0C52: ED78    	                in      A,(C)           ; read register #15
0C54: C1      	                pop     BC
0C55: C9      	                ret
              	
              	; read the keyboard matrix to look for a key pressure
0C56: 0E40    	KEYBOARD:       ld      C,PSG_REG       ; PSG register port
0C58: 0607    	                ld      B,$07           ; set register #7...
0C5A: ED41    	                out     (C),B           ; ...to work with
0C5C: ED78    	                in      A,(C)           ; read register #7
0C5E: CBF7    	                set     6,A             ; port A set to output
0C60: CBBF    	                res     7,A             ; port B set to input
0C62: ED41    	                out     (C),B           ; set register #7
0C64: 0E41    	                ld      C,PSG_DAT       ; PSG data port
0C66: ED79    	                out     (C),A           ; set I/O ports w/o altering the rest of the mixer
              	                ; check special keys (SHIFT/ALT/CTRL)
0C68: 3EFD    	                ld      A,%11111101     ; select SHIFT row
0C6A: CD410C  	                call    READKBLN        ; read row
0C6D: CB5F    	                bit     3,A             ; test if SHIFT key is pressed (4th bit is reset)
0C6F: 2005    	                jr      NZ,CHECKALT     ; no, so go on
0C71: 212D82  	                ld      HL,CONTROLKEYS  ; control key flags
0C74: 3601    	                ld      (HL),%00000001  ; set SHIFT flag, reset CTRL & ALT flags (currently multiply control keys are NOT supported)
0C76: 3EFE    	CHECKALT:       ld      A,%11111110     ; select ALT row
0C78: CD410C  	                call    READKBLN        ; read ALT row
0C7B: CB6F    	                bit     5,A             ; test if ALT key is pressed (5th bit is reset)
0C7D: 2005    	                jr      NZ,CHECKCTRL    ; no, so go on
0C7F: 212D82  	                ld      HL,CONTROLKEYS  ; control key flags
0C82: 3604    	                ld      (HL),%00000100  ; set ALT flag, reset SHIFT & CTRL flag (currently multiply control keys are NOT supported)
0C84: 3EFE    	CHECKCTRL:      ld      A,%11111110     ; select CTRL row
0C86: CD410C  	                call    READKBLN        ; read CTRL row
0C89: CB57    	                bit     2,A             ; test if CTRL key is pressed (3rd bit is reset)
0C8B: 2005    	                jr      NZ,CHECKKBD     ; no, so make a normal reading
0C8D: 212D82  	                ld      HL,CONTROLKEYS  ; control key flags
0C90: 3602    	                ld      (HL),%00000010  ; set CTRL flag, reset SHIFT & ALT flags (currently multiply control keys are NOT supported)
0C92: 0608    	CHECKKBD:       ld      B,$08           ; 8 lines
0C94: 3E7F    	                ld      A,%01111111     ; start from the last line of the matrix
0C96: 160E    	RPTKBDRD:       ld      D,$0E           ; register #14 (port A)
0C98: 0E40    	                ld      C,PSG_REG       ; PSG register port
0C9A: ED51    	                out     (C),D           ; select reg. #14
0C9C: 0E41    	                ld      C,PSG_DAT       ; PSG data port
0C9E: ED79    	                out     (C),A           ; activate 1 line (active line is grounded, i.e. with a LOW signal)
0CA0: 5F      	                ld      E,A             ; save current line into E
0CA1: 160F    	                ld      D,$0F           ; register #15 (port B)
0CA3: 0E40    	                ld      C,PSG_REG       ; PSG register port
0CA5: ED51    	                out     (C),D           ; select reg. 15 (port B)
0CA7: 00      	                nop
0CA8: ED78    	                in      A,(C)           ; read register #15
0CAA: FEFF    	                cp      $FF             ; is there any line set to 0?
0CAC: 282E    	                jr      Z,NOKEYPRSD     ; no, go to the next row
              	                ; check control keys
0CAE: 322A82  	                ld      (KBTMP),A       ; yes, check if a control key was pressed. First, store current row
0CB1: 78      	                ld      A,B             ; copy current row (B) into A
0CB2: FE02    	                cp      $02             ; is it the row of the SHIFT?
0CB4: 200F    	                jr      NZ,TESTALT      ; no, continue checking the other control keys
0CB6: 3A2A82  	                ld      A,(KBTMP)       ; yes, retrieve current row data
0CB9: CB5F    	                bit     3,A             ; check SHIFT bit line
0CBB: 202E    	                jr      NZ,FINDKEY      ; no SHIFT, continue checking
0CBD: CBDF    	                set     3,A             ; yes, it's the SHIFT. So remove SHIFT bit
0CBF: FEFF    	                cp      $FF             ; after deleting the SHIFT bit, is there any other bit selected?
0CC1: 2028    	                jr      NZ,FINDKEY      ; yes, go to check which one
0CC3: 1817    	                jr      NOKEYPRSD       ; no, go to next row        
0CC5: FE01    	TESTALT:        cp      $01             ; is it the line of ALT & CTRL?
0CC7: 3A2A82  	                ld      A,(KBTMP)       ; retrieve current row data
0CCA: 201F    	                jr      NZ,FINDKEY      ; no, continue
0CCC: CB6F    	                bit     5,A             ; yes, check ALT bit line
0CCE: 2002    	                jr      NZ,TESTCTRL     ; no ALT, continue checking
0CD0: CBEF    	                set     5,A             ; yes, it's the ALT. So remove ALT bit
0CD2: CB57    	TESTCTRL:       bit     2,A             ; check CTRL bit line
0CD4: 2002    	                jr      NZ,ENDCTRLCK    ; no CTRL, continue checking
0CD6: CBD7    	                set     2,A             ; delete CTRL bit flag
0CD8: FEFF    	ENDCTRLCK:      cp      $FF             ; after deleting the ALT & CTRL bits, is there any other bit selected?
0CDA: 200F    	                jr      NZ,FINDKEY      ; yes, go to check which one
0CDC: 7B      	NOKEYPRSD:      ld      A,E             ; no key pressed, load current output port
0CDD: 0F      	                rrca                    ; rotate right by 1
0CDE: 10B6    	                djnz    RPTKBDRD        ; repeat for 8 lines
0CE0: AF      	                xor     A               ; if exit from here, no key has been pressed...
0CE1: 322C82  	                ld      (LASTKEYPRSD),A ; ...so reset the last key cell...
0CE4: 322D82  	                ld      (CONTROLKEYS),A ; ...reset contro key flags...
0CE7: 322982  	                ld      (KBDNPT),A      ; ...no input from keyboard...
0CEA: C9      	                ret                     ; ...and leave
0CEB: 1EFF    	FINDKEY:        ld      E,$FF           ; counter
0CED: 1C      	CHKLN:          inc     E               ; E goes from 0 to 7
0CEE: CB3F    	                srl     A               ; is the first bit reset? (we're looking for a "0", meaning grounded line)
0CF0: 38FB    	                jr      C,CHKLN         ; no, check next bit
0CF2: 3A2D82  	                ld      A,(CONTROLKEYS) ; load control key flags
0CF5: 21BE0D  	                ld      HL,KBMAP        ; normal keymap
0CF8: FE01    	                cp      $01             ; SHIFT flag?
0CFA: 2005    	                jr      NZ,CHKCTRL      ; no, jump over
0CFC: 21FE0D  	                ld      HL,KBMAP_SFT    ; SHIFT keymap
0CFF: 1810    	                jr      LOADMAP         ; and load it
0D01: FE02    	CHKCTRL:        cp      $02             ; CTRL flag?
0D03: 2005    	                jr      NZ,CHKALT       ; no, jump over
0D05: 217E0E  	                ld      HL,KBMAP_CTRL   ; CTRL map
0D08: 1807    	                jr      LOADMAP         ; and load it
0D0A: FE04    	CHKALT:         cp      $04             ; ALT flag?
0D0C: 2003    	                jr      NZ,LOADMAP      ; no, check over
0D0E: 213E0E  	                ld      HL,KBMAP_ALT    ; ALT map
0D11: 05      	LOADMAP:        dec     B               ; decrement row # (rows go from 0 to 7)
0D12: 48      	                ld      C,B             ; move B into C and...
0D13: CB21    	                sla     C               ; ...multiply it...
0D15: CB21    	                sla     C               ; ...by 8 to find...
0D17: CB21    	                sla     C               ; ...the current row into the matrix
0D19: 0600    	                ld      B,$00           ; reset B
0D1B: 09      	                add     HL,BC           ; find the address of the current row
0D1C: 50      	                ld      D,B             ; reset D
0D1D: 19      	                add     HL,DE           ; find the current column
0D1E: 3A2C82  	                ld      A,(LASTKEYPRSD) ; load the last key pressed
0D21: BE      	                cp      (HL)            ; is it the same key?
0D22: 2847    	                jr      Z,LVKBRDCHK     ; yes, so do nothing
0D24: 7E      	                ld      A,(HL)          ; no, load it...
0D25: 322C82  	                ld      (LASTKEYPRSD),A ; ...store it...
0D28: 322B82  	                ld      (TMPKEYBFR),A   ; ...insert it into the INKEY buffer...
0D2B: 32EC81  	                ld      (CHR4VID),A     ; ...and store char for video
0D2E: FE03    	                cp      CTRLC           ; is it RUN/STOP?
0D30: 2005    	                jr      NZ,CNTKBCK      ; no, jump over
0D32: CD3301  	                call    CHARINTOBFR     ; yes, send directly to buffer and...
0D35: 1830    	                jr      LVKBRDCHK2      ; ...leave
0D37: 010008  	CNTKBCK:        ld      BC,$0800        ; 8 FN keys (B), FN key number (C)
0D3A: 21B60D  	                ld      HL,FNKEYSORD    ; FN keys codes
0D3D: BE      	CHKFNK:         cp      (HL)            ; is it an FN key?
0D3E: CA6C0D  	                jp      Z,PRNTFNKEY     ; yes, jump over
0D41: 0C      	                inc     C               ; next FN key
0D42: 23      	                inc     HL              ; next FN key code
0D43: 10F8    	                djnz    CHKFNK          ; continue for 8 FN keys
0D45: 3E01    	SNDKEYTOBFR:    ld      A,$01           ; normal key - set input flag
0D47: 322982  	                ld      (KBDNPT),A      ; to keyboard
0D4A: 3AEB81  	                ld      A,(PRNTVIDEO)   ; load status of print-on-video
0D4D: B7      	                or      A               ; is the print-on-video disabled?
0D4E: CA570D  	                jp      Z,PUTCHRBUF     ; yes, so send char to input buffer
0D51: 3AE981  	                ld      A,(CRSR_STATE)  ; check cursor state
0D54: B7      	                or      A               ; is it 0 (cursor OFF)?
0D55: 200D    	                jr      NZ,PNT2VD       ; no, print on screen
0D57: AF      	PUTCHRBUF:      xor     A
0D58: 322982  	                ld      (KBDNPT),A      ; if send to input buffer, set RETURN as from BASIC
0D5B: 3A2B82  	                ld      A,(TMPKEYBFR)   ; retrieve char
0D5E: CD3301  	                call    CHARINTOBFR     ; cursor off, so send char to buffer...
0D61: C3670D  	                jp      LVKBRDCHK2      ; ...and leave
0D64: CDA206  	PNT2VD:         call    CHAR2VID        ; send char to video
0D67: AF      	LVKBRDCHK2:     xor     A
0D68: 322D82  	                ld      (CONTROLKEYS),A ; reset control key flags
0D6B: C9      	LVKBRDCHK:      ret                     ; return to caller: the current key code is into TMPKEYBFR    
              	                                        ; manage FN keys          
0D6C: 57      	PRNTFNKEY:      ld      D,A             ; copy A into D
0D6D: 2AAF80  	                ld      HL,(LINEAT)     ; Get current line number
0D70: 23      	                inc     HL              ; -1 means direct statement
0D71: 7C      	                ld      A,H
0D72: B5      	                or      L
0D73: 7A      	                ld      A,D             ; retrieve char
0D74: 20CF    	                jr      NZ,SNDKEYTOBFR  ; indirect mode - just send FN key code to buffer
0D76: 79      	                ld      A,C             ; direct mode, so print text - first, get FN key number
0D77: 87      	                add     A,A
0D78: 87      	                add     A,A
0D79: 87      	                add     A,A
0D7A: 87      	                add     A,A             ; FN key number * 16
0D7B: 4F      	                ld      C,A             ; move it into C
0D7C: 0600    	                ld      B,$00           ; reset B, to get offset
0D7E: 21B380  	                ld      HL,FNKEYS       ; load address of FN keys texts
0D81: 09      	                add     HL,BC           ; get correct text address
0D82: 0610    	                ld      B,$10           ; 16 chars
0D84: 7E      	LDFNKEYCHR:     ld      A,(HL)          ; load char
0D85: A7      	                and     A               ; null char?
0D86: CA670D  	                jp      Z,LVKBRDCHK2    ; yes, so leave
0D89: 57      	                ld      D,A             ; pass char into D
0D8A: 3AEB81  	                ld      A,(PRNTVIDEO)   ; load status of print-on-video
0D8D: B7      	                or      A               ; is the print-on-video disabled?
0D8E: CA9E0D  	                jp      Z,PUTCHRBUF1    ; yes, so send char to input buffer
0D91: 3AE981  	                ld      A,(CRSR_STATE)  ; check cursor state
0D94: B7      	                or      A               ; is it 0 (cursor OFF)?
0D95: C4A90D  	                call    NZ,PRNTFNK      ; no, print on screen
0D98: 23      	CNTFNK:         inc     HL              ; next char
0D99: 10E9    	                djnz    LDFNKEYCHR      ; repeat for max. 16 chars
0D9B: C3670D  	                jp      LVKBRDCHK2      ; leave
0D9E: AF      	PUTCHRBUF1:     xor     A
0D9F: 322982  	                ld      (KBDNPT),A      ; if send to input buffer, set RETURN as from BASIC
0DA2: 7A      	                ld      A,D             ; retrieve char
0DA3: CD3301  	                call    CHARINTOBFR     ; cursor off, so send char to buffer...
0DA6: C3980D  	                jp      CNTFNK          ; jump over
0DA9: 7A      	PRNTFNK:        ld      A,D             ; recover char
0DAA: 32EC81  	                ld      (CHR4VID),A     ; store char for printing
0DAD: 3E01    	                ld      A,$01           ; normal key - set input flag
0DAF: 322982  	                ld      (KBDNPT),A      ; to keyboard
0DB2: CDA206  	                call    CHAR2VID        ; print on screen
0DB5: C9      	                ret                     ; return to caller
              	
              	
              	;-----------------------------------------------------------------------
0DB6: 01020405	FNKEYSORD:      defb 1,2,4,5,6,22,23,24                 ; order of FN Keys
0DBA: 06161718	
              	;-----------------------------------------------------------------------
              	; key codes
0DBE: 31190E03	KBMAP:          defb '1',25,14,3,' ',16,'q','2'         ; 25=HOME  14=CTRL  3=RUN/STOP 16=C=
0DC2: 20107132	
0DC6: 33776114	                defb '3','w','a',20,'z','s','e','4'     ; 20=SHIFT
0DCA: 7A736534	
0DCE: 35726478	                defb '5','r','d','x','c','f','t','6'
0DD2: 63667436	
0DD6: 37796776	                defb '7','y','g','v','b','h','u','8'
0DDA: 62687538	
0DDE: 39696A6E	                defb '9','i','j','n','m','k','o','0'
0DE2: 6D6B6F30	
0DE6: 1F706C2C	                defb 31,'p','l',',','.',':','-',30      ; 31=CURSOR DOWN  30=CURSOR UP
0DEA: 2E3A2D1E	
0DEE: 1C2A3B2F	                defb 28,'*',';','/',27,'=','+',29       ; 28=CURSOR LEFT  27=ESCAPE  29=CURSOR RIGHT
0DF2: 1B3D2B1D	
0DF6: 080DFC40	                defb 8,13,252,'@',1,2,4,24              ; 8=DEL(backspace)  13=RETURN  252=  1=F1  2=F2  4=F3  24=HELP
0DFA: 01020418	
              	
              	; shifted codes - not all the keys have the shifted version
0DFE: 210C0E03	KBMAP_SFT:      defb '!',12,14,3,' ',16,'Q',34          ; 12=CLEAR  14=CTRL  3=RUN/STOP 16=C=   34="
0E02: 20105122	
0E06: 23574114	                defb '#','W','A',20,'Z','S','E','$'     ; 20=SHIFT
0E0A: 5A534524	
0E0E: 25524458	                defb '%','R','D','X','C','F','T','&'
0E12: 43465426	
0E16: 27594756	                defb 39,'Y','G','V','B','H','U','('     ; 39='
0E1A: 42485528	
0E1E: 29494A4E	                defb ')','I','J','N','M','K','O',94     ; 94=^
0E22: 4D4B4F5E	
0E26: 1F504C3C	                defb 31,'P','L','<','>','[','_',30      ; 31=CURSOR DOWN  30=CURSOR UP
0E2A: 3E5B5F1E	
0E2E: 1C2A5D3F	                defb 28,'*',']','?',27,198,'+',29       ; 28=CURSOR LEFT  27=ESCAPE  29=CURSOR RIGHT
0E32: 1BC62B1D	
0E36: 080DD340	                defb 8,13,211,'@',5,6,22,23             ; 211=  5=F4  6=F5  22=F6  23=F7
0E3A: 05061617	
              	
              	; ALT (C=) codes - not all the keys have the alt-ed version
0E3E: 310C0E03	KBMAP_ALT:      defb '1',12,14,3,' ',16,222,196         ; 12=CLEAR  14=CTRL  3=RUN/STOP  16=C=  34="
0E42: 2010DEC4	
0E46: 33DD8514	                defb '3',221,133,20,131,130,165,'4'     ; 20=SHIFT
0E4A: 8382A534	
0E4E: 35A2A684	                defb '5',162,166,132,157,163,168,'6'
0E52: 9DA3A836	
0E56: 37ABA9A1	                defb '7',171,169,161,158,172,213,'8'    ;
0E5A: 9EACD538	
0E5E: 39D6D89F	                defb '9',214,216,159,160,215,135,195    ;
0E62: A0D787C3	
0E66: 1F888AC1	                defb 31,136,138,193,192,123,144,30      ; 31=CURSOR DOWN  123={  30=CURSOR UP
0E6A: C07B901E	
0E6E: 1C8F7DFE	                defb 28,143,125,254,27,209,148,29       ; 28=CURSOR LEFT  125=}  27=ESCAPE  29=CURSOR RIGHT
0E72: 1BD1941D	
0E76: 080DE089	                defb 8,13,224,137,5,6,22,23             ; 8=DEL(backspace)  13=RETURN  252=  5=F4  6=F5  22=F6  23=F7
0E7A: 05061617	
              	
              	; CTRL codes - not all the keys have the control-ed version
0E7E: 31190E03	KBMAP_CTRL:     defb '1',25,14,3,' ',16,154,'2'         ; 25=HOME  14=CTRL  3=RUN/STOP  16=C=
0E82: 20109A32	
0E86: 339C9514	                defb '3',156,149,20,152,150,153,'4'     ; 20=SHIFT
0E8A: 98969934	
0E8E: 359BB097	                defb '5',155,176,151,177,175,165,'6'
0E92: B1AFA536	
0E96: 37A6A8B2	                defb '7',166,168,178,179,169,167,'8'
0E9A: B3A9A738	
0E9E: 39B8AAAC	                defb '9',184,170,172,171,181,164,'0'
0EA2: ABB5A430	
0EA6: 1FA3AD2C	                defb 31,163,173,',','.',':',186,30      ; 31=CURSOR DOWN  30=CURSOR UP
0EAA: 2E3ABA1E	
0EAE: 1CE13B2F	                defb 28,225,';','/',27,212,185,29       ; 28=CURSOR LEFT  27=ESCAPE  212=  29=CURSOR RIGHT
0EB2: 1BD4B91D	
0EB6: 080DBDA2	                defb 8,13,189,162,1,2,4,24              ; 8=DEL(backspace)  13=RETURN  252=  1=F1  2=F2  4=F3  24=HELP; ------------------------------------------------------------------------------
0EBA: 01020418	
              	; LM80C - BASIC32K - R3.9
              	; ------------------------------------------------------------------------------
              	; The following code is intended to be used with LM80C Z80-based computer
              	; designed by Leonardo Miliani. Code and computer schematics are released under
              	; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
              	; kind of warranty: you can use them at your own risk.
              	; You are free to use them for any non-commercial use: you are only asked to
              	; maintain the copyright notices, include this advice and the note to the 
              	; attribution of the original version to Leonardo Miliani, if you intend to
              	; redistribuite them.
              	; https://www.leonardomiliani.com
              	; 
              	; Please support me by visiting the following links:
              	; Main project page: https://www.leonardomiliani.com
              	; Schematics and code: https://github.com/leomil72/LM80C
              	; Videos about the computer: https://www.youtube.com/user/leomil72/videos
              	; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
              	; ------------------------------------------------------------------------------
              	; NASCOM BASIC versions:
              	; 4.7  - original version by NASCOM
              	; 4.7b - modified version by Grant Searle (additional commands & functions)
              	; 4.8  - modified by Leonardo Miliani (new commands/functions)
              	
              	
              	;------------------------------------------------------------------------------
              	;  B A S I C
              	;------------------------------------------------------------------------------
              	
              	; GENERAL EQUATES
              	
0000:         	NLLCR           equ     $00             ; null char (used as space/empty char in video prints)
0003:         	CTRLC           equ     $03             ; Control "C"
0007:         	CTRLG           equ     $07             ; Control "G"
0008:         	BKSP            equ     $08             ; Back space
000A:         	LF              equ     $0A             ; Line feed
000C:         	CS              equ     $0C             ; Clear screen
000D:         	CR              equ     $0D             ; Carriage return
000F:         	CTRLO           equ     $0F             ; Control "O"
0011:         	CTRLQ           equ     $11             ; Control "Q"
0012:         	CTRLR           equ     $12             ; Control "R"
0013:         	CTRLS           equ     $13             ; Control "S"
0015:         	CTRLU           equ     $15             ; Control "U"
0019:         	HOME            equ     $19             ; Home (cursor at 0,0)
001B:         	ESC             equ     $1B             ; Escape
0020:         	SPC             equ     $20             ; Space
007F:         	DEL             equ     $7F             ; Delete
              	; cursor ASCII codes
001C:         	CRSLFT          equ     $1C             ; cursor left
001D:         	CRSRGT          equ     $1D             ; cursor right
001E:         	CRSUP           equ     $1E             ; cursor up
001F:         	CRSDN           equ     $1F             ; cursor down
              	
              	
              	; BASIC WORK SPACE LOCATIONS
              	; BY STARTING FROM $8045 THE INTERPRETER ALLOCATES THE FOLLOWING RAM CELLS
              	; TO STORE IMPORTANT VALUES USED FOR SOME SPECIFIC FUNCTIONS:
              	; THEY CAN BE VECTOR (ADDRESSES) FUNCTIONS, SYSTEM DATAS (I.E. VARIABLES)
              	; AND SO ON. THE FIRST CELLS ARE FILLED WITH VALUES STORED INTO ROM AT $(INITAB) ADDRESS
805E:         	WRKSPC          equ     basicStarted+$01; (3) BASIC Work space
8061:         	NMIUSR          equ     WRKSPC+$03      ; (3) NMI exit point routine
8064:         	USR             equ     NMIUSR+$03      ; (3) "USR (x)" jump  <-- in $8049/804A the user can store the address of a specific machine language routine
8067:         	OUTSUB          equ     USR+$03         ; (1) "out p,n"
8068:         	OTPORT          equ     OUTSUB+$01      ; (2) Port (p)
806A:         	DIVSUP          equ     OTPORT+$02      ; (1) Division support routine
806B:         	DIV1            equ     DIVSUP+$01      ; (4) <- Values
806F:         	DIV2            equ     DIV1+$04        ; (4) <-   to
8073:         	DIV3            equ     DIV2+$04        ; (3) <-   be
8076:         	DIV4            equ     DIV3+$03        ; (2) <-inserted
8078:         	SEED            equ     DIV4+$02        ; (35) Random number seed  <-- starting address of a seed table
809B:         	LSTRND          equ     SEED+$23        ; (4) Last random number
809F:         	INPSUB          equ     LSTRND+$04      ; (1) #INP (x)" Routine
80A0:         	INPORT          equ     INPSUB+$01      ; (2) PORT (x)
80A2:         	LWIDTH          equ     INPORT+$02      ; (1) Terminal width
80A3:         	COMMAN          equ     LWIDTH+$01      ; (1) Width for commas
80A4:         	NULFLG          equ     COMMAN+$01      ; (1) Null after input byte flag
80A5:         	CTLOFG          equ     NULFLG+$01      ; (1) Control "O" flag
80A6:         	CHKSUM          equ     CTLOFG+$01      ; (2) Array load/save check sum
80A8:         	NMIFLG          equ     CHKSUM+$02      ; (1) Flag for NMI break routine
80A9:         	BRKFLG          equ     NMIFLG+$01      ; (1) Break flag
80AA:         	RINPUT          equ     BRKFLG+$01      ; (3) Input reflection
80AD:         	STRSPC          equ     RINPUT+$03      ; (2) Bottom of string space
80AF:         	LINEAT          equ     STRSPC+$02      ; (2) Current line number
80B1:         	HLPLN           equ     LINEAT+$02      ; (2) Current line with errors
80B3:         	FNKEYS          equ     HLPLN+$02       ; (128) text of FN keys
8133:         	BASTXT          equ     FNKEYS+$80      ; (3) Pointer to start of program   <-- actually this is the last value pre-filled by the firmware at startup
8136:         	BUFFER          equ     BASTXT+$03      ; (5) Input buffer
813B:         	STACK           equ     BUFFER+$05      ; (85) Initial stack
8190:         	CURPOS          equ     STACK+$55       ; (1) Character position on line
8191:         	LCRFLG          equ     CURPOS+$01      ; (1) Locate/Create flag
8192:         	TYPE            equ     LCRFLG+$01      ; (1) Data type flag
8193:         	DATFLG          equ     TYPE+$01        ; (1) Literal statement flag
8194:         	LSTRAM          equ     DATFLG+$01      ; (2) Last available RAM
8196:         	TMSTPT          equ     LSTRAM+$02      ; (2) Temporary string pointer
8198:         	TMSTPL          equ     TMSTPT+$02      ; (12) Temporary string pool
81A4:         	TMPSTR          equ     TMSTPL+$0C      ; (4) Temporary string
81A8:         	STRBOT          equ     TMPSTR+$04      ; (2) Bottom of string space
81AA:         	CUROPR          equ     STRBOT+$02      ; (2) Current operator in EVAL
81AC:         	LOOPST          equ     CUROPR+$02      ; (2) First statement of loop
81AE:         	DATLIN          equ     LOOPST+$02      ; (2) Line of current DATA item
81B0:         	FORFLG          equ     DATLIN+$02      ; (1) "FOR" loop flag
81B1:         	LSTBIN          equ     FORFLG+$01      ; (1) Last byte entered
81B2:         	READFG          equ     LSTBIN+$01      ; (1) Read/Input flag
81B3:         	BRKLIN          equ     READFG+$01      ; (2) Line of break
81B5:         	NXTOPR          equ     BRKLIN+$02      ; (2) Next operator in EVAL
81B7:         	ERRLIN          equ     NXTOPR+$02      ; (2) Line of error
81B9:         	CONTAD          equ     ERRLIN+$02      ; (2) Where to CONTinue
81BB:         	PROGND          equ     CONTAD+$02      ; (2) End of program
81BD:         	VAREND          equ     PROGND+$02      ; (2) End of variables
81BF:         	ARREND          equ     VAREND+$02      ; (2) End of arrays
81C1:         	NXTDAT          equ     ARREND+$02      ; (2) Next data item
81C3:         	FNRGNM          equ     NXTDAT+$02      ; (2) Name of FN argument
81C5:         	FNARG           equ     FNRGNM+$02      ; (4) FN argument value
81C9:         	FPREG           equ     FNARG+$04       ; (3) Floating point register
81CC:         	FPEXP           equ     FPREG+$03       ; (1) Floating point exponent
81CD:         	SGNRES          equ     FPEXP+$01       ; (1) Sign of result
81CE:         	TMRCNT          equ     SGNRES+$01      ; (4) TMR counter for 1/100 seconds
81D2:         	CTC0IV          equ     TMRCNT+$04      ; (3) CTC0 interrupt vector
81D5:         	CTC1IV          equ     CTC0IV+$03      ; (3) CTC1 interrupt vector
81D8:         	CTC2IV          equ     CTC1IV+$03      ; (3) CTC2 interrupt vector
81DB:         	CTC3IV          equ     CTC2IV+$03      ; (3) CTC3 interrupt vector
              	; - - - - - - - - - - - - - - - - - - -   VIDEO REGISTERS - FROM HERE...
81DE:         	SCR_SIZE_W      equ     CTC3IV+$03      ; (1) screen width (it can be either 40 chars or 32 chars/bytes)
81DF:         	SCR_SIZE_H      equ     SCR_SIZE_W+$01  ; (1) screen height (it can be 24/48/192: 24 for text, 48 for MC, 192 for graphics)
81E0:         	SCR_MODE        equ     SCR_SIZE_H+$01  ; (1) screen mode (0=text, 1=G1, 2=G2, 3=MC, 4=ExG2)
81E2:         	SCR_NAM_TB      equ     SCR_MODE+$02    ; (2) video name table address
81E4:         	SCR_CURS_X      equ     SCR_NAM_TB+$02  ; (1) cursor X
81E5:         	SCR_CURS_Y      equ     SCR_CURS_X+$01  ; (1) cursor Y
81E6:         	SCR_CUR_NX      equ     SCR_CURS_Y+$01  ; (1) new cursor X position
81E7:         	SCR_CUR_NY      equ     SCR_CUR_NX+$01  ; (1) new cursor Y position
81E8:         	SCR_ORG_CHR     equ     SCR_CUR_NY+$01  ; (1) original char positioned under the cursor
81E9:         	CRSR_STATE      equ     SCR_ORG_CHR+$01 ; (1) state of cursor (1=on, 0=off)
81EA:         	LSTCSRSTA       equ     CRSR_STATE+$01  ; (1) last cursor state
81EB:         	PRNTVIDEO       equ     LSTCSRSTA+$01   ; (1) print on video buffer (1=on / 0=off) set to off on graphic only modes
81EC:         	CHR4VID         equ     PRNTVIDEO+$01   ; (1) char for video buffer
81ED:         	FRGNDCLR        equ     CHR4VID+$01     ; (1) foreground color as set by SCREEN or COLOR commands
81EE:         	BKGNDCLR        equ     FRGNDCLR+$01    ; (1) background color as set by SCREEN or COLOR commands
81EF:         	TMPBFR1         equ     BKGNDCLR+$01    ; (2) word for general purposes use (temp. buffer for 1 or 2 bytes)
81F1:         	TMPBFR2         equ     TMPBFR1+$02     ; (2) word for general purposes use (temp. buffer for 1 or 2 bytes)
81F3:         	TMPBFR3         equ     TMPBFR2+$02     ; (2) word for general purposes use (temp. buffer for 1 or 2 bytes)
81F5:         	TMPBFR4         equ     TMPBFR3+$02     ; (2) word for general purposes use (temp. buffer for 1 or 2 bytes)
81F7:         	VIDEOBUFF       equ     TMPBFR4+$02     ; (40) buffer used for video scrolling and other purposes
821F:         	VIDTMP1         equ     VIDEOBUFF+$28   ; (2) temporary video word
8221:         	VIDTMP2         equ     VIDTMP1+$02     ; (2) temporary video word
              	; - - - - - - - - - - - - - - - - - - -   ...TO HERE. DO NOT ADD ANYTHING RELATED TO VPD OUT OF THIS RANGE,
              	                                        ; OTHERWISE YOU WILL HAVE TO CHECK THE POINTER IN "EMPTY_RAM" FUNCTION
              	; - - - - - - - - - - - - - - - - - - -   SOUND & KEYBOARD REGISTERS - FROM HERE...
8223:         	CHASNDDTN       equ     VIDTMP2+$02     ; (2) sound Ch.A duration (1/100s)
8225:         	CHBSNDDTN       equ     CHASNDDTN+$02   ; (2) sound Ch.B duration (1/100s)
8227:         	CHCSNDDTN       equ     CHBSNDDTN+$02   ; (2) sound Ch.C duration (1/100s)
8229:         	KBDNPT          equ     CHCSNDDTN+$02   ; (1) temp cell used to flag if input comes from keyboard
822A:         	KBTMP           equ     KBDNPT+$01      ; (1) temp cell used by keyboard scanner
822B:         	TMPKEYBFR       equ     KBTMP+$01       ; (1) temp buffer for last key pressed
822C:         	LASTKEYPRSD     equ     TMPKEYBFR+$01   ; (1) last key code pressed
822D:         	CONTROLKEYS     equ     LASTKEYPRSD+$01 ; (1) flags for control keys (bit#0=SHIFT; bit#1=CTRL; bit#2=C=)
              	; - - - - - - - - - - - - - - - - - - -   ...TO HERE. DO NOT ADD ANYTHING RELATED TO PSG OUT OF THIS RANGE,
              	                                        ; OTHERWISE YOU WILL HAVE TO CHANGE THE POINTER IN "INIT_PSG" FUNCTION
822E:         	SERIALS_EN      equ     CONTROLKEYS+$01 ; (1) serial ports status: bit 0 for Port1(A), bit 1 for Port2(B): 0=OFF, 1=ON
822F:         	SERABITS        equ     SERIALS_EN+$01  ; (1) serial port A data bits
8230:         	PBUFF           equ     SERABITS+$01    ; (13) Number print buffer
823D:         	MULVAL          equ     PBUFF+$0D       ; (3) Multiplier
8240:         	PROGST          equ     MULVAL+$03      ; (100) Start of program text area
82A4:         	STLOOK          equ     PROGST+$64      ; Start of memory test
              	
              	; BASIC ERROR CODE VALUES
              	; These values act as an offset to point to the error message into the error table
              	; must be incremented by 2 because they point to a word address jump
0000:         	NF              equ     $00             ; NEXT without FOR
0002:         	SN              equ     $02             ; Syntax error
0004:         	RG              equ     $04             ; RETURN without GOSUB
0006:         	OD              equ     $06             ; Out of DATA
0008:         	FC              equ     $08             ; Function call error
000A:         	OV              equ     $0A             ; Overflow
000C:         	OM              equ     $0C             ; Out of memory
000E:         	UL              equ     $0E             ; Undefined line number
0010:         	BS              equ     $10             ; Bad subscript
0012:         	DD              equ     $12             ; Re-Dimensioned array
0014:         	DZ              equ     $14             ; Division by zero (/0)
0016:         	ID              equ     $16             ; Illegal direct
0018:         	TM              equ     $18             ; Type mis-match
001A:         	OS              equ     $1A             ; Out of string space
001C:         	LS              equ     $1C             ; String too long
001E:         	ST              equ     $1E             ; String formula too complex
0020:         	CN              equ     $20             ; Can't continue
0022:         	UF              equ     $22             ; Undefined FN function
0024:         	MO              equ     $24             ; Missing operand
0026:         	HX              equ     $26             ; HEX error
0028:         	BN              equ     $28             ; BIN error
002A:         	GM              equ     $2A             ; No Graphics Mode
002C:         	SC              equ     $2C             ; Serial configuration
002E:         	SA              equ     $2E             ; Serial port already open
0030:         	HP              equ     $30             ; HELP call
              	
0EBE: C3C40E  	COLD:   jp      STARTB          ; Jump for cold start
0EC1: C35C0F  	WARM:   jp      WARMST          ; Jump for warm start
              	
0EC4: C3CB0E  	STARTB: jp      CSTART          ; Jump to initialise
0EC7: D81A    	        defw    DEINT           ; Get integer -32768 to 32767
0EC9: 7D22    	        defw    ABPASS          ; Return integer in AB
0ECB: 215E80  	CSTART: ld      HL,WRKSPC       ; Start of workspace RAM
0ECE: F9      	        ld      SP,HL           ; Set up a temporary stack
0ECF: C3183A  	        jp      INITST          ; Go to initialise
              	
0ED2: 21B613  	INIT:   ld      HL,INITAB       ; Initialise workspace
0ED5: 01DA00  	        ld      BC,INITBE-INITAB+3; Bytes to copy
0ED8: 115E80  	        ld      DE,WRKSPC       ; Into workspace RAM
0EDB: EDB0    	        ldir                    ; Copy data
0EDD: EB      	        ex      DE,HL           ; Copy DE into HL
0EDE: F9      	        ld      SP,HL           ; Temporary stack
0EDF: CD6716  	        call    CLREG           ; Clear registers and stack
0EE2: CDDB1C  	        call    PRNTCRLF        ; Output CRLF
0EE5: 328F81  	        ld      (BUFFER+88+1),A ; Mark end of buffer
0EE8: 324082  	        ld      (PROGST),A      ; Initialise program area
0EEB: 1810    	        jr      MNOASK          ; usually, don't ask for memory top (only when there are errors)
0EED: 21A60F  	MSIZE:  ld      HL,MEMMSG       ; Point to message
0EF0: CD9B23  	        call    PRS             ; Output "Memory size"
0EF3: CD8416  	        call    PROMPT          ; Get input with '?'
0EF6: CD221A  	        call    GETCHR          ; Get next character
0EF9: B7      	        or      A               ; Set flags
0EFA: C2120F  	        jp      NZ,TSTMEM       ; If number - Test if RAM there
0EFD: 21A482  	MNOASK: ld      HL,STLOOK       ; Point to start of RAM
0F00: 23      	MLOOP:  inc     HL              ; Next byte
0F01: 7C      	        ld      A,H             ; Above address FFFF ?
0F02: B5      	        or      L
0F03: CA240F  	        jp      Z,SETTOP        ; Yes - 64K RAM
0F06: 7E      	        ld      A,(HL)          ; Get contents
0F07: 47      	        ld      B,A             ; Save it
0F08: 2F      	        cpl                     ; Flip all bits
0F09: 77      	        ld      (HL),A          ; Put it back
0F0A: BE      	        cp      (HL)            ; RAM there if same
0F0B: 70      	        ld      (HL),B          ; Restore old contents
0F0C: CA000F  	        jp      Z,MLOOP         ; If RAM - test next byte
0F0F: C3240F  	        jp      SETTOP          ; Top of RAM found
              	
0F12: CDF21A  	TSTMEM: call    ATOH            ; Get high memory into DE
0F15: B7      	        or      A               ; Set flags on last byte
0F16: C21B15  	        jp      NZ,SNERR        ; ?SN Error if bad character
0F19: EB      	        ex      DE,HL           ; Address into HL
0F1A: 2B      	        dec     HL              ; Back one byte
0F1B: 3ED9    	        ld      A,%11011001     ; Test byte
0F1D: 46      	        ld      B,(HL)          ; Get old contents
0F1E: 77      	        ld      (HL),A          ; Load test byte
0F1F: BE      	        cp      (HL)            ; RAM there if same
0F20: 70      	        ld      (HL),B          ; Restore old contents
0F21: C2ED0E  	        jp      NZ,MSIZE        ; Ask again if no RAM
              	
0F24: 2B      	SETTOP: dec     HL              ; Back one byte
0F25: 11A382  	        ld      DE,STLOOK-1     ; See if enough RAM
0F28: CDF917  	        call    CPDEHL          ; Compare DE with HL
0F2B: DAED0E  	        jp      C,MSIZE         ; Ask again if not enough RAM
0F2E: 119CFF  	        ld      DE,0-100        ; 100 Bytes string space
0F31: 229481  	        ld      (LSTRAM),HL     ; Save last available RAM
0F34: 19      	        add     HL,DE           ; Allocate string space
0F35: 22AD80  	        ld      (STRSPC),HL     ; Save string space
0F38: CD4216  	        call    CLRPTR          ; Clear program area
0F3B: 2AAD80  	        ld      HL,(STRSPC)     ; Get end of memory
0F3E: 11EFFF  	        ld      DE,0-17         ; Offset for free bytes
0F41: 19      	        add     HL,DE           ; Adjust HL
0F42: 114082  	        ld      DE,PROGST       ; Start of program text
0F45: 7D      	        ld      A,L             ; Get LSB
0F46: 93      	        sub     E               ; Adjust it
0F47: 6F      	        ld      L,A             ; Re-save
0F48: 7C      	        ld      A,H             ; Get MSB
0F49: 9A      	        sbc     A,D             ; Adjust it
0F4A: 67      	        ld      H,A             ; Re-save
0F4B: E5      	        push    HL              ; Save bytes free
0F4C: 21750F  	        ld      HL,SIGNON       ; Sign-on message
0F4F: CD9B23  	        call    PRS             ; Output string
0F52: E1      	        pop     HL              ; Get bytes free back
0F53: CD1C2D  	        call    PRNTHL          ; Output amount of free memory
0F56: 21680F  	        ld      HL,BFREE        ; " Bytes free" message
0F59: CD9B23  	        call    PRS             ; Output string
              	
0F5C: 313B81  	WARMST: ld      SP,STACK        ; Temporary stack
0F5F: CD6716  	BRKRET: call    CLREG           ; Clear registers and stack
0F62: CD2C08  	        call    CURSOR_ON       ; enable cursor
0F65: C37515  	        jp      PRNTOK          ; Go to get command line
              	
0F68: 20427974	BFREE:  defb    " Bytes free",CR,0
0F6C: 65732066	
0F70: 7265650D	
0F74: 00      	
              	
0F75: 5A383020	SIGNON: defb    "Z80 BASIC Ver 4.8",CR
0F79: 42415349	
0F7D: 43205665	
0F81: 7220342E	
0F85: 380D    	
0F87: 436F7079	        defb    "Copyright ",251," 1978"
0F8B: 72696768	
0F8F: 7420FB20	
0F93: 31393738	
0F97: 20627920	        defb    " by Microsoft",CR,0
0F9B: 4D696372	
0F9F: 6F736F66	
0FA3: 740D00  	
              	
0FA6: 4D656D6F	MEMMSG: defb    "Memory top",0
0FAA: 72792074	
0FAE: 6F7000  	
              	
              	; The following list reports all the functions supported by the interpreter.
              	; To add a custom function, the user must first insert the reserved word here,
              	; then into the list of the reserved words below, and finally must increment the
              	; ZSGN token value and all the following ones after ZSGN by 1 for every added
              	; function.
              	
              	; FUNCTION ADDRESS TABLE (this is a sort of offset table)
              	; this list must be coherent with the tokens' functions list. This means that every
              	; entry here must have the corresponding entry in the tokens list.
0FB1: 912B    	FNCTAB: defw    SGN
0FB3: 4422    	        defw    TMR         ; added by Leonardo Miliani
0FB5: 552C    	        defw    INT
0FB7: A72B    	        defw    ABS
0FB9: 6480    	        defw    USR
0FBB: 5B22    	        defw    FRE
0FBD: E025    	        defw    INP
0FBF: 8922    	        defw    POS
0FC1: 1B2E    	        defw    SQR
0FC3: FA2E    	        defw    RND
0FC5: E529    	        defw    LOG
0FC7: 692E    	        defw    EXP
0FC9: 6F2F    	        defw    COS
0FCB: 752F    	        defw    SIN
0FCD: D62F    	        defw    TAN
0FCF: EB2F    	        defw    ATN
0FD1: B626    	        defw    PEEK
0FD3: 5630    	        defw    DEEK
0FD5: BD26    	        defw    VPEEK       ; added by Leonardo Miliani
0FD7: 7A28    	        defw    VSTAT       ; added by Leonardo Miliani
0FD9: 8528    	        defw    SSTAT       ; added by Leonardo Miliani
0FDB: 9728    	        defw    INKEY       ; added by Leonardo Miliani
0FDD: CC31    	        defw    POINT       ; added by Leonardo Miliani
0FDF: 0D25    	        defw    LEN
0FE1: 2523    	        defw    STR
0FE3: A725    	        defw    VAL
0FE5: 1C25    	        defw    ASC
0FE7: 2D25    	        defw    CHR
0FE9: 1739    	        defw    HEX         ; added by Grant Searle
0FEB: A839    	        defw    BIN         ; added by Grant Searle
0FED: 3D25    	        defw    LEFT
0FEF: 6D25    	        defw    RIGHT
0FF1: 7725    	        defw    MID
              	
              	; RESERVED WORD LIST
              	; Here are all the reserved words used by the interpreter
              	; To add custom functions/commands, the user must insert the keyword
              	; in this list, following the schematic
0FF3: C54E44  	WORDS:  defb    'E'+$80,"ND"            ; from here the list contains the COMMANDS
0FF6: C64F52  	        defb    'F'+$80,"OR"
0FF9: CE455854	        defb    'N'+$80,"EXT"
0FFD: C4415441	        defb    'D'+$80,"ATA"
1001: C94E5055	        defb    'I'+$80,"NPUT"
1005: 54      	
1006: C4494D  	        defb    'D'+$80,"IM"
1009: D2454144	        defb    'R'+$80,"EAD"
100D: CC4554  	        defb    'L'+$80,"ET"
1010: C74F544F	        defb    'G'+$80,"OTO"
1014: D2554E  	        defb    'R'+$80,"UN"
1017: C946    	        defb    'I'+$80,"F"
1019: D2455354	        defb    'R'+$80,"ESTORE"
101D: 4F5245  	
1020: C74F5355	        defb    'G'+$80,"OSUB"
1024: 42      	
1025: D2455455	        defb    'R'+$80,"ETURN"
1029: 524E    	
102B: D2454D  	        defb    'R'+$80,"EM"
102E: D3544F50	        defb    'S'+$80,"TOP"
1032: CF5554  	        defb    'O'+$80,"UT"
1035: CF4E    	        defb    'O'+$80,"N"
1037: CE554C4C	        defb    'N'+$80,"ULL"
103B: D7414954	        defb    'W'+$80,"AIT"
103F: C44546  	        defb    'D'+$80,"EF"
1042: D04F4B45	        defb    'P'+$80,"OKE"
1046: C44F4B45	        defb    'D'+$80,"OKE"
104A: D6504F4B	        defb    'V'+$80,"POKE"          ; added by Leonardo Miliani
104E: 45      	
104F: D3524547	        defb    'S'+$80,"REG"           ; added by Leonardo Miliani
1053: D6524547	        defb    'V'+$80,"REG"           ; added by Leonardo Miliani
1057: D3435245	        defb    'S'+$80,"CREEN"         ; changed by Leonardo Miliani
105B: 454E    	
105D: CC4F4341	        defb    'L'+$80,"OCATE"         ; added by Leonardo Miliani
1061: 5445    	
1063: D34F554E	        defb    'S'+$80,"OUND"          ; added by Leonardo Miliani
1067: 44      	
1068: D64F4C55	        defb    'V'+$80,"OLUME"         ; added by Leonardo Miliani
106C: 4D45    	
106E: D0415553	        defb    'P'+$80,"AUSE"          ; added by Leonardo Miliani
1072: 45      	
1073: C34F4C4F	        defb    'C'+$80,"OLOR"          ; added by Leonardo Miliani
1077: 52      	
1078: D04C4F54	        defb    'P'+$80,"LOT"           ; added by Leonardo Miliani
107C: C4524157	        defb    'D'+$80,"RAW"           ; added by Leonardo Miliani
1080: C3495243	        defb    'C'+$80,"IRCLE"         ; added by Leonardo Miliani
1084: 4C45    	
1086: D3455249	        defb    'S'+$80,"ERIAL"         ; added by Leonardo Miliani
108A: 414C    	
108C: C8454C50	        defb    'H'+$80,"ELP"           ; changed by Leonardo Miliani - was LINES
1090: C34C53  	        defb    'C'+$80,"LS"            ; restored command
1093: CB4559  	        defb    'K'+$80,"EY"            ; added by Leonardo Miliani
1096: CE4D49  	        defb    'N'+$80,"MI"            ; added by Leonardo Miliani
1099: D7494454	        defb    'W'+$80,"IDTH"
109D: 48      	
109E: D35953  	        defb    'S'+$80,"YS"            ; added by Leonardo Miliani
10A1: D2455345	        defb    'R'+$80,"ESET"          ; changed by Leonardo Miliani
10A5: 54      	
10A6: D052494E	        defb    'P'+$80,"RINT"
10AA: 54      	
10AB: C34F4E54	        defb    'C'+$80,"ONT"
10AF: CC495354	        defb    'L'+$80,"IST"
10B3: C34C4541	        defb    'C'+$80,"LEAR"
10B7: 52      	
10B8: C34C4F41	        defb    'C'+$80,"LOAD"
10BC: 44      	
10BD: C3534156	        defb    'C'+$80,"SAVE"
10C1: 45      	
10C2: CE4557  	        defb    'N'+$80,"EW"
10C5: D4414228	        defb    'T'+$80,"AB("
10C9: D44F    	        defb    'T'+$80,"O"
10CB: C64E    	        defb    'F'+$80,"N"
10CD: D3504328	        defb    'S'+$80,"PC("
10D1: D448454E	        defb    'T'+$80,"HEN"
10D5: CE4F54  	        defb    'N'+$80,"OT"
10D8: D3544550	        defb    'S'+$80,"TEP"
              	        ; from here: operators
10DC: AB      	        defb    '+'+$80
10DD: AD      	        defb    '-'+$80
10DE: AA      	        defb    '*'+$80
10DF: AF      	        defb    '/'+$80
10E0: A5      	        defb    '%'+$80
10E1: A3      	        defb    '#'+$80
10E2: DE      	        defb    '^'+$80
10E3: C14E44  	        defb    'A'+$80,"ND"
10E6: D84F52  	        defb    'X'+$80,"OR"
10E9: CF52    	        defb    'O'+$80,"R"
10EB: BE      	        defb    '>'+$80
10EC: BD      	        defb    '='+$80
10ED: BC      	        defb    '<'+$80
              	
              	        ; from here there are the tokens' FUNCTIONS list
              	        ; this list must be coherent with the functions list above
10EE: D3474E  	        defb    'S'+$80,"GN"
10F1: D44D52  	        defb    'T'+$80,"MR"            ; added by Leonardo Miliani
10F4: C94E54  	        defb    'I'+$80,"NT"
10F7: C14253  	        defb    'A'+$80,"BS"
10FA: D55352  	        defb    'U'+$80,"SR"
10FD: C65245  	        defb    'F'+$80,"RE"
1100: C94E50  	        defb    'I'+$80,"NP"
1103: D04F53  	        defb    'P'+$80,"OS"
1106: D35152  	        defb    'S'+$80,"QR"
1109: D24E44  	        defb    'R'+$80,"ND"
110C: CC4F47  	        defb    'L'+$80,"OG"
110F: C55850  	        defb    'E'+$80,"XP"
1112: C34F53  	        defb    'C'+$80,"OS"
1115: D3494E  	        defb    'S'+$80,"IN"
1118: D4414E  	        defb    'T'+$80,"AN"
111B: C1544E  	        defb    'A'+$80,"TN"
111E: D045454B	        defb    'P'+$80,"EEK"
1122: C445454B	        defb    'D'+$80,"EEK"
1126: D6504545	        defb    'V'+$80,"PEEK"          ; added by Leonardo Miliani
112A: 4B      	
112B: D6535441	        defb    'V'+$80,"STAT"          ; added by Leonardo Miliani
112F: 54      	
1130: D3535441	        defb    'S'+$80,"STAT"          ; added by Leonardo Miliani
1134: 54      	
1135: C94E4B45	        defb    'I'+$80,"NKEY"          ; added by Leonardo Miliani
1139: 59      	
113A: D04F494E	        defb    'P'+$80,"OINT"          ; added by Leonardo Miliani
113E: 54      	
113F: CC454E  	        defb    'L'+$80,"EN"
1142: D3545224	        defb    'S'+$80,"TR$"
1146: D6414C  	        defb    'V'+$80,"AL"
1149: C15343  	        defb    'A'+$80,"SC"
114C: C3485224	        defb    'C'+$80,"HR$"
1150: C8455824	        defb    'H'+$80,"EX$"           ; added by Grant Searle
1154: C2494E24	        defb    'B'+$80,"IN$"           ; added by Grant Searle
1158: CC454654	        defb    'L'+$80,"EFT$"
115C: 24      	
115D: D2494748	        defb    'R'+$80,"IGHT$"
1161: 5424    	
1163: CD494424	        defb    'M'+$80,"ID$"
1167: 80      	        defb    $80                     ; End-of-list marker
              	
              	; KEYWORD ADDRESS TABLE
              	; this list must be coherent with the commands'
              	; tokens list above
1168: 6C1A    	WORDTB: defw    PEND
116A: 6919    	        defw    FOR
116C: 4C1E    	        defw    NEXT
116E: C51B    	        defw    DATA
1170: 511D    	        defw    INPUT
1172: 9C20    	        defw    DIM
1174: 831D    	        defw    READ
1176: DC1B    	        defw    LET
1178: 821B    	        defw    GOTO
117A: 5D1B    	        defw    RUN
117C: 541C    	        defw    IF
117E: 321A    	        defw    RESTOR
1180: 711B    	        defw    GOSUB
1182: A01B    	        defw    RETURN
1184: C71B    	        defw    REM
1186: 6A1A    	        defw    STOP
1188: EC25    	        defw    POUT
118A: 361C    	        defw    ON
118C: C71B    	        defw    REM         ; removed - was NULL
118E: F225    	        defw    WAIT
1190: 9122    	        defw    DEF
1192: E026    	        defw    POKE
1194: 6130    	        defw    DOKE
1196: E526    	        defw    VPOKE       ; added by Leonardo Miliani
1198: 2227    	        defw    SREG        ; added by Leonardo Miliani
119A: 5E28    	        defw    VREG        ; added by Leonardo Miliani
119C: 9730    	        defw    SCREEN      ; mod function: now it sets up a graphics mode (Leonardo Miliani)
119E: F026    	        defw    LOCATE      ; added by Leonardo Miliani
11A0: 7A27    	        defw    SOUND       ; added by Leonardo Miliani
11A2: 4127    	        defw    VOLUME      ; added by Leonardo Miliani
11A4: 7830    	        defw    PAUSE       ; added by Leonardo Miliani
11A6: 1231    	        defw    COLOR       ; added by Leonardo Miliani
11A8: 0B32    	        defw    PLOT        ; added by Leonardo Miliani
11AA: 8A32    	        defw    DRAW        ; added by Leonardo Miliani
11AC: B133    	        defw    CIRCLE      ; added by Leonardo Miliani
11AE: B635    	        defw    SERIAL      ; added by Leonardo Miliani
11B0: B137    	        defw    HELP        ; changed by Leonardo Miliani - was LINES
11B2: 3A30    	        defw    CLS
11B4: CC37    	        defw    KEY         ; added by Leonardo Miliani
11B6: 3426    	        defw    NMI         ; added by Leonardo Miliani
11B8: 4E30    	        defw    WIDTH
11BA: 8E26    	        defw    SYS
11BC: 0D3A    	        defw    RESET       ; new behaviour: now it resets the system
11BE: 781C    	        defw    PRINT
11C0: 9E1A    	        defw    CONT
11C2: 5E18    	        defw    LIST
11C4: 171B    	        defw    CLEAR
11C6: C71B    	        defw    REM         ; not implemented (was CLOAD)
11C8: C71B    	        defw    REM         ; not implemented (was CSAVE)
11CA: 4116    	        defw    NEW
              	
              	; RESERVED WORD TOKEN VALUES
              	; if you add a function or command you must increment by 1
              	; the values below. Pay attention that you must increment only the
              	; values AFTER the position where you entered the function/command word
              	; in the "Reserver word list" above. I.E.: VPOKE has been added between
              	; DOKE and SCREEN, and since REM is the reserved work listed below
              	; that is before the point where VPOKE has been entered, every entry
              	; after REM has been incremented.
              	; Another example: when TMR has been added, since it's a function, every
              	; entry after & included ZSGN must be checked (read below)
              	
0080:         	ZEND    equ     $80             ; END        <-- from here, there are the commands
0081:         	ZFOR    equ     $81             ; FOR
0083:         	ZDATA   equ     $83             ; DATA
0088:         	ZGOTO   equ     $88             ; GOTO
008C:         	ZGOSUB  equ     $8C             ; GOSUB
008E:         	ZREM    equ     $8E             ; REM
00AB:         	ZPRINT  equ     $AB             ; PRINT
00B1:         	ZNEW    equ     $B1             ; NEW
              	
00B2:         	ZTAB    equ     $B2             ; TAB
00B3:         	ZTO     equ     $B3             ; TO
00B4:         	ZFN     equ     $B4             ; FN
00B5:         	ZSPC    equ     $B5             ; SPC
00B6:         	ZTHEN   equ     $B6             ; THEN
00B7:         	ZNOT    equ     $B7             ; NOT
00B8:         	ZSTEP   equ     $B8             ; STEP
              	
00B9:         	ZPLUS   equ     $B9             ; +         <-- from here, there are the math operators
00BA:         	ZMINUS  equ     $BA             ; -
00BB:         	ZTIMES  equ     $BB             ; *
00BC:         	ZDIV    equ     $BC             ; /
00BD:         	ZMOD    equ     $BD             ; %
00BE:         	ZDINT   equ     $BE             ; #
00C2:         	ZOR     equ     $C2             ; OR
00C3:         	ZGTR    equ     $C3             ; >
00C4:         	ZEQUAL  equ     $C4             ; M
00C5:         	ZLTH    equ     $C5             ; <
              	
00C6:         	ZSGN    equ     $C6             ; SGN       <-- from here, there are the functions
00DC:         	ZPOINT  equ     $DC             ; ZPOINT    <-- if the user enters a custom function, between
              	                                ;               SGN and POINT, he/she must increment this pointer by 1
00E4:         	ZLEFT   equ     $E4             ; LEFT$     <-- if the user enters a custom function anywhere,
              	                                ;               he/she must increment this pointer by 1
              	
              	; ARITHMETIC PRECEDENCE TABLE
              	; in the formulas below, <last> is a number stored into the stack that must be retrieved
              	; with POP BC, POP DE; FPREG is a f.p. number store into the RAM register FPREG
11CC: 79      	PRITAB: defb    $79             ; Precedence value
11CD: 032D    	        defw    PADD            ; FPREG = <last> + FPREG
              	
11CF: 79      	        defb    $79             ; Precedence value
11D0: E628    	        defw    PSUB            ; FPREG = <last> - FPREG
              	
11D2: 7C      	        defb    $7C             ; Precedence value
11D3: 242A    	        defw    MULT            ; PPREG = <last> * FPREG
              	
11D5: 7C      	        defb    $7C             ; Precedence value
11D6: D62A    	        defw    DIV             ; FPREG = <last> / FPREG
              	
11D8: 7C      	        defb    $7C             ; Precedence value
11D9: 812A    	        defw    MOD             ; FPREG = INT(<last>)-(INT(FPREG)*INT(<last>/FPREG))
              	
11DB: 7C      	        defb    $7C             ; precedence value
11DC: 792A    	        defw    DINT            ; FPREG = INT(<last> / FPREG )
              	
11DE: 7F      	        defb    $7F             ; Precedence value
11DF: 242E    	        defw    POWER           ; FPREG = <last> ^ FPREG
              	
11E1: 50      	        defb    $50             ; Precedence value
11E2: E51F    	        defw    PAND            ; FPREG = <last> AND FPREG
              	
11E4: 4A      	        defb    $4A             ; Precedence value
11E5: ED1F    	        defw    PXOR            ; FPREG = <last> XOR FPREG
              	
11E7: 46      	        defb    $46             ; Precedence value
11E8: E81F    	        defw    POR             ; FPREG = <last> OR FPREG
              	
              	; BASIC ERROR CODE LIST
              	
11EA:         	ERRORS  equ $
11EA: 4E455854	NFMSG:  defb    "NEXT Without FOR",0
11EE: 20576974	
11F2: 686F7574	
11F6: 20464F52	
11FA: 00      	
11FB: 53796E74	SNMSG:  defb    "Syntax",0
11FF: 617800  	
1202: 52455455	RGMSG:  defb    "RETURN without GOSUB",0
1206: 524E2077	
120A: 6974686F	
120E: 75742047	
1212: 4F535542	
1216: 00      	
1217: 4F757420	ODMSG:  defb    "Out of DATA",0
121B: 6F662044	
121F: 41544100	
1223: 496C6C65	FCMSG:  defb    "Illegal Function Call",0
1227: 67616C20	
122B: 46756E63	
122F: 74696F6E	
1233: 2043616C	
1237: 6C00    	
1239: 4F766572	OVMSG:  defb    "Overflow",0
123D: 666C6F77	
1241: 00      	
1242: 4F757420	OMMSG:  defb    "Out of Memory",0
1246: 6F66204D	
124A: 656D6F72	
124E: 7900    	
1250: 556E6465	ULMSG:  defb    "Undefined Line",0
1254: 66696E65	
1258: 64204C69	
125C: 6E6500  	
125F: 42616420	BSMSG:  defb    "Bad Subscript",0
1263: 53756273	
1267: 63726970	
126B: 7400    	
126D: 52652D44	DDMSG:  defb    "Re-Dimensioned Array",0
1271: 696D656E	
1275: 73696F6E	
1279: 65642041	
127D: 72726179	
1281: 00      	
1282: 44697669	DZMSG:  defb    "Division by Zero",0
1286: 73696F6E	
128A: 20627920	
128E: 5A65726F	
1292: 00      	
1293: 496C6C65	IDMSG:  defb    "Illegal Direct",0
1297: 67616C20	
129B: 44697265	
129F: 637400  	
12A2: 54797065	TMMSG:  defb    "Type Mis-match",0
12A6: 204D6973	
12AA: 2D6D6174	
12AE: 636800  	
12B1: 4F757420	OSMSG:  defb    "Out of String Space",0
12B5: 6F662053	
12B9: 7472696E	
12BD: 67205370	
12C1: 61636500	
12C5: 53747269	LSMSG:  defb    "String Too Long",0
12C9: 6E672054	
12CD: 6F6F204C	
12D1: 6F6E6700	
12D5: 53747269	STMSG:  defb    "String Formula Too Complex",0
12D9: 6E672046	
12DD: 6F726D75	
12E1: 6C612054	
12E5: 6F6F2043	
12E9: 6F6D706C	
12ED: 657800  	
12F0: 43616E27	CNMSG:  defb    "Can't Continue",0
12F4: 7420436F	
12F8: 6E74696E	
12FC: 756500  	
12FF: 556E6465	UFMSG:  defb    "Undefined FN Function",0
1303: 66696E65	
1307: 6420464E	
130B: 2046756E	
130F: 6374696F	
1313: 6E00    	
1315: 4D697373	MOMSG:  defb    "Missing Operand",0
1319: 696E6720	
131D: 4F706572	
1321: 616E6400	
1325: 48455820	HXMSG:  defb    "HEX Format",0
1329: 466F726D	
132D: 617400  	
1330: 42494E20	BNMSG:  defb    "BIN Format",0
1334: 466F726D	
1338: 617400  	
133B: 4E6F2047	GMMSG:  defb    "No Graphics Mode",0
133F: 72617068	
1343: 69637320	
1347: 4D6F6465	
134B: 00      	
134C: 53657269	SCMSG:  defb    "Serial Configuration",0
1350: 616C2043	
1354: 6F6E6669	
1358: 67757261	
135C: 74696F6E	
1360: 00      	
1361: 53657269	SAMSG:  defb    "Serial Port Already Open",0
1365: 616C2050	
1369: 6F727420	
136D: 416C7265	
1371: 61647920	
1375: 4F70656E	
1379: 00      	
137A: 48454C50	HPMSG:  defb    "HELP Call",0
137E: 2043616C	
1382: 6C00    	
              	
1384:         	ERRTBL  equ $
1384: EA11    	NFPTR   defw    NFMSG
1386: FB11    	SNPTR   defw    SNMSG
1388: 0212    	RGPTR   defw    RGMSG
138A: 1712    	ODPTR   defw    ODMSG
138C: 2312    	FCPTR   defw    FCMSG
138E: 3912    	OVPTR   defw    OVMSG
1390: 4212    	OMPTR   defw    OMMSG
1392: 5012    	ULPTR   defw    ULMSG
1394: 5F12    	BSPTR   defw    BSMSG
1396: 6D12    	DDPTR   defw    DDMSG
1398: 8212    	DZPTR   defw    DZMSG
139A: 9312    	IDPTR   defw    IDMSG
139C: A212    	TMPTR   defw    TMMSG
139E: B112    	OSPTR   defw    OSMSG
13A0: C512    	LSPTR   defw    LSMSG
13A2: D512    	STPTR   defw    STMSG
13A4: F012    	CNPTR   defw    CNMSG
13A6: FF12    	UFPTR   defw    UFMSG
13A8: 1513    	MOPTR   defw    MOMSG
13AA: 2513    	HXPTR   defw    HXMSG
13AC: 3013    	BNPTR   defw    BNMSG
13AE: 3B13    	GMPRT   defw    GMMSG
13B0: 4C13    	SCPTR   defw    SCMSG
13B2: 6113    	SAPTR   defw    SAMSG
13B4: 7A13    	HPPTR   defw    HPMSG
              	
              	; INITIALISATION TABLE -------------------------------------------------------
              	; these values are copied into RAM at startup
13B6: C35C0F  	INITAB: jp      WARMST          ; Warm start jump
13B9: ED4500  	        defb    $ED,$45,$00     ; RETN + NOP for default NMI service routine
13BC: C3ED1A  	        jp      FCERR           ; "USR (X)" jump (Set to Error)
13BF: D300    	        out     (0),A           ; "out p,n" skeleton
13C1: C9      	        ret
13C2: D600    	        sub     $00             ; Division support routine
13C4: 6F      	        ld      L,A
13C5: 7C      	        ld      A,H
13C6: DE00    	        sbc     A,$00
13C8: 67      	        ld      H,A
13C9: 78      	        ld      A,B
13CA: DE00    	        sbc     A,$00
13CC: 47      	        ld      B,A
13CD: 3E00    	        ld      A,$00
13CF: C9      	        ret
13D0: 000000  	        defb    $00,$00,$00     ; Random number seed table used by RND
13D3: 354ACA99	        defb    $35,$4A,$CA,$99 ;-2.65145E+07
13D7: 391C7698	        defb    $39,$1C,$76,$98 ; 1.61291E+07
13DB: 2295B398	        defb    $22,$95,$B3,$98 ;-1.17691E+07
13DF: 0ADD4798	        defb    $0A,$DD,$47,$98 ; 1.30983E+07
13E3: 53D19999	        defb    $53,$D1,$99,$99 ;-2-01612E+07
13E7: 0A1A9F98	        defb    $0A,$1A,$9F,$98 ;-1.04269E+07
13EB: 65BCCD98	        defb    $65,$BC,$CD,$98 ;-1.34831E+07
13EF: D6773E98	        defb    $D6,$77,$3E,$98 ; 1.24825E+07
13F3: 52C74F80	        defb    $52,$C7,$4F,$80 ; Last random number
13F7: DB00    	        in      A,($00)         ; INP (x) skeleton
13F9: C9      	        ret
13FA: FF      	        defb    $FF             ; Terminal width (255 = no auto CRLF)
13FB: 1C      	        defb    $1C             ; Width for commas (3 columns)
13FC: 00      	        defb    $00             ; No nulls after input bytes
13FD: 00      	        defb    $00             ; Output enabled (^O off)
13FE: 0000    	        defw    $00             ; Array load/save check sum
1400: 00      	        defb    $00             ; Break not by NMI
1401: 00      	        defb    $00             ; Break flag
1402: C37D17  	        jp      TTYLIN          ; Input reflection (set to TTY)
1405: A482    	        defw    STLOOK          ; Temp string space
1407: FEFF    	        defw    -2              ; Current line number (cold)
1409: FFFF    	        defw    -1              ; Current line with errors (no errors)
140B: 4C495354	DEFFNKS:defm    "LIST",13,0,0,0,0,0,0,0,0,0,0,0     ; KEY 1
140F: 0D000000	
1413: 00000000	
1417: 00000000	
141B: 52554E0D	        defm    "RUN",13,0,0,0,0,0,0,0,0,0,0,0,0    ; KEY 2
141F: 00000000	
1423: 00...   	
142B: 53435245	        defm    "SCREEN1",13,0,0,0,0,0,0,0,0        ; KEY 3
142F: 454E310D	
1433: 00000000	
1437: 00000000	
143B: 434F4C4F	        defm    "COLOR1,15,5",13,0,0,0,0            ; KEY 4
143F: 52312C31	
1443: 352C350D	
1447: 00000000	
144B: 53455249	        defm    "SERIAL1,38400",13,0,0              ; KEY 5
144F: 414C312C	
1453: 33383430	
1457: 300D0000	
145B: 53435245	        defm    "SCREEN2",13,0,0,0,0,0,0,0,0        ; KEY 6
145F: 454E320D	
1463: 00000000	
1467: 00000000	
146B: 434F4E54	        defm    "CONT",13,0,0,0,0,0,0,0,0,0,0,0     ; KEY 7
146F: 0D000000	
1473: 00000000	
1477: 00000000	
147B: 48454C50	        defm    "HELP",13,0,0,0,0,0,0,0,0,0,0,0     ; KEY 8 (HELP KEY)
147F: 0D000000	
1483: 00000000	
1487: 00000000	
148B: 4182    	        defw    PROGST+1        ; Start of program text
148D:         	INITBE:
              	
              	; END OF INITIALISATION TABLE ---------------------------------------------------
              	
148D: 20457272	ERRMSG: defb    " Error",0
1491: 6F7200  	
1494: 20696E20	INMSG:  defb    " in ",0
1498: 00      	
1498:         	ZERBYT  equ     $-1             ; A zero byte
1499: 4F6B0D00	OKMSG:  defb    "Ok",CR,0,0
149D: 00      	
149E: 42726561	BRKMSG: defb    "Break",0
14A2: 6B00    	
              	
14A4: 210400  	BAKSTK: ld      HL,$04          ; Look for "FOR" block with
14A7: 39      	        add     HL,SP           ; same index as specified
14A8: 7E      	LOKFOR: ld      A,(HL)          ; Get block ID
14A9: 23      	        inc     HL              ; Point to index address
14AA: FE81    	        cp      ZFOR            ; Is it a "FOR" token
14AC: C0      	        ret     NZ              ; No - exit
14AD: 4E      	        ld      C,(HL)          ; BC = Address of "FOR" index
14AE: 23      	        inc     HL
14AF: 46      	        ld      B,(HL)
14B0: 23      	        inc     HL              ; Point to sign of STEP
14B1: E5      	        push    HL              ; Save pointer to sign
14B2: 69      	        ld      L,C             ; HL = address of "FOR" index
14B3: 60      	        ld      H,B
14B4: 7A      	        ld      A,D             ; See if an index was specified
14B5: B3      	        or      E               ; DE = 0 if no index specified
14B6: EB      	        ex      DE,HL           ; Specified index into HL
14B7: CABE14  	        jp      Z,INDFND        ; Skip if no index given
14BA: EB      	        ex      DE,HL           ; Index back into DE
14BB: CDF917  	        call    CPDEHL          ; Compare index with one given
14BE: 010D00  	INDFND: ld      BC,16-3         ; Offset to next block
14C1: E1      	        pop     HL              ; Restore pointer to sign
14C2: C8      	        ret     Z               ; Return if block found
14C3: 09      	        add     HL,BC           ; Point to next block
14C4: C3A814  	        jp      LOKFOR          ; Keep on looking
              	
14C7: CDE114  	MOVUP:  call    ENFMEM          ; See if enough memory
14CA: C5      	MOVSTR: push    BC              ; Save end of source
14CB: E3      	        ex      (SP),HL         ; Swap source and dest" end
14CC: C1      	        pop     BC              ; Get end of destination
14CD: CDF917  	MOVLP:  call    CPDEHL          ; See if list moved
14D0: 7E      	        ld      A,(HL)          ; Get byte
14D1: 02      	        ld      (BC),A          ; Move it
14D2: C8      	        ret     Z               ; Exit if all done
14D3: 0B      	        dec     BC              ; Next byte to move to
14D4: 2B      	        dec     HL              ; Next byte to move
14D5: C3CD14  	        jp      MOVLP           ; Loop until all bytes moved
              	
14D8: E5      	CHKSTK: push    HL              ; Save code string address
14D9: 2ABF81  	        ld      HL,(ARREND)     ; Lowest free memory
14DC: 0600    	        ld      B,$00           ; BC = Number of levels to test
14DE: 09      	        add     HL,BC           ; 2 Bytes for each level
14DF: 09      	        add     HL,BC
14E0: 3E      	        defb    $3E             ; Skip "push HL"
14E1: E5      	ENFMEM: push    HL              ; Save code string address
14E2: 3ED0    	        ld      A,$D0           ; LOW -48 ; 48 Bytes minimum RAM
14E4: 95      	        sub     L
14E5: 6F      	        ld      L,A
14E6: 3EFF    	        ld      A,$FF           ; HIGH (-48) ; 48 Bytes minimum RAM
14E8: 9C      	        sbc     A,H
14E9: DAF014  	        jp      C,OMERR         ; Not enough - ?OM Error
14EC: 67      	        ld      H,A
14ED: 39      	        add     HL,SP           ; Test if stack is overflowed
14EE: E1      	        pop     HL              ; Restore code string address
14EF: D8      	        ret     C               ; Return if enough memory
14F0: 1E0C    	OMERR:  ld      E,OM            ; ?OM Error
14F2: C32F15  	        jp      ERROR
              	
              	
              	; if in graphics mode, return to text (called by "NOLIN" and "ERROR")
14F5: F5      	EXITGM: push    AF              ; store AF
14F6: 3AE081  	        ld      A,(SCR_MODE)    ; check screen mode
14F9: FE02    	        cp      $02             ; G2?
14FB: CA0215  	        jp      Z,LDG1          ; yes, back to G1
14FE: FE03    	        cp      $03             ; G3?
1500: 2011    	        jr      NZ,LDG1ND       ; no, so return
1502: E5      	LDG1:   push    HL              ; store HL
1503: D5      	        push    DE              ; store DE
1504: 110100  	        ld      DE,$0001        ; sprites set to defaults, G1 mode
1507: F3      	        di                      ; disable INTs
1508: CD7403  	        call    initVDP         ; initialize VDP with mode pointed by E
150B: FB      	        ei                      ; re-enable INTs
150C: 3E01    	        ld      A,$01           ; activate the...
150E: 32EB81  	        ld      (PRNTVIDEO),A   ; ...video buffer...
1511: D1      	        pop     DE              ; retrieve DE
1512: E1      	        pop     HL              ; retrieve HL
1513: F1      	LDG1ND: pop     AF              ; retrieve AF
1514: C9      	        ret                     ; return to caller
              	
              	
1515: 2AAE81  	DATSNR: ld      HL,(DATLIN)     ; Get line of current DATA item
1518: 22AF80  	        ld      (LINEAT),HL     ; Save as current line
151B: 1E02    	SNERR:  ld      E,SN            ; ?SN Error
151D: 01      	        defb    $01             ; Skip "ld E,DZ"
151E: 1E14    	DZERR:  ld      E,DZ            ; ?/0 Error
1520: 01      	        defb    $01             ; Skip "ld E,NF"
1521: 1E00    	NFERR:  ld      E,NF            ; ?NF Error
1523: 01      	        defb    $01             ; Skip "ld E,DD"
1524: 1E12    	DDERR:  ld      E,DD            ; ?DD Error
1526: 01      	        defb    $01             ; Skip "ld E,UF"
1527: 1E22    	UFERR:  ld      E,UF            ; ?UF Error
1529: 01      	        defb    $01             ; Skip "ld E,OV
152A: 1E0A    	OVERR:  ld      E,OV            ; ?OV Error
152C: 01      	        defb    $01             ; Skip "ld E,TM"
152D: 1E18    	TMERR:  ld      E,TM            ; ?TM Error
              	
152F: CD6716  	ERROR:  call    CLREG           ; Clear registers and stack
1532: CDF514  	        call    EXITGM          ; exit from graphic modes
1535: 32A580  	        ld      (CTLOFG),A      ; Enable output (A is 0)
1538: CD2C08  	        call    CURSOR_ON       ; enable cursor
153B: CDC91C  	        call    STTLIN          ; Start new line
153E: 218413  	        ld      HL,ERRTBL       ; Point to error codes
1541: 57      	        ld      D,A             ; D = 0 (A is 0)
1542: 3E3F    	        ld      A,'?'
1544: CD0A18  	        call    OUTC            ; Output '?'
1547: 19      	        add     HL,DE           ; Offset to correct error code
1548: 5E      	        ld      E,(HL)          ; load pointer to error message
1549: 23      	        inc     HL              ; by loading LSB,
154A: 56      	        ld      D,(HL)          ; then MSB
154B: 626B    	        ld      HL,DE           ; load pointer to HL
154D: CD9B23  	        call    PRS             ; Output error message
1550: 218D14  	        ld      HL,ERRMSG       ; "Error" message
1553: CD9B23  	ERRIN:  call    PRS             ; Output message
1556: 2AAF80  	        ld      HL,(LINEAT)     ; Get line of error
1559: 11FEFF  	        ld      DE,-2           ; Cold start error if -2
155C: CDF917  	        call    CPDEHL          ; See if cold start error
155F: CACB0E  	        jp      Z,CSTART        ; Cold start error - Restart
1562: 7C      	        ld      A,H             ; Was it a direct error?
1563: A5      	        and     L               ; Line = -1 if direct error
1564: 3C      	        inc     A
1565: CA7015  	        jp      Z,PTLN          ; Yes, jump over
1568: E5      	        push    HL              ; indirect mode - store HL
1569: 2AAF80  	        ld      HL,(LINEAT)     ; copy current line number
156C: 22B180  	        ld      (HLPLN),HL      ; save in HELP line register
156F: E1      	        pop     HL              ; retrieve HL
1570: C4142D  	PTLN:   call    NZ,LINEIN       ; No - output line of error
              	
1573: 3E      	        defb    $3E             ; Skip "pop BC"
1574: C1      	POPNOK: pop     BC              ; Drop address in input buffer
              	
              	; run into direct mode: print OK and get command
1575: AF      	PRNTOK: xor     A               ; Output "Ok" and get command
1576: 32A580  	        ld      (CTLOFG),A      ; Enable output
1579: CDC91C  	        call    STTLIN          ; Start new line
157C: 219914  	        ld      HL,OKMSG        ; "Ok" message
157F: CD9B23  	        call    PRS             ; Output "Ok"
1582: CD2C08  	GETCMD: call    CURSOR_ON       ; enable cursor
1585: 21FFFF  	        ld      HL,-1           ; Flag direct mode
1588: 22AF80  	        ld      (LINEAT),HL     ; Save as current line
158B: CD7D17  	        call    GETLIN          ; Get an input line
158E: DA8215  	        jp      C,GETCMD        ; Get line again if break
1591: CD221A  	        call    GETCHR          ; Get first character
1594: 17      	        rla                     ; 8th bit is copied into carry and original carry is copied into bit 0)
1595: DA1B15  	        jp      C,SNERR         ; if char >=128 (8th bit set) then raise an error
1598: 1F      	        rra                     ; recover original char and Carry
1599: 3C      	        inc     A               ; Test if end of line
159A: 3D      	        dec     A               ; Without affecting Carry
159B: CA8215  	        jp      Z,GETCMD        ; Nothing entered - Get another
159E: F5      	        push    AF              ; Save Carry status
159F: CD4208  	        call    CURSOR_OFF      ; cursor disabled
15A2: CDF21A  	        call    ATOH            ; Get line number into DE
15A5: D5      	        push    DE              ; Save line number
15A6: CD9416  	        call    CRUNCH          ; Tokenise rest of line
15A9: 47      	        ld      B,A             ; Length of tokenised line
15AA: D1      	        pop     DE              ; Restore line number
15AB: F1      	        pop     AF              ; Restore Carry
15AC: D2021A  	        jp      NC,EXCUTE       ; No line number - Direct mode
15AF: D5      	        push    DE              ; Save line number
15B0: C5      	        push    BC              ; Save length of tokenised line
15B1: AF      	        xor     A
15B2: 32B181  	        ld      (LSTBIN),A      ; Clear last byte input
15B5: CD221A  	        call    GETCHR          ; Get next character
15B8: B7      	        or      A               ; Set flags
15B9: F5      	        push    AF              ; And save them
15BA: CD2116  	        call    SRCHLN          ; Search for line number in DE
15BD: DAC615  	        jp      C,LINFND        ; Jump if line found
15C0: F1      	        pop     AF              ; Get status
15C1: F5      	        push    AF              ; And re-save
15C2: CA9B1B  	        jp      Z,ULERR         ; Nothing after number - Error
15C5: B7      	        or      A               ; Clear Carry
15C6: C5      	LINFND: push    BC              ; Save address of line in prog
15C7: D2DD15  	        jp      NC,INEWLN       ; Line not found - Insert new
15CA: EB      	        ex      DE,HL           ; Next line address in DE
15CB: 2ABB81  	        ld      HL,(PROGND)     ; End of program
15CE: 1A      	SFTPRG: ld      A,(DE)          ; Shift rest of program down
15CF: 02      	        ld      (BC),A
15D0: 03      	        inc     BC              ; Next destination
15D1: 13      	        inc     DE              ; Next source
15D2: CDF917  	        call    CPDEHL          ; All done?
15D5: C2CE15  	        jp      NZ,SFTPRG       ; More to do
15D8: 60      	        ld      H,B             ; HL - New end of program
15D9: 69      	        ld      L,C
15DA: 22BB81  	        ld      (PROGND),HL     ; Update end of program
              	
15DD: D1      	INEWLN: pop     DE              ; Get address of line,
15DE: F1      	        pop     AF              ; Get status
15DF: CA0416  	        jp      Z,SETPTR        ; No text - Set up pointers
15E2: 2ABB81  	        ld      HL,(PROGND)     ; Get end of program
15E5: E3      	        ex      (SP),HL         ; Get length of input line
15E6: C1      	        pop     BC              ; End of program to BC
15E7: 09      	        add     HL,BC           ; Find new end
15E8: E5      	        push    HL              ; Save new end
15E9: CDC714  	        call    MOVUP           ; Make space for line
15EC: E1      	        pop     HL              ; Restore new end
15ED: 22BB81  	        ld      (PROGND),HL     ; Update end of program pointer
15F0: EB      	        ex      DE,HL           ; Get line to move up in HL
15F1: 74      	        ld      (HL),H          ; Save MSB
15F2: D1      	        pop     DE              ; Get new line number
15F3: 23      	        inc     HL              ; Skip pointer
15F4: 23      	        inc     HL
15F5: 73      	        ld      (HL),E          ; Save LSB of line number
15F6: 23      	        inc     HL
15F7: 72      	        ld      (HL),D          ; Save MSB of line number
15F8: 23      	        inc     HL              ; To first byte in line
15F9: 113681  	        ld      DE,BUFFER       ; Copy buffer to program
15FC: 1A      	MOVBUF: ld      A,(DE)          ; Get source
15FD: 77      	        ld      (HL),A          ; Save destinations
15FE: 23      	        inc     HL              ; Next source
15FF: 13      	        inc     DE              ; Next destination
1600: B7      	        or      A               ; Done?
1601: C2FC15  	        jp      NZ,MOVBUF       ; No - Repeat
1604: CD4D16  	SETPTR: call    RUNFST          ; Set line pointers
1607: 23      	        inc     HL              ; To LSB of pointer
1608: EB      	        ex      DE,HL           ; Address to DE
1609: 62      	PTRLP:  ld      H,D             ; Address to HL
160A: 6B      	        ld      L,E
160B: 7E      	        ld      A,(HL)          ; Get LSB of pointer
160C: 23      	        inc     HL              ; To MSB of pointer
160D: B6      	        or      (HL)            ; Compare with MSB pointer
160E: CA8215  	        jp      Z,GETCMD        ; Get command line if end
1611: 23      	        inc     HL              ; To LSB of line number
1612: 23      	        inc     HL              ; Skip line number
1613: 23      	        inc     HL              ; Point to first byte in line
1614: AF      	        xor     A               ; Looking for 00 byte
1615: BE      	FNDEND: cp      (HL)            ; Found end of line?
1616: 23      	        inc     HL              ; Move to next byte
1617: C21516  	        jp      NZ,FNDEND       ; No - Keep looking
161A: EB      	        ex      DE,HL           ; Next line address to HL
161B: 73      	        ld      (HL),E          ; Save LSB of pointer
161C: 23      	        inc     HL
161D: 72      	        ld      (HL),D          ; Save MSB of pointer
161E: C30916  	        jp      PTRLP           ; Do next line
              	
1621: 2A3381  	SRCHLN: ld      HL,(BASTXT)     ; Start of program text
1624: 44      	SRCHLP: ld      B,H             ; BC = Address to look at
1625: 4D      	        ld      C,L
1626: 7E      	        ld      A,(HL)          ; Get address of next line
1627: 23      	        inc     HL
1628: B6      	        or      (HL)            ; End of program found?
1629: 2B      	        dec     HL
162A: C8      	        ret     Z               ; Yes - Line not found
162B: 23      	        inc     HL
162C: 23      	        inc     HL
162D: 7E      	        ld      A,(HL)          ; Get LSB of line number
162E: 23      	        inc     HL
162F: 66      	        ld      H,(HL)          ; Get MSB of line number
1630: 6F      	        ld      L,A
1631: CDF917  	        call    CPDEHL          ; Compare with line in DE
1634: 60      	        ld      H,B             ; HL = Start of this line
1635: 69      	        ld      L,C
1636: 7E      	        ld      A,(HL)          ; Get LSB of next line address
1637: 23      	        inc     HL
1638: 66      	        ld      H,(HL)          ; Get MSB of next line address
1639: 6F      	        ld      L,A             ; Next line to HL
163A: 3F      	        ccf
163B: C8      	        ret     Z               ; Lines found - Exit
163C: 3F      	        ccf
163D: D0      	        ret     NC              ; Line not found,at line after
163E: C32416  	        jp      SRCHLP          ; Keep looking
              	
1641: C0      	NEW:    ret     NZ              ; Return if any more on line
1642: 2A3381  	CLRPTR: ld      HL,(BASTXT)     ; Point to start of program
1645: AF      	        xor     A               ; Set program area to empty
1646: 77      	        ld      (HL),A          ; Save LSB = 00
1647: 23      	        inc     HL
1648: 77      	        ld      (HL),A          ; Save MSB = 00
1649: 23      	        inc     HL
164A: 22BB81  	        ld      (PROGND),HL     ; Set program end
              	
164D: 2A3381  	RUNFST: ld      HL,(BASTXT)     ; Clear all variables
1650: 2B      	        dec     HL
              	
1651: 22B381  	INTVAR: ld      (BRKLIN),HL     ; Initialise RUN variables
1654: 2A9481  	        ld      HL,(LSTRAM)     ; Get end of RAM
1657: 22A881  	        ld      (STRBOT),HL     ; Clear string space
165A: AF      	        xor     A
165B: CD321A  	        call    RESTOR          ; Reset DATA pointers
165E: 2ABB81  	        ld      HL,(PROGND)     ; Get end of program
1661: 22BD81  	        ld      (VAREND),HL     ; Clear variables
1664: 22BF81  	        ld      (ARREND),HL     ; Clear arrays
              	
1667: C1      	CLREG:  pop     BC              ; Save return address
1668: 2AAD80  	        ld      HL,(STRSPC)     ; Get end of working RAM
166B: F9      	        ld      SP,HL           ; Set stack
166C: 219881  	        ld      HL,TMSTPL       ; Temporary string pool
166F: 229681  	        ld      (TMSTPT),HL     ; Reset temporary string ptr
1672: AF      	        xor     A               ; A = 00
1673: 6F      	        ld      L,A             ; HL = 0000
1674: 67      	        ld      H,A
1675: 22B981  	        ld      (CONTAD),HL     ; No CONTinue
1678: 32B081  	        ld      (FORFLG),A      ; Clear FOR flag
167B: 22C381  	        ld      (FNRGNM),HL     ; Clear FN argument
167E: E5      	        push    HL              ; HL = 0000
167F: C5      	        push    BC              ; Put back return
1680: 2AB381  	DOAGN:  ld      HL,(BRKLIN)     ; Get address of code to RUN
1683: C9      	        ret                     ; Return to execution driver
              	
1684: 3E3F    	PROMPT: ld      A,'?'           ; '?'
1686: CD0A18  	        call    OUTC            ; Output character
1689: 3E00    	        ld      A,NLLCR         ; null char
168B: CD0A18  	        call    OUTC            ; Output character
168E: CD2C08  	        call    CURSOR_ON       ; enable cursor
1691: C3AA80  	        jp      RINPUT          ; Get input line
              	
1694: AF      	CRUNCH: xor     A               ; Tokenise line @ HL to BUFFER
1695: 329381  	        ld      (DATFLG),A      ; Reset literal flag
1698: 0E05    	        ld      C,2+3           ; 2 byte number and 3 nulls
169A: 113681  	        ld      DE,BUFFER       ; Start of input buffer
169D: 7E      	CRNCLP: ld      A,(HL)          ; Get byte
169E: FE20    	        cp      SPC             ; Is it a space?
16A0: CA1C17  	        jp      Z,MOVDIR        ; Yes - Copy direct
16A3: 47      	        ld      B,A             ; Save character
16A4: FE22    	        cp      22H             ; '"'             ; Is it a quote?
16A6: CA3C17  	        jp      Z,CPYLIT        ; Yes - Copy literal string
16A9: B7      	        or      A               ; Is it end of buffer?
16AA: CA4317  	        jp      Z,ENDBUF        ; Yes - End buffer
16AD: 3A9381  	        ld      A,(DATFLG)      ; Get data type
16B0: B7      	        or      A               ; Literal?
16B1: 7E      	        ld      A,(HL)          ; Get byte to copy
16B2: C21C17  	        jp      NZ,MOVDIR       ; Literal - Copy direct
16B5: FE3F    	        cp      '?'             ; Is it '?' short for PRINT
16B7: 3EAB    	        ld      A,ZPRINT        ; "PRINT" token
16B9: CA1C17  	        jp      Z,MOVDIR        ; Yes - replace it
16BC: 7E      	        ld      A,(HL)          ; Get byte again
16BD: FE30    	        cp      '0'             ; Is it less than '0'
16BF: DAC716  	        jp      C,FNDWRD        ; Yes - Look for reserved words
16C2: FE3C    	        cp      $3C  ;60; ";"+1       ; Is it "0123456789:;" ?
16C4: DA1C17  	        jp      C,MOVDIR        ; Yes - copy it direct
16C7: D5      	FNDWRD: push    DE              ; Look for reserved words
16C8: 11F20F  	        ld      DE,WORDS-1      ; Point to table
16CB: C5      	        push    BC              ; Save count
16CC: 011817  	        ld      BC,RETNAD       ; Where to return to
16CF: C5      	        push    BC              ; Save return address
16D0: 067F    	        ld      B,ZEND-1        ; First token value -1
16D2: 7E      	        ld      A,(HL)          ; Get byte
16D3: FE61    	        cp      'a'             ; Less than 'a' ?
16D5: DAE016  	        jp      C,SEARCH        ; Yes - search for words
16D8: FE7B    	        cp      'z'+1           ; Greater than 'z' ?
16DA: D2E016  	        jp      NC,SEARCH       ; Yes - search for words
16DD: E65F    	        and     %01011111       ; Force upper case
16DF: 77      	        ld      (HL),A          ; Replace byte
16E0: 4E      	SEARCH: ld      C,(HL)          ; Search for a word
16E1: EB      	        ex      DE,HL
16E2: 23      	GETNXT: inc     HL              ; Get next reserved word
16E3: B6      	        or      (HL)            ; Start of word?
16E4: F2E216  	        jp      P,GETNXT        ; No - move on
16E7: 04      	        inc     B               ; Increment token value
16E8: 7E      	        ld      A,(HL)          ; Get byte from table
16E9: E67F    	        and     %01111111       ; Strip bit 7
16EB: C8      	        ret     Z               ; Return if end of list
16EC: B9      	        cp      C               ; Same character as in buffer?
16ED: C2E216  	        jp      NZ,GETNXT       ; No - get next word
16F0: EB      	        ex      DE,HL
16F1: E5      	        push    HL              ; Save start of word
              	
16F2: 13      	NXTBYT: inc     DE              ; Look through rest of word
16F3: 1A      	        ld      A,(DE)          ; Get byte from table
16F4: B7      	        or      A               ; End of word ?
16F5: FA1417  	        jp      M,MATCH         ; Yes - Match found
16F8: 4F      	        ld      C,A             ; Save it
16F9: 78      	        ld      A,B             ; Get token value
16FA: FE88    	        cp      ZGOTO           ; Is it "GOTO" token ?
16FC: C20317  	        jp      NZ,NOSPC        ; No - Don't allow spaces
16FF: CD221A  	        call    GETCHR          ; Get next character
1702: 2B      	        dec     HL              ; Cancel increment from GETCHR
1703: 23      	NOSPC:  inc     HL              ; Next byte
1704: 7E      	        ld      A,(HL)          ; Get byte
1705: FE61    	        cp      'a'             ; Less than 'a' ?
1707: DA0C17  	        jp      C,NOCHNG        ; Yes - don't change
170A: E65F    	        and     %01011111       ; Make upper case
170C: B9      	NOCHNG: cp      C               ; Same as in buffer ?
170D: CAF216  	        jp      Z,NXTBYT        ; Yes - keep testing
1710: E1      	        pop     HL              ; Get back start of word
1711: C3E016  	        jp      SEARCH          ; Look at next word
              	
1714: 48      	MATCH:  ld      C,B             ; Word found - Save token value
1715: F1      	        pop     AF              ; Throw away return
1716: EB      	        ex      DE,HL
1717: C9      	        ret                     ; Return to "RETNAD"
1718: EB      	RETNAD: ex      DE,HL           ; Get address in string
1719: 79      	        ld      A,C             ; Get token value
171A: C1      	        pop     BC              ; Restore buffer length
171B: D1      	        pop     DE              ; Get destination address
171C: 23      	MOVDIR: inc     HL              ; Next source in buffer
171D: 12      	        ld      (DE),A          ; Put byte in buffer
171E: 13      	        inc     DE              ; Move up buffer
171F: 0C      	        inc     C               ; Increment length of buffer
1720: D63A    	        sub     ':'             ; End of statement?
1722: CA2A17  	        jp      Z,SETLIT        ; Jump if multi-statement line
1725: FE49    	        cp      ZDATA-$3A       ; Is it DATA statement ?
1727: C22D17  	        jp      NZ,TSTREM       ; No - see if REM
172A: 329381  	SETLIT: ld      (DATFLG),A      ; Set literal flag
172D: D654    	TSTREM: sub     ZREM-$3A        ; Is it REM?
172F: C29D16  	        jp      NZ,CRNCLP       ; No - Leave flag
1732: 47      	        ld      B,A             ; Copy rest of buffer
1733: 7E      	NXTCHR: ld      A,(HL)          ; Get byte
1734: B7      	        or      A               ; End of line ?
1735: CA4317  	        jp      Z,ENDBUF        ; Yes - Terminate buffer
1738: B8      	        cp      B               ; End of statement ?
1739: CA1C17  	        jp      Z,MOVDIR        ; Yes - Get next one
173C: 23      	CPYLIT: inc     HL              ; Move up source string
173D: 12      	        ld      (DE),A          ; Save in destination
173E: 0C      	        inc     C               ; Increment length
173F: 13      	        inc     DE              ; Move up destination
1740: C33317  	        jp      NXTCHR          ; Repeat
              	
1743: 213581  	ENDBUF: ld      HL,BUFFER-1     ; Point to start of buffer
1746: 12      	        ld      (DE),A          ; Mark end of buffer (A = 00)
1747: 13      	        inc     DE
1748: 12      	        ld      (DE),A          ; A = 00
1749: 13      	        inc     DE
174A: 12      	        ld      (DE),A          ; A = 00
174B: C9      	        ret
              	
174C: 3AA480  	DODEL:  ld      A,(NULFLG)      ; Get null flag status
174F: B7      	        or      A               ; Is it zero?
1750: 3E00    	        ld      A,$00           ; Zero A - Leave flags
1752: 32A480  	        ld      (NULFLG),A      ; Zero null flag
1755: C26017  	        jp      NZ,ECHDEL       ; Set - Echo it
1758: 05      	        dec     B               ; Decrement length
1759: CA7D17  	        jp      Z,GETLIN        ; Get line again if empty
175C: CD0A18  	        call    OUTC            ; Output null character
175F: 3E      	        defb    $3E             ; Skip "dec B"
1760: 05      	ECHDEL: dec     B               ; Count bytes in buffer
1761: 2B      	        dec     HL              ; Back space buffer
1762: CA7417  	        jp      Z,OTKLN         ; No buffer - Try again
1765: 7E      	        ld      A,(HL)          ; Get deleted byte
1766: CD0A18  	        call    OUTC            ; Echo it
1769: C38617  	        jp      MORINP          ; Get more input
              	
176C: 05      	DELCHR: dec     B               ; Count bytes in buffer
176D: 2B      	        dec     HL              ; Back space buffer
176E: CD0A18  	        call    OUTC            ; Output character in A
1771: C28617  	        jp      NZ,MORINP       ; Not end - Get more
1774: CD0A18  	OTKLN:  call    OUTC            ; Output character in A
1777: CDDB1C  	KILIN:  call    PRNTCRLF        ; Output CRLF
177A: C37D17  	        jp      TTYLIN          ; Get line again
              	
177D:         	GETLIN:
177D: 213681  	TTYLIN: ld      HL,BUFFER       ; Get a line by character
1780: 0601    	        ld      B,$01           ; Set buffer as empty
1782: AF      	        xor     A
1783: 32A480  	        ld      (NULFLG),A      ; Clear null flag
1786: CD4B18  	MORINP: call    CLOTST          ; Get character and test ^O
1789: 4F      	        ld      C,A             ; Save character in C
178A: FE7F    	        cp      DEL             ; Delete character?
178C: CA4C17  	        jp      Z,DODEL         ; Yes - Process it
178F: 3AA480  	        ld      A,(NULFLG)      ; Get null flag
1792: B7      	        or      A               ; Test null flag status
1793: CA9F17  	        jp      Z,PROCES        ; Reset - Process character
1796: 3E00    	        ld      A,$00           ; Set a null
1798: CD0A18  	        call    OUTC            ; Output null
179B: AF      	        xor     A               ; Clear A
179C: 32A480  	        ld      (NULFLG),A      ; Reset null flag
179F: 79      	PROCES: ld      A,C             ; Get character
17A0: FE07    	        cp      CTRLG           ; Bell?
17A2: CADF17  	        jp      Z,PUTCTL        ; Yes - Save it
17A5: FE03    	        cp      CTRLC           ; Is it control "C"?
17A7: CCD417  	        call    Z,GMNCR         ; Yes - exit from graphic mode & Output CRLF
17AA: 37      	        scf                     ; Flag break
17AB: C8      	        ret     Z               ; Return if control "C"
17AC: FE0D    	        cp      CR              ; Is it enter?
17AE: CAD11C  	        jp      Z,ENDINP        ; Yes - Terminate input
17B1: FE15    	        cp      CTRLU           ; Is it control "U"?
17B3: CA7717  	        jp      Z,KILIN         ; Yes - Get another line
17B6: FE08    	        cp      BKSP            ; Is it backspace?
17B8: CA6C17  	        jp      Z,DELCHR        ; Yes - Delete character
17BB: FE12    	        cp      CTRLR           ; Is it control "R"?
17BD: C2DA17  	        jp      NZ,PUTBUF       ; No - Put in buffer
17C0: C5      	        push    BC              ; Save buffer length
17C1: D5      	        push    DE              ; Save DE
17C2: E5      	        push    HL              ; Save buffer address
17C3: 3600    	        ld      (HL),$00        ; Mark end of buffer
17C5: CD273A  	        call    OUTNCR          ; Output and do CRLF
17C8: 213681  	        ld      HL,BUFFER       ; Point to buffer start
17CB: CD9B23  	        call    PRS             ; Output buffer
17CE: E1      	        pop     HL              ; Restore buffer address
17CF: D1      	        pop     DE              ; Restore DE
17D0: C1      	        pop     BC              ; Restore buffer length
17D1: C38617  	        jp      MORINP          ; Get another character
17D4: CDF514  	GMNCR:  call    EXITGM          ; exit from graphic mode
17D7: C3DB1C  	        jp      PRNTCRLF        ; output CRLF
              	
17DA: FE20    	PUTBUF: cp      SPC             ; Is it a control code?
17DC: DA8617  	        jp      C,MORINP        ; Yes - Ignore
17DF: 78      	PUTCTL: ld      A,B             ; Get number of bytes in buffer
17E0: FE59    	        cp      $58+$01         ; Test for line overflow
17E2: 3E07    	        ld      A,CTRLG         ; Set a bell
17E4: D2F117  	        jp      NC,OUTNBS       ; Ring bell if buffer full
17E7: 79      	        ld      A,C             ; Get character
17E8: 71      	        ld      (HL),C          ; Save in buffer
17E9: 32B181  	        ld      (LSTBIN),A      ; Save last input byte
17EC: 23      	        inc     HL              ; Move up buffer
17ED: 04      	        inc     B               ; Increment length
17EE: C38617  	OUTIT:  jp      MORINP          ; Get another character
              	
17F1: CD0A18  	OUTNBS: call    OUTC            ; Output bell and back over it
17F4: 3E08    	        ld      A,BKSP          ; Set back space
17F6: C3EE17  	        jp      OUTIT           ; Output it and get more
              	
17F9: 7C      	CPDEHL: ld      A,H             ; Get H
17FA: 92      	        sub     D               ; Compare with D
17FB: C0      	        ret     NZ              ; Different - Exit
17FC: 7D      	        ld      A,L             ; Get L
17FD: 93      	        sub     E               ; Compare with E
17FE: C9      	        ret                     ; Return status
              	
17FF: 7E      	CHKSYN: ld      A,(HL)          ; Check syntax of character
1800: E3      	        ex      (SP),HL         ; Address of test byte
1801: BE      	        cp      (HL)            ; Same as in code string?
1802: 23      	        inc     HL              ; Return address
1803: E3      	        ex      (SP),HL         ; Put it back
1804: CA221A  	        jp      Z,GETCHR        ; Yes - Get next character
1807: C31B15  	        jp      SNERR           ; Different - ?SN Error
              	
180A: F5      	OUTC:   push    AF              ; Save character
180B: 3AA580  	        ld      A,(CTLOFG)      ; Get control "O" flag
180E: B7      	        or      A               ; Is it set?
180F: C2D023  	        jp      NZ,POPAF        ; Yes - don't output
1812: F1      	        pop     AF              ; Restore character
1813: C5      	        push    BC              ; Save buffer length
1814: F5      	        push    AF              ; Save character
1815: FE20    	        cp      SPC             ; Is it a control code?
1817: DA2E18  	        jp      C,DINPOS        ; Yes - Don't inc POS(X)
181A: 3AA280  	        ld      A,(LWIDTH)      ; Get line width
181D: 47      	        ld      B,A             ; To B
181E: 3A9081  	        ld      A,(CURPOS)      ; Get cursor position
1821: 04      	        inc     B               ; Width 255?
1822: CA2A18  	        jp      Z,INCLEN        ; Yes - No width limit
1825: 05      	        dec     B               ; Restore width
1826: B8      	        cp      B               ; At end of line?
1827: CCDB1C  	        call    Z,PRNTCRLF      ; Yes - output CRLF
182A: 3C      	INCLEN: inc     A               ; Move on one character
182B: 329081  	        ld      (CURPOS),A      ; Save new position
182E: AF      	DINPOS: xor     A
182F: 322982  	        ld      (KBDNPT),A      ; set flag for no char from keyboard
1832: F1      	        pop     AF              ; Restore character
1833: C1      	        pop     BC              ; Restore buffer length
1834: F5      	        push    AF
1835: CD3D18  	        call    SND2VID         ; send char to video
1838: F1      	        pop     AF
1839: CD0A3A  	        call    MONOUT          ; send char to serial if enabled
183C: C9      	        ret
              	
              	; print char to video if cursor is on
183D: 32EC81  	SND2VID:ld      (CHR4VID),A     ; store A
1840: 3AEB81  	        ld      A,(PRNTVIDEO)   ; check print-on-video
1843: B7      	        or      A               ; is it off?
1844: C8      	        ret     Z               ; yes, so return
1845: F3      	        di                      ; disable INTs
1846: CDA206  	        call    CHAR2VID        ; cursor is on, so print char on screen
1849: FB      	        ei                      ; re-enable INTs
184A: C9      	        ret                     ; return to caller
              	
184B: CD3830  	CLOTST: call    GETINP          ; Get input character
184E: FE0F    	        cp      CTRLO           ; Is it control "O"?
1850: C0      	        ret     NZ              ; No don't flip flag
1851: 3AA580  	        ld      A,(CTLOFG)      ; Get flag
1854: 2F      	        cpl                     ; Flip it
1855: 32A580  	        ld      (CTLOFG),A      ; Put it back
1858: A7      	        and     A               ; is output enabled?
1859: CC2C08  	        call    Z,CURSOR_ON     ; yes, so cursor on
185C: AF      	        xor     A               ; Null character
185D: C9      	        ret
              	
              	; LIST: list the program stored into memory
185E: C1      	LIST:   pop     BC              ; rubbish - not needed (legacy from original call of LIST)
185F: 2B      	        dec     HL              ; dec 'cos GETCHR INCs
1860: CD221A  	        call    GETCHR          ; Get next character
1863: CAAF18  	        jp      Z,LSTALL        ; list all if nothing follows
1866: FEBA    	        cp      ZMINUS          ; is it '-'?
1868: 2020    	        jr      NZ,LST01        ; no, look for a line number
186A: 110000  	        ld      DE,$0000        ; yes, set search from 0
186D: CD4A19  	        call    SRCHLIN         ; find address of line number
1870: ED43EF81	        ld      (TMPBFR1),BC    ; store address of starting line
1874: CDFF17  	        call    CHKSYN          ; skip '-'
1877: BA      	        defb    ZMINUS
1878: CDF21A  	        call    ATOH            ; now, look for another number (ASCII number to DE)
187B: CD4A19  	        call    SRCHLIN         ; find address of line number
187E: ED43F181	        ld      (TMPBFR2),BC    ; store address of ending line
1882: ED4BEF81	        ld      BC,(TMPBFR1)    ; retrieve address of starting line
1886: C5      	        push    BC              ; store address of line for later use
1887: C3E118  	        jp      LISTLP          ; go listing
188A: CDF21A  	LST01:  call    ATOH            ; get a line number (ASCII number to DE)
188D: CD4A19  	LST01H: call    SRCHLIN         ; find address of line number
1890: ED43EF81	        ld      (TMPBFR1),BC    ; store address of starting line
1894: ED43F181	        ld      (TMPBFR2),BC    ; same address for ending line (we'll change later if needed)
1898: 2B      	        dec     HL              ; dec 'cos GETCHR INCs
1899: CD221A  	        call    GETCHR          ; Get next character
189C: CAAB18  	        jp      Z,LST06         ; nothing follows, so ending & starting lines are the same
189F: FEBA    	        cp      ZMINUS          ; is it '-'?
18A1: CAC718  	        jp      Z,LST03         ; yes, read ending line
18A4: CD4A19  	LST04:  call    SRCHLIN         ; find address of line number
18A7: ED43F181	        ld      (TMPBFR2),BC    ; set address of ending line
18AB: C5      	LST06:  push    BC              ; store address for later use
18AC: C3E118  	        jp      LISTLP          ; jump to list
18AF: 11F9FF  	LSTALL  ld      DE,65529        ; set ending line to max. allowed line number
18B2: CD4A19  	        call    SRCHLIN         ; get address of last line
18B5: ED43F181	        ld      (TMPBFR2),BC    ; store it
18B9: 110000  	        ld      DE,$0000        ; set start to first line in memory
18BC: CD4A19  	        call    SRCHLIN         ; get address of first line
18BF: ED43EF81	        ld      (TMPBFR1),BC    ; store it
18C3: C5      	        push    BC              ; store address of starting line for later use
18C4: C3E118  	        jp      LISTLP          ; start printing
18C7: CDFF17  	LST03:  call    CHKSYN          ; skip '-'
18CA: BA      	        defb    ZMINUS
18CB: CDF21A  	        call    ATOH            ; look for another number (return into DE)
18CE: 7A      	        ld      A,D
18CF: B3      	        or      E               ; is line=0?
18D0: 2003    	        jr      NZ,LST05        ; no, jump over
18D2: 11F9FF  	        ld      DE,65529        ; yes set last valid line number
18D5: CD4A19  	LST05:  call    SRCHLIN         ; find address of line number
18D8: ED43F181	        ld      (TMPBFR2),BC    ; store address of ending line
18DC: ED4BEF81	        ld      BC,(TMPBFR1)    ; retrieve address of starting line
18E0: C5      	        push    BC              ; store it for later use
18E1: E1      	LISTLP: pop     HL              ; Restore address of line
18E2: 4E      	        ld      C,(HL)          ; Get LSB of next line
18E3: 23      	        inc     HL
18E4: 46      	        ld      B,(HL)          ; Get MSB of next line
18E5: 23      	        inc     HL
18E6: 78      	        ld      A,B             ; BC = 0 (End of program)?
18E7: B1      	        or      C
18E8: CA7515  	        jp      Z,PRNTOK        ; Yes - Go to command mode
18EB: CD4D1A  	        call    TSTBRK          ; Test for break key
18EE: CD5019  	        call    TSTSPC          ; test for space
18F1: C5      	        push    BC              ; Save address of next line
18F2: 3AE481  	        ld      A,(SCR_CURS_X)  ; load current X pos of cursor
18F5: A7      	        and     A               ; is it at the beginning of a new line?
18F6: 200B    	        jr      NZ,LST08        ; No, jump over
18F8: 3E0D    	        ld      A,CR            ; yes, so just send a CR
18FA: CD0A3A  	        call    MONOUT          ; to serial if it's open
18FD: AF      	        xor     A               ; then, set cursor
18FE: 329081  	        ld      (CURPOS),A      ; to position 0
1901: 1803    	        jr      LST07           ; and continue
1903: CDDB1C  	LST08:  call    PRNTCRLF        ; output CRLF
1906: 5E      	LST07:  ld      E,(HL)          ; Get LSB of line number
1907: 23      	        inc     HL
1908: 56      	        ld      D,(HL)          ; Get MSB of line number
1909: 23      	        inc     HL
190A: E5      	        push    HL              ; Save address of line start
190B: EB      	        ex      DE,HL           ; Line number to HL
190C: CD1C2D  	        call    PRNTHL          ; Output line number in decimal
190F: 3E20    	        ld      A,SPC           ; Space after line number
1911: E1      	        pop     HL              ; Restore start of line address
1912: CD0A18  	LSTLP2: call    OUTC            ; Output character in A
1915: 7E      	LSTLP3: ld      A,(HL)          ; Get next byte in line
1916: B7      	        or      A               ; End of line?
1917: 23      	        inc     HL              ; To next byte in line
1918: CA3C19  	        jp      Z,NXTLN         ; Yes - check next line
191B: F21219  	        jp      P,LSTLP2        ; No token - output it
191E: D67F    	        sub     ZEND-1          ; Find and output word
1920: 4F      	        ld      C,A             ; Token offset+1 to C
1921: 11F30F  	        ld      DE,WORDS        ; Reserved word list
1924: 1A      	FNDTOK: ld      A,(DE)          ; Get character in list
1925: 13      	        inc     DE              ; Move on to next
1926: B7      	        or      A               ; Is it start of word?
1927: F22419  	        jp      P,FNDTOK        ; No - Keep looking for word
192A: 0D      	        dec     C               ; Count words
192B: C22419  	        jp      NZ,FNDTOK       ; Not there - keep looking
192E: E67F    	OUTWRD: and     %01111111       ; Strip bit 7
1930: CD0A18  	        call    OUTC            ; Output character
1933: 1A      	        ld      A,(DE)          ; Get next character
1934: 13      	        inc     DE              ; Move on to next
1935: B7      	        or      A               ; Is it end of word?
1936: F22E19  	        jp      P,OUTWRD        ; No - output the rest
1939: C31519  	        jp      LSTLP3          ; Next byte in line
193C: D1      	NXTLN:  pop     DE              ; recover address of current line
193D: 2AF181  	        ld      HL,(TMPBFR2)    ; address of last line to print
1940: CD2D3A  	        call    CMP16           ; check if current line is over last printable line
1943: DA7515  	        jp      C,PRNTOK        ; finish - leave & print OK
1946: D5      	        push    DE              ; store address of current line
1947: C3E118  	        jp      LISTLP          ; continue listing
194A: E5      	SRCHLIN:push    HL              ; store HL (this is needed because HL store the pointer to the input buffer)
194B: CD2116  	        call    SRCHLN          ; search for line number in DE
194E: E1      	        pop     HL              ; retrieve HL
194F: C9      	        ret                     ; return to caller
              	
              	; during LISTing, check if PAUSE is pressed, then pause listing and
              	; wait for another pressing of PAUSE to continue or CTRL-C/BREAK to exit
1950: 3A2B82  	TSTSPC: ld      A,(TMPKEYBFR)   ; Get input character
1953: FE20    	        cp      SPC             ; Is it SPACE?
1955: C0      	        ret     NZ              ; No, return
1956: CD3830  	WTSPC   call    GETINP          ; Yes, stop listing and wait for another space or BREAK
1959: FE20    	        cp      SPC             ; is it SPACE?
195B: 2005    	        jr      NZ,CNTWTSP      ; no, continue
195D: AF      	        xor     A
195E: 322B82  	        ld      (TMPKEYBFR),A   ; reset key
1961: C9      	        ret                     ; return to caller
1962: FE03    	CNTWTSP:cp      CTRLC           ; is it CTRL-C/BREAK?
1964: 20F0    	        jr      NZ,WTSPC        ; no, loop
1966: C35F0F  	        jp      BRKRET          ; exit and output "Ok"
              	
              	
1969: 3E64    	FOR:    ld      A,$64           ; Flag "FOR" assignment
196B: 32B081  	        ld      (FORFLG),A      ; Save "FOR" flag
196E: CDDC1B  	        call    LET             ; Set up initial index
1971: C1      	        pop     BC              ; Drop RETurn address
1972: E5      	        push    HL              ; Save code string address
1973: CDC51B  	        call    DATA            ; Get next statement address
1976: 22AC81  	        ld      (LOOPST),HL     ; Save it for start of loop
1979: 210200  	        ld      HL,$0002        ; Offset for "FOR" block
197C: 39      	        add     HL,SP           ; Point to it
197D: CDA814  	FORSLP: call    LOKFOR          ; Look for existing "FOR" block
1980: D1      	        pop     DE              ; Get code string address
1981: C29919  	        jp      NZ,FORFND       ; No nesting found
1984: 09      	        add     HL,BC           ; Move into "FOR" block
1985: D5      	        push    DE              ; Save code string address
1986: 2B      	        dec     HL
1987: 56      	        ld      D,(HL)          ; Get MSB of loop statement
1988: 2B      	        dec     HL
1989: 5E      	        ld      E,(HL)          ; Get LSB of loop statement
198A: 23      	        inc     HL
198B: 23      	        inc     HL
198C: E5      	        push    HL              ; Save block address
198D: 2AAC81  	        ld      HL,(LOOPST)     ; Get address of loop statement
1990: CDF917  	        call    CPDEHL          ; Compare the FOR loops
1993: E1      	        pop     HL              ; Restore block address
1994: C27D19  	        jp      NZ,FORSLP       ; Different FORs - Find another
1997: D1      	        pop     DE              ; Restore code string address
1998: F9      	        ld      SP,HL           ; Remove all nested loops
              	
1999: EB      	FORFND: ex      DE,HL           ; Code string address to HL
199A: 0E08    	        ld      C,$08
199C: CDD814  	        call    CHKSTK          ; Check for 8 levels of stack
199F: E5      	        push    HL              ; Save code string address
19A0: 2AAC81  	        ld      HL,(LOOPST)     ; Get first statement of loop
19A3: E3      	        ex      (SP),HL         ; Save and restore code string
19A4: E5      	        push    HL              ; Re-save code string address
19A5: 2AAF80  	        ld      HL,(LINEAT)     ; Get current line number
19A8: E3      	        ex      (SP),HL         ; Save and restore code string
19A9: CD9A1E  	        call    TSTNUM          ; Make sure it's a number
19AC: CDFF17  	        call    CHKSYN          ; Make sure "TO" is next
19AF: B3      	        defb    ZTO             ; "TO" token
19B0: CD971E  	        call    GETNUM          ; Get "TO" expression value
19B3: E5      	        push    HL              ; Save code string address
19B4: CDCE2B  	        call    BCDEFP          ; Move "TO" value to BCDE
19B7: E1      	        pop     HL              ; Restore code string address
19B8: C5      	        push    BC              ; Save "TO" value in block
19B9: D5      	        push    DE
19BA: 010081  	        ld      BC,$8100        ; BCDE - 1 (default STEP)
19BD: 51      	        ld      D,C             ; C=0
19BE: 5A      	        ld      E,D             ; D=0
19BF: 7E      	        ld      A,(HL)          ; Get next byte in code string
19C0: FEB8    	        cp      ZSTEP           ; See if "STEP" is stated
19C2: 3E01    	        ld      A,$01           ; Sign of step = 1
19C4: C2D519  	        jp      NZ,SAVSTP       ; No STEP given - Default to 1
19C7: CD221A  	        call    GETCHR          ; Jump over "STEP" token
19CA: CD971E  	        call    GETNUM          ; Get step value
19CD: E5      	        push    HL              ; Save code string address
19CE: CDCE2B  	        call    BCDEFP          ; Move STEP to BCDE
19D1: CD822B  	        call    TSTSGN          ; Test sign of FPREG
19D4: E1      	        pop     HL              ; Restore code string address
19D5: C5      	SAVSTP: push    BC              ; Save the STEP value in block
19D6: D5      	        push    DE
19D7: F5      	        push    AF              ; Save sign of STEP
19D8: 33      	        inc     SP              ; Don't save flags
19D9: E5      	        push    HL              ; Save code string address
19DA: 2AB381  	        ld      HL,(BRKLIN)     ; Get address of index variable
19DD: E3      	        ex      (SP),HL         ; Save and restore code string
19DE: 0681    	PUTFID: ld      B,ZFOR          ; "FOR" block marker
19E0: C5      	        push    BC              ; Save it
19E1: 33      	        inc     SP              ; Don't save C
              	
19E2: CD4D1A  	RUNCNT: call    TSTBRK          ; Execution driver - Test break
19E5: 22B381  	        ld      (BRKLIN),HL     ; Save code address for break
19E8: 7E      	        ld      A,(HL)          ; Get next byte in code string
19E9: FE3A    	        cp      ':'             ; Multi statement line?
19EB: CA021A  	        jp      Z,EXCUTE        ; Yes - Execute it
19EE: B7      	        or      A               ; End of line?
19EF: C21B15  	        jp      NZ,SNERR        ; No - Syntax error
19F2: 23      	        inc     HL              ; Point to address of next line
19F3: 7E      	        ld      A,(HL)          ; Get LSB of line pointer
19F4: 23      	        inc     HL
19F5: B6      	        or      (HL)            ; Is it zero (End of prog)?
19F6: CA741A  	        jp      Z,ENDPRG        ; Yes - Terminate execution
19F9: 23      	        inc     HL              ; Point to line number
19FA: 5E      	        ld      E,(HL)          ; Get LSB of line number
19FB: 23      	        inc     HL
19FC: 56      	        ld      D,(HL)          ; Get MSB of line number
19FD: EB      	        ex      DE,HL           ; Line number to HL
19FE: 22AF80  	        ld      (LINEAT),HL     ; Save as current line number
1A01: EB      	        ex      DE,HL           ; Line number back to DE
1A02: CD221A  	EXCUTE: call    GETCHR          ; Get key word
1A05: 11E219  	        ld      DE,RUNCNT       ; Where to RETurn to
1A08: D5      	        push    DE              ; Save for RETurn
1A09: C8      	IFJMP:  ret     Z               ; Go to RUNCNT if end of STMT
              	
1A0A: D680    	ONJMP:  sub     ZEND            ; Is it a token?
1A0C: DADC1B  	        jp      C,LET           ; No - try to assign it
1A0F: FE32    	        cp      ZNEW+1-ZEND     ; END to NEW ?
1A11: D21B15  	        jp      NC,SNERR        ; Not a key word - ?SN Error
1A14: 07      	        rlca                    ; Double it
1A15: 4F      	        ld      C,A             ; BC = Offset into table
1A16: 0600    	        ld      B,0
1A18: EB      	        ex      DE,HL           ; Save code string address
1A19: 216811  	        ld      HL,WORDTB       ; Keyword address table
1A1C: 09      	        add     HL,BC           ; Point to routine address
1A1D: 4E      	        ld      C,(HL)          ; Get LSB of routine address
1A1E: 23      	        inc     HL
1A1F: 46      	        ld      B,(HL)          ; Get MSB of routine address
1A20: C5      	        push    BC              ; Save routine address
1A21: EB      	        ex      DE,HL           ; Restore code string address
              	
              	; get a char from input buffer: exit with NC if character found is
              	; not a number; exit with Z if nothing found; char is into A
1A22: 23      	GETCHR: inc     HL              ; Point to next character
1A23: 7E      	        ld      A,(HL)          ; Get next code string byte
1A24: FE3A    	        cp      ':'             ; Z if ':'
1A26: D0      	        ret     NC              ; NC if > "9"
1A27: FE20    	        cp      SPC
1A29: CA221A  	        jp      Z,GETCHR        ; Skip over spaces
1A2C: FE30    	        cp      '0'
1A2E: 3F      	        ccf                     ; NC if < '0'
1A2F: 3C      	        inc     A               ; Test for zero - Leave carry
1A30: 3D      	        dec     A               ; Z if Null
1A31: C9      	        ret
              	
1A32: EB      	RESTOR: ex      DE,HL           ; Save code string address
1A33: 2A3381  	        ld      HL,(BASTXT)     ; Point to start of program
1A36: CA471A  	        jp      Z,RESTNL        ; Just RESTORE - reset pointer
1A39: EB      	        ex      DE,HL           ; Restore code string address
1A3A: CDF21A  	        call    ATOH            ; Get line number to DE
1A3D: E5      	        push    HL              ; Save code string address
1A3E: CD2116  	        call    SRCHLN          ; Search for line number in DE
1A41: 60      	        ld      H,B             ; HL = Address of line
1A42: 69      	        ld      L,C
1A43: D1      	        pop     DE              ; Restore code string address
1A44: D29B1B  	        jp      NC,ULERR        ; ?UL Error if not found
1A47: 2B      	RESTNL: dec     HL              ; Byte before DATA statement
1A48: 22C181  	UPDATA: ld      (NXTDAT),HL     ; Update DATA pointer
1A4B: EB      	        ex      DE,HL           ; Restore code string address
1A4C: C9      	        ret
              	
              	
1A4D: DF      	TSTBRK: rst     $18             ; Check input status
1A4E: C8      	        ret     Z               ; No key, go back
1A4F: D7      	        rst     $10             ; Get the key into A
1A50: FE1B    	        cp      ESC             ; Escape key?
1A52: 2811    	        jr      Z,BRK           ; Yes, break
1A54: FE03    	        cp      CTRLC           ; <Ctrl-C>
1A56: 280D    	        jr      Z,BRK           ; Yes, break
1A58: FE13    	        cp      CTRLS           ; Stop scrolling?
1A5A: C0      	        ret     NZ              ; Other key, ignore
              	
              	
1A5B: D7      	STALL:  rst     $10             ; Wait for key
1A5C: FE11    	        cp      CTRLQ           ; Resume scrolling?
1A5E: C8      	        ret     Z               ; Release the chokehold
1A5F: FE03    	        cp      CTRLC           ; Second break?
1A61: 2807    	        jr      Z,STOP          ; Break during hold exits prog
1A63: 18F6    	        jr      STALL           ; Loop until <Ctrl-Q> or <brk>
              	
1A65: 3EFF    	BRK:    ld      A,$FF           ; Set BRKFLG
1A67: 32A980  	        ld      (BRKFLG),A      ; Store it
              	
1A6A: C0      	STOP:   ret     NZ              ; Exit if anything else
1A6B: F6      	        defb    $F6             ; Flag "STOP"
1A6C: C0      	PEND:   ret     NZ              ; Exit if anything else
1A6D: 22B381  	        ld      (BRKLIN),HL     ; Save point of break
1A70: 21      	        defb    $21             ; Skip "OR 11111111B"
1A71: F6FF    	INPBRK: or      %11111111       ; Flag "Break" wanted
1A73: C1      	        pop     BC              ; Return not needed and more
1A74: 2AAF80  	ENDPRG: ld      HL,(LINEAT)     ; Get current line number
1A77: F5      	        push    AF              ; Save STOP / END status
1A78: 7D      	        ld      A,L             ; Is it direct break?
1A79: A4      	        and     H
1A7A: 3C      	        inc     A               ; Line is -1 if direct break
1A7B: CA871A  	        jp      Z,NOLIN         ; Yes - No line number
1A7E: 22B781  	        ld      (ERRLIN),HL     ; Save line of break
1A81: 2AB381  	        ld      HL,(BRKLIN)     ; Get point of break
1A84: 22B981  	        ld      (CONTAD),HL     ; Save point to CONTinue
1A87: AF      	NOLIN:  xor     A
1A88: 32A580  	        ld      (CTLOFG),A      ; Enable output
1A8B: CDC91C  	        call    STTLIN          ; Start a new line
1A8E: F1      	        pop     AF              ; Restore STOP / END status
1A8F: 219E14  	        ld      HL,BRKMSG       ; "Break" message
1A92: C2981A  	        jp      NZ,ERRINT       ; "in line" wanted?
1A95: C37515  	        jp      PRNTOK          ; Go to command mode
1A98: CDF514  	ERRINT: call    EXITGM          ; exit from graphics mode
1A9B: C35315  	        jp      ERRIN           ; print message
              	
              	
1A9E: 21FFFF  	CONT:   ld      HL,-1           ; reset...
1AA1: 22B180  	        ld      (HLPLN),HL      ; ...HELP line register
1AA4: 2AB981  	        ld      HL,(CONTAD)     ; Get CONTinue address
1AA7: 7C      	        ld      A,H             ; Is it zero?
1AA8: B5      	        or      L
1AA9: 1E20    	        ld      E,CN            ; ?CN Error
1AAB: CA2F15  	        jp      Z,ERROR         ; Yes - output "?CN Error"
1AAE: EB      	        ex      DE,HL           ; Save code string address
1AAF: 2AB781  	        ld      HL,(ERRLIN)     ; Get line of last break
1AB2: 22AF80  	        ld      (LINEAT),HL     ; Set up current line number
1AB5: EB      	        ex      DE,HL           ; Restore code string address
1AB6: C9      	        ret                     ; CONTinue where left off
              	
1AB7: E5      	ACCSUM: push    HL              ; Save address in array
1AB8: 2AA680  	        ld      HL,(CHKSUM)     ; Get check sum
1ABB: 0600    	        ld      B,$00           ; BC - Value of byte
1ABD: 4F      	        ld      C,A
1ABE: 09      	        add     HL,BC           ; Add byte to check sum
1ABF: 22A680  	        ld      (CHKSUM),HL     ; Re-save check sum
1AC2: E1      	        pop     HL              ; Restore address in array
1AC3: C9      	        ret
              	
1AC4: 7E      	CHKLTR: ld      A,(HL)          ; Get byte
1AC5: FE41    	        cp      'A'             ; < 'a' ?
1AC7: D8      	        ret     C               ; Carry set if not letter
1AC8: FE5B    	        cp      'Z'+1           ; > 'z' ?
1ACA: 3F      	        ccf
1ACB: C9      	        ret                     ; Carry set if not letter
              	
1ACC: CD221A  	FPSINT: call    GETCHR          ; Get next character
1ACF: CD971E  	POSINT: call    GETNUM          ; Get integer 0 to 32767
1AD2: CD822B  	DEPINT: call    TSTSGN          ; Test sign of FPREG
1AD5: FAED1A  	        jp      M,FCERR         ; Negative - ?FC Error
1AD8: 3ACC81  	DEINT:  ld      A,(FPEXP)       ; Get integer value to DE
1ADB: FE90    	        cp      $80+$10         ; Exponent in range (16 bits)?
1ADD: DA2A2C  	        jp      C,FPINT         ; Yes - convert it
1AE0: 018090  	        ld      BC,$9080        ; BCDE = -32768
1AE3: 110000  	        ld      DE,$0000
1AE6: E5      	        push    HL              ; Save code string address
1AE7: CDFD2B  	        call    CMPNUM          ; Compare FPREG with BCDE
1AEA: E1      	        pop     HL              ; Restore code string address
1AEB: 51      	        ld      D,C             ; MSB to D
1AEC: C8      	        ret     Z               ; Return if in range
1AED: 1E08    	FCERR:  ld      E,FC            ; ?FC Error
1AEF: C32F15  	        jp      ERROR           ; Output error-
              	
1AF2: 2B      	ATOH:   dec     HL              ; ASCII number to DE binary
1AF3: 110000  	GETLN:  ld      DE,$0000        ; Get number to DE
1AF6: CD221A  	GTLNLP: call    GETCHR          ; Get next character
1AF9: D0      	        ret     NC              ; Exit if not a digit
1AFA: E5      	        push    HL              ; Save code string address
1AFB: F5      	        push    AF              ; Save digit
1AFC: 219819  	        ld      HL,65529/10     ; Largest number 65529
1AFF: CDF917  	        call    CPDEHL          ; Number in range?
1B02: DA1B15  	        jp      C,SNERR         ; No - ?SN Error
1B05: 62      	        ld      H,D             ; HL = Number
1B06: 6B      	        ld      L,E
1B07: 19      	        add     HL,DE           ; Times 2
1B08: 29      	        add     HL,HL           ; Times 4
1B09: 19      	        add     HL,DE           ; Times 5
1B0A: 29      	        add     HL,HL           ; Times 10
1B0B: F1      	        pop     AF              ; Restore digit
1B0C: D630    	        sub     '0'             ; Make it 0 to 9
1B0E: 5F      	        ld      E,A             ; DE = Value of digit
1B0F: 1600    	        ld      D,0
1B11: 19      	        add     HL,DE           ; Add to number
1B12: EB      	        ex      DE,HL           ; Number to DE
1B13: E1      	        pop     HL              ; Restore code string address
1B14: C3F61A  	        jp      GTLNLP          ; Go to next character
              	
1B17: CA5116  	CLEAR:  jp      Z,INTVAR        ; Just "CLEAR" Keep parameters
1B1A: CDCF1A  	        call    POSINT          ; Get integer 0 to 32767 to DE
1B1D: 2B      	        dec     HL              ; Cancel increment
1B1E: CD221A  	        call    GETCHR          ; Get next character
1B21: E5      	        push    HL              ; Save code string address
1B22: 2A9481  	        ld      HL,(LSTRAM)     ; Get end of RAM
1B25: CA3A1B  	        jp      Z,STORED        ; No value given - Use stored
1B28: E1      	        pop     HL              ; Restore code string address
1B29: CDFF17  	        call    CHKSYN          ; Check for comma
1B2C: 2C      	        defb    ','
1B2D: D5      	        push    DE              ; Save number
1B2E: CDCF1A  	        call    POSINT          ; Get integer 0 to 32767
1B31: 2B      	        dec     HL              ; Cancel increment
1B32: CD221A  	        call    GETCHR          ; Get next character
1B35: C21B15  	        jp      NZ,SNERR        ; ?SN Error if more on line
1B38: E3      	        ex      (SP),HL         ; Save code string address
1B39: EB      	        ex      DE,HL           ; Number to DE
1B3A: 7D      	STORED: ld      A,L             ; Get LSB of new RAM top
1B3B: 93      	        sub     E               ; Subtract LSB of string space
1B3C: 5F      	        ld      E,A             ; Save LSB
1B3D: 7C      	        ld      A,H             ; Get MSB of new RAM top
1B3E: 9A      	        sbc     A,D             ; Subtract MSB of string space
1B3F: 57      	        ld      D,A             ; Save MSB
1B40: DAF014  	        jp      C,OMERR         ; ?OM Error if not enough mem
1B43: E5      	        push    HL              ; Save RAM top
1B44: 2ABB81  	        ld      HL,(PROGND)     ; Get program end
1B47: 012800  	        ld      BC,$28          ; 40 Bytes minimum working RAM
1B4A: 09      	        add     HL,BC           ; Get lowest address
1B4B: CDF917  	        call    CPDEHL          ; Enough memory?
1B4E: D2F014  	        jp      NC,OMERR        ; No - ?OM Error
1B51: EB      	        ex      DE,HL           ; RAM top to HL
1B52: 22AD80  	        ld      (STRSPC),HL     ; Set new string space
1B55: E1      	        pop     HL              ; End of memory to use
1B56: 229481  	        ld      (LSTRAM),HL     ; Set new top of RAM
1B59: E1      	        pop     HL              ; Restore code string address
1B5A: C35116  	        jp      INTVAR          ; Initialise variables
              	
1B5D: E5      	RUN:    push    HL              ; store HL
1B5E: 21FFFF  	        ld      HL,-1           ; reset...
1B61: 22B180  	        ld      (HLPLN),HL      ; ...HELP line register
1B64: E1      	        pop     HL              ; retrieve HL
1B65: CA4D16  	        jp      Z,RUNFST        ; RUN from start if just RUN
1B68: CD5116  	        call    INTVAR          ; Initialise variables
1B6B: 01E219  	        ld      BC,RUNCNT       ; Execution driver loop
1B6E: C3811B  	        jp      RUNLIN          ; RUN from line number
              	
1B71: 0E03    	GOSUB:  ld      C,$03           ; 3 Levels of stack needed
1B73: CDD814  	        call    CHKSTK          ; Check for 3 levels of stack
1B76: C1      	        pop     BC              ; Get return address
1B77: E5      	        push    HL              ; Save code string for RETURN
1B78: E5      	        push    HL              ; And for GOSUB routine
1B79: 2AAF80  	        ld      HL,(LINEAT)     ; Get current line
1B7C: E3      	        ex      (SP),HL         ; Into stack - Code string out
1B7D: 3E8C    	        ld      A,ZGOSUB        ; "GOSUB" token
1B7F: F5      	        push    AF              ; Save token
1B80: 33      	        inc     SP              ; Don't save flags
              	
1B81: C5      	RUNLIN: push    BC              ; Save return address
1B82: CDF21A  	GOTO:   call    ATOH            ; ASCII number to DE binary
1B85: CDC71B  	        call    REM             ; Get end of line
1B88: E5      	        push    HL              ; Save end of line
1B89: 2AAF80  	        ld      HL,(LINEAT)     ; Get current line
1B8C: CDF917  	        call    CPDEHL          ; Line after current?
1B8F: E1      	        pop     HL              ; Restore end of line
1B90: 23      	        inc     HL              ; Start of next line
1B91: DC2416  	        call    C,SRCHLP        ; Line is after current line
1B94: D42116  	        call    NC,SRCHLN       ; Line is before current line
1B97: 60      	        ld      H,B             ; Set up code string address
1B98: 69      	        ld      L,C
1B99: 2B      	        dec     HL              ; Incremented after
1B9A: D8      	        ret     C               ; Line found
1B9B: 1E0E    	ULERR:  ld      E,UL            ; ?UL Error
1B9D: C32F15  	        jp      ERROR           ; Output error message
              	
1BA0: C0      	RETURN: ret     NZ              ; Return if not just RETURN
1BA1: 16FF    	        ld      D,-1            ; Flag "GOSUB" search
1BA3: CDA414  	        call    BAKSTK          ; Look "GOSUB" block
1BA6: F9      	        ld      SP,HL           ; Kill all FORs in subroutine
1BA7: FE8C    	        cp      ZGOSUB          ; Test for "GOSUB" token
1BA9: 1E04    	        ld      E,RG            ; ?RG Error
1BAB: C22F15  	        jp      NZ,ERROR        ; Error if no "GOSUB" found
1BAE: E1      	        pop     HL              ; Get RETURN line number
1BAF: 22AF80  	        ld      (LINEAT),HL     ; Save as current
1BB2: 23      	        inc     HL              ; Was it from direct statement?
1BB3: 7C      	        ld      A,H
1BB4: B5      	        or      L               ; Return to line
1BB5: C2BF1B  	        jp      NZ,RETLIN       ; No - Return to line
1BB8: 3AB181  	        ld      A,(LSTBIN)      ; Any INPUT in subroutine?
1BBB: B7      	        or      A               ; If so buffer is corrupted
1BBC: C27415  	        jp      NZ,POPNOK       ; Yes - Go to command mode
1BBF: 21E219  	RETLIN: ld      HL,RUNCNT       ; Execution driver loop
1BC2: E3      	        ex      (SP),HL         ; Into stack - Code string out
1BC3: 3E      	        defb    $3E             ; Skip "pop HL"
1BC4: E1      	NXTDTA: pop     HL              ; Restore code string address
              	
1BC5: 013A    	DATA:   defb    $01,$3A         ; ':' End of statement
1BC7: 0E00    	REM:    ld      C,$00           ; 00  End of statement
1BC9: 0600    	        ld      B,$00
1BCB: 79      	NXTSTL: ld      A,C             ; Statement and byte
1BCC: 48      	        ld      C,B
1BCD: 47      	        ld      B,A             ; Statement end byte
1BCE: 7E      	NXTSTT: ld      A,(HL)          ; Get byte
1BCF: B7      	        or      A               ; End of line?
1BD0: C8      	        ret     Z               ; Yes - Exit
1BD1: B8      	        cp      B               ; End of statement?
1BD2: C8      	        ret     Z               ; Yes - Exit
1BD3: 23      	        inc     HL              ; Next byte
1BD4: FE22    	        cp      $22             ; '"'             ; Literal string?
1BD6: CACB1B  	        jp      Z,NXTSTL        ; Yes - Look for another '"'
1BD9: C3CE1B  	        jp      NXTSTT          ; Keep looking
              	
1BDC: CDA120  	LET:    call    GETVAR          ; Get variable name
1BDF: CDFF17  	        call    CHKSYN          ; Make sure "=" follows
1BE2: C4      	        defb    ZEQUAL          ; "=" token
1BE3: D5      	        push    DE              ; Save address of variable
1BE4: 3A9281  	        ld      A,(TYPE)        ; Get data type
1BE7: F5      	        push    AF              ; Save type
1BE8: CDA91E  	        call    EVAL            ; Evaluate expression
1BEB: F1      	        pop     AF              ; Restore type
1BEC: E3      	        ex      (SP),HL         ; Save code - Get var addr
1BED: 22B381  	        ld      (BRKLIN),HL     ; Save address of variable
1BF0: 1F      	        rra                     ; Adjust type
1BF1: CD9C1E  	        call    CHKTYP          ; Check types are the same
1BF4: CA2F1C  	        jp      Z,LETNUM        ; Numeric - Move value
1BF7: E5      	LETSTR: push    HL              ; Save address of string var
1BF8: 2AC981  	        ld      HL,(FPREG)      ; Pointer to string entry
1BFB: E5      	        push    HL              ; Save it on stack
1BFC: 23      	        inc     HL              ; Skip over length
1BFD: 23      	        inc     HL
1BFE: 5E      	        ld      E,(HL)          ; LSB of string address
1BFF: 23      	        inc     HL
1C00: 56      	        ld      D,(HL)          ; MSB of string address
1C01: 2A3381  	        ld      HL,(BASTXT)     ; Point to start of program
1C04: CDF917  	        call    CPDEHL          ; Is string before program?
1C07: D21E1C  	        jp      NC,CRESTR       ; Yes - Create string entry
1C0A: 2AAD80  	        ld      HL,(STRSPC)     ; Point to string space
1C0D: CDF917  	        call    CPDEHL          ; Is string literal in program?
1C10: D1      	        pop     DE              ; Restore address of string
1C11: D2261C  	        jp      NC,MVSTPT       ; Yes - Set up pointer
1C14: 21A481  	        ld      HL,TMPSTR       ; Temporary string pool
1C17: CDF917  	        call    CPDEHL          ; Is string in temporary pool?
1C1A: D2261C  	        jp      NC,MVSTPT       ; No - Set up pointer
1C1D: 3E      	        defb    $3E             ; Skip "pop DE"
1C1E: D1      	CRESTR: pop     DE              ; Restore address of string
1C1F: CDFC24  	        call    BAKTMP          ; Back to last tmp-str entry
1C22: EB      	        ex      DE,HL           ; Address of string entry
1C23: CD3523  	        call    SAVSTR          ; Save string in string area
1C26: CDFC24  	MVSTPT: call    BAKTMP          ; Back to last tmp-str entry
1C29: E1      	        pop     HL              ; Get string pointer
1C2A: CDDD2B  	        call    DETHL4          ; Move string pointer to var
1C2D: E1      	        pop     HL              ; Restore code string address
1C2E: C9      	        ret
              	
1C2F: E5      	LETNUM: push    HL              ; Save address of variable
1C30: CDDA2B  	        call    FPTHL           ; Move value to variable
1C33: D1      	        pop     DE              ; Restore address of variable
1C34: E1      	        pop     HL              ; Restore code string address
1C35: C9      	        ret
              	
1C36: CD2326  	ON:     call    GETINT          ; Get integer 0-255
1C39: 7E      	        ld      A,(HL)          ; Get "GOTO" or "GOSUB" token
1C3A: 47      	        ld      B,A             ; Save in B
1C3B: FE8C    	        cp      ZGOSUB          ; "GOSUB" token?
1C3D: CA451C  	        jp      Z,ONGO          ; Yes - Find line number
1C40: CDFF17  	        call    CHKSYN          ; Make sure it's "GOTO"
1C43: 88      	        defb    ZGOTO           ; "GOTO" token
1C44: 2B      	        dec     HL              ; Cancel increment
1C45: 4B      	ONGO:   ld      C,E             ; Integer of branch value
1C46: 0D      	ONGOLP: dec     C               ; Count branches
1C47: 78      	        ld      A,B             ; Get "GOTO" or "GOSUB" token
1C48: CA0A1A  	        jp      Z,ONJMP         ; Go to that line if right one
1C4B: CDF31A  	        call    GETLN           ; Get line number to DE
1C4E: FE2C    	        cp      ','             ; Another line number?
1C50: C0      	        ret     NZ              ; No - Drop through
1C51: C3461C  	        jp      ONGOLP          ; Yes - loop
              	
1C54: CDA91E  	IF:     call    EVAL            ; Evaluate expression
1C57: 7E      	        ld      A,(HL)          ; Get token
1C58: FE88    	        cp      ZGOTO           ; "GOTO" token?
1C5A: CA621C  	        jp      Z,IFGO          ; Yes - Get line
1C5D: CDFF17  	        call    CHKSYN          ; Make sure it's "THEN"
1C60: B6      	        defb    ZTHEN           ; "THEN" token
1C61: 2B      	        dec     HL              ; Cancel increment
1C62: CD9A1E  	IFGO:   call    TSTNUM          ; Make sure it's numeric
1C65: CD822B  	        call    TSTSGN          ; Test state of expression
1C68: CAC71B  	        jp      Z,REM           ; False - Drop through
1C6B: CD221A  	        call    GETCHR          ; Get next character
1C6E: DA821B  	        jp      C,GOTO          ; Number - GOTO that line
1C71: C3091A  	        jp      IFJMP           ; Otherwise do statement
              	
1C74: 2B      	MRPRNT: dec     HL              ; dec 'cos GETCHR INCs
1C75: CD221A  	        call    GETCHR          ; Get next character
1C78: CADB1C  	PRINT:  jp      Z,PRNTCRLF      ; CRLF if just PRINT
1C7B: C8      	PRNTLP: ret     Z               ; End of list - Exit
1C7C: FEB2    	        cp      ZTAB            ; "TAB(" token?
1C7E: CA031D  	        jp      Z,DOTAB         ; Yes - Do TAB routine
1C81: FEB5    	        cp      ZSPC            ; "SPC(" token?
1C83: CA031D  	        jp      Z,DOTAB         ; Yes - Do SPC routine
1C86: E5      	        push    HL              ; Save code string address
1C87: FE2C    	        cp      ','             ; Comma?
1C89: CAEA1C  	        jp      Z,DOCOM         ; Yes - Move to next zone
1C8C: FE3B    	        cp      ';'             ; Semi-colon?
1C8E: CA271D  	        jp      Z,NEXITM        ; Do semi-colon routine
1C91: C1      	        pop     BC              ; Code string address to BC
1C92: CDA91E  	        call    EVAL            ; Evaluate expression
1C95: E5      	        push    HL              ; Save code string address
1C96: 3A9281  	        ld      A,(TYPE)        ; Get variable type
1C99: B7      	        or      A               ; Is it a string variable?
1C9A: C2C21C  	        jp      NZ,PRNTST       ; Yes - Output string contents
1C9D: CD272D  	        call    NUMASC          ; Convert number to text
1CA0: CD5923  	        call    CRTST           ; Create temporary string
1CA3: 3600    	        ld      (HL),NLLCR      ; Followed by a NULL char (was SPC, space)
1CA5: 2AC981  	        ld      HL,(FPREG)      ; Get length of output
1CA8: 34      	        inc     (HL)            ; Plus 1 for the space
1CA9: 2AC981  	        ld      HL,(FPREG)      ; < Not needed >
1CAC: 3AA280  	        ld      A,(LWIDTH)      ; Get width of line
1CAF: 47      	        ld      B,A             ; To B
1CB0: 04      	        inc     B               ; Width 255 (No limit)?
1CB1: CABE1C  	        jp      Z,PRNTNB        ; Yes - Output number string
1CB4: 04      	        inc     B               ; Adjust it
1CB5: 3A9081  	        ld      A,(CURPOS)      ; Get cursor position
1CB8: 86      	        add     A,(HL)          ; Add length of string
1CB9: 3D      	        dec     A               ; Adjust it
1CBA: B8      	        cp      B               ; Will output fit on this line?
1CBB: D4DB1C  	        call    NC,PRNTCRLF     ; No - CRLF first
1CBE: CD9E23  	PRNTNB: call    PRS1            ; Output string at (HL)
1CC1: AF      	        xor     A               ; Skip call by setting 'z' flag
1CC2: C49E23  	PRNTST: call    NZ,PRS1         ; Output string at (HL)
1CC5: E1      	        pop     HL              ; Restore code string address
1CC6: C3741C  	        jp      MRPRNT          ; See if more to PRINT
              	
1CC9: 3A9081  	STTLIN: ld      A,(CURPOS)      ; Make sure on new line
1CCC: B7      	        or      A               ; Already at start?
1CCD: C8      	        ret     Z               ; Yes - Do nothing
1CCE: C3DB1C  	        jp      PRNTCRLF        ; Start a new line
              	
1CD1: AF      	ENDINP: xor     A
1CD2: 322982  	        ld      (KBDNPT),A      ; char is not from keyboard
1CD5: 77      	        ld      (HL),A          ; Mark end of buffer
1CD6: 213581  	        ld      HL,BUFFER-1     ; Point to buffer
1CD9: 180A    	        jr      CNTEND
1CDB: 3E0D    	PRNTCRLF:ld     A,CR            ; Load a CR
1CDD: CD0A18  	        call    OUTC            ; Output character
1CE0: 3E0A    	        ld      A,LF            ; Load a LF
1CE2: CD0A18  	        call    OUTC            ; Output character
1CE5: AF      	CNTEND: xor     A               ; Set to position 0
1CE6: 329081  	        ld      (CURPOS),A      ; Store it
1CE9: C9      	        ret                     ; return to caller
              	
1CEA: 3AA380  	DOCOM:  ld      A,(COMMAN)      ; Get comma width
1CED: 47      	        ld      B,A             ; Save in B
1CEE: 3A9081  	        ld      A,(CURPOS)      ; Get current position
1CF1: B8      	        cp      B               ; Within the limit?
1CF2: D4DB1C  	        call    NC,PRNTCRLF     ; No - output CRLF
1CF5: D2271D  	        jp      NC,NEXITM       ; Get next item
1CF8: D60E    	ZONELP: sub     $0E             ; Next zone of 14 characters
1CFA: D2F81C  	        jp      NC,ZONELP       ; Repeat if more zones
1CFD: 2F      	        cpl                     ; Number of null chars to output
1CFE: 0E00    	        ld      C,NLLCR         ; null char
1D00: C31D1D  	        jp      ASPCS           ; Output them
              	
1D03: F5      	DOTAB:  push    AF              ; Save token
1D04: CD2026  	        call    FNDNUM          ; Evaluate expression
1D07: CDFF17  	        call    CHKSYN          ; Make sure ")" follows
1D0A: 29      	        defb    ')'
1D0B: 2B      	        dec     HL              ; Back space on to ")"
1D0C: F1      	        pop     AF              ; Restore token
1D0D: 0E00    	        ld      C,NLLCR         ; for SPC we use NULL char (was SPACE)
1D0F: D6B5    	        sub     ZSPC            ; Was it "SPC(" ?
1D11: E5      	        push    HL              ; Save code string address
1D12: CA181D  	        jp      Z,DOSPC         ; Yes - Do 'E' spaces
1D15: 3AE481  	        ld      A,(SCR_CURS_X)  ; Get current X position
1D18: 2F      	DOSPC:  cpl                     ; Number of spaces to print to
1D19: 83      	        add     A,E             ; Total number to print
1D1A: D2271D  	        jp      NC,NEXITM       ; TAB < Current POS(X)
1D1D: 3C      	ASPCS:  inc     A               ; Output A spaces
1D1E: 47      	        ld      B,A             ; Save number to print
1D1F: 79      	SPCLP:  ld      A,C             ; char to print
1D20: CD0A18  	        call    OUTC            ; Output character in A
1D23: 05      	        dec     B               ; Count them
1D24: C21F1D  	        jp      NZ,SPCLP        ; Repeat if more
1D27: E1      	NEXITM: pop     HL              ; Restore code string address
1D28: CD221A  	        call    GETCHR          ; Get next character
1D2B: C37B1C  	        jp      PRNTLP          ; More to print
              	
1D2E: 3F526564	REDO:   defb    "?Redo from start",CR,0
1D32: 6F206672	
1D36: 6F6D2073	
1D3A: 74617274	
1D3E: 0D00    	
              	
1D40: 3AB281  	BADINP: ld      A,(READFG)      ; READ or INPUT?
1D43: B7      	        or      A
1D44: C21515  	        jp      NZ,DATSNR       ; READ - ?SN Error
1D47: C1      	        pop     BC              ; Throw away code string addr
1D48: 212E1D  	        ld      HL,REDO         ; "Redo from start" message
1D4B: CD9B23  	        call    PRS             ; Output string
1D4E: C38016  	        jp      DOAGN           ; Do last INPUT again
              	
1D51: CD0623  	INPUT:  call    IDTEST          ; Test for illegal direct
1D54: 7E      	        ld      A,(HL)          ; Get character after "INPUT"
1D55: FE22    	        cp      $22             ; '"' ; Is there a prompt string?
1D57: 3E00    	        ld      A,$00           ; Clear A and leave flags
1D59: 32A580  	        ld      (CTLOFG),A      ; Enable output
1D5C: C26B1D  	        jp      NZ,NOPMPT       ; No prompt - get input
1D5F: CD5A23  	        call    QTSTR           ; Get string terminated by '"'
1D62: CDFF17  	        call    CHKSYN          ; Check for ';' after prompt
1D65: 3B      	        defb    ";"
1D66: E5      	        push    HL              ; Save code string address
1D67: CD9E23  	        call    PRS1            ; Output prompt string
1D6A: 3E      	        defb    $3E             ; Skip "push HL"
1D6B: E5      	NOPMPT: push    HL              ; Save code string address
1D6C: CD8416  	        call    PROMPT          ; Get input with "? " prompt
1D6F: C1      	        pop     BC              ; Restore code string address
1D70: DA711A  	        jp      C,INPBRK        ; Break pressed - Exit
1D73: 23      	        inc     HL              ; Next byte
1D74: 7E      	        ld      A,(HL)          ; Get it
1D75: B7      	        or      A               ; End of line?
1D76: 2B      	        dec     HL              ; Back again
1D77: C5      	        push    BC              ; Re-save code string address
1D78: CD4208  	        call    CURSOR_OFF      ; disable cursor
1D7B: CAC41B  	        jp      Z,NXTDTA        ; Yes - Find next DATA stmt
1D7E: 362C    	        ld      (HL),','        ; Store comma as separator
1D80: C3881D  	        jp      NXTITM          ; Get next item
              	
1D83: E5      	READ:   push    HL              ; Save code string address
1D84: 2AC181  	        ld      HL,(NXTDAT)     ; Next DATA statement
1D87: F6      	        defb    $F6             ; Flag "READ"
1D88: AF      	NXTITM: xor     A               ; Flag "INPUT"
1D89: 32B281  	        ld      (READFG),A      ; Save "READ"/"INPUT" flag
1D8C: E3      	        ex      (SP),HL         ; Get code str' , Save pointer
1D8D: C3941D  	        jp      GTVLUS          ; Get values
              	
1D90: CDFF17  	NEDMOR: call    CHKSYN          ; Check for comma between items
1D93: 2C      	        defb    ','
1D94: CDA120  	GTVLUS: call    GETVAR          ; Get variable name
1D97: E3      	        ex      (SP),HL         ; Save code str" , Get pointer
1D98: D5      	        push    DE              ; Save variable address
1D99: 7E      	        ld      A,(HL)          ; Get next "INPUT"/"DATA" byte
1D9A: FE2C    	        cp      ','             ; Comma?
1D9C: CABC1D  	        jp      Z,ANTVLU        ; Yes - Get another value
1D9F: 3AB281  	        ld      A,(READFG)      ; Is it READ?
1DA2: B7      	        or      A
1DA3: C2281E  	        jp      NZ,FDTLP        ; Yes - Find next DATA stmt
1DA6: 3E3F    	        ld      A,'?'           ; More INPUT needed
1DA8: CD0A18  	        call    OUTC            ; Output character
1DAB: CD8416  	        call    PROMPT          ; Get INPUT with prompt
1DAE: D1      	        pop     DE              ; Variable address
1DAF: C1      	        pop     BC              ; Code string address
1DB0: DA711A  	        jp      C,INPBRK        ; Break pressed
1DB3: 23      	        inc     HL              ; Point to next DATA byte
1DB4: 7E      	        ld      A,(HL)          ; Get byte
1DB5: B7      	        or      A               ; Is it zero (No input) ?
1DB6: 2B      	        dec     HL              ; Back space INPUT pointer
1DB7: C5      	        push    BC              ; Save code string address
1DB8: CAC41B  	        jp      Z,NXTDTA        ; Find end of buffer
1DBB: D5      	        push    DE              ; Save variable address
1DBC: 3A9281  	ANTVLU: ld      A,(TYPE)        ; Check data type
1DBF: B7      	        or      A               ; Is it numeric?
1DC0: CAE61D  	        jp      Z,INPBIN        ; Yes - Convert to binary
1DC3: CD221A  	        call    GETCHR          ; Get next character
1DC6: 57      	        ld      D,A             ; Save input character
1DC7: 47      	        ld      B,A             ; Again
1DC8: FE22    	        cp      $22             ; '"'     ; Start of literal sting?
1DCA: CADA1D  	        jp      Z,STRENT        ; Yes - Create string entry
1DCD: 3AB281  	        ld      A,(READFG)      ; "READ" or "INPUT" ?
1DD0: B7      	        or      A
1DD1: 57      	        ld      D,A             ; Save 00 if "INPUT"
1DD2: CAD71D  	        jp      Z,ITMSEP        ; "INPUT" - End with 00
1DD5: 163A    	        ld      D,':'           ; "DATA" - End with 00 or ':'
1DD7: 062C    	ITMSEP: ld      B,','           ; Item separator
1DD9: 2B      	        dec     HL              ; Back space for DTSTR
1DDA: CD5D23  	STRENT: call    DTSTR           ; Get string terminated by D
1DDD: EB      	        ex      DE,HL           ; String address to DE
1DDE: 21F11D  	        ld      HL,LTSTND       ; Where to go after LETSTR
1DE1: E3      	        ex      (SP),HL         ; Save HL , get input pointer
1DE2: D5      	        push    DE              ; Save address of string
1DE3: C3F71B  	        jp      LETSTR          ; Assign string to variable
              	
1DE6: CD221A  	INPBIN: call    GETCHR          ; Get next character
1DE9: CD892C  	        call    ASCTFP          ; Convert ASCII to FP number
1DEC: E3      	        ex      (SP),HL         ; Save input ptr, Get var addr
1DED: CDDA2B  	        call    FPTHL           ; Move FPREG to variable
1DF0: E1      	        pop     HL              ; Restore input pointer
1DF1: 2B      	LTSTND: dec     HL              ; dec 'cos GETCHR INCs
1DF2: CD221A  	        call    GETCHR          ; Get next character
1DF5: CAFD1D  	        jp      Z,MORDT         ; End of line - More needed?
1DF8: FE2C    	        cp      ','             ; Another value?
1DFA: C2401D  	        jp      NZ,BADINP       ; No - Bad input
1DFD: E3      	MORDT:  ex      (SP),HL         ; Get code string address
1DFE: 2B      	        dec     HL              ; dec 'cos GETCHR INCs
1DFF: CD221A  	        call    GETCHR          ; Get next character
1E02: C2901D  	        jp      NZ,NEDMOR       ; More needed - Get it
1E05: D1      	        pop     DE              ; Restore DATA pointer
1E06: 3AB281  	        ld      A,(READFG)      ; "READ" or "INPUT" ?
1E09: B7      	        or      A
1E0A: EB      	        ex      DE,HL           ; DATA pointer to HL
1E0B: C2481A  	        jp      NZ,UPDATA       ; Update DATA pointer if "READ"
1E0E: D5      	        push    DE              ; Save code string address
1E0F: B6      	        or      (HL)            ; More input given?
1E10: 21181E  	        ld      HL,EXTIG        ; "?Extra ignored" message
1E13: C49B23  	        call    NZ,PRS          ; Output string if extra given
1E16: E1      	        pop     HL              ; Restore code string address
1E17: C9      	        ret
              	
1E18: 3F457874	EXTIG:  defb    "?Extra ignored",CR,0
1E1C: 72612069	
1E20: 676E6F72	
1E24: 65640D00	
              	
1E28: CDC51B  	FDTLP:  call    DATA            ; Get next statement
1E2B: B7      	        or      A               ; End of line?
1E2C: C2411E  	        jp      NZ,FANDT        ; No - See if DATA statement
1E2F: 23      	        inc     HL
1E30: 7E      	        ld      A,(HL)          ; End of program?
1E31: 23      	        inc     HL
1E32: B6      	        or      (HL)            ; 00 00 Ends program
1E33: 1E06    	        ld      E,OD            ; ?OD Error
1E35: CA2F15  	        jp      Z,ERROR         ; Yes - Out of DATA
1E38: 23      	        inc     HL
1E39: 5E      	        ld      E,(HL)          ; LSB of line number
1E3A: 23      	        inc     HL
1E3B: 56      	        ld      D,(HL)          ; MSB of line number
1E3C: EB      	        ex      DE,HL
1E3D: 22AE81  	        ld      (DATLIN),HL     ; Set line of current DATA item
1E40: EB      	        ex      DE,HL
1E41: CD221A  	FANDT:  call    GETCHR          ; Get next character
1E44: FE83    	        cp      ZDATA           ; "DATA" token
1E46: C2281E  	        jp      NZ,FDTLP        ; No "DATA" - Keep looking
1E49: C3BC1D  	        jp      ANTVLU          ; Found - Convert input
              	
1E4C: 110000  	NEXT:   ld      DE,$0000        ; In case no index given
1E4F: C4A120  	NEXT1:  call    NZ,GETVAR       ; Get index address
1E52: 22B381  	        ld      (BRKLIN),HL     ; Save code string address
1E55: CDA414  	        call    BAKSTK          ; Look for "FOR" block
1E58: C22115  	        jp      NZ,NFERR        ; No "FOR" - ?NF Error
1E5B: F9      	        ld      SP,HL           ; Clear nested loops
1E5C: D5      	        push    DE              ; Save index address
1E5D: 7E      	        ld      A,(HL)          ; Get sign of STEP
1E5E: 23      	        inc     HL
1E5F: F5      	        push    AF              ; Save sign of STEP
1E60: D5      	        push    DE              ; Save index address
1E61: CDC02B  	        call    PHLTFP          ; Move index value to FPREG
1E64: E3      	        ex      (SP),HL         ; Save address of TO value
1E65: E5      	        push    HL              ; Save address of index
1E66: CDDC28  	        call    ADDPHL          ; Add STEP to index value
1E69: E1      	        pop     HL              ; Restore address of index
1E6A: CDDA2B  	        call    FPTHL           ; Move value to index variable
1E6D: E1      	        pop     HL              ; Restore address of TO value
1E6E: CDD12B  	        call    LOADFP          ; Move TO value to BCDE
1E71: E5      	        push    HL              ; Save address of line of FOR
1E72: CDFD2B  	        call    CMPNUM          ; Compare index with TO value
1E75: E1      	        pop     HL              ; Restore address of line num
1E76: C1      	        pop     BC              ; Address of sign of STEP
1E77: 90      	        sub     B               ; Compare with expected sign
1E78: CDD12B  	        call    LOADFP          ; BC = Loop stmt,DE = Line num
1E7B: CA871E  	        jp      Z,KILFOR        ; Loop finished - Terminate it
1E7E: EB      	        ex      DE,HL           ; Loop statement line number
1E7F: 22AF80  	        ld      (LINEAT),HL     ; Set loop line number
1E82: 69      	        ld      L,C             ; Set code string to loop
1E83: 60      	        ld      H,B
1E84: C3DE19  	        jp      PUTFID          ; Put back "FOR" and continue
              	
1E87: F9      	KILFOR: ld      SP,HL           ; Remove "FOR" block
1E88: 2AB381  	        ld      HL,(BRKLIN)     ; Code string after "NEXT"
1E8B: 7E      	        ld      A,(HL)          ; Get next byte in code string
1E8C: FE2C    	        cp      ','             ; More NEXTs ?
1E8E: C2E219  	        jp      NZ,RUNCNT       ; No - Do next statement
1E91: CD221A  	        call    GETCHR          ; Position to index name
1E94: CD4F1E  	        call    NEXT1           ; Re-enter NEXT routine
              	; < will not RETurn to here , Exit to RUNCNT or Loop >
              	
1E97: CDA91E  	GETNUM: call    EVAL            ; Get a numeric expression
1E9A: F6      	TSTNUM: defb    $F6             ; Clear carry (numeric)
1E9B: 37      	TSTSTR: scf                     ; Set carry (string)
1E9C: 3A9281  	CHKTYP: ld      A,(TYPE)        ; Check types match
1E9F: 8F      	        adc     A,A             ; Expected + actual
1EA0: B7      	        or      A               ; Clear carry , set parity
1EA1: E8      	        ret     PE              ; Even parity - Types match
1EA2: C32D15  	        jp      TMERR           ; Different types - Error
              	
1EA5: CDFF17  	OPNPAR: call    CHKSYN          ; Make sure "(" follows
1EA8: 28      	        defb    '('
1EA9: 2B      	EVAL:   dec     HL              ; Evaluate expression & save
1EAA: 1600    	        ld      D,$00           ; Precedence value
1EAC: D5      	EVAL1:  push    DE              ; Save precedence
1EAD: 0E01    	        ld      C,$01
1EAF: CDD814  	        call    CHKSTK          ; Check for 1 level of stack
1EB2: CD201F  	        call    OPRND           ; Get next expression value
1EB5: 22B581  	EVAL2:  ld      (NXTOPR),HL     ; Save address of next operator
1EB8: 2AB581  	EVAL3:  ld      HL,(NXTOPR)     ; Restore address of next opr
1EBB: C1      	        pop     BC              ; Precedence value and operator
1EBC: 78      	        ld      A,B             ; Get precedence value
1EBD: FE78    	        cp      $78             ; "AND", "OR", or "XOR" ?
1EBF: D49A1E  	        call    NC,TSTNUM       ; No - Make sure it's a number
1EC2: 7E      	        ld      A,(HL)          ; Get next operator / function
1EC3: 1600    	        ld      D,$00           ; Clear Last relation
1EC5: D6C3    	RLTLP:  sub     ZGTR            ; ">" Token
1EC7: DAE11E  	        jp      C,FOPRND        ; + - * / ^ AND OR XOR - Test it
1ECA: FE03    	        cp      ZLTH+1-ZGTR     ; < = >
1ECC: D2E11E  	        jp      NC,FOPRND       ; Function - Call it
1ECF: FE01    	        cp      ZEQUAL-ZGTR     ; "="
1ED1: 17      	        rla                     ; <- Test for legal
1ED2: AA      	        xor     D               ; <- combinations of < = >
1ED3: BA      	        cp      D               ; <- by combining last token
1ED4: 57      	        ld      D,A             ; <- with current one
1ED5: DA1B15  	        jp      C,SNERR         ; Error if "<<' '==" or ">>"
1ED8: 22AA81  	        ld      (CUROPR),HL     ; Save address of current token
1EDB: CD221A  	        call    GETCHR          ; Get next character
1EDE: C3C51E  	        jp      RLTLP           ; Treat the two as one
              	
1EE1: 7A      	FOPRND: ld      A,D             ; < = > found ?
1EE2: B7      	        or      A
1EE3: C21C20  	        jp      NZ,TSTRED       ; Yes - Test for reduction
1EE6: 7E      	        ld      A,(HL)          ; Get operator token
1EE7: 22AA81  	        ld      (CUROPR),HL     ; Save operator address
1EEA: D6B9    	        sub     ZPLUS           ; Operator or function?
1EEC: D8      	        ret     C               ; Neither - Exit
1EED: FE0A    	        cp      ZOR+1-ZPLUS     ; Is it + - * / ^ AND XOR OR ?
1EEF: D0      	        ret     NC              ; No - Exit
1EF0: 5F      	        ld      E,A             ; Coded operator
1EF1: 3A9281  	        ld      A,(TYPE)        ; Get data type
1EF4: 3D      	        dec     A               ; FF = numeric , 00 = string
1EF5: B3      	        or      E               ; Combine with coded operator
1EF6: 7B      	        ld      A,E             ; Get coded operator
1EF7: CA9124  	        jp      Z,CONCAT        ; String concatenation
1EFA: 07      	        rlca                    ; Times 2
1EFB: 83      	        add     A,E             ; Times 3
1EFC: 5F      	        ld      E,A             ; To DE (D is 0)
1EFD: 21CC11  	        ld      HL,PRITAB       ; Precedence table
1F00: 19      	        add     HL,DE           ; To the operator concerned
1F01: 78      	        ld      A,B             ; Last operator precedence
1F02: 56      	        ld      D,(HL)          ; Get evaluation precedence
1F03: BA      	        cp      D               ; Compare with eval precedence
1F04: D0      	        ret     NC              ; Exit if higher precedence
1F05: 23      	        inc     HL              ; Point to routine address
1F06: CD9A1E  	        call    TSTNUM          ; Make sure it's a number
              	
1F09: C5      	STKTHS: push    BC              ; Save last precedence & token
1F0A: 01B81E  	        ld      BC,EVAL3        ; Where to go on prec' break
1F0D: C5      	        push    BC              ; Save on stack for return
1F0E: 43      	        ld      B,E             ; Save operator
1F0F: 4A      	        ld      C,D             ; Save precedence
1F10: CDB32B  	        call    STAKFP          ; Move value to stack
1F13: 58      	        ld      E,B             ; Restore operator
1F14: 51      	        ld      D,C             ; Restore precedence
1F15: 4E      	        ld      C,(HL)          ; Get LSB of routine address
1F16: 23      	        inc     HL
1F17: 46      	        ld      B,(HL)          ; Get MSB of routine address
1F18: 23      	        inc     HL
1F19: C5      	        push    BC              ; Save routine address
1F1A: 2AAA81  	        ld      HL,(CUROPR)     ; Address of current operator
1F1D: C3AC1E  	        jp      EVAL1           ; Loop until prec' break
              	
1F20: AF      	OPRND:  xor     A               ; Get operand routine
1F21: 329281  	        ld      (TYPE),A        ; Set numeric expected
1F24: CD221A  	        call    GETCHR          ; Get next character
1F27: 1E24    	        ld      E,MO            ; ?MO Error
1F29: CA2F15  	        jp      Z,ERROR         ; No operand - Error
1F2C: DA892C  	        jp      C,ASCTFP        ; Number - Get value
1F2F: CDC41A  	        call    CHKLTR          ; See if a letter
1F32: D2871F  	        jp      NC,CONVAR       ; Letter - Find variable
1F35: FE26    	        cp      '&'             ; &H = HEX, &B = BINARY
1F37: 2012    	        jr      NZ,NOTAMP
1F39: CD221A  	        call    GETCHR          ; Get next character
1F3C: FE48    	        cp      'H'             ; Hex number indicated? [function added]
1F3E: CA6A39  	        jp      Z,HEXTFP        ; Convert Hex to FPREG
1F41: FE42    	        cp      'B'             ; Binary number indicated? [function added]
1F43: CADA39  	        jp      Z,BINTFP        ; Convert Bin to FPREG
1F46: 1E02    	        ld      E,SN            ; If neither then a ?SN Error
1F48: CA2F15  	        jp      Z,ERROR         ;
1F4B: FEB9    	NOTAMP: cp      ZPLUS           ; '+' Token ?
1F4D: CA201F  	        jp      Z,OPRND         ; Yes - Look for operand
1F50: FE2E    	        cp      '.'             ; '.' ?
1F52: CA892C  	        jp      Z,ASCTFP        ; Yes - Create FP number
1F55: FEBA    	        cp      ZMINUS          ; '-' Token ?
1F57: CA761F  	        jp      Z,MINUS         ; Yes - Do minus
1F5A: FE22    	        cp      $22             ; '"'             ; Literal string ?
1F5C: CA5A23  	        jp      Z,QTSTR         ; Get string terminated by '"'
1F5F: FEB7    	        cp      ZNOT            ; "NOT" Token ?
1F61: CA7C20  	        jp      Z,EVNOT         ; Yes - Eval NOT expression
1F64: FEB4    	        cp      ZFN             ; "FN" Token ?
1F66: CABE22  	        jp      Z,DOFN          ; Yes - Do FN routine
1F69: D6C6    	        sub     ZSGN            ; Is it a function?
1F6B: D2981F  	        jp      NC,FNOFST       ; Yes - Evaluate function
1F6E: CDA51E  	EVLPAR: call    OPNPAR          ; Evaluate expression in "()"
1F71: CDFF17  	        call    CHKSYN          ; Make sure ")" follows
1F74: 29      	        defb    ')'
1F75: C9      	        ret
              	
1F76: 167D    	MINUS:  ld      D,$7D           ; '-' precedence
1F78: CDAC1E  	        call    EVAL1           ; Evaluate until prec' break
1F7B: 2AB581  	        ld      HL,(NXTOPR)     ; Get next operator address
1F7E: E5      	        push    HL              ; Save next operator address
1F7F: CDAB2B  	        call    INVSGN          ; Negate value
1F82: CD9A1E  	RETNUM: call    TSTNUM          ; Make sure it's a number
1F85: E1      	        pop     HL              ; Restore next operator address
1F86: C9      	        ret
              	
1F87: CDA120  	CONVAR: call    GETVAR          ; Get variable address to DE
1F8A: E5      	FRMEVL: push    HL              ; Save code string address
1F8B: EB      	        ex      DE,HL           ; Variable address to HL
1F8C: 22C981  	        ld      (FPREG),HL      ; Save address of variable
1F8F: 3A9281  	        ld      A,(TYPE)        ; Get type
1F92: B7      	        or      A               ; Numeric?
1F93: CCC02B  	        call    Z,PHLTFP        ; Yes - Move contents to FPREG
1F96: E1      	        pop     HL              ; Restore code string address
1F97: C9      	        ret
              	
1F98: 0600    	FNOFST: ld      B,$00           ; Get address of function
1F9A: 07      	        rlca                    ; Double function offset
1F9B: 4F      	        ld      C,A             ; BC = Offset in function table
1F9C: C5      	        push    BC              ; Save adjusted token value
1F9D: CD221A  	        call    GETCHR          ; Get next character
1FA0: 79      	        ld      A,C             ; Get adjusted token value
1FA1: FE2C    	        cp      2*(ZPOINT-ZSGN) ; "POINT" token?
1FA3: CACC31  	        jp      Z,POINT         ; Yes, do "POINT"
1FA6: FE3B    	        cp      2*(ZLEFT-ZSGN)-1; Adj' LEFT$,RIGHT$ or MID$ ?
1FA8: DAC41F  	        jp      C,FNVAL         ; No - Do function
1FAB: CDA51E  	        call    OPNPAR          ; Evaluate expression  (X,...
1FAE: CDFF17  	        call    CHKSYN          ; Make sure ',' follows
1FB1: 2C      	        defb    ','
1FB2: CD9B1E  	        call    TSTSTR          ; Make sure it's a string
1FB5: EB      	        ex      DE,HL           ; Save code string address
1FB6: 2AC981  	        ld      HL,(FPREG)      ; Get address of string
1FB9: E3      	        ex      (SP),HL         ; Save address of string
1FBA: E5      	        push    HL              ; Save adjusted token value
1FBB: EB      	        ex      DE,HL           ; Restore code string address
1FBC: CD2326  	        call    GETINT          ; Get integer 0-255
1FBF: EB      	        ex      DE,HL           ; Save code string address
1FC0: E3      	        ex      (SP),HL         ; Save integer,HL = adj' token
1FC1: C3CC1F  	        jp      GOFUNC          ; Jump to string function
              	
1FC4: CD6E1F  	FNVAL:  call    EVLPAR          ; Evaluate expression
1FC7: E3      	        ex      (SP),HL         ; HL = Adjusted token value
1FC8: 11821F  	        ld      DE,RETNUM       ; Return number from function
1FCB: D5      	        push    DE              ; Save on stack
1FCC: 01B10F  	GOFUNC: ld      BC,FNCTAB       ; Function routine addresses
1FCF: 09      	        add     HL,BC           ; Point to right address
1FD0: 4E      	        ld      C,(HL)          ; Get LSB of address
1FD1: 23      	        inc     HL              ;
1FD2: 66      	        ld      H,(HL)          ; Get MSB of address
1FD3: 69      	        ld      L,C             ; Address to HL
1FD4: E9      	        jp      (HL)            ; Jump to function
              	
1FD5: 15      	SGNEXP: dec     D               ; Dee to flag negative exponent
1FD6: FEBA    	        cp      ZMINUS          ; '-' token ?
1FD8: C8      	        ret     Z               ; Yes - Return
1FD9: FE2D    	        cp      '-'             ; '-' ASCII ?
1FDB: C8      	        ret     Z               ; Yes - Return
1FDC: 14      	        inc     D               ; Inc to flag positive exponent
1FDD: FE2B    	        cp      '+'             ; '+' ASCII ?
1FDF: C8      	        ret     Z               ; Yes - Return
1FE0: FEB9    	        cp      ZPLUS           ; '+' token ?
1FE2: C8      	        ret     Z               ; Yes - Return
1FE3: 2B      	        dec     HL              ; dec 'cos GETCHR INCs
1FE4: C9      	        ret                     ; Return "NZ"
              	
              	; execute OR, AND, and XOR operations
1FE5: AF      	PAND:   xor     A               ; for AND, Z=1
1FE6: 1807    	        jr      CNTLGC          
1FE8: AF      	POR     xor     A               ; for OR, Z=0, S=1
1FE9: D601    	        sub     $01
1FEB: 1802    	        jr      CNTLGC
1FED: AF      	PXOR:   xor     A               ; for XOR, Z=0, S=0
1FEE: 3C      	        inc     A
1FEF: F5      	CNTLGC: push    AF              ; store operand's flags
1FF0: CD9A1E  	        call    TSTNUM          ; Make sure it's a number
1FF3: CDD81A  	        call    DEINT           ; Get integer -32768 to 32767
1FF6: F1      	        pop     AF              ; retrieve operand's flags
1FF7: EB      	        ex      DE,HL           ; <- Get last
1FF8: C1      	        pop     BC              ; <-  value
1FF9: E3      	        ex      (SP),HL         ; <-  from
1FFA: EB      	        ex      DE,HL           ; <-  stack
1FFB: CDC32B  	        call    FPBCDE          ; Move last value to FPREG
1FFE: F5      	        push    AF              ; store operand's flags
1FFF: CDD81A  	        call    DEINT           ; Get integer -32768 to 32767
2002: F1      	        pop     AF              ; retrieve operand's flags
2003: C1      	        pop     BC              ; Get value
2004: 79      	        ld      A,C             ; Get LSB
2005: 217C22  	        ld      HL,ACPASS       ; Address of save AC as current
2008: 2005    	        jr      NZ,POR1         ; if X/OR, jump over
200A: A3      	PAND1:  and     E               ; "AND" LSBs
200B: 4F      	        ld      C,A             ; Save LSB
200C: 78      	        ld      A,B             ; Get MSB
200D: A2      	        and     D               ; "AND" MSBs
200E: E9      	        jp      (HL)            ; Save AC as current (ACPASS)
200F: F21720  	POR1:   jp      P,PXOR1         ; if S=0, jump to XOR
2012: B3      	        or      E               ; "OR" LSBs
2013: 4F      	        ld      C,A             ; Save LSB
2014: 78      	        ld      A,B             ; Get MSB
2015: B2      	        or      D               ; "OR" MSBs
2016: E9      	        jp      (HL)            ; Save AC as current (ACPASS)
2017: AB      	PXOR1:  xor     E               ; "XOR" LSBs
2018: 4F      	        ld      C,A             ; Save LSB
2019: 78      	        ld      A,B             ; Get MSB
201A: AA      	        xor     D               ; "XOR" MSBs
201B: E9      	        jp      (HL)            ; Save AC as current (ACPASS) 
              	
201C: 212E20  	TSTRED: ld      HL,CMPLOG       ; Logical compare routine
201F: 3A9281  	        ld      A,(TYPE)        ; Get data type
2022: 1F      	        rra                     ; Carry set = string
2023: 7A      	        ld      A,D             ; Get last precedence value
2024: 17      	        rla                     ; Times 2 plus carry
2025: 5F      	        ld      E,A             ; To E
2026: 1664    	        ld      D,$64           ; Relational precedence
2028: 78      	        ld      A,B             ; Get current precedence
2029: BA      	        cp      D               ; Compare with last
202A: D0      	        ret     NC              ; Eval if last was rel' or log'
202B: C3091F  	        jp      STKTHS          ; Stack this one and get next
              	
202E: 3020    	CMPLOG: defw    CMPLG1          ; Compare two values / strings
2030: 79      	CMPLG1: ld      A,C             ; Get data type
2031: B7      	        or      A
2032: 1F      	        rra
2033: C1      	        pop     BC              ; Get last expression to BCDE
2034: D1      	        pop     DE
2035: F5      	        push    AF              ; Save status
2036: CD9C1E  	        call    CHKTYP          ; Check that types match
2039: 217220  	        ld      HL,CMPRES       ; Result to comparison
203C: E5      	        push    HL              ; Save for RETurn
203D: CAFD2B  	        jp      Z,CMPNUM        ; Compare values if numeric
2040: AF      	        xor     A               ; Compare two strings
2041: 329281  	        ld      (TYPE),A        ; Set type to numeric
2044: D5      	        push    DE              ; Save string name
2045: CDDE24  	        call    GSTRCU          ; Get current string
2048: 7E      	        ld      A,(HL)          ; Get length of string
2049: 23      	        inc     HL
204A: 23      	        inc     HL
204B: 4E      	        ld      C,(HL)          ; Get LSB of address
204C: 23      	        inc     HL
204D: 46      	        ld      B,(HL)          ; Get MSB of address
204E: D1      	        pop     DE              ; Restore string name
204F: C5      	        push    BC              ; Save address of string
2050: F5      	        push    AF              ; Save length of string
2051: CDE224  	        call    GSTRDE          ; Get second string
2054: CDD12B  	        call    LOADFP          ; Get address of second string
2057: F1      	        pop     AF              ; Restore length of string 1
2058: 57      	        ld      D,A             ; Length to D
2059: E1      	        pop     HL              ; Restore address of string 1
205A: 7B      	CMPSTR: ld      A,E             ; Bytes of string 2 to do
205B: B2      	        or      D               ; Bytes of string 1 to do
205C: C8      	        ret     Z               ; Exit if all bytes compared
205D: 7A      	        ld      A,D             ; Get bytes of string 1 to do
205E: D601    	        sub     $01
2060: D8      	        ret     C               ; Exit if end of string 1
2061: AF      	        xor     A
2062: BB      	        cp      E               ; Bytes of string 2 to do
2063: 3C      	        inc     A
2064: D0      	        ret     NC              ; Exit if end of string 2
2065: 15      	        dec     D               ; Count bytes in string 1
2066: 1D      	        dec     E               ; Count bytes in string 2
2067: 0A      	        ld      A,(BC)          ; Byte in string 2
2068: BE      	        cp      (HL)            ; Compare to byte in string 1
2069: 23      	        inc     HL              ; Move up string 1
206A: 03      	        inc     BC              ; Move up string 2
206B: CA5A20  	        jp      Z,CMPSTR        ; Same - Try next bytes
206E: 3F      	        ccf                     ; Flag difference (">" or "<")
206F: C38D2B  	        jp      FLGDIF          ; "<" gives -1 , ">" gives +1
              	
2072: 3C      	CMPRES: inc     A               ; Increment current value
2073: 8F      	        adc     A,A             ; Double plus carry
2074: C1      	        pop     BC              ; Get other value
2075: A0      	        and     B               ; Combine them
2076: C6FF    	        add     A,-1            ; Carry set if different
2078: 9F      	        sbc     A,A             ; 00 - Equal , FF - Different
2079: C3942B  	        jp      FLGREL          ; Set current value & continue
              	
207C: 165A    	EVNOT:  ld      D,$5A           ; Precedence value for "NOT"
207E: CDAC1E  	        call    EVAL1           ; Eval until precedence break
2081: CD9A1E  	        call    TSTNUM          ; Make sure it's a number
2084: CDD81A  	        call    DEINT           ; Get integer -32768 - 32767
2087: 7B      	        ld      A,E             ; Get LSB
2088: 2F      	        cpl                     ; Invert LSB
2089: 4F      	        ld      C,A             ; Save "NOT" of LSB
208A: 7A      	        ld      A,D             ; Get MSB
208B: 2F      	        cpl                     ; Invert MSB
208C: CD7C22  	        call    ACPASS          ; Save AC as current
208F: C1      	        pop     BC              ; Clean up stack
2090: C3B81E  	        jp      EVAL3           ; Continue evaluation
              	
2093: 2B      	DIMRET: dec     HL              ; dec 'cos GETCHR INCs
2094: CD221A  	        call    GETCHR          ; Get next character
2097: C8      	        ret     Z               ; End of DIM statement
2098: CDFF17  	        call    CHKSYN          ; Make sure ',' follows
209B: 2C      	        defb    ','
209C: 019320  	DIM:    ld      BC,DIMRET       ; Return to "DIMRET"
209F: C5      	        push    BC              ; Save on stack
20A0: F6      	        defb    $F6             ; Flag "Create" variable
20A1: AF      	GETVAR: xor     A               ; Find variable address,to DE
20A2: 329181  	        ld      (LCRFLG),A      ; Set locate / create flag
20A5: 46      	        ld      B,(HL)          ; Get First byte of name
20A6: CDC41A  	GTFNAM: call    CHKLTR          ; See if a letter
20A9: DA1B15  	        jp      C,SNERR         ; ?SN Error if not a letter
20AC: AF      	        xor     A
20AD: 4F      	        ld      C,A             ; Clear second byte of name
20AE: 329281  	        ld      (TYPE),A        ; Set type to numeric
20B1: CD221A  	        call    GETCHR          ; Get next character
20B4: DABD20  	        jp      C,SVNAM2        ; Numeric - Save in name
20B7: CDC41A  	        call    CHKLTR          ; See if a letter
20BA: DACA20  	        jp      C,CHARTY        ; Not a letter - Check type
20BD: 4F      	SVNAM2: ld      C,A             ; Save second byte of name
20BE: CD221A  	ENDNAM: call    GETCHR          ; Get next character
20C1: DABE20  	        jp      C,ENDNAM        ; Numeric - Get another
20C4: CDC41A  	        call    CHKLTR          ; See if a letter
20C7: D2BE20  	        jp      NC,ENDNAM       ; Letter - Get another
20CA: D624    	CHARTY: sub     '$'             ; String variable?
20CC: C2D920  	        jp      NZ,NOTSTR       ; No - Numeric variable
20CF: 3C      	        inc     A               ; A = 1 (string type)
20D0: 329281  	        ld      (TYPE),A        ; Set type to string
20D3: 0F      	        rrca                    ; A = 80H , Flag for string
20D4: 81      	        add     A,C             ; 2nd byte of name has bit 7 on
20D5: 4F      	        ld      C,A             ; Resave second byte on name
20D6: CD221A  	        call    GETCHR          ; Get next character
20D9: 3AB081  	NOTSTR: ld      A,(FORFLG)      ; Array name needed ?
20DC: 3D      	        dec     A
20DD: CA8621  	        jp      Z,ARLDSV        ; Yes - Get array name
20E0: F2E920  	        jp      P,NSCFOR        ; No array with "FOR" or "FN"
20E3: 7E      	        ld      A,(HL)          ; Get byte again
20E4: D628    	        sub     '('             ; Subscripted variable?
20E6: CA5E21  	        jp      Z,SBSCPT        ; Yes - Sort out subscript
              	
20E9: AF      	NSCFOR: xor     A               ; Simple variable
20EA: 32B081  	        ld      (FORFLG),A      ; Clear "FOR" flag
20ED: E5      	        push    HL              ; Save code string address
20EE: 50      	        ld      D,B             ; DE = Variable name to find
20EF: 59      	        ld      E,C
20F0: 2AC381  	        ld      HL,(FNRGNM)     ; FN argument name
20F3: CDF917  	        call    CPDEHL          ; Is it the FN argument?
20F6: 11C581  	        ld      DE,FNARG        ; Point to argument value
20F9: CA722A  	        jp      Z,POPHRT        ; Yes - Return FN argument value
20FC: 2ABD81  	        ld      HL,(VAREND)     ; End of variables
20FF: EB      	        ex      DE,HL           ; Address of end of search
2100: 2ABB81  	        ld      HL,(PROGND)     ; Start of variables address
2103: CDF917  	FNDVAR: call    CPDEHL          ; End of variable list table?
2106: CA1C21  	        jp      Z,CFEVAL        ; Yes - Called from EVAL?
2109: 79      	        ld      A,C             ; Get second byte of name
210A: 96      	        sub     (HL)            ; Compare with name in list
210B: 23      	        inc     HL              ; Move on to first byte
210C: C21121  	        jp      NZ,FNTHR        ; Different - Find another
210F: 78      	        ld      A,B             ; Get first byte of name
2110: 96      	        sub     (HL)            ; Compare with name in list
2111: 23      	FNTHR:  inc     HL              ; Move on to LSB of value
2112: CA5021  	        jp      Z,RETADR        ; Found - Return address
2115: 23      	        inc     HL              ; <- Skip
2116: 23      	        inc     HL              ; <- over
2117: 23      	        inc     HL              ; <- F.P.
2118: 23      	        inc     HL              ; <- value
2119: C30321  	        jp      FNDVAR          ; Keep looking
              	
211C: E1      	CFEVAL: pop     HL              ; Restore code string address
211D: E3      	        ex      (SP),HL         ; Get return address
211E: D5      	        push    DE              ; Save address of variable
211F: 118A1F  	        ld      DE,FRMEVL       ; Return address in EVAL
2122: CDF917  	        call    CPDEHL          ; Called from EVAL ?
2125: D1      	        pop     DE              ; Restore address of variable
2126: CA5321  	        jp      Z,RETNUL        ; Yes - Return null variable
2129: E3      	        ex      (SP),HL         ; Put back return
212A: E5      	        push    HL              ; Save code string address
212B: C5      	        push    BC              ; Save variable name
212C: 010600  	        ld      BC,$0006        ; 2 byte name plus 4 byte data
212F: 2ABF81  	        ld      HL,(ARREND)     ; End of arrays
2132: E5      	        push    HL              ; Save end of arrays
2133: 09      	        add     HL,BC           ; Move up 6 bytes
2134: C1      	        pop     BC              ; Source address in BC
2135: E5      	        push    HL              ; Save new end address
2136: CDC714  	        call    MOVUP           ; Move arrays up
2139: E1      	        pop     HL              ; Restore new end address
213A: 22BF81  	        ld      (ARREND),HL     ; Set new end address
213D: 60      	        ld      H,B             ; End of variables to HL
213E: 69      	        ld      L,C
213F: 22BD81  	        ld      (VAREND),HL     ; Set new end address
              	
2142: 2B      	ZEROLP: dec     HL              ; Back through to zero variable
2143: 3600    	        ld      (HL),$00        ; Zero byte in variable
2145: CDF917  	        call    CPDEHL          ; Done them all?
2148: C24221  	        jp      NZ,ZEROLP       ; No - Keep on going
214B: D1      	        pop     DE              ; Get variable name
214C: 73      	        ld      (HL),E          ; Store second character
214D: 23      	        inc     HL
214E: 72      	        ld      (HL),D          ; Store first character
214F: 23      	        inc     HL
2150: EB      	RETADR: ex      DE,HL           ; Address of variable in DE
2151: E1      	        pop     HL              ; Restore code string address
2152: C9      	        ret
              	
2153: 32CC81  	RETNUL: ld      (FPEXP),A       ; Set result to zero
2156: 219814  	        ld      HL,ZERBYT       ; Also set a null string
2159: 22C981  	        ld      (FPREG),HL      ; Save for EVAL
215C: E1      	        pop     HL              ; Restore code string address
215D: C9      	        ret
              	
215E: E5      	SBSCPT: push    HL              ; Save code string address
215F: 2A9181  	        ld      HL,(LCRFLG)     ; Locate/Create and Type
2162: E3      	        ex      (SP),HL         ; Save and get code string
2163: 57      	        ld      D,A             ; Zero number of dimensions
2164: D5      	SCPTLP: push    DE              ; Save number of dimensions
2165: C5      	        push    BC              ; Save array name
2166: CDCC1A  	        call    FPSINT          ; Get subscript (0-32767)
2169: C1      	        pop     BC              ; Restore array name
216A: F1      	        pop     AF              ; Get number of dimensions
216B: EB      	        ex      DE,HL
216C: E3      	        ex      (SP),HL         ; Save subscript value
216D: E5      	        push    HL              ; Save LCRFLG and TYPE
216E: EB      	        ex      DE,HL
216F: 3C      	        inc     A               ; Count dimensions
2170: 57      	        ld      D,A             ; Save in D
2171: 7E      	        ld      A,(HL)          ; Get next byte in code string
2172: FE2C    	        cp      ','             ; Comma (more to come)?
2174: CA6421  	        jp      Z,SCPTLP        ; Yes - More subscripts
2177: CDFF17  	        call    CHKSYN          ; Make sure ")" follows
217A: 29      	        defb    ')'
217B: 22B581  	        ld      (NXTOPR),HL     ; Save code string address
217E: E1      	        pop     HL              ; Get LCRFLG and TYPE
217F: 229181  	        ld      (LCRFLG),HL     ; Restore Locate/create & type
2182: 1E00    	        ld      E,$00           ; Flag not CSAVE* or CLOAD*
2184: D5      	        push    DE              ; Save number of dimensions (D)
2185: 11      	        defb    $11             ; Skip "push HL" and "push AF'
              	
2186: E5      	ARLDSV: push    HL              ; Save code string address
2187: F5      	        push    AF              ; A = 00 , Flags set = Z,N
2188: 2ABD81  	        ld      HL,(VAREND)     ; Start of arrays
218B: 3E      	        defb    $3E             ; Skip "add HL,DE"
218C: 19      	FNDARY: add     HL,DE           ; Move to next array start
218D: EB      	        ex      DE,HL
218E: 2ABF81  	        ld      HL,(ARREND)     ; End of arrays
2191: EB      	        ex      DE,HL           ; Current array pointer
2192: CDF917  	        call    CPDEHL          ; End of arrays found?
2195: CABE21  	        jp      Z,CREARY        ; Yes - Create array
2198: 7E      	        ld      A,(HL)          ; Get second byte of name
2199: B9      	        cp      C               ; Compare with name given
219A: 23      	        inc     HL              ; Move on
219B: C2A021  	        jp      NZ,NXTARY       ; Different - Find next array
219E: 7E      	        ld      A,(HL)          ; Get first byte of name
219F: B8      	        cp      B               ; Compare with name given
21A0: 23      	NXTARY: inc     HL              ; Move on
21A1: 5E      	        ld      E,(HL)          ; Get LSB of next array address
21A2: 23      	        inc     HL
21A3: 56      	        ld      D,(HL)          ; Get MSB of next array address
21A4: 23      	        inc     HL
21A5: C28C21  	        jp      NZ,FNDARY       ; Not found - Keep looking
21A8: 3A9181  	        ld      A,(LCRFLG)      ; Found Locate or Create it?
21AB: B7      	        or      A
21AC: C22415  	        jp      NZ,DDERR        ; Create - ?DD Error
21AF: F1      	        pop     AF              ; Locate - Get number of dim'ns
21B0: 44      	        ld      B,H             ; BC Points to array dim'ns
21B1: 4D      	        ld      C,L
21B2: CA722A  	        jp      Z,POPHRT        ; Jump if array load/save
21B5: 96      	        sub     (HL)            ; Same number of dimensions?
21B6: CA1C22  	        jp      Z,FINDEL        ; Yes - Find element
21B9: 1E10    	BSERR:  ld      E,BS            ; ?BS Error
21BB: C32F15  	        jp      ERROR           ; Output error
              	
21BE: 110400  	CREARY: ld      DE,$0004        ; 4 Bytes per entry
21C1: F1      	        pop     AF              ; Array to save or 0 dim'ns?
21C2: CAED1A  	        jp      Z,FCERR         ; Yes - ?FC Error
21C5: 71      	        ld      (HL),C          ; Save second byte of name
21C6: 23      	        inc     HL
21C7: 70      	        ld      (HL),B          ; Save first byte of name
21C8: 23      	        inc     HL
21C9: 4F      	        ld      C,A             ; Number of dimensions to C
21CA: CDD814  	        call    CHKSTK          ; Check if enough memory
21CD: 23      	        inc     HL              ; Point to number of dimensions
21CE: 23      	        inc     HL
21CF: 22AA81  	        ld      (CUROPR),HL     ; Save address of pointer
21D2: 71      	        ld      (HL),C          ; Set number of dimensions
21D3: 23      	        inc     HL
21D4: 3A9181  	        ld      A,(LCRFLG)      ; Locate of Create?
21D7: 17      	        rla                     ; Carry set = Create
21D8: 79      	        ld      A,C             ; Get number of dimensions
21D9: 010B00  	CRARLP: ld      BC,10+1         ; Default dimension size 10
21DC: D2E121  	        jp      NC,DEFSIZ       ; Locate - Set default size
21DF: C1      	        pop     BC              ; Get specified dimension size
21E0: 03      	        inc     BC              ; Include zero element
21E1: 71      	DEFSIZ: ld      (HL),C          ; Save LSB of dimension size
21E2: 23      	        inc     HL
21E3: 70      	        ld      (HL),B          ; Save MSB of dimension size
21E4: 23      	        inc     HL
21E5: F5      	        push    AF              ; Save num' of dim'ns an status
21E6: E5      	        push    HL              ; Save address of dim'n size
21E7: CD6E2C  	        call    MLDEBC          ; Multiply DE by BC to find
21EA: EB      	        ex      DE,HL           ; amount of mem needed (to DE)
21EB: E1      	        pop     HL              ; Restore address of dimension
21EC: F1      	        pop     AF              ; Restore number of dimensions
21ED: 3D      	        dec     A               ; Count them
21EE: C2D921  	        jp      NZ,CRARLP       ; Do next dimension if more
21F1: F5      	        push    AF              ; Save locate/create flag
21F2: 42      	        ld      B,D             ; MSB of memory needed
21F3: 4B      	        ld      C,E             ; LSB of memory needed
21F4: EB      	        ex      DE,HL
21F5: 19      	        add     HL,DE           ; Add bytes to array start
21F6: DAF014  	        jp      C,OMERR         ; Too big - Error
21F9: CDE114  	        call    ENFMEM          ; See if enough memory
21FC: 22BF81  	        ld      (ARREND),HL     ; Save new end of array
              	
21FF: 2B      	ZERARY: dec     HL              ; Back through array data
2200: 3600    	        ld      (HL),$00        ; Set array element to zero
2202: CDF917  	        call    CPDEHL          ; All elements zeroed?
2205: C2FF21  	        jp      NZ,ZERARY       ; No - Keep on going
2208: 03      	        inc     BC              ; Number of bytes + 1
2209: 57      	        ld      D,A             ; A=0
220A: 2AAA81  	        ld      HL,(CUROPR)     ; Get address of array
220D: 5E      	        ld      E,(HL)          ; Number of dimensions
220E: EB      	        ex      DE,HL           ; To HL
220F: 29      	        add     HL,HL           ; Two bytes per dimension size
2210: 09      	        add     HL,BC           ; Add number of bytes
2211: EB      	        ex      DE,HL           ; Bytes needed to DE
2212: 2B      	        dec     HL
2213: 2B      	        dec     HL
2214: 73      	        ld      (HL),E          ; Save LSB of bytes needed
2215: 23      	        inc     HL
2216: 72      	        ld      (HL),D          ; Save MSB of bytes needed
2217: 23      	        inc     HL
2218: F1      	        pop     AF              ; Locate / Create?
2219: DA4022  	        jp      C,ENDDIM        ; A is 0 , End if create
221C: 47      	FINDEL: ld      B,A             ; Find array element
221D: 4F      	        ld      C,A
221E: 7E      	        ld      A,(HL)          ; Number of dimensions
221F: 23      	        inc     HL
2220: 16      	        defb    $16             ; Skip "pop HL"
2221: E1      	FNDELP: pop     HL              ; Address of next dim' size
2222: 5E      	        ld      E,(HL)          ; Get LSB of dim'n size
2223: 23      	        inc     HL
2224: 56      	        ld      D,(HL)          ; Get MSB of dim'n size
2225: 23      	        inc     HL
2226: E3      	        ex      (SP),HL         ; Save address - Get index
2227: F5      	        push    AF              ; Save number of dim'ns
2228: CDF917  	        call    CPDEHL          ; Dimension too large?
222B: D2B921  	        jp      NC,BSERR        ; Yes - ?BS Error
222E: E5      	        push    HL              ; Save index
222F: CD6E2C  	        call    MLDEBC          ; Multiply previous by size
2232: D1      	        pop     DE              ; Index supplied to DE
2233: 19      	        add     HL,DE           ; Add index to pointer
2234: F1      	        pop     AF              ; Number of dimensions
2235: 3D      	        dec     A               ; Count them
2236: 44      	        ld      B,H             ; MSB of pointer
2237: 4D      	        ld      C,L             ; LSB of pointer
2238: C22122  	        jp      NZ,FNDELP       ; More - Keep going
223B: 29      	        add     HL,HL           ; 4 Bytes per element
223C: 29      	        add     HL,HL
223D: C1      	        pop     BC              ; Start of array
223E: 09      	        add     HL,BC           ; Point to element
223F: EB      	        ex      DE,HL           ; Address of element to DE
2240: 2AB581  	ENDDIM: ld      HL,(NXTOPR)     ; Got code string address
2243: C9      	        ret
              	
2244: CD9A1E  	TMR:    call    TSTNUM          ; Make sure it's a number
2247: CDD81A  	        call    DEINT           ; Get integer -32768 to 32767
224A: F3      	        di                      ; we must work with INTs disabled
224B: 21CE81  	        ld      HL,TMRCNT       ; load the address of the first byte of the counter
224E: 7B      	        ld      A,E             ; move param into A
224F: A7      	        and     A               ; is it 0?
2250: 2802    	        jr      Z,LSBTMR        ; print the 2 LSBytes of timer
2252: 23      	        inc     HL              ; else print the 2 MSBytes of timer
2253: 23      	        inc     HL
2254: 46      	LSBTMR: ld      B,(HL)          ; Get LSB of contents
2255: 23      	        inc     HL
2256: 7E      	        ld      A,(HL)          ; Get MSB of contents
2257: FB      	        ei                      ; re-enable INTs
2258: C37D22  	        jp      ABPASS          ;return word into AB
              	
225B: 2ABF81  	FRE:    ld      HL,(ARREND)     ; Start of free memory
225E: EB      	        ex      DE,HL           ; To DE
225F: 210000  	        ld      HL,$0000        ; End of free memory
2262: 39      	        add     HL,SP           ; Current stack value
2263: 3A9281  	        ld      A,(TYPE)        ; Dummy argument type
2266: B7      	        or      A
2267: CA7722  	        jp      Z,FRENUM        ; Numeric - Free variable space
226A: CDDE24  	        call    GSTRCU          ; Current string to pool
226D: CDDE23  	        call    GARBGE          ; Garbage collection
2270: 2AAD80  	        ld      HL,(STRSPC)     ; Bottom of string space in use
2273: EB      	        ex      DE,HL           ; To DE
2274: 2AA881  	        ld      HL,(STRBOT)     ; Bottom of string space
2277: 7D      	FRENUM: ld      A,L             ; Get LSB of end
2278: 93      	        sub     E               ; Subtract LSB of beginning
2279: 4F      	        ld      C,A             ; Save difference if C
227A: 7C      	        ld      A,H             ; Get MSB of end
227B: 9A      	        sbc     A,D             ; Subtract MSB of beginning
227C: 41      	ACPASS: ld      B,C             ; Return integer AC
227D: 50      	ABPASS: ld      D,B             ; Return integer AB
227E: 1E00    	        ld      E,$00
2280: 219281  	        ld      HL,TYPE         ; Point to type
2283: 73      	        ld      (HL),E          ; Set type to numeric
2284: 0690    	        ld      B,$80+$10       ; 16 bit integer
2286: C3992B  	        jp      RETINT          ; Return the integer
              	
              	; returns the X position of the cursor during a print
2289: 3A9081  	POS:    ld      A,(CURPOS)      ; Get cursor position
228C: 47      	PASSA:  ld      B,A             ; Put A into AB
228D: AF      	        xor     A               ; Zero A
228E: C37D22  	        jp      ABPASS          ; Return integer AB
              	
2291: CD1423  	DEF:    call    CHEKFN          ; Get "FN" and name
2294: CD0623  	        call    IDTEST          ; Test for illegal direct
2297: 01C51B  	        ld      BC,DATA         ; To get next statement
229A: C5      	        push    BC              ; Save address for RETurn
229B: D5      	        push    DE              ; Save address of function ptr
229C: CDFF17  	        call    CHKSYN          ; Make sure "(" follows
229F: 28      	        defb    '('
22A0: CDA120  	        call    GETVAR          ; Get argument variable name
22A3: E5      	        push    HL              ; Save code string address
22A4: EB      	        ex      DE,HL           ; Argument address to HL
22A5: 2B      	        dec     HL
22A6: 56      	        ld      D,(HL)          ; Get first byte of arg name
22A7: 2B      	        dec     HL
22A8: 5E      	        ld      E,(HL)          ; Get second byte of arg name
22A9: E1      	        pop     HL              ; Restore code string address
22AA: CD9A1E  	        call    TSTNUM          ; Make sure numeric argument
22AD: CDFF17  	        call    CHKSYN          ; Make sure ")" follows
22B0: 29      	        defb    ')'
22B1: CDFF17  	        call    CHKSYN          ; Make sure "=" follows
22B4: C4      	        defb    ZEQUAL          ; "=" token
22B5: 44      	        ld      B,H             ; Code string address to BC
22B6: 4D      	        ld      C,L
22B7: E3      	        ex      (SP),HL         ; Save code str , Get FN ptr
22B8: 71      	        ld      (HL),C          ; Save LSB of FN code string
22B9: 23      	        inc     HL
22BA: 70      	        ld      (HL),B          ; Save MSB of FN code string
22BB: C35323  	        jp      SVSTAD          ; Save address and do function
              	
22BE: CD1423  	DOFN:   call    CHEKFN          ; Make sure FN follows
22C1: D5      	        push    DE              ; Save function pointer address
22C2: CD6E1F  	        call    EVLPAR          ; Evaluate expression in "()"
22C5: CD9A1E  	        call    TSTNUM          ; Make sure numeric result
22C8: E3      	        ex      (SP),HL         ; Save code str , Get FN ptr
22C9: 5E      	        ld      E,(HL)          ; Get LSB of FN code string
22CA: 23      	        inc     HL
22CB: 56      	        ld      D,(HL)          ; Get MSB of FN code string
22CC: 23      	        inc     HL
22CD: 7A      	        ld      A,D             ; And function DEFined?
22CE: B3      	        or      E
22CF: CA2715  	        jp      Z,UFERR         ; No - ?UF Error
22D2: 7E      	        ld      A,(HL)          ; Get LSB of argument address
22D3: 23      	        inc     HL
22D4: 66      	        ld      H,(HL)          ; Get MSB of argument address
22D5: 6F      	        ld      L,A             ; HL = Arg variable address
22D6: E5      	        push    HL              ; Save it
22D7: 2AC381  	        ld      HL,(FNRGNM)     ; Get old argument name
22DA: E3      	        ex      (SP),HL         ; Save old , Get new
22DB: 22C381  	        ld      (FNRGNM),HL     ; Set new argument name
22DE: 2AC781  	        ld      HL,(FNARG+2)    ; Get LSB,NLSB of old arg value
22E1: E5      	        push    HL              ; Save it
22E2: 2AC581  	        ld      HL,(FNARG)      ; Get MSB,EXP of old arg value
22E5: E5      	        push    HL              ; Save it
22E6: 21C581  	        ld      HL,FNARG        ; HL = Value of argument
22E9: D5      	        push    DE              ; Save FN code string address
22EA: CDDA2B  	        call    FPTHL           ; Move FPREG to argument
22ED: E1      	        pop     HL              ; Get FN code string address
22EE: CD971E  	        call    GETNUM          ; Get value from function
22F1: 2B      	        dec     HL              ; dec 'cos GETCHR INCs
22F2: CD221A  	        call    GETCHR          ; Get next character
22F5: C21B15  	        jp      NZ,SNERR        ; Bad character in FN - Error
22F8: E1      	        pop     HL              ; Get MSB,EXP of old arg
22F9: 22C581  	        ld      (FNARG),HL      ; Restore it
22FC: E1      	        pop     HL              ; Get LSB,NLSB of old arg
22FD: 22C781  	        ld      (FNARG+2),HL    ; Restore it
2300: E1      	        pop     HL              ; Get name of old arg
2301: 22C381  	        ld      (FNRGNM),HL     ; Restore it
2304: E1      	        pop     HL              ; Restore code string address
2305: C9      	        ret
              	
2306: E5      	IDTEST: push    HL              ; Save code string address
2307: 2AAF80  	        ld      HL,(LINEAT)     ; Get current line number
230A: 23      	        inc     HL              ; -1 means direct statement
230B: 7C      	        ld      A,H
230C: B5      	        or      L
230D: E1      	        pop     HL              ; Restore code string address
230E: C0      	        ret     NZ              ; Return if in program
230F: 1E16    	        ld      E,ID            ; ?ID Error
2311: C32F15  	        jp      ERROR
              	
2314: CDFF17  	CHEKFN: call    CHKSYN          ; Make sure FN follows
2317: B4      	        defb    ZFN             ; "FN" token
2318: 3E80    	        ld      A,$80
231A: 32B081  	        ld      (FORFLG),A      ; Flag FN name to find
231D: B6      	        or      (HL)            ; FN name has bit 7 set
231E: 47      	        ld      B,A             ; in first byte of name
231F: CDA620  	        call    GTFNAM          ; Get FN name
2322: C39A1E  	        jp      TSTNUM          ; Make sure numeric function
              	
2325: CD9A1E  	STR:    call    TSTNUM          ; Make sure it's a number
2328: CD272D  	        call    NUMASC          ; Turn number into text
232B: CD5923  	STR1:   call    CRTST           ; Create string entry for it
232E: CDDE24  	        call    GSTRCU          ; Current string to pool
2331: 013925  	        ld      BC,TOPOOL       ; Save in string pool
2334: C5      	        push    BC              ; Save address on stack
              	
2335: 7E      	SAVSTR: ld      A,(HL)          ; Get string length
2336: 23      	        inc     HL
2337: 23      	        inc     HL
2338: E5      	        push    HL              ; Save pointer to string
2339: CDB423  	        call    TESTR           ; See if enough string space
233C: E1      	        pop     HL              ; Restore pointer to string
233D: 4E      	        ld      C,(HL)          ; Get LSB of address
233E: 23      	        inc     HL
233F: 46      	        ld      B,(HL)          ; Get MSB of address
2340: CD4D23  	        call    CRTMST          ; Create string entry
2343: E5      	        push    HL              ; Save pointer to MSB of addr
2344: 6F      	        ld      L,A             ; Length of string
2345: CDD124  	        call    TOSTRA          ; Move to string area
2348: D1      	        pop     DE              ; Restore pointer to MSB
2349: C9      	        ret
              	
234A: CDB423  	MKTMST: call    TESTR           ; See if enough string space
234D: 21A481  	CRTMST: ld      HL,TMPSTR       ; Temporary string
2350: E5      	        push    HL              ; Save it
2351: 77      	        ld      (HL),A          ; Save length of string
2352: 23      	        inc     HL
2353: 23      	SVSTAD: inc     HL
2354: 73      	        ld      (HL),E          ; Save LSB of address
2355: 23      	        inc     HL
2356: 72      	        ld      (HL),D          ; Save MSB of address
2357: E1      	        pop     HL              ; Restore pointer
2358: C9      	        ret
              	
2359: 2B      	CRTST:  dec     HL              ; dec - INCed after
235A: 0622    	QTSTR:  ld      B,$22           ; '"'           ; Terminating quote
235C: 50      	        ld      D,B             ; Quote to D
235D: E5      	DTSTR:  push    HL              ; Save start
235E: 0EFF    	        ld      C,-1            ; Set counter to -1
2360: 23      	QTSTLP: inc     HL              ; Move on
2361: 7E      	        ld      A,(HL)          ; Get byte
2362: 0C      	        inc     C               ; Count bytes
2363: B7      	        or      A               ; End of line?
2364: CA6F23  	        jp      Z,CRTSTE        ; Yes - Create string entry
2367: BA      	        cp      D               ; Terminator D found?
2368: CA6F23  	        jp      Z,CRTSTE        ; Yes - Create string entry
236B: B8      	        cp      B               ; Terminator B found?
236C: C26023  	        jp      NZ,QTSTLP       ; No - Keep looking
236F: FE22    	CRTSTE: cp      $22             ; '"'             ; End with '"'?
2371: CC221A  	        call    Z,GETCHR        ; Yes - Get next character
2374: E3      	        ex      (SP),HL         ; Starting quote
2375: 23      	        inc     HL              ; First byte of string
2376: EB      	        ex      DE,HL           ; To DE
2377: 79      	        ld      A,C             ; Get length
2378: CD4D23  	        call    CRTMST          ; Create string entry
237B: 11A481  	TSTOPL: ld      DE,TMPSTR       ; Temporary string
237E: 2A9681  	        ld      HL,(TMSTPT)     ; Temporary string pool pointer
2381: 22C981  	        ld      (FPREG),HL      ; Save address of string ptr
2384: 3E01    	        ld      A,$01
2386: 329281  	        ld      (TYPE),A        ; Set type to string
2389: CDDD2B  	        call    DETHL4          ; Move string to pool
238C: CDF917  	        call    CPDEHL          ; Out of string pool?
238F: 229681  	        ld      (TMSTPT),HL     ; Save new pointer
2392: E1      	        pop     HL              ; Restore code string address
2393: 7E      	        ld      A,(HL)          ; Get next code byte
2394: C0      	        ret     NZ              ; Return if pool OK
2395: 1E1E    	        ld      E,ST            ; ?ST Error
2397: C32F15  	        jp      ERROR           ; String pool overflow
              	
239A: 23      	PRNUMS: inc     HL              ; Skip leading space
239B: CD5923  	PRS:    call    CRTST           ; Create string entry for it
239E: CDDE24  	PRS1:   call    GSTRCU          ; Current string to pool
23A1: CDD12B  	        call    LOADFP          ; Move string block to BCDE
23A4: 1C      	        inc     E               ; Length + 1
23A5: 1D      	PRSLP:  dec     E               ; Count characters
23A6: C8      	        ret     Z               ; End of string
23A7: 0A      	        ld      A,(BC)          ; Get byte to output
23A8: CD0A18  	        call    OUTC            ; Output character in A
23AB: FE0D    	        cp      CR              ; Return?
23AD: CCE51C  	        call    Z,CNTEND        ; Yes - Position cursor to 0
23B0: 03      	        inc     BC              ; Next byte in string
23B1: C3A523  	        jp      PRSLP           ; More characters to output
              	
23B4: B7      	TESTR:  or      A               ; Test if enough room
23B5: 0E      	        defb    $0E             ; No garbage collection done
23B6: F1      	GRBDON: pop     AF              ; Garbage collection done
23B7: F5      	        push    AF              ; Save status
23B8: 2AAD80  	        ld      HL,(STRSPC)     ; Bottom of string space in use
23BB: EB      	        ex      DE,HL           ; To DE
23BC: 2AA881  	        ld      HL,(STRBOT)     ; Bottom of string area
23BF: 2F      	        cpl                     ; Negate length (Top down)
23C0: 4F      	        ld      C,A             ; -Length to BC
23C1: 06FF    	        ld      B,-1            ; BC = -ve length of string
23C3: 09      	        add     HL,BC           ; Add to bottom of space in use
23C4: 23      	        inc     HL              ; Plus one for 2's complement
23C5: CDF917  	        call    CPDEHL          ; Below string RAM area?
23C8: DAD223  	        jp      C,TESTOS        ; Tidy up if not done else err
23CB: 22A881  	        ld      (STRBOT),HL     ; Save new bottom of area
23CE: 23      	        inc     HL              ; Point to first byte of string
23CF: EB      	        ex      DE,HL           ; Address to DE
23D0: F1      	POPAF:  pop     AF              ; Throw away status push
23D1: C9      	        ret
              	
23D2: F1      	TESTOS: pop     AF              ; Garbage collect been done?
23D3: 1E1A    	        ld      E,OS            ; ?OS Error
23D5: CA2F15  	        jp      Z,ERROR         ; Yes - Not enough string space
23D8: BF      	        cp      A               ; Flag garbage collect done
23D9: F5      	        push    AF              ; Save status
23DA: 01B623  	        ld      BC,GRBDON       ; Garbage collection done
23DD: C5      	        push    BC              ; Save for RETurn
23DE: 2A9481  	GARBGE: ld      HL,(LSTRAM)     ; Get end of RAM pointer
23E1: 22A881  	GARBLP: ld      (STRBOT),HL     ; Reset string pointer
23E4: 210000  	        ld      HL,$0000
23E7: E5      	        push    HL              ; Flag no string found
23E8: 2AAD80  	        ld      HL,(STRSPC)     ; Get bottom of string space
23EB: E5      	        push    HL              ; Save bottom of string space
23EC: 219881  	        ld      HL,TMSTPL       ; Temporary string pool
23EF: EB      	GRBLP:  ex      DE,HL
23F0: 2A9681  	        ld      HL,(TMSTPT)     ; Temporary string pool pointer
23F3: EB      	        ex      DE,HL
23F4: CDF917  	        call    CPDEHL          ; Temporary string pool done?
23F7: 01EF23  	        ld      BC,GRBLP        ; Loop until string pool done
23FA: C24324  	        jp      NZ,STPOOL       ; No - See if in string area
23FD: 2ABB81  	        ld      HL,(PROGND)     ; Start of simple variables
2400: EB      	SMPVAR: ex      DE,HL
2401: 2ABD81  	        ld      HL,(VAREND)     ; End of simple variables
2404: EB      	        ex      DE,HL
2405: CDF917  	        call    CPDEHL          ; All simple strings done?
2408: CA1624  	        jp      Z,ARRLP         ; Yes - Do string arrays
240B: 7E      	        ld      A,(HL)          ; Get type of variable
240C: 23      	        inc     HL
240D: 23      	        inc     HL
240E: B7      	        or      A               ; "S" flag set if string
240F: CD4624  	        call    STRADD          ; See if string in string area
2412: C30024  	        jp      SMPVAR          ; Loop until simple ones done
              	
2415: C1      	GNXARY: pop     BC              ; Scrap address of this array
2416: EB      	ARRLP:  ex      DE,HL
2417: 2ABF81  	        ld      HL,(ARREND)     ; End of string arrays
241A: EB      	        ex      DE,HL
241B: CDF917  	        call    CPDEHL          ; All string arrays done?
241E: CA6C24  	        jp      Z,SCNEND        ; Yes - Move string if found
2421: CDD12B  	        call    LOADFP          ; Get array name to BCDE
2424: 7B      	        ld      A,E             ; Get type of array
2425: E5      	        push    HL              ; Save address of num of dim'ns
2426: 09      	        add     HL,BC           ; Start of next array
2427: B7      	        or      A               ; Test type of array
2428: F21524  	        jp      P,GNXARY        ; Numeric array - Ignore it
242B: 22AA81  	        ld      (CUROPR),HL     ; Save address of next array
242E: E1      	        pop     HL              ; Get address of num of dim'ns
242F: 4E      	        ld      C,(HL)          ; BC = Number of dimensions
2430: 0600    	        ld      B,$00
2432: 09      	        add     HL,BC           ; Two bytes per dimension size
2433: 09      	        add     HL,BC
2434: 23      	        inc     HL              ; Plus one for number of dim'ns
2435: EB      	GRBARY: ex      DE,HL
2436: 2AAA81  	        ld      HL,(CUROPR)     ; Get address of next array
2439: EB      	        ex      DE,HL
243A: CDF917  	        call    CPDEHL          ; Is this array finished?
243D: CA1624  	        jp      Z,ARRLP         ; Yes - Get next one
2440: 013524  	        ld      BC,GRBARY       ; Loop until array all done
2443: C5      	STPOOL: push    BC              ; Save return address
2444: F680    	        or      $80             ; Flag string type
2446: 7E      	STRADD: ld      A,(HL)          ; Get string length
2447: 23      	        inc     HL
2448: 23      	        inc     HL
2449: 5E      	        ld      E,(HL)          ; Get LSB of string address
244A: 23      	        inc     HL
244B: 56      	        ld      D,(HL)          ; Get MSB of string address
244C: 23      	        inc     HL
244D: F0      	        ret     P               ; Not a string - Return
244E: B7      	        or      A               ; Set flags on string length
244F: C8      	        ret     Z               ; Null string - Return
2450: 44      	        ld      B,H             ; Save variable pointer
2451: 4D      	        ld      C,L
2452: 2AA881  	        ld      HL,(STRBOT)     ; Bottom of new area
2455: CDF917  	        call    CPDEHL          ; String been done?
2458: 60      	        ld      H,B             ; Restore variable pointer
2459: 69      	        ld      L,C
245A: D8      	        ret     C               ; String done - Ignore
245B: E1      	        pop     HL              ; Return address
245C: E3      	        ex      (SP),HL         ; Lowest available string area
245D: CDF917  	        call    CPDEHL          ; String within string area?
2460: E3      	        ex      (SP),HL         ; Lowest available string area
2461: E5      	        push    HL              ; Re-save return address
2462: 60      	        ld      H,B             ; Restore variable pointer
2463: 69      	        ld      L,C
2464: D0      	        ret     NC              ; Outside string area - Ignore
2465: C1      	        pop     BC              ; Get return , Throw 2 away
2466: F1      	        pop     AF              ;
2467: F1      	        pop     AF              ;
2468: E5      	        push    HL              ; Save variable pointer
2469: D5      	        push    DE              ; Save address of current
246A: C5      	        push    BC              ; Put back return address
246B: C9      	        ret                     ; Go to it
              	
246C: D1      	SCNEND: pop     DE              ; Addresses of strings
246D: E1      	        pop     HL              ;
246E: 7D      	        ld      A,L             ; HL = 0 if no more to do
246F: B4      	        or      H
2470: C8      	        ret     Z               ; No more to do - Return
2471: 2B      	        dec     HL
2472: 46      	        ld      B,(HL)          ; MSB of address of string
2473: 2B      	        dec     HL
2474: 4E      	        ld      C,(HL)          ; LSB of address of string
2475: E5      	        push    HL              ; Save variable address
2476: 2B      	        dec     HL
2477: 2B      	        dec     HL
2478: 6E      	        ld      L,(HL)          ; HL = Length of string
2479: 2600    	        ld      H,$00
247B: 09      	        add     HL,BC           ; Address of end of string+1
247C: 50      	        ld      D,B             ; String address to DE
247D: 59      	        ld      E,C
247E: 2B      	        dec     HL              ; Last byte in string
247F: 44      	        ld      B,H             ; Address to BC
2480: 4D      	        ld      C,L
2481: 2AA881  	        ld      HL,(STRBOT)     ; Current bottom of string area
2484: CDCA14  	        call    MOVSTR          ; Move string to new address
2487: E1      	        pop     HL              ; Restore variable address
2488: 71      	        ld      (HL),C          ; Save new LSB of address
2489: 23      	        inc     HL
248A: 70      	        ld      (HL),B          ; Save new MSB of address
248B: 69      	        ld      L,C             ; Next string area+1 to HL
248C: 60      	        ld      H,B
248D: 2B      	        dec     HL              ; Next string area address
248E: C3E123  	        jp      GARBLP          ; Look for more strings
              	
2491: C5      	CONCAT: push    BC              ; Save prec' opr & code string
2492: E5      	        push    HL              ;
2493: 2AC981  	        ld      HL,(FPREG)      ; Get first string
2496: E3      	        ex      (SP),HL         ; Save first string
2497: CD201F  	        call    OPRND           ; Get second string
249A: E3      	        ex      (SP),HL         ; Restore first string
249B: CD9B1E  	        call    TSTSTR          ; Make sure it's a string
249E: 7E      	        ld      A,(HL)          ; Get length of second string
249F: E5      	        push    HL              ; Save first string
24A0: 2AC981  	        ld      HL,(FPREG)      ; Get second string
24A3: E5      	        push    HL              ; Save second string
24A4: 86      	        add     A,(HL)          ; Add length of second string
24A5: 1E1C    	        ld      E,LS            ; ?LS Error
24A7: DA2F15  	        jp      C,ERROR         ; String too long - Error
24AA: CD4A23  	        call    MKTMST          ; Make temporary string
24AD: D1      	        pop     DE              ; Get second string to DE
24AE: CDE224  	        call    GSTRDE          ; Move to string pool if needed
24B1: E3      	        ex      (SP),HL         ; Get first string
24B2: CDE124  	        call    GSTRHL          ; Move to string pool if needed
24B5: E5      	        push    HL              ; Save first string
24B6: 2AA681  	        ld      HL,(TMPSTR+2)   ; Temporary string address
24B9: EB      	        ex      DE,HL           ; To DE
24BA: CDC824  	        call    SSTSA           ; First string to string area
24BD: CDC824  	        call    SSTSA           ; Second string to string area
24C0: 21B51E  	        ld      HL,EVAL2        ; Return to evaluation loop
24C3: E3      	        ex      (SP),HL         ; Save return,get code string
24C4: E5      	        push    HL              ; Save code string address
24C5: C37B23  	        jp      TSTOPL          ; To temporary string to pool
              	
24C8: E1      	SSTSA:  pop     HL              ; Return address
24C9: E3      	        ex      (SP),HL         ; Get string block,save return
24CA: 7E      	        ld      A,(HL)          ; Get length of string
24CB: 23      	        inc     HL
24CC: 23      	        inc     HL
24CD: 4E      	        ld      C,(HL)          ; Get LSB of string address
24CE: 23      	        inc     HL
24CF: 46      	        ld      B,(HL)          ; Get MSB of string address
24D0: 6F      	        ld      L,A             ; Length to L
24D1: 2C      	TOSTRA: inc     L               ; inc - DECed after
24D2: 2D      	TSALP:  dec     L               ; Count bytes moved
24D3: C8      	        ret     Z               ; End of string - Return
24D4: 0A      	        ld      A,(BC)          ; Get source
24D5: 12      	        ld      (DE),A          ; Save destination
24D6: 03      	        inc     BC              ; Next source
24D7: 13      	        inc     DE              ; Next destination
24D8: C3D224  	        jp      TSALP           ; Loop until string moved
              	
24DB: CD9B1E  	GETSTR: call    TSTSTR          ; Make sure it's a string
24DE: 2AC981  	GSTRCU: ld      HL,(FPREG)      ; Get current string
24E1: EB      	GSTRHL: ex      DE,HL           ; Save DE
24E2: CDFC24  	GSTRDE: call    BAKTMP          ; Was it last tmp-str?
24E5: EB      	        ex      DE,HL           ; Restore DE
24E6: C0      	        ret     NZ              ; No - Return
24E7: D5      	        push    DE              ; Save string
24E8: 50      	        ld      D,B             ; String block address to DE
24E9: 59      	        ld      E,C
24EA: 1B      	        dec     DE              ; Point to length
24EB: 4E      	        ld      C,(HL)          ; Get string length
24EC: 2AA881  	        ld      HL,(STRBOT)     ; Current bottom of string area
24EF: CDF917  	        call    CPDEHL          ; Last one in string area?
24F2: C2FA24  	        jp      NZ,POPHL        ; No - Return
24F5: 47      	        ld      B,A             ; Clear B (A=0)
24F6: 09      	        add     HL,BC           ; Remove string from str' area
24F7: 22A881  	        ld      (STRBOT),HL     ; Save new bottom of str' area
24FA: E1      	POPHL:  pop     HL              ; Restore string
24FB: C9      	        ret
              	
24FC: 2A9681  	BAKTMP: ld      HL,(TMSTPT)     ; Get temporary string pool top
24FF: 2B      	        dec     HL              ; Back
2500: 46      	        ld      B,(HL)          ; Get MSB of address
2501: 2B      	        dec     HL              ; Back
2502: 4E      	        ld      C,(HL)          ; Get LSB of address
2503: 2B      	        dec     HL              ; Back
2504: 2B      	        dec     HL              ; Back
2505: CDF917  	        call    CPDEHL          ; String last in string pool?
2508: C0      	        ret     NZ              ; Yes - Leave it
2509: 229681  	        ld      (TMSTPT),HL     ; Save new string pool top
250C: C9      	        ret
              	
250D: 018C22  	LEN:    ld      BC,PASSA        ; To return integer A
2510: C5      	        push    BC              ; Save address
2511: CDDB24  	GETLEN: call    GETSTR          ; Get string and its length
2514: AF      	        xor     A
2515: 57      	        ld      D,A             ; Clear D
2516: 329281  	        ld      (TYPE),A        ; Set type to numeric
2519: 7E      	        ld      A,(HL)          ; Get length of string
251A: B7      	        or      A               ; Set status flags
251B: C9      	        ret
              	
251C: 018C22  	ASC:    ld      BC,PASSA        ; To return integer A
251F: C5      	        push    BC              ; Save address
2520: CD1125  	GTFLNM: call    GETLEN          ; Get length of string
2523: CAED1A  	        jp      Z,FCERR         ; Null string - Error
2526: 23      	        inc     HL
2527: 23      	        inc     HL
2528: 5E      	        ld      E,(HL)          ; Get LSB of address
2529: 23      	        inc     HL
252A: 56      	        ld      D,(HL)          ; Get MSB of address
252B: 1A      	        ld      A,(DE)          ; Get first byte of string
252C: C9      	        ret
              	
252D: 3E01    	CHR:    ld      A,$01           ; One character string
252F: CD4A23  	        call    MKTMST          ; Make a temporary string
2532: CD2626  	        call    MAKINT          ; Make it integer A
2535: 2AA681  	        ld      HL,(TMPSTR+2)   ; Get address of string
2538: 73      	        ld      (HL),E          ; Save character
2539: C1      	TOPOOL: pop     BC              ; Clean up stack
253A: C37B23  	        jp      TSTOPL          ; Temporary string to pool
              	
253D: CDD625  	LEFT:   call    LFRGNM          ; Get number and ending ")"
2540: AF      	        xor     A               ; Start at first byte in string
2541: E3      	RIGHT1: ex      (SP),HL         ; Save code string,Get string
2542: 4F      	        ld      C,A             ; Starting position in string
2543: E5      	MID1:   push    HL              ; Save string block address
2544: 7E      	        ld      A,(HL)          ; Get length of string
2545: B8      	        cp      B               ; Compare with number given
2546: DA4B25  	        jp      C,ALLFOL        ; All following bytes required
2549: 78      	        ld      A,B             ; Get new length
254A: 11      	        defb    $11             ; Skip "ld C,0"
254B: 0E00    	ALLFOL: ld      C,$00           ; First byte of string
254D: C5      	        push    BC              ; Save position in string
254E: CDB423  	        call    TESTR           ; See if enough string space
2551: C1      	        pop     BC              ; Get position in string
2552: E1      	        pop     HL              ; Restore string block address
2553: E5      	        push    HL              ; And re-save it
2554: 23      	        inc     HL
2555: 23      	        inc     HL
2556: 46      	        ld      B,(HL)          ; Get LSB of address
2557: 23      	        inc     HL
2558: 66      	        ld      H,(HL)          ; Get MSB of address
2559: 68      	        ld      L,B             ; HL = address of string
255A: 0600    	        ld      B,$00           ; BC = starting address
255C: 09      	        add     HL,BC           ; Point to that byte
255D: 44      	        ld      B,H             ; BC = source string
255E: 4D      	        ld      C,L
255F: CD4D23  	        call    CRTMST          ; Create a string entry
2562: 6F      	        ld      L,A             ; Length of new string
2563: CDD124  	        call    TOSTRA          ; Move string to string area
2566: D1      	        pop     DE              ; Clear stack
2567: CDE224  	        call    GSTRDE          ; Move to string pool if needed
256A: C37B23  	        jp      TSTOPL          ; Temporary string to pool
              	
256D: CDD625  	RIGHT:  call    LFRGNM          ; Get number and ending ")"
2570: D1      	        pop     DE              ; Get string length
2571: D5      	        push    DE              ; And re-save
2572: 1A      	        ld      A,(DE)          ; Get length
2573: 90      	        sub     B               ; Move back N bytes
2574: C34125  	        jp      RIGHT1          ; Go and get sub-string
              	
2577: EB      	MID:    ex      DE,HL           ; Get code string address
2578: 7E      	        ld      A,(HL)          ; Get next byte ',' or ")"
2579: CDDB25  	        call    MIDNUM          ; Get number supplied
257C: 04      	        inc     B               ; Is it character zero?
257D: 05      	        dec     B
257E: CAED1A  	        jp      Z,FCERR         ; Yes - Error
2581: C5      	        push    BC              ; Save starting position
2582: 1EFF    	        ld      E,$FF           ; All of string
2584: FE29    	        cp      ')'             ; Any length given?
2586: CA9025  	        jp      Z,RSTSTR        ; No - Rest of string
2589: CDFF17  	        call    CHKSYN          ; Make sure ',' follows
258C: 2C      	        defb    ','
258D: CD2326  	        call    GETINT          ; Get integer 0-255
2590: CDFF17  	RSTSTR: call    CHKSYN          ; Make sure ")" follows
2593: 29      	        defb    ')'
2594: F1      	        pop     AF              ; Restore starting position
2595: E3      	        ex      (SP),HL         ; Get string,save code string
2596: 014325  	        ld      BC,MID1         ; Continuation of MID$ routine
2599: C5      	        push    BC              ; Save for return
259A: 3D      	        dec     A               ; Starting position-1
259B: BE      	        cp      (HL)            ; Compare with length
259C: 0600    	        ld      B,$00           ; Zero bytes length
259E: D0      	        ret     NC              ; Null string if start past end
259F: 4F      	        ld      C,A             ; Save starting position-1
25A0: 7E      	        ld      A,(HL)          ; Get length of string
25A1: 91      	        sub     C               ; Subtract start
25A2: BB      	        cp      E               ; Enough string for it?
25A3: 47      	        ld      B,A             ; Save maximum length available
25A4: D8      	        ret     C               ; Truncate string if needed
25A5: 43      	        ld      B,E             ; Set specified length
25A6: C9      	        ret                     ; Go and create string
              	
25A7: CD1125  	VAL:    call    GETLEN          ; Get length of string
25AA: CA5129  	        jp      Z,RESZER        ; Result zero
25AD: 5F      	        ld      E,A             ; Save length
25AE: 23      	        inc     HL
25AF: 23      	        inc     HL
25B0: 7E      	        ld      A,(HL)          ; Get LSB of address
25B1: 23      	        inc     HL
25B2: 66      	        ld      H,(HL)          ; Get MSB of address
25B3: 6F      	        ld      L,A             ; HL = String address
25B4: E5      	        push    HL              ; Save string address
25B5: 19      	        add     HL,DE
25B6: 46      	        ld      B,(HL)          ; Get end of string+1 byte
25B7: 72      	        ld      (HL),D          ; Zero it to terminate
25B8: E3      	        ex      (SP),HL         ; Save string end,get start
25B9: C5      	        push    BC              ; Save end+1 byte
25BA: 7E      	        ld      A,(HL)          ; Get starting byte
25BB: FE24    	        cp      '$'             ; Hex number indicated? [function added]
25BD: C2C525  	        jp      NZ,VAL1
25C0: CD6A39  	        call    HEXTFP          ; Convert Hex to FPREG
25C3: 180D    	        jr      VAL3
25C5: FE25    	VAL1:   cp      '%'             ; Binary number indicated? [function added]
25C7: C2CF25  	        jp      NZ,VAL2
25CA: CDDA39  	        call    BINTFP          ; Convert Bin to FPREG
25CD: 1803    	        jr      VAL3
25CF: CD892C  	VAL2:   call    ASCTFP          ; Convert ASCII string to FP
25D2: C1      	VAL3:   pop     BC              ; Restore end+1 byte
25D3: E1      	        pop     HL              ; Restore end+1 address
25D4: 70      	        ld      (HL),B          ; Put back original byte
25D5: C9      	        ret
              	
25D6: EB      	LFRGNM: ex      DE,HL           ; Code string address to HL
25D7: CDFF17  	        call    CHKSYN          ; Make sure ")" follows
25DA: 29      	        defb    ')'
25DB: C1      	MIDNUM: pop     BC              ; Get return address
25DC: D1      	        pop     DE              ; Get number supplied
25DD: C5      	        push    BC              ; Re-save return address
25DE: 43      	        ld      B,E             ; Number to B
25DF: C9      	        ret
              	
25E0: CD2626  	INP:    call    MAKINT          ; Make it integer A
25E3: 32A080  	        ld      (INPORT),A      ; Set input port
25E6: CD9F80  	        call    INPSUB          ; Get input from port
25E9: C38C22  	        jp      PASSA           ; Return integer A
              	
25EC: CD1026  	POUT:   call    SETIO           ; Set up port number
25EF: C36780  	        jp      OUTSUB          ; Output data and return
              	
25F2: CD1026  	WAIT:   call    SETIO           ; Set up port number
25F5: F5      	        push    AF              ; Save AND mask
25F6: 1E00    	        ld      E,$00           ; Assume zero if none given
25F8: 2B      	        dec     HL              ; dec 'cos GETCHR INCs
25F9: CD221A  	        call    GETCHR          ; Get next character
25FC: CA0626  	        jp      Z,NOXOR         ; No XOR byte given
25FF: CDFF17  	        call    CHKSYN          ; Make sure ',' follows
2602: 2C      	        defb    ','
2603: CD2326  	        call    GETINT          ; Get integer 0-255 to XOR with
2606: C1      	NOXOR:  pop     BC              ; Restore AND mask
2607: CD9F80  	WAITLP: call    INPSUB          ; Get input
260A: AB      	        xor     E               ; Flip selected bits
260B: A0      	        and     B               ; Result non-zero?
260C: CA0726  	        jp      Z,WAITLP        ; No = keep waiting
260F: C9      	        ret
              	
2610: CD2326  	SETIO:  call    GETINT          ; Get integer 0-255
2613: 32A080  	        ld      (INPORT),A      ; Set input port
2616: 326880  	        ld      (OTPORT),A      ; Set output port
2619: CDFF17  	        call    CHKSYN          ; Make sure ',' follows
261C: 2C      	        defb    ','
261D: C32326  	        jp      GETINT          ; Get integer 0-255 and return
              	
2620: CD221A  	FNDNUM: call    GETCHR          ; Get next character
2623: CD971E  	GETINT: call    GETNUM          ; Get a number from 0 to 255
2626: CDD21A  	MAKINT: call    DEPINT          ; Make sure value 0 - 255
2629: 7A      	        ld      A,D             ; Get MSB of number
262A: B7      	        or      A               ; Zero?
262B: C2ED1A  	        jp      NZ,FCERR        ; No - Error
262E: 2B      	        dec     HL              ; dec 'cos GETCHR INCs
262F: CD221A  	        call    GETCHR          ; Get next character
2632: 7B      	        ld      A,E             ; Get number to A
2633: C9      	        ret
              	
              	
              	; activate a Non-Maskable Interrupt hooked to VDP interrupt signal
2634: CD971E  	NMI:    call    GETNUM          ; Get memory address
2637: CDD81A  	        call    DEINT           ; get integer -32768 to 32767
263A: 7B      	        ld      A,E             ; check if address is 0
263B: B2      	        or      D
263C: 2011    	        jr      NZ,NM1          ; no, so jump over
263E: F3      	        di                      ; disable INTs
263F: CD6B26  	        call    NMIDINT         ; disable VDP INT
2642: E5      	        push    HL              ; store HL
2643: 21ED45  	        ld      HL,$45ED        ; these are the op-codes for "RETN"
2646: 226180  	        ld      (NMIUSR),HL     ; store RETN
2649: AF      	        xor     A
264A: 326380  	        ld      (NMIUSR+2),A    ; "NOP"
264D: 1811    	        jr      NMI2            ; execute the last part of code
264F: E5      	NM1:    push    HL              ; store current HL
2650: EB      	        ex      DE,HL           ; move address argument into HL
2651: F3      	        di                      ; disable INTs
2652: CD6B26  	        call    NMIDINT         ; disable VDP INT, if enabled
2655: 3EC3    	        ld      A,$C3           ; "jp" instruction
2657: 326180  	        ld      (NMIUSR),A      ; store it
265A: 226280  	        ld      (NMIUSR+1),HL   ; store address
265D: CD6426  	        call    NMIEINT         ; re-enable VDP INT
2660: FB      	NMI2:   ei                      ; re-enable INTS
2661: 00      	        nop                     ; wait for INTs
2662: E1      	        pop    HL               ; retrieve HL
2663: C9      	        ret                     ; return to caller
              	; enable VDP INT
2664: CD7A26  	NMIEINT:call    NMIVR1          ; load default VReg #1 setting
2667: F620    	        or      %00100000       ; enable VDP INT
2669: 1803    	        jr      NMIINT          ; rest of code is shared
              	; disable VDP INT
266B: CD7A26  	NMIDINT:call    NMIVR1          ; load default VReg #1 setting
266E: D5      	NMIINT: push    DE              ; store DE
266F: 5F      	        ld      E,A             ; move value into E
2670: 3E01    	        ld      A,$01           ; VREG #1
2672: F3      	        di                      ; disable INTs
2673: CD2A06  	        call    WRITE_VREG      ; disable VDP INT
2676: FB      	        ei                      ; re-enable INTs
2677: 00      	        nop                     ; wait for INTs being enabled
2678: D1      	        pop     DE              ; retrieve DE
2679: C9      	        ret                     ; return to caller
              	
              	; load VREG #1 setting for current screen mode and return it into A
267A: E5      	NMIVR1: push    HL              ; store HL
267B: D5      	        push    DE              ; store DE
267C: 3AE081  	        ld      A,(SCR_MODE)    ; check screen mode
267F: 87      	        add     A,A             ; multiply A by 8...
2680: 87      	        add     A,A             ; ...so that reg. A can points..
2681: 87      	        add     A,A             ; to the correct settings
2682: 3C      	        inc     A               ; need to change VREG 1
2683: 5F      	        ld      E,A             ; copy A into E
2684: 1600    	        ld      D,$00           ; reset D
2686: 212B0A  	        ld      HL,VDPMODESET   ; pointer to register #1 setting...
2689: 19      	        add     HL,DE           ; ...for current screen mode
268A: 7E      	        ld      A,(HL)          ; load current setting
268B: D1      	        pop     DE              ; retrieve DE
268C: E1      	        pop     HL              ; retrieve HL
268D: C9      	        ret                     ; return to caller
              	
              	; execute a machine language routine, eventually passing a param into A
268E: CD971E  	SYS:    call    GETNUM          ; Get memory address
2691: CDD81A  	        call    DEINT           ; Get integer -32768 to 32767
2694: D5      	        push    DE              ; store address
2695: AF      	        xor     A               ; reset A
2696: 32EF81  	        ld      (TMPBFR1),A     ; store into temp buffer
2699: 2B      	        dec     HL              ; dec 'cos GETCHR INCs
269A: CD221A  	        call    GETCHR          ; Get next character
269D: 280A    	        jr      Z,NOSYSPR       ; jump if nothing follows
269F: CDFF17  	        call    CHKSYN          ; Make sure ',' follows
26A2: 2C      	        defb    ','
26A3: CD2326  	        call    GETINT          ; get value if something follows
26A6: 32EF81  	        ld      (TMPBFR1),A     ; store into temp buffer
26A9: 3AEF81  	NOSYSPR:ld      A,(TMPBFR1)     ; recover A
26AC: D1      	        pop     DE              ; recover user routine's address
26AD: E5      	        push    HL              ; save current HL
26AE: EB      	        ex      DE,HL           ; move address into HL
26AF: 11B426  	        ld      DE,SYSRET       ; recover point to return to after the user routine
26B2: D5      	        push    DE              ; store into stack
26B3: E9      	        jp      HL              ; execute user routine
26B4: E1      	SYSRET: pop     HL              ; retrieve HL
26B5: C9      	        ret                     ; return to caller
              	
              	
              	; read the contents of a byte from RAM
26B6: CDD81A  	PEEK:   call    DEINT           ; Get memory address
26B9: 1A      	        ld      A,(DE)          ; Get byte in memory
26BA: C38C22  	        jp      PASSA           ; Return integer A
              	
              	; read the contents of a byte from VRAM
26BD: CDD81A  	VPEEK:  call    DEINT           ; Get VRAM address into DE
26C0: EB      	        ex      DE,HL           ; Copy param into HL
26C1: F3      	        di                      ; Disable interrupts
26C2: CD0006  	        call    READ_VIDEO_LOC  ; Read data from VRAM at address HL
26C5: FB      	        ei                      ; Re-enable interrupts
26C6: EB      	        ex      DE,HL           ; Restore HL
26C7: C38C22  	        jp      PASSA           ; Return value into A
              	
              	; recover params for POKE/VPOKE commands
              	; returns address into DE and byte to be written into A
26CA: CD971E  	PKEPRMS:call    GETNUM          ; Get memory address
26CD: CDD81A  	        call    DEINT           ; Get integer -32768 to 32767
26D0: ED53EF81	        ld      (TMPBFR1),DE    ; Store DE into a temp. buffer
26D4: CDFF17  	        call    CHKSYN          ; Make sure ',' follows
26D7: 2C      	        defb    ','
26D8: CD2326  	        call    GETINT          ; Get integer 0-255
26DB: ED5BEF81	        ld      DE,(TMPBFR1)    ; Restore memory address
26DF: C9      	        ret                     ; Return to caller
              	
              	; write a byte into SRAM
26E0: CDCA26  	POKE:   call    PKEPRMS         ; Get params: address and value, return into DE and A, resp.
26E3: 12      	        ld      (DE),A          ; Load it into memory
26E4: C9      	        ret
              	
              	; write a byte into VRAM
26E5: CDCA26  	VPOKE:  call    PKEPRMS         ; Get params: address and value, return into DE and A, resp.
26E8: EB      	        ex      DE,HL           ; Copy address into HL
26E9: F3      	        di                      ; Disable interrupts
26EA: CD1506  	        call    WRITE_VIDEO_LOC ; write data into VRAM at address HL
26ED: FB      	        ei                      ; Re-enable interrupts
26EE: EB      	        ex      DE,HL           ; Restore HL
26EF: C9      	        ret                     ; Return to caller
              	
              	; position the cursor at a specific X,Y location onto screen
26F0: CD2326  	LOCATE: call    GETINT          ; get the first param into A
26F3: E5      	        push    HL              ; store HL
26F4: 21DE81  	        ld      HL,SCR_SIZE_W   ; load address of screen width
26F7: 5E      	        ld      E,(HL)          ; load screen width into E
26F8: E1      	        pop     HL              ; restore HL
26F9: BB      	        cp      E               ; compare witdh with param
26FA: D2ED1A  	        jp      NC,FCERR        ; value over the width of the screen, exit with Illegal F.C. error
26FD: 32EF81  	        ld      (TMPBFR1),A     ; Store X into a temp. buffer
2700: CDFF17  	        call    CHKSYN          ; Make sure ',' follows
2703: 2C      	        defb    ','
2704: CD2326  	        call    GETINT          ; Get the second param into A
2707: E5      	        push    HL              ; store HL
2708: 21DF81  	        ld      HL,SCR_SIZE_H   ; load address of screen width
270B: 5E      	        ld      E,(HL)          ; load screen width into A
270C: E1      	        pop     HL              ; restore HL
270D: BB      	        cp      E               ; compare witdh with param
270E: D2ED1A  	        jp      NC,FCERR        ; value over the height of the screen, exit with Illegal F.C. error
2711: 32E781  	        ld      (SCR_CUR_NY),A  ; store new Y
2714: 3AEF81  	        ld      A,(TMPBFR1)     ; recover the new X
2717: 32E681  	        ld      (SCR_CUR_NX),A  ; store new X
271A: E5      	        push    HL              ; store HL
271B: F3      	        di                      ; disable INTs
271C: CD4606  	        call    MOVCRS          ; move cursor to new location
271F: FB      	        ei                      ; re-enable INTs
2720: E1      	        pop     HL              ; restore HL
2721: C9      	        ret                     ; return to caller
              	
              	; write a byte into one of the PSG registers
2722: CD2326  	SREG:   call    GETINT          ; Get register number back into A
2725: FE10    	        cp      $10             ; check if value >= 16 (PSG registers go from 0 to 15)
2727: D2ED1A  	        jp      NC,FCERR        ; If yes, exit and raise an Illegal function call Error
272A: 32EF81  	        ld      (TMPBFR1),A     ; Store A into a temp. buffer
272D: CDFF17  	        call    CHKSYN          ; Make sure ',' follows
2730: 2C      	        defb    ','
2731: CD2326  	        call    GETINT          ; get second value (0-255), returned into A
2734: 5F      	        ld      E,A             ; store value into E
2735: 3AEF81  	        ld      A,(TMPBFR1)     ; recover VDP register and store into D
2738: 0E40    	        ld      C,PSG_REG       ; output port to access PSG registers
273A: ED79    	        out     (C),A           ; send register # to PSG
273C: 0E41    	        ld      C,PSG_DAT       ; output port to send data to PSG
273E: ED59    	        out     (C),E           ; send byte to write into selected register
2740: C9      	        ret                     ; return to caller
              	
              	; VOLUME ch,vol
              	; set the volume for the audio channels
              	; "ch" is 1~3 for corresponding channel, or 0 for all; "vol" is 0~15 (0=OFF, 15=MAX)
2741: CD2326  	VOLUME: call    GETINT          ; get integer 0-255 (recover channel)
2744: FE04    	        cp      $04             ; check if it's in the range 0~3
2746: D2ED1A  	        jp      NC,FCERR        ; if not, exit with Illegal function call error
2749: 32EF81  	        ld      (TMPBFR1),A     ; Store A into a temp. buffer
274C: CDFF17  	        call    CHKSYN          ; Make sure ',' follows
274F: 2C      	        defb    ','
2750: CD2326  	        call    GETINT          ; get integer 0-255 (recover channel)
2753: FE10    	        cp      $10             ; check if it's in the range 0~15
2755: D2ED1A  	        jp      NC,FCERR        ; if not, exit with Illegal funcion call
2758: 57      	        ld      D,A             ; store volume into D
2759: 3AEF81  	        ld      A,(TMPBFR1)     ; retrieve channel
275C: A7      	        and     A               ; is it 0? (0=every channel)
275D: 2010    	        jr      NZ,VOLCH        ; no, jump over
275F: 0603    	        ld      B,$03           ; yes, set every channel
2761: 1E08    	        ld      E,$08           ; register volume of first channel
2763: 0E40    	RPVOLCG:ld      C,PSG_REG       ; PSG register port
2765: ED59    	        out     (C),E           ; set register #
2767: 0E41    	        ld      C,PSG_DAT       ; PSG data port
2769: ED51    	        out     (C),D           ; send volume
276B: 1C      	        inc     E               ; next register
276C: 10F5    	        djnz    RPVOLCG         ; repeat for each channel
276E: C9      	        ret                     ; return to caller
276F: 0E40    	VOLCH:  ld      C,PSG_REG       ; PSG register port
2771: C607    	        add     $07             ; add 7 to A so that we have the correct register (1->8, 2->9, 3->10)
2773: ED79    	        out     (C),A           ; set register
2775: 0E41    	        ld      C,PSG_DAT       ; PSG data port
2777: ED51    	        out     (C),D           ; send volume level
2779: C9      	        ret                     ; return to caller
              	
              	; SOUND ch,tone,dur
              	; play a tone or noise of "tone" frequency from selected channel "ch" for duration "dur"
              	; "ch" is 1~6 (0=means sound OFF,1~3 for tone, 4~6 for noise) / "tone" is 1~4,095 (0=means no tone) /
              	; "dur" is 1~16383 h.o.s.,0.001~163s (0=means non-stop tone)
277A: CD2326  	SOUND:  call    GETINT          ; get integer 0-255 (recover channel)
277D: A7      	        and     A               ; is it zero?
277E: 2006    	        jr      NZ,CTSNDC       ; no, continue with checking of params
2780: E5      	        push    HL              ; store HL
2781: CD9D0B  	        call    CLRPSGREGS      ; yes, it's zero, so reset PSG registers to shut down every sound
2784: E1      	        pop     HL              ; retrieve HL
2785: C9      	        ret                     ; return to caller
2786: 32EF81  	CTSNDC: ld      (TMPBFR1),A     ; no, continue by storing A into a temp. buffer
2789: FE04    	        cp      $04             ; is channel >3?
278B: D20B28  	        jp      NC,NOISUP       ; Yes - check to see if it's a noise channel
278E: CDFF17  	        call    CHKSYN          ; No, continue checking by making sure ',' follows
2791: 2C      	        defb    ','
2792: CD971E  	        call    GETNUM          ; Get tone frequency
2795: CDD81A  	        call    DEINT           ; Get integer -32768 to 32767
2798: ED53F181	        ld      (TMPBFR2),DE    ; Store frequency
279C: CDFF17  	        call    CHKSYN          ; Make sure ',' follows
279F: 2C      	        defb    ','
27A0: CD971E  	        call    GETNUM          ; Get duration
27A3: CDD81A  	        call    DEINT           ; Get integer -32768 to 32767
27A6: ED53F381	        ld      (TMPBFR3),DE    ; Store duration
              	                                ; CHECK CHANNEL
27AA: 3AEF81  	        ld      A,(TMPBFR1)     ; recover channel
27AD: FE01    	        cp      $01             ; is channel <1?
27AF: DAED1A  	        jp      C,FCERR         ; Yes - Illegal function call error
              	                                ; CHECK FREQUENCY
27B2: ED5BF181	        ld      DE,(TMPBFR2)    ; restore frequency from temp buffer
27B6: 7A      	        ld      A,D             ; move D into A and check if it is in the range 0~4095...
27B7: FE10    	        cp      $10             ; ...so D must not be greater than $0F (15)
27B9: D2ED1A  	        jp      NC,FCERR        ; if not in the range, exit with an Illegal function call error
              	                                ; CHECK DURATION
27BC: ED5BF381	        ld      DE,(TMPBFR3)    ; restore duration from temp buffer
27C0: 7A      	        ld      A,D             ; check if it is in the range 0~16383...
27C1: E6C0    	        and     $C0             ; ...(15th & 14th bits must not be set)
27C3: C2ED1A  	        jp      NZ,FCERR        ; if not in the range, exit with an Illegal function call error
              	                                ;
              	                                ; SET TONE:
              	                                ; let's start by setting up the channel
27C6: 3AEF81  	        ld      A,(TMPBFR1)     ; restore channel value
27C9: FE03    	        cp      $03             ; is it 3?
27CB: 2002    	        jr      NZ,SND1         ; no, jump over
27CD: 3E04    	        ld      A,%00000100     ; yes, for ch.3, set 3rd bit only (so A=001, B=010, C=100)
27CF: 2F      	SND1:   cpl                     ; complement of A - this is used later to set on the channel into the mixer
27D0: CD4928  	        call    WRTSND          ; enable line into mixer of channel stored in A
              	                                ; SET FREQUENCY
              	                                ; we simply get frequency and subtract from 4096. The result
              	                                ; is put into register pair of the corresponding freq tone channel
27D3: ED5BF181	        ld      DE,(TMPBFR2)    ; restore frequency from temp buffer
27D7: E5      	        push    HL              ; store HL (it will be used by the subroutine)
27D8: 210010  	        ld      HL,$1000        ; load 4096 into HL
27DB: A7      	        and     A               ; reset C flag
27DC: ED52    	        sbc     HL,DE           ; subtract freq from HL - now the frequency is inverted, so we will send the low as high and vice-versa
27DE: 3AEF81  	        ld      A,(TMPBFR1)     ; restore channel value
27E1: 3D      	        dec     A               ; set A into the range 0~2
27E2: 87      	        add     A,A             ; double A to find the register pair that correspond to the channel (A->0,1 / B->2,3, C->4,5)
27E3: 0E40    	        ld      C,PSG_REG       ; PSG register port
27E5: ED79    	        out     (C),A           ; select first register of the pair
27E7: 0E41    	        ld      C,PSG_DAT       ; PSG data port
27E9: ED69    	        out     (C),L           ; send high byte
27EB: 0E40    	        ld      C,PSG_REG       ; PSG register support
27ED: 3C      	        inc     A               ; second register of the pair
27EE: ED79    	        out     (C),A           ; select register
27F0: 0E41    	        ld      C,PSG_DAT       ; PSG data port
27F2: ED61    	        out     (C),H           ; send low byte
27F4: ED5BF381	        ld      DE,(TMPBFR3)    ; recover duration
27F8: 3AEF81  	        ld      A,(TMPBFR1)     ; recover channel value
27FB: 3D      	        dec     A               ; set channel into the range 0~2
27FC: 87      	        add     A,A             ; double A to find the correct offset
27FD: 212382  	        ld      HL,CHASNDDTN    ; set duration into...
2800: 85      	        add     A,L             ; ...the proper...
2801: 3001    	        jr      NC,SNDOVR       ; (is there a rest? no, jump over
2803: 24      	        inc     H               ; yes, increment H)
2804: 6F      	SNDOVR: ld      L,A             ; ...register pair...
2805: 7323722B	        ld      (HL),DE         ; ...and store the value
2809: E1      	        pop     HL              ; retrieve HL
280A: C9      	        ret                     ; Return to caller
280B: FE07    	NOISUP: cp      $07             ; is channel in range 4 to 6 (for a noise)?
280D: D2ED1A  	        jp      NC,FCERR        ; no, so ILLEGAL FUNCTION CALL
2810: CDFF17  	        call    CHKSYN          ; yes, continue checking by making sure ',' follows
2813: 2C      	        defb    ','
2814: CD2326  	        call    GETINT          ; get integer 0-255 (recover frequency)
2817: FE20    	        cp      $20             ; make sure it's in range 0~31
2819: D2ED1A  	        jp      NC,FCERR        ; no, so Illegal function call
281C: 5F      	        ld      E,A             ; store freq into E
281D: 3AEF81  	        ld      A,(TMPBFR1)     ; retrieve channel
2820: D603    	        sub     $03             ; subtract 3 to get channel in range 1~3
2822: FE03    	        cp      $03             ; is it 3?
2824: 2002    	        jr      NZ,NOS1         ; no, jump over
2826: 3E04    	        ld      A,%00000100     ; yes, for ch.3, set 3rd bit only (so A=001, B=010, C=100)
2828: 87      	NOS1:   add     A,A
2829: 87      	        add     A,A
282A: 87      	        add     A,A             ; let's move A 3 bits to left
282B: 47      	        ld      B,A             ; store channel into B
282C: 7B      	        ld      A,E             ; check if
282D: A7      	        and     A               ; freq is 0 (means that noise reproduction must be halted)
282E: 200A    	        jr      NZ,NOS2         ; no, so jump over
2830: 3E07    	        ld      A,$07           ; mixer register
2832: CDEB0B  	        call    SETSNDREG       ; set mixer register
2835: ED78    	        in      A,(C)           ; load current mixer value
2837: B0      	        or      B               ; disable noise
2838: 1818    	        jr      NOS3            ; continue over
283A: 78      	NOS2:   ld      A,B             ; recover channel
283B: 2F      	        cpl                     ; complement of A - this is used to set on the channel into the mixer
283C: CD4928  	        call    WRTSND          ; enable line into mixer of channel stored in A
283F: 3E06    	        ld      A,$06           ; write into noise register
2841: CDEB0B  	        call    SETSNDREG       ; set register into PSG
2844: 7B      	        ld      A,E             ; load value for noise frequency
2845: CDF00B  	        call    WRTSNDREG       ; write data into register $06
2848: C9      	        ret
              	        ; enable line into mixer of channel stored in A
2849: 47      	WRTSND: ld      B,A             ; move channel into B
284A: 3E07    	        ld      A,$07           ; mixer register
284C: CDEB0B  	        call    SETSNDREG       ; set mixer register
284F: ED78    	        in      A,(C)           ; load current value
2851: A0      	        and     B               ; set on the channel into the mixer (remember that 0=ON)
              	                                ; example: if channel is A (1), complement of 1 is 254 (11111110). So, 255 (in case
              	                                ; the register is still unchanged after reset) is 11111111 and
              	                                ; 11111111 AND 11111110 is equal to 11111110
              	                                ; 11111001 AND 11111110 is equal to 11111000 (in case channels B & C are ON)
2852: 47      	NOS3:   ld      B,A
2853: 3E07    	        ld      A,$07
2855: CDEB0B  	        call    SETSNDREG
2858: 78      	        ld      A,B
2859: 00      	        nop
285A: CDF00B  	        call    WRTSNDREG       ; send new value for the mixer
285D: C9      	        ret                     ; return to caller
              	
              	; write a byte into one of the VDP registers
285E: CD2326  	VREG:   call    GETINT          ; Get register number back into A
2861: FE08    	        cp      $08             ; check if value is equal or greater than 8 (VDP registers are only 8, from 0 to 7)
2863: D2ED1A  	        jp      NC,FCERR        ; If yes, exit and raise an Illegal function call Error
2866: 32EF81  	        ld      (TMPBFR1),A     ; Store A into a temp. buffer
2869: CDFF17  	        call    CHKSYN          ; Make sure ',' follows
286C: 2C      	        defb    ','
286D: CD2326  	        call    GETINT          ; get value (0-255)
2870: 5F      	        ld      E,A             ; store value into E
2871: 3AEF81  	        ld      A,(TMPBFR1)     ; recover VDP register and store into A
2874: F3      	        di                      ; disable INTs
2875: CD2A06  	        call    WRITE_VREG      ; write value into VDP register
2878: FB      	        ei                      ; re-enable INTs
2879: C9      	        ret                     ; return to caller
              	
              	; read the VDP status register and return it into A
287A: CDD81A  	VSTAT:  call    DEINT           ; Get integer -32768 to 32767 (Note: we do NOT use it)
287D: F3      	        di                      ; disable INTs
287E: CD3506  	        call    READ_VSTAT      ; read VDP register status
2881: FB      	        ei                      ; re-enable INTs
2882: C38C22  	        jp      PASSA           ; Return integer A
              	
              	; read from PSG register and return it into A
2885: CDD81A  	SSTAT:  call    DEINT           ; get integer -32768 to 32767
2888: 7B      	        ld      A,E             ; consider LSB
2889: FE10    	        cp      $10             ; check if value >= 16 (PSG registers go from 0 to 15)
288B: D2ED1A  	        jp      NC,FCERR        ; If yes, exit and raise an Illegal function call Error
288E: 0E40    	        ld      C,PSG_REG       ; output port to set PSG register
2890: ED79    	        out     (C),A           ; send register to read from
2892: ED78    	        in      A,(C)           ; read register's contents and store into A
2894: C38C22  	        jp      PASSA           ; return A
              	
              	; read the temp key buffer and return the value of the current key being pressed
              	; can wait for the number of 100thds of second before to return
2897: CD0623  	INKEY:  call    IDTEST          ; Test for illegal direct
289A: CDD81A  	        call    DEINT           ; get number param (100thds of second to wait)
289D: C5      	        push    BC              ; store BC
289E: 3ACE81  	        ld      A,(TMRCNT)      ; Load current value of system timer
28A1: 47      	        ld      B,A             ; move it into B
28A2: 3ACE81  	CMP_A:  ld      A,(TMRCNT)      ; make a little delay of 1/100 sec...
28A5: B8      	        cp      B               ; ...to let the sniffer collect...
28A6: 20FA    	        jr      NZ,CMP_A        ; ...at least 1 char before to continue
28A8: 7A      	        ld      A,D             ; check the param
28A9: AB      	        xor     E               ; if DE<>0 then...
28AA: 2005    	        jr      NZ,INKEY2       ; ...jump over...
28AC: 3A2B82  	        ld      A,(TMPKEYBFR)   ; ...else read the buffer and...
28AF: 181C    	        jr      ENDINK          ; ...return it
28B1: 7A      	INKEY2: ld      A,D             ; check if param>1023
28B2: FE04    	        cp      $04             ; to do this we check if MSB>3
28B4: D2ED1A  	        jp      NC,FCERR        ; if MSB >=4 then error
28B7: 3ACE81  	        ld      A,(TMRCNT)      ; Load current value of system timer
28BA: 47      	        ld      B,A             ; move it into B
28BB: 3A2B82  	CHKINK: ld      A,(TMPKEYBFR)   ; load current value
28BE: A7      	        and     A               ; is it 0?
28BF: 200C    	        jr      NZ,ENDINK       ; no, so we can return it
28C1: 3ACE81  	        ld      A,(TMRCNT)      ; load current value of system timer
28C4: B8      	        cp      B               ; is it the same value?
28C5: 28F4    	        jr      Z,CHKINK        ; yes, so read again
28C7: 47      	        ld      B,A             ; store new value
28C8: 1B      	        dec     DE              ; no, decrement timer
28C9: 7A      	        ld      A,D             ; check if zero reached
28CA: B3      	        or      E               ; by ORing D and E
28CB: 20EE    	        jr      NZ,CHKINK       ; if not 0, repeat
28CD: C1      	ENDINK: pop     BC              ; restore BC
28CE: F5      	        push    AF              ; store A
28CF: F3      	        di                      ; disable INTs
28D0: AF      	        xor     A               ; clear the...
28D1: 322B82  	        ld      (TMPKEYBFR),A   ; ...TMP KEY buffer for the next read
28D4: FB      	        ei                      ; re-enable INTs
28D5: F1      	        pop     AF              ; retrieve A
28D6: C38C22  	ENDINK2:jp      PASSA           ; return A as ASCII value
              	
28D9: 21002E  	ROUND:  ld      HL,HALF         ; Add 0.5 to FPREG
28DC: CDD12B  	ADDPHL: call    LOADFP          ; Load FP at (HL) to BCDE
28DF: C3EB28  	        jp      FPADD           ; Add BCDE to FPREG
              	
28E2: CDD12B  	SUBPHL: call    LOADFP          ; FPREG = -FPREG + number at HL
28E5: 21      	        defb    $21             ; Skip "pop BC" and "pop DE"
28E6: C1      	PSUB:   pop     BC              ; Get FP number from stack
28E7: D1      	        pop     DE
28E8: CDAB2B  	SUBCDE: call    INVSGN          ; Negate FPREG
28EB: 78      	FPADD:  ld      A,B             ; Get FP exponent
28EC: B7      	        or      A               ; Is number zero?
28ED: C8      	        ret     Z               ; Yes - Nothing to add
28EE: 3ACC81  	        ld      A,(FPEXP)       ; Get FPREG exponent
28F1: B7      	        or      A               ; Is this number zero?
28F2: CAC32B  	        jp      Z,FPBCDE        ; Yes - Move BCDE to FPREG
28F5: 90      	        sub     B               ; BCDE number larger?
28F6: D20529  	        jp      NC,NOSWAP       ; No - Don't swap them
28F9: 2F      	        cpl                     ; Two's complement
28FA: 3C      	        inc     A               ;  FP exponent
28FB: EB      	        ex      DE,HL
28FC: CDB32B  	        call    STAKFP          ; Put FPREG on stack
28FF: EB      	        ex      DE,HL
2900: CDC32B  	        call    FPBCDE          ; Move BCDE to FPREG
2903: C1      	        pop     BC              ; Restore number from stack
2904: D1      	        pop     DE
2905: FE19    	NOSWAP: cp      24+1            ; Second number insignificant?
2907: D0      	        ret     NC              ; Yes - First number is result
2908: F5      	        push    AF              ; Save number of bits to scale
2909: CDE82B  	        call    SIGNS           ; Set MSBs & sign of result
290C: 67      	        ld      H,A             ; Save sign of result
290D: F1      	        pop     AF              ; Restore scaling factor
290E: CDB029  	        call    SCALE           ; Scale BCDE to same exponent
2911: B4      	        or      H               ; Result to be positive?
2912: 21C981  	        ld      HL,FPREG        ; Point to FPREG
2915: F22B29  	        jp      P,MINCDE        ; No - Subtract FPREG from CDE
2918: CD9029  	        call    PLUCDE          ; Add FPREG to CDE
291B: D27129  	        jp      NC,RONDUP       ; No overflow - Round it up
291E: 23      	        inc     HL              ; Point to exponent
291F: 34      	        inc     (HL)            ; Increment it
2920: CA2A15  	        jp      Z,OVERR         ; Number overflowed - Error
2923: 2E01    	        ld      L,$01           ; 1 bit to shift right
2925: CDC629  	        call    SHRT1           ; Shift result right
2928: C37129  	        jp      RONDUP          ; Round it up
              	
292B: AF      	MINCDE: xor     A               ; Clear A and carry
292C: 90      	        sub     B               ; Negate exponent
292D: 47      	        ld      B,A             ; Re-save exponent
292E: 7E      	        ld      A,(HL)          ; Get LSB of FPREG
292F: 9B      	        sbc     A, E            ; Subtract LSB of BCDE
2930: 5F      	        ld      E,A             ; Save LSB of BCDE
2931: 23      	        inc     HL
2932: 7E      	        ld      A,(HL)          ; Get NMSB of FPREG
2933: 9A      	        sbc     A,D             ; Subtract NMSB of BCDE
2934: 57      	        ld      D,A             ; Save NMSB of BCDE
2935: 23      	        inc     HL
2936: 7E      	        ld      A,(HL)          ; Get MSB of FPREG
2937: 99      	        sbc     A,C             ; Subtract MSB of BCDE
2938: 4F      	        ld      C,A             ; Save MSB of BCDE
2939: DC9C29  	CONPOS: call    C,COMPL         ; Overflow - Make it positive
              	
293C: 68      	BNORM:  ld      L,B             ; L = Exponent
293D: 63      	        ld      H,E             ; H = LSB
293E: AF      	        xor     A
293F: 47      	BNRMLP: ld      B,A             ; Save bit count
2940: 79      	        ld      A,C             ; Get MSB
2941: B7      	        or      A               ; Is it zero?
2942: C25E29  	        jp      NZ,PNORM        ; No - Do it bit at a time
2945: 4A      	        ld      C,D             ; MSB = NMSB
2946: 54      	        ld      D,H             ; NMSB= LSB
2947: 65      	        ld      H,L             ; LSB = VLSB
2948: 6F      	        ld      L,A             ; VLSB= 0
2949: 78      	        ld      A,B             ; Get exponent
294A: D608    	        sub     $08             ; Count 8 bits
294C: FEE0    	        cp      -24-8           ; Was number zero?
294E: C23F29  	        jp      NZ,BNRMLP       ; No - Keep normalising
2951: AF      	RESZER: xor     A               ; Result is zero
2952: 32CC81  	SAVEXP: ld      (FPEXP),A       ; Save result as zero
2955: C9      	        ret
              	
2956: 05      	NORMAL: dec     B               ; Count bits
2957: 29      	        add     HL,HL           ; Shift HL left
2958: 7A      	        ld      A,D             ; Get NMSB
2959: 17      	        rla                     ; Shift left with last bit
295A: 57      	        ld      D,A             ; Save NMSB
295B: 79      	        ld      A,C             ; Get MSB
295C: 8F      	        adc     A,A             ; Shift left with last bit
295D: 4F      	        ld      C,A             ; Save MSB
295E: F25629  	PNORM:  jp      P,NORMAL        ; Not done - Keep going
2961: 78      	        ld      A,B             ; Number of bits shifted
2962: 5C      	        ld      E,H             ; Save HL in EB
2963: 45      	        ld      B,L
2964: B7      	        or      A               ; Any shifting done?
2965: CA7129  	        jp      Z,RONDUP        ; No - Round it up
2968: 21CC81  	        ld      HL,FPEXP        ; Point to exponent
296B: 86      	        add     A,(HL)          ; Add shifted bits
296C: 77      	        ld      (HL),A          ; Re-save exponent
296D: D25129  	        jp      NC,RESZER       ; Underflow - Result is zero
2970: C8      	        ret     Z               ; Result is zero
2971: 78      	RONDUP: ld      A,B             ; Get VLSB of number
2972: 21CC81  	RONDB:  ld      HL,FPEXP        ; Point to exponent
2975: B7      	        or      A               ; Any rounding?
2976: FC8329  	        call    M,FPROND        ; Yes - Round number up
2979: 46      	        ld      B,(HL)          ; B = Exponent
297A: 23      	        inc     HL
297B: 7E      	        ld      A,(HL)          ; Get sign of result
297C: E680    	        and     %10000000       ; Only bit 7 needed
297E: A9      	        xor     C               ; Set correct sign
297F: 4F      	        ld      C,A             ; Save correct sign in number
2980: C3C32B  	        jp      FPBCDE          ; Move BCDE to FPREG
              	
2983: 1C      	FPROND: inc     E               ; Round LSB
2984: C0      	        ret     NZ              ; Return if ok
2985: 14      	        inc     D               ; Round NMSB
2986: C0      	        ret     NZ              ; Return if ok
2987: 0C      	        inc     C               ; Round MSB
2988: C0      	        ret     NZ              ; Return if ok
2989: 0E80    	        ld      C,$80           ; Set normal value
298B: 34      	        inc     (HL)            ; Increment exponent
298C: C0      	        ret     NZ              ; Return if ok
298D: C32A15  	        jp      OVERR           ; Overflow error
              	
2990: 7E      	PLUCDE: ld      A,(HL)          ; Get LSB of FPREG
2991: 83      	        add     A,E             ; Add LSB of BCDE
2992: 5F      	        ld      E,A             ; Save LSB of BCDE
2993: 23      	        inc     HL
2994: 7E      	        ld      A,(HL)          ; Get NMSB of FPREG
2995: 8A      	        adc     A,D             ; Add NMSB of BCDE
2996: 57      	        ld      D,A             ; Save NMSB of BCDE
2997: 23      	        inc     HL
2998: 7E      	        ld      A,(HL)          ; Get MSB of FPREG
2999: 89      	        adc     A,C             ; Add MSB of BCDE
299A: 4F      	        ld      C,A             ; Save MSB of BCDE
299B: C9      	        ret
              	
299C: 21CD81  	COMPL:  ld      HL,SGNRES       ; Sign of result
299F: 7E      	        ld      A,(HL)          ; Get sign of result
29A0: 2F      	        cpl                     ; Negate it
29A1: 77      	        ld      (HL),A          ; Put it back
29A2: AF      	        xor     A
29A3: 6F      	        ld      L,A             ; Set L to zero
29A4: 90      	        sub     B               ; Negate exponent,set carry
29A5: 47      	        ld      B,A             ; Re-save exponent
29A6: 7D      	        ld      A,L             ; Load zero
29A7: 9B      	        sbc     A,E             ; Negate LSB
29A8: 5F      	        ld      E,A             ; Re-save LSB
29A9: 7D      	        ld      A,L             ; Load zero
29AA: 9A      	        sbc     A,D             ; Negate NMSB
29AB: 57      	        ld      D,A             ; Re-save NMSB
29AC: 7D      	        ld      A,L             ; Load zero
29AD: 99      	        sbc     A,C             ; Negate MSB
29AE: 4F      	        ld      C,A             ; Re-save MSB
29AF: C9      	        ret
              	
29B0: 0600    	SCALE:  ld      B,$00           ; Clear underflow
29B2: D608    	SCALLP: sub     $08             ; 8 bits (a whole byte)?
29B4: DABF29  	        jp      C,SHRITE        ; No - Shift right A bits
29B7: 43      	        ld      B,E             ; <- Shift
29B8: 5A      	        ld      E,D             ; <- right
29B9: 51      	        ld      D,C             ; <- eight
29BA: 0E00    	        ld      C,$00           ; <- bits
29BC: C3B229  	        jp      SCALLP          ; More bits to shift
              	
29BF: C609    	SHRITE: add     A,8+1           ; Adjust count
29C1: 6F      	        ld      L,A             ; Save bits to shift
29C2: AF      	SHRLP:  xor     A               ; Flag for all done
29C3: 2D      	        dec     L               ; All shifting done?
29C4: C8      	        ret     Z               ; Yes - Return
29C5: 79      	        ld      A,C             ; Get MSB
29C6: 1F      	SHRT1:  rra                     ; Shift it right
29C7: 4F      	        ld      C,A             ; Re-save
29C8: 7A      	        ld      A,D             ; Get NMSB
29C9: 1F      	        rra                     ; Shift right with last bit
29CA: 57      	        ld      D,A             ; Re-save it
29CB: 7B      	        ld      A,E             ; Get LSB
29CC: 1F      	        rra                     ; Shift right with last bit
29CD: 5F      	        ld      E,A             ; Re-save it
29CE: 78      	        ld      A,B             ; Get underflow
29CF: 1F      	        rra                     ; Shift right with last bit
29D0: 47      	        ld      B,A             ; Re-save underflow
29D1: C3C229  	        jp      SHRLP           ; More bits to do
              	
29D4: 00000081	UNITY:  defb    $00,$00,$00,$81 ; 1.00000
              	
29D8: 03      	LOGTAB: defb    $03             ; Table used by LOG
29D9: AA561980	        defb    $AA,$56,$19,$80 ; 0.59898
29DD: F1227680	        defb    $F1,$22,$76,$80 ; 0.96147
29E1: 45AA3882	        defb    $45,$AA,$38,$82 ; 2.88539
              	
29E5: CD822B  	LOG:    call    TSTSGN          ; Test sign of value
29E8: B7      	        or      A
29E9: EAED1A  	        jp      PE,FCERR        ; ?FC Error if <= zero
29EC: 21CC81  	        ld      HL,FPEXP        ; Point to exponent
29EF: 7E      	        ld      A,(HL)          ; Get exponent
29F0: 013580  	        ld      BC,$8035        ; BCDE = SQR(1/2)
29F3: 11F304  	        ld      DE,$04F3
29F6: 90      	        sub     B               ; Scale value to be < 1
29F7: F5      	        push    AF              ; Save scale factor
29F8: 70      	        ld      (HL),B          ; Save new exponent
29F9: D5      	        push    DE              ; Save SQR(1/2)
29FA: C5      	        push    BC
29FB: CDEB28  	        call    FPADD           ; Add SQR(1/2) to value
29FE: C1      	        pop     BC              ; Restore SQR(1/2)
29FF: D1      	        pop     DE
2A00: 04      	        inc     B               ; Make it SQR(2)
2A01: CDD82A  	        call    DVBCDE          ; Divide by SQR(2)
2A04: 21D429  	        ld      HL,UNITY        ; Point to 1.
2A07: CDE228  	        call    SUBPHL          ; Subtract FPREG from 1
2A0A: 21D829  	        ld      HL,LOGTAB       ; Coefficient table
2A0D: CDCA2E  	        call    SUMSER          ; Evaluate sum of series
2A10: 018080  	        ld      BC,$8080        ; BCDE = -0.5
2A13: 110000  	        ld      DE,$0000
2A16: CDEB28  	        call    FPADD           ; Subtract 0.5 from FPREG
2A19: F1      	        pop     AF              ; Restore scale factor
2A1A: CDFD2C  	        call    RSCALE          ; Re-scale number
2A1D: 013180  	MULLN2: ld      BC,$8031        ; BCDE = Ln(2)
2A20: 111872  	        ld      DE,$7218
2A23: 21      	        defb    $21             ; Skip "pop BC" and "pop DE"
              	
2A24: C1      	MULT:   pop     BC              ; Get number from stack
2A25: D1      	        pop     DE
2A26: CD822B  	FPMULT: call    TSTSGN          ; Test sign of FPREG
2A29: C8      	        ret     Z               ; Return zero if zero
2A2A: 2E00    	        ld      L,$00           ; Flag add exponents
2A2C: CD402B  	        call    ADDEXP          ; Add exponents
2A2F: 79      	        ld      A,C             ; Get MSB of multiplier
2A30: 323D82  	        ld      (MULVAL),A      ; Save MSB of multiplier
2A33: EB      	        ex      DE,HL
2A34: 223E82  	        ld      (MULVAL+1),HL   ; Save rest of multiplier
2A37: 010000  	        ld      BC,$0000        ; Partial product (BCDE) = zero
2A3A: 50      	        ld      D,B
2A3B: 58      	        ld      E,B
2A3C: 213C29  	        ld      HL,BNORM        ; Address of normalise
2A3F: E5      	        push    HL              ; Save for return
2A40: 21482A  	        ld      HL,MULT8        ; Address of 8 bit multiply
2A43: E5      	        push    HL              ; Save for NMSB,MSB
2A44: E5      	        push    HL              ;
2A45: 21C981  	        ld      HL,FPREG        ; Point to number
2A48: 7E      	MULT8:  ld      A,(HL)          ; Get LSB of number
2A49: 23      	        inc     HL              ; Point to NMSB
2A4A: B7      	        or      A               ; Test LSB
2A4B: CA742A  	        jp      Z,BYTSFT        ; Zero - shift to next byte
2A4E: E5      	        push    HL              ; Save address of number
2A4F: 2E08    	        ld      L,$08           ; 8 bits to multiply by
2A51: 1F      	MUL8LP: rra                     ; Shift LSB right
2A52: 67      	        ld      H,A             ; Save LSB
2A53: 79      	        ld      A,C             ; Get MSB
2A54: D2622A  	        jp      NC,NOMADD       ; Bit was zero - Don't add
2A57: E5      	        push    HL              ; Save LSB and count
2A58: 2A3E82  	        ld      HL,(MULVAL+1)   ; Get LSB and NMSB
2A5B: 19      	        add     HL,DE           ; Add NMSB and LSB
2A5C: EB      	        ex      DE,HL           ; Leave sum in DE
2A5D: E1      	        pop     HL              ; Restore MSB and count
2A5E: 3A3D82  	        ld      A,(MULVAL)      ; Get MSB of multiplier
2A61: 89      	        adc     A,C             ; Add MSB
2A62: 1F      	NOMADD: rra                     ; Shift MSB right
2A63: 4F      	        ld      C,A             ; Re-save MSB
2A64: 7A      	        ld      A,D             ; Get NMSB
2A65: 1F      	        rra                     ; Shift NMSB right
2A66: 57      	        ld      D,A             ; Re-save NMSB
2A67: 7B      	        ld      A,E             ; Get LSB
2A68: 1F      	        rra                     ; Shift LSB right
2A69: 5F      	        ld      E,A             ; Re-save LSB
2A6A: 78      	        ld      A,B             ; Get VLSB
2A6B: 1F      	        rra                     ; Shift VLSB right
2A6C: 47      	        ld      B,A             ; Re-save VLSB
2A6D: 2D      	        dec     L               ; Count bits multiplied
2A6E: 7C      	        ld      A,H             ; Get LSB of multiplier
2A6F: C2512A  	        jp      NZ,MUL8LP       ; More - Do it
2A72: E1      	POPHRT: pop     HL              ; Restore address of number
2A73: C9      	        ret
              	
2A74: 43      	BYTSFT: ld      B,E             ; Shift partial product left
2A75: 5A      	        ld      E,D
2A76: 51      	        ld      D,C
2A77: 4F      	        ld      C,A
2A78: C9      	        ret
              	
              	
              	; WORKING 
2A79: C1      	DINT:   pop     BC              ; Get number from stack
2A7A: D1      	        pop     DE
2A7B: CDD82A  	        call    DVBCDE          ; get BCDE/FPREG and store result into FPREG
2A7E: C3552C  	        jp      INT             ; return INT(FPREG)
              	
              	
              	; A MODULO B - return remainder of the integer division A/B where:
              	; A is in stack; B is in FPREG
              	; math is:
              	; A=INT(A); B=INT(B); R=A-(B*INT(A/B))
2A81: CD552C  	MOD:    call    INT             ; B=INT(B)
2A84: CDCE2B  	        call    BCDEFP          ; copy B (from FPREG) into BCDE
2A87: ED53F381	        ld      (TMPBFR3),DE    ; store B into...
2A8B: ED43F581	        ld      (TMPBFR4),BC    ; ...a temp buffer
2A8F: C1      	        pop     BC              ; recover A...
2A90: D1      	        pop     DE              ; ...from stack
2A91: CDC32B  	        call    FPBCDE          ; store A into FPREG
2A94: CD552C  	        call    INT             ; get integer part: A=INT(A)
2A97: CDCE2B  	        call    BCDEFP          ; copy A (from FPREG) into BCDE
2A9A: ED53EF81	        ld      (TMPBFR1),DE    ; store A into...
2A9E: ED43F181	        ld      (TMPBFR2),BC    ; ...a temp buffer
              	                                ; begin calculation
2AA2: 2AF381  	        ld      HL,(TMPBFR3)    ; move B...
2AA5: 22C981  	        ld      (FPREG),HL      ; ...from...
2AA8: 2AF581  	        ld      HL,(TMPBFR4)    ; ...temp buffer...
2AAB: 22CB81  	        ld      (FPREG+2),HL    ; ...into FPREG
2AAE: CDD82A  	        call    DVBCDE          ; compute A/B and store into FPREG
2AB1: CD552C  	        call    INT             ; get integer part of result: now FPREG = INT(A/B)
2AB4: ED5BF381	        ld      DE,(TMPBFR3)    ; load B...
2AB8: ED4BF581	        ld      BC,(TMPBFR4)    ; ...into BCDE
2ABC: CD262A  	        call    FPMULT          ; get B*INT(A/B) and store into FPREG
2ABF: ED5BEF81	        ld      DE,(TMPBFR1)    ; retrieve A from...
2AC3: ED4BF181	        ld      BC,(TMPBFR2)    ; ...temp buffer
2AC7: C3E828  	        jp      SUBCDE          ; return result of A-(B*INT(A/B))
              	
              	
2ACA: CDB32B  	DIV10:  call    STAKFP          ; Save FPREG on stack
2ACD: 012084  	        ld      BC,$8420        ; BCDE = 10.
2AD0: 110000  	        ld      DE,$0000
2AD3: CDC32B  	        call    FPBCDE          ; Move 10 to FPREG
              	
2AD6: C1      	DIV:    pop     BC              ; Get number from stack
2AD7: D1      	        pop     DE
2AD8: CD822B  	DVBCDE: call    TSTSGN          ; Test sign of FPREG
2ADB: CA1E15  	        jp      Z,DZERR         ; Error if division by zero
2ADE: 2EFF    	        ld      L,-1            ; Flag subtract exponents
2AE0: CD402B  	        call    ADDEXP          ; Subtract exponents
2AE3: 34      	        inc     (HL)            ; Add 2 to exponent to adjust
2AE4: 34      	        inc     (HL)
2AE5: 2B      	        dec     HL              ; Point to MSB
2AE6: 7E      	        ld      A,(HL)          ; Get MSB of dividend
2AE7: 327380  	        ld      (DIV3),A        ; Save for subtraction
2AEA: 2B      	        dec     HL
2AEB: 7E      	        ld      A,(HL)          ; Get NMSB of dividend
2AEC: 326F80  	        ld      (DIV2),A        ; Save for subtraction
2AEF: 2B      	        dec     HL
2AF0: 7E      	        ld      A,(HL)          ; Get MSB of dividend
2AF1: 326B80  	        ld      (DIV1),A        ; Save for subtraction
2AF4: 41      	        ld      B,C             ; Get MSB
2AF5: EB      	        ex      DE,HL           ; NMSB,LSB to HL
2AF6: AF      	        xor     A
2AF7: 4F      	        ld      C,A             ; Clear MSB of quotient
2AF8: 57      	        ld      D,A             ; Clear NMSB of quotient
2AF9: 5F      	        ld      E,A             ; Clear LSB of quotient
2AFA: 327680  	        ld      (DIV4),A        ; Clear overflow count
2AFD: E5      	DIVLP:  push    HL              ; Save divisor
2AFE: C5      	        push    BC
2AFF: 7D      	        ld      A,L             ; Get LSB of number
2B00: CD6A80  	        call    DIVSUP          ; Subt' divisor from dividend
2B03: DE00    	        sbc     A,$00           ; Count for overflows
2B05: 3F      	        ccf
2B06: D2102B  	        jp      NC,RESDIV       ; Restore divisor if borrow
2B09: 327680  	        ld      (DIV4),A        ; Re-save overflow count
2B0C: F1      	        pop     AF              ; Scrap divisor
2B0D: F1      	        pop     AF
2B0E: 37      	        scf                     ; Set carry to
2B0F: D2      	        defb    $D2             ; Skip "pop BC" and "pop HL"
              	
2B10: C1      	RESDIV: pop     BC              ; Restore divisor
2B11: E1      	        pop     HL
2B12: 79      	        ld      A,C             ; Get MSB of quotient
2B13: 3C      	        inc     A
2B14: 3D      	        dec     A
2B15: 1F      	        rra                     ; Bit 0 to bit 7
2B16: FA7229  	        jp      M,RONDB         ; Done - Normalise result
2B19: 17      	        rla                     ; Restore carry
2B1A: 7B      	        ld      A,E             ; Get LSB of quotient
2B1B: 17      	        rla                     ; Double it
2B1C: 5F      	        ld      E,A             ; Put it back
2B1D: 7A      	        ld      A,D             ; Get NMSB of quotient
2B1E: 17      	        rla                     ; Double it
2B1F: 57      	        ld      D,A             ; Put it back
2B20: 79      	        ld      A,C             ; Get MSB of quotient
2B21: 17      	        rla                     ; Double it
2B22: 4F      	        ld      C,A             ; Put it back
2B23: 29      	        add     HL,HL           ; Double NMSB,LSB of divisor
2B24: 78      	        ld      A,B             ; Get MSB of divisor
2B25: 17      	        rla                     ; Double it
2B26: 47      	        ld      B,A             ; Put it back
2B27: 3A7680  	        ld      A,(DIV4)        ; Get VLSB of quotient
2B2A: 17      	        rla                     ; Double it
2B2B: 327680  	        ld      (DIV4),A        ; Put it back
2B2E: 79      	        ld      A,C             ; Get MSB of quotient
2B2F: B2      	        or      D               ; Merge NMSB
2B30: B3      	        or      E               ; Merge LSB
2B31: C2FD2A  	        jp      NZ,DIVLP        ; Not done - Keep dividing
2B34: E5      	        push    HL              ; Save divisor
2B35: 21CC81  	        ld      HL,FPEXP        ; Point to exponent
2B38: 35      	        dec     (HL)            ; Divide by 2
2B39: E1      	        pop     HL              ; Restore divisor
2B3A: C2FD2A  	        jp      NZ,DIVLP        ; Ok - Keep going
2B3D: C32A15  	        jp      OVERR           ; Overflow error
              	
              	
2B40: 78      	ADDEXP: ld      A,B             ; Get exponent of dividend
2B41: B7      	        or      A               ; Test it
2B42: CA642B  	        jp      Z,OVTST3        ; Zero - Result zero
2B45: 7D      	        ld      A,L             ; Get add/subtract flag
2B46: 21CC81  	        ld      HL,FPEXP        ; Point to exponent
2B49: AE      	        xor     (HL)            ; Add or subtract it
2B4A: 80      	        add     A,B             ; Add the other exponent
2B4B: 47      	        ld      B,A             ; Save new exponent
2B4C: 1F      	        rra                     ; Test exponent for overflow
2B4D: A8      	        xor     B
2B4E: 78      	        ld      A,B             ; Get exponent
2B4F: F2632B  	        jp      P,OVTST2        ; Positive - Test for overflow
2B52: C680    	        add     A,$80           ; Add excess 128
2B54: 77      	        ld      (HL),A          ; Save new exponent
2B55: CA722A  	        jp      Z,POPHRT        ; Zero - Result zero
2B58: CDE82B  	        call    SIGNS           ; Set MSBs and sign of result
2B5B: 77      	        ld      (HL),A          ; Save new exponent
2B5C: 2B      	        dec     HL              ; Point to MSB
2B5D: C9      	        ret
              	
2B5E: CD822B  	OVTST1: call    TSTSGN          ; Test sign of FPREG
2B61: 2F      	        cpl                     ; Invert sign
2B62: E1      	        pop     HL              ; Clean up stack
2B63: B7      	OVTST2: or      A               ; Test if new exponent zero
2B64: E1      	OVTST3: pop     HL              ; Clear off return address
2B65: F25129  	        jp      P,RESZER        ; Result zero
2B68: C32A15  	        jp      OVERR           ; Overflow error
              	
2B6B: CDCE2B  	MLSP10: call    BCDEFP          ; Move FPREG to BCDE
2B6E: 78      	        ld      A,B             ; Get exponent
2B6F: B7      	        or      A               ; Is it zero?
2B70: C8      	        ret     Z               ; Yes - Result is zero
2B71: C602    	        add     A,$02           ; Multiply by 4
2B73: DA2A15  	        jp      C,OVERR         ; Overflow - ?OV Error
2B76: 47      	        ld      B,A             ; Re-save exponent
2B77: CDEB28  	        call    FPADD           ; Add BCDE to FPREG (Times 5)
2B7A: 21CC81  	        ld      HL,FPEXP        ; Point to exponent
2B7D: 34      	        inc     (HL)            ; Double number (Times 10)
2B7E: C0      	        ret     NZ              ; Ok - Return
2B7F: C32A15  	        jp      OVERR           ; Overflow error
              	
2B82: 3ACC81  	TSTSGN: ld      A,(FPEXP)       ; Get sign of FPREG
2B85: B7      	        or      A
2B86: C8      	        ret     Z               ; RETurn if number is zero
2B87: 3ACB81  	        ld      A,(FPREG+2)     ; Get MSB of FPREG
2B8A: FE      	        defb    0FEH            ; Test sign
2B8B: 2F      	RETREL: cpl                     ; Invert sign
2B8C: 17      	        rla                     ; Sign bit to carry
2B8D: 9F      	FLGDIF: sbc     A,A             ; Carry to all bits of A
2B8E: C0      	        ret     NZ              ; Return -1 if negative
2B8F: 3C      	        inc     A               ; Bump to +1
2B90: C9      	        ret                     ; Positive - Return +1
              	
2B91: CD822B  	SGN:    call    TSTSGN          ; Test sign of FPREG
2B94: 0688    	FLGREL: ld      B,$80+8         ; 8 bit integer in exponent
2B96: 110000  	        ld      DE,0            ; Zero NMSB and LSB
2B99: 21CC81  	RETINT: ld      HL,FPEXP        ; Point to exponent
2B9C: 4F      	        ld      C,A             ; CDE = MSB,NMSB and LSB
2B9D: 70      	        ld      (HL),B          ; Save exponent
2B9E: 0600    	        ld      B,0             ; CDE = integer to normalise
2BA0: 23      	        inc     HL              ; Point to sign of result
2BA1: 3680    	        ld      (HL),$80        ; Set sign of result
2BA3: 17      	        rla                     ; Carry = sign of integer
2BA4: C33929  	        jp      CONPOS          ; Set sign of result
              	
2BA7: CD822B  	ABS:    call    TSTSGN          ; Test sign of FPREG
2BAA: F0      	        ret     P               ; Return if positive
2BAB: 21CB81  	INVSGN: ld      HL,FPREG+2      ; Point to MSB
2BAE: 7E      	        ld      A,(HL)          ; Get sign of mantissa
2BAF: EE80    	        xor     $80             ; Invert sign of mantissa
2BB1: 77      	        ld      (HL),A          ; Re-save sign of mantissa
2BB2: C9      	        ret
              	
2BB3: EB      	STAKFP: ex      DE,HL           ; Save code string address
2BB4: 2AC981  	        ld      HL,(FPREG)      ; LSB,NLSB of FPREG
2BB7: E3      	        ex      (SP),HL         ; Stack them,get return
2BB8: E5      	        push    HL              ; Re-save return
2BB9: 2ACB81  	        ld      HL,(FPREG+2)    ; MSB and exponent of FPREG
2BBC: E3      	        ex      (SP),HL         ; Stack them,get return
2BBD: E5      	        push    HL              ; Re-save return
2BBE: EB      	        ex      DE,HL           ; Restore code string address
2BBF: C9      	        ret
              	
              	; store F.P. number from BCDE into FPREG
2BC0: CDD12B  	PHLTFP: call    LOADFP          ; Number at HL to BCDE
2BC3: EB      	FPBCDE: ex      DE,HL           ; Save code string address
2BC4: 22C981  	        ld      (FPREG),HL      ; Save LSB,NLSB of number
2BC7: 60      	        ld      H,B             ; Exponent of number
2BC8: 69      	        ld      L,C             ; MSB of number
2BC9: 22CB81  	        ld      (FPREG+2),HL    ; Save MSB and exponent
2BCC: EB      	        ex      DE,HL           ; Restore code string address
2BCD: C9      	        ret
              	
              	; load F.P. number from FPREG into BCDE
2BCE: 21C981  	BCDEFP: ld      HL,FPREG        ; Point to FPREG
2BD1: 5E      	LOADFP: ld      E,(HL)          ; Get LSB of number
2BD2: 23      	        inc     HL
2BD3: 56      	        ld      D,(HL)          ; Get NMSB of number
2BD4: 23      	        inc     HL
2BD5: 4E      	        ld      C,(HL)          ; Get MSB of number
2BD6: 23      	        inc     HL
2BD7: 46      	        ld      B,(HL)          ; Get exponent of number
2BD8: 23      	INCHL:  inc     HL              ; Used for conditional "inc HL"
2BD9: C9      	        ret
              	
2BDA: 11C981  	FPTHL:  ld      DE,FPREG        ; Point to FPREG
2BDD: 0604    	DETHL4: ld      B,$04           ; 4 bytes to move
2BDF: 1A      	DETHLB: ld      A,(DE)          ; Get source
2BE0: 77      	        ld      (HL),A          ; Save destination
2BE1: 13      	        inc     DE              ; Next source
2BE2: 23      	        inc     HL              ; Next destination
2BE3: 05      	        dec     B               ; Count bytes
2BE4: C2DF2B  	        jp      NZ,DETHLB       ; Loop if more
2BE7: C9      	        ret
              	
2BE8: 21CB81  	SIGNS:  ld      HL,FPREG+2      ; Point to MSB of FPREG
2BEB: 7E      	        ld      A,(HL)          ; Get MSB
2BEC: 07      	        rlca                    ; Old sign to carry
2BED: 37      	        scf                     ; Set MSBit
2BEE: 1F      	        rra                     ; Set MSBit of MSB
2BEF: 77      	        ld      (HL),A          ; Save new MSB
2BF0: 3F      	        ccf                     ; Complement sign
2BF1: 1F      	        rra                     ; Old sign to carry
2BF2: 23      	        inc     HL
2BF3: 23      	        inc     HL
2BF4: 77      	        ld      (HL),A          ; Set sign of result
2BF5: 79      	        ld      A,C             ; Get MSB
2BF6: 07      	        rlca                    ; Old sign to carry
2BF7: 37      	        scf                     ; Set MSBit
2BF8: 1F      	        rra                     ; Set MSBit of MSB
2BF9: 4F      	        ld      C,A             ; Save MSB
2BFA: 1F      	        rra
2BFB: AE      	        xor     (HL)            ; New sign of result
2BFC: C9      	        ret
              	
2BFD: 78      	CMPNUM: ld      A,B             ; Get exponent of number
2BFE: B7      	        or      A
2BFF: CA822B  	        jp      Z,TSTSGN        ; Zero - Test sign of FPREG
2C02: 218B2B  	        ld      HL,RETREL       ; Return relation routine
2C05: E5      	        push    HL              ; Save for return
2C06: CD822B  	        call    TSTSGN          ; Test sign of FPREG
2C09: 79      	        ld      A,C             ; Get MSB of number
2C0A: C8      	        ret     Z               ; FPREG zero - Number's MSB
2C0B: 21CB81  	        ld      HL,FPREG+2      ; MSB of FPREG
2C0E: AE      	        xor     (HL)            ; Combine signs
2C0F: 79      	        ld      A,C             ; Get MSB of number
2C10: F8      	        ret     M               ; Exit if signs different
2C11: CD172C  	        call    CMPFP           ; Compare FP numbers
2C14: 1F      	        rra                     ; Get carry to sign
2C15: A9      	        xor     C               ; Combine with MSB of number
2C16: C9      	        ret
              	
2C17: 23      	CMPFP:  inc     HL              ; Point to exponent
2C18: 78      	        ld      A,B             ; Get exponent
2C19: BE      	        cp      (HL)            ; Compare exponents
2C1A: C0      	        ret     NZ              ; Different
2C1B: 2B      	        dec     HL              ; Point to MBS
2C1C: 79      	        ld      A,C             ; Get MSB
2C1D: BE      	        cp      (HL)            ; Compare MSBs
2C1E: C0      	        ret     NZ              ; Different
2C1F: 2B      	        dec     HL              ; Point to NMSB
2C20: 7A      	        ld      A,D             ; Get NMSB
2C21: BE      	        cp      (HL)            ; Compare NMSBs
2C22: C0      	        ret     NZ              ; Different
2C23: 2B      	        dec     HL              ; Point to LSB
2C24: 7B      	        ld      A,E             ; Get LSB
2C25: 96      	        sub     (HL)            ; Compare LSBs
2C26: C0      	        ret     NZ              ; Different
2C27: E1      	        pop     HL              ; Drop RETurn
2C28: E1      	        pop     HL              ; Drop another RETurn
2C29: C9      	        ret
              	
2C2A: 47      	FPINT:  ld      B,A             ; <- Move
2C2B: 4F      	        ld      C,A             ; <- exponent
2C2C: 57      	        ld      D,A             ; <- to all
2C2D: 5F      	        ld      E,A             ; <- bits
2C2E: B7      	        or      A               ; Test exponent
2C2F: C8      	        ret     Z               ; Zero - Return zero
2C30: E5      	        push    HL              ; Save pointer to number
2C31: CDCE2B  	        call    BCDEFP          ; Move FPREG to BCDE
2C34: CDE82B  	        call    SIGNS           ; Set MSBs & sign of result
2C37: AE      	        xor     (HL)            ; Combine with sign of FPREG
2C38: 67      	        ld      H,A             ; Save combined signs
2C39: FC4E2C  	        call    M,DCBCDE        ; Negative - Decrement BCDE
2C3C: 3E98    	        ld      A,$80+24        ; 24 bits
2C3E: 90      	        sub     B               ; Bits to shift
2C3F: CDB029  	        call    SCALE           ; Shift BCDE
2C42: 7C      	        ld      A,H             ; Get combined sign
2C43: 17      	        rla                     ; Sign to carry
2C44: DC8329  	        call    C,FPROND        ; Negative - Round number up
2C47: 0600    	        ld      B,$00           ; Zero exponent
2C49: DC9C29  	        call    C,COMPL         ; If negative make positive
2C4C: E1      	        pop     HL              ; Restore pointer to number
2C4D: C9      	        ret
              	
2C4E: 1B      	DCBCDE: dec     DE              ; Decrement BCDE
2C4F: 7A      	        ld      A,D             ; Test LSBs
2C50: A3      	        and     E
2C51: 3C      	        inc     A
2C52: C0      	        ret     NZ              ; Exit if LSBs not FFFF
2C53: 0B      	        dec     BC              ; Decrement MSBs
2C54: C9      	        ret
              	
2C55: 21CC81  	INT:    ld      HL,FPEXP        ; Point to exponent
2C58: 7E      	        ld      A,(HL)          ; Get exponent
2C59: FE98    	        cp      $80+24          ; Integer accuracy only?
2C5B: 3AC981  	        ld      A,(FPREG)       ; Get LSB
2C5E: D0      	        ret     NC              ; Yes - Already integer
2C5F: 7E      	        ld      A,(HL)          ; Get exponent
2C60: CD2A2C  	        call    FPINT           ; F.P to integer
2C63: 3698    	        ld      (HL),$80+24     ; Save 24 bit integer
2C65: 7B      	        ld      A,E             ; Get LSB of number
2C66: F5      	        push    AF              ; Save LSB
2C67: 79      	        ld      A,C             ; Get MSB of number
2C68: 17      	        rla                     ; Sign to carry
2C69: CD3929  	        call    CONPOS          ; Set sign of result
2C6C: F1      	        pop     AF              ; Restore LSB of number
2C6D: C9      	        ret
              	
2C6E: 210000  	MLDEBC: ld      HL,$0000        ; Clear partial product
2C71: 78      	        ld      A,B             ; Test multiplier
2C72: B1      	        or      C
2C73: C8      	        ret     Z               ; Return zero if zero
2C74: 3E10    	        ld      A,$10           ; 16 bits
2C76: 29      	MLDBLP: add     HL,HL           ; Shift P.P left
2C77: DAB921  	        jp      C,BSERR         ; ?BS Error if overflow
2C7A: EB      	        ex      DE,HL
2C7B: 29      	        add     HL,HL           ; Shift multiplier left
2C7C: EB      	        ex      DE,HL
2C7D: D2842C  	        jp      NC,NOMLAD       ; Bit was zero - No add
2C80: 09      	        add     HL,BC           ; Add multiplicand
2C81: DAB921  	        jp      C,BSERR         ; ?BS Error if overflow
2C84: 3D      	NOMLAD: dec     A               ; Count bits
2C85: C2762C  	        jp      NZ,MLDBLP       ; More
2C88: C9      	        ret
              	
2C89: FE2D    	ASCTFP: cp      '-'             ; Negative?
2C8B: F5      	        push    AF              ; Save it and flags
2C8C: CA952C  	        jp      Z,CNVNUM        ; Yes - Convert number
2C8F: FE2B    	        cp      '+'             ; Positive?
2C91: CA952C  	        jp      Z,CNVNUM        ; Yes - Convert number
2C94: 2B      	        dec     HL              ; dec 'cos GETCHR INCs
2C95: CD5129  	CNVNUM: call    RESZER          ; Set result to zero
2C98: 47      	        ld      B,A             ; Digits after point counter
2C99: 57      	        ld      D,A             ; Sign of exponent
2C9A: 5F      	        ld      E,A             ; Exponent of ten
2C9B: 2F      	        cpl
2C9C: 4F      	        ld      C,A             ; Before or after point flag
2C9D: CD221A  	MANLP:  call    GETCHR          ; Get next character
2CA0: DAE62C  	        jp      C,ADDIG         ; Digit - Add to number
2CA3: FE2E    	        cp      '.'
2CA5: CAC12C  	        jp      Z,DPOINT        ; '.' - Flag point
2CA8: FE45    	        cp      'E'
2CAA: C2C52C  	        jp      NZ,CONEXP       ; Not 'E' - Scale number
2CAD: CD221A  	        call    GETCHR          ; Get next character
2CB0: CDD51F  	        call    SGNEXP          ; Get sign of exponent
2CB3: CD221A  	EXPLP:  call    GETCHR          ; Get next character
2CB6: DA082D  	        jp      C,EDIGIT        ; Digit - Add to exponent
2CB9: 14      	        inc     D               ; Is sign negative?
2CBA: C2C52C  	        jp      NZ,CONEXP       ; No - Scale number
2CBD: AF      	        xor     A
2CBE: 93      	        sub     E               ; Negate exponent
2CBF: 5F      	        ld      E,A             ; And re-save it
2CC0: 0C      	        inc     C               ; Flag end of number
2CC1: 0C      	DPOINT: inc     C               ; Flag point passed
2CC2: CA9D2C  	        jp      Z,MANLP         ; Zero - Get another digit
2CC5: E5      	CONEXP: push    HL              ; Save code string address
2CC6: 7B      	        ld      A,E             ; Get exponent
2CC7: 90      	        sub     B               ; Subtract digits after point
2CC8: F4DE2C  	SCALMI: call    P,SCALPL        ; Positive - Multiply number
2CCB: F2D42C  	        jp      P,ENDCON        ; Positive - All done
2CCE: F5      	        push    AF              ; Save number of times to /10
2CCF: CDCA2A  	        call    DIV10           ; Divide by 10
2CD2: F1      	        pop     AF              ; Restore count
2CD3: 3C      	        inc     A               ; Count divides
              	
2CD4: C2C82C  	ENDCON: jp      NZ,SCALMI       ; More to do
2CD7: D1      	        pop     DE              ; Restore code string address
2CD8: F1      	        pop     AF              ; Restore sign of number
2CD9: CCAB2B  	        call    Z,INVSGN        ; Negative - Negate number
2CDC: EB      	        ex      DE,HL           ; Code string address to HL
2CDD: C9      	        ret
              	
2CDE: C8      	SCALPL: ret     Z               ; Exit if no scaling needed
2CDF: F5      	MULTEN: push    AF              ; Save count
2CE0: CD6B2B  	        call    MLSP10          ; Multiply number by 10
2CE3: F1      	        pop     AF              ; Restore count
2CE4: 3D      	        dec     A               ; Count multiplies
2CE5: C9      	        ret
              	
2CE6: D5      	ADDIG:  push    DE              ; Save sign of exponent
2CE7: 57      	        ld      D,A             ; Save digit
2CE8: 78      	        ld      A,B             ; Get digits after point
2CE9: 89      	        adc     A,C             ; Add one if after point
2CEA: 47      	        ld      B,A             ; Re-save counter
2CEB: C5      	        push    BC              ; Save point flags
2CEC: E5      	        push    HL              ; Save code string address
2CED: D5      	        push    DE              ; Save digit
2CEE: CD6B2B  	        call    MLSP10          ; Multiply number by 10
2CF1: F1      	        pop     AF              ; Restore digit
2CF2: D630    	        sub     '0'             ; Make it absolute
2CF4: CDFD2C  	        call    RSCALE          ; Re-scale number
2CF7: E1      	        pop     HL              ; Restore code string address
2CF8: C1      	        pop     BC              ; Restore point flags
2CF9: D1      	        pop     DE              ; Restore sign of exponent
2CFA: C39D2C  	        jp      MANLP           ; Get another digit
              	
2CFD: CDB32B  	RSCALE: call    STAKFP          ; Put number on stack
2D00: CD942B  	        call    FLGREL          ; Digit to add to FPREG
2D03: C1      	PADD:   pop     BC              ; Restore number
2D04: D1      	        pop     DE
2D05: C3EB28  	        jp      FPADD           ; Add BCDE to FPREG and return
              	
2D08: 7B      	EDIGIT: ld      A,E             ; Get digit
2D09: 07      	        rlca                    ; Times 2
2D0A: 07      	        rlca                    ; Times 4
2D0B: 83      	        add     A,E             ; Times 5
2D0C: 07      	        rlca                    ; Times 10
2D0D: 86      	        add     A,(HL)          ; Add next digit
2D0E: D630    	        sub     '0'             ; Make it absolute
2D10: 5F      	        ld      E,A             ; Save new digit
2D11: C3B32C  	        jp      EXPLP           ; Look for another digit
              	
2D14: E5      	LINEIN: push    HL              ; Save code string address
2D15: 219414  	        ld      HL,INMSG        ; Output " in "
2D18: CD9B23  	        call    PRS             ; Output string at HL
2D1B: E1      	        pop     HL              ; Restore code string address
2D1C: EB      	PRNTHL: ex      DE,HL           ; Code string address to DE
2D1D: AF      	        xor     A
2D1E: 0698    	        ld      B,$80+24        ; 24 bits
2D20: CD992B  	        call    RETINT          ; Return the integer
2D23: 219A23  	        ld      HL,PRNUMS       ; Print number string
2D26: E5      	        push    HL              ; Save for return
2D27: 213082  	NUMASC: ld      HL,PBUFF        ; Convert number to ASCII
2D2A: E5      	        push    HL              ; Save for return
2D2B: CD822B  	        call    TSTSGN          ; Test sign of FPREG
2D2E: 3620    	        ld      (HL),SPC        ; Space at start
2D30: F2352D  	        jp      P,SPCFST        ; Positive - Space to start
2D33: 362D    	        ld      (HL),'-'        ; '-' sign at start
2D35: 23      	SPCFST: inc     HL              ; First byte of number
2D36: 3630    	        ld      (HL),'0'        ; '0' if zero
2D38: CAEB2D  	        jp      Z,JSTZER        ; Return '0' if zero
2D3B: E5      	        push    HL              ; Save buffer address
2D3C: FCAB2B  	        call    M,INVSGN        ; Negate FPREG if negative
2D3F: AF      	        xor     A               ; Zero A
2D40: F5      	        push    AF              ; Save it
2D41: CDF12D  	        call    RNGTST          ; Test number is in range
2D44: 014391  	SIXDIG: ld      BC,$9143        ; BCDE - 99999.9
2D47: 11F84F  	        ld      DE,$4FF8
2D4A: CDFD2B  	        call    CMPNUM          ; Compare numbers
2D4D: B7      	        or      A
2D4E: E2622D  	        jp      PO,INRNG        ; > 99999.9 - Sort it out
2D51: F1      	        pop     AF              ; Restore count
2D52: CDDF2C  	        call    MULTEN          ; Multiply by ten
2D55: F5      	        push    AF              ; Re-save count
2D56: C3442D  	        jp      SIXDIG          ; Test it again
              	
2D59: CDCA2A  	GTSIXD: call    DIV10           ; Divide by 10
2D5C: F1      	        pop     AF              ; Get count
2D5D: 3C      	        inc     A               ; Count divides
2D5E: F5      	        push    AF              ; Re-save count
2D5F: CDF12D  	        call    RNGTST          ; Test number is in range
2D62: CDD928  	INRNG:  call    ROUND           ; Add 0.5 to FPREG
2D65: 3C      	        inc     A
2D66: CD2A2C  	        call    FPINT           ; F.P to integer
2D69: CDC32B  	        call    FPBCDE          ; Move BCDE to FPREG
2D6C: 010603  	        ld      BC,$0306        ; 1E+06 to 1E-03 range
2D6F: F1      	        pop     AF              ; Restore count
2D70: 81      	        add     A,C             ; 6 digits before point
2D71: 3C      	        inc     A               ; Add one
2D72: FA7E2D  	        jp      M,MAKNUM        ; Do it in 'E' form if < 1E-02
2D75: FE08    	        cp      6+1+1           ; More than 999999 ?
2D77: D27E2D  	        jp      NC,MAKNUM       ; Yes - Do it in 'E' form
2D7A: 3C      	        inc     A               ; Adjust for exponent
2D7B: 47      	        ld      B,A             ; Exponent of number
2D7C: 3E02    	        ld      A,2             ; Make it zero after
              	
2D7E: 3D      	MAKNUM: dec     A               ; Adjust for digits to do
2D7F: 3D      	        dec     A
2D80: E1      	        pop     HL              ; Restore buffer address
2D81: F5      	        push    AF              ; Save count
2D82: 11042E  	        ld      DE,POWERS       ; Powers of ten
2D85: 05      	        dec     B               ; Count digits before point
2D86: C28F2D  	        jp      NZ,DIGTXT       ; Not zero - Do number
2D89: 362E    	        ld      (HL),'.'        ; Save point
2D8B: 23      	        inc     HL              ; Move on
2D8C: 3630    	        ld      (HL),'0'        ; Save zero
2D8E: 23      	        inc     HL              ; Move on
2D8F: 05      	DIGTXT: dec     B               ; Count digits before point
2D90: 362E    	        ld      (HL),'.'        ; Save point in case
2D92: CCD82B  	        call    Z,INCHL         ; Last digit - move on
2D95: C5      	        push    BC              ; Save digits before point
2D96: E5      	        push    HL              ; Save buffer address
2D97: D5      	        push    DE              ; Save powers of ten
2D98: CDCE2B  	        call    BCDEFP          ; Move FPREG to BCDE
2D9B: E1      	        pop     HL              ; Powers of ten table
2D9C: 062F    	        ld      B,'0'-1         ; ASCII '0' - 1
2D9E: 04      	TRYAGN: inc     B               ; Count subtractions
2D9F: 7B      	        ld      A,E             ; Get LSB
2DA0: 96      	        sub     (HL)            ; Subtract LSB
2DA1: 5F      	        ld      E,A             ; Save LSB
2DA2: 23      	        inc     HL
2DA3: 7A      	        ld      A,D             ; Get NMSB
2DA4: 9E      	        sbc     A,(HL)          ; Subtract NMSB
2DA5: 57      	        ld      D,A             ; Save NMSB
2DA6: 23      	        inc     HL
2DA7: 79      	        ld      A,C             ; Get MSB
2DA8: 9E      	        sbc     A,(HL)          ; Subtract MSB
2DA9: 4F      	        ld      C,A             ; Save MSB
2DAA: 2B      	        dec     HL              ; Point back to start
2DAB: 2B      	        dec     HL
2DAC: D29E2D  	        jp      NC,TRYAGN       ; No overflow - Try again
2DAF: CD9029  	        call    PLUCDE          ; Restore number
2DB2: 23      	        inc     HL              ; Start of next number
2DB3: CDC32B  	        call    FPBCDE          ; Move BCDE to FPREG
2DB6: EB      	        ex      DE,HL           ; Save point in table
2DB7: E1      	        pop     HL              ; Restore buffer address
2DB8: 70      	        ld      (HL),B          ; Save digit in buffer
2DB9: 23      	        inc     HL              ; And move on
2DBA: C1      	        pop     BC              ; Restore digit count
2DBB: 0D      	        dec     C               ; Count digits
2DBC: C28F2D  	        jp      NZ,DIGTXT       ; More - Do them
2DBF: 05      	        dec     B               ; Any decimal part?
2DC0: CACF2D  	        jp      Z,DOEBIT        ; No - Do 'E' bit
2DC3: 2B      	SUPTLZ: dec     HL              ; Move back through buffer
2DC4: 7E      	        ld      A,(HL)          ; Get character
2DC5: FE30    	        cp      '0'             ; '0' character?
2DC7: CAC32D  	        jp      Z,SUPTLZ        ; Yes - Look back for more
2DCA: FE2E    	        cp      '.'             ; A decimal point?
2DCC: C4D82B  	        call    NZ,INCHL        ; Move back over digit
              	
2DCF: F1      	DOEBIT: pop     AF              ; Get 'E' flag
2DD0: CAEE2D  	        jp      Z,NOENED        ; No 'E' needed - End buffer
2DD3: 3645    	        ld      (HL),'E'        ; Put 'E' in buffer
2DD5: 23      	        inc     HL              ; And move on
2DD6: 362B    	        ld      (HL),'+'        ; Put '+' in buffer
2DD8: F2DF2D  	        jp      P,OUTEXP        ; Positive - Output exponent
2DDB: 362D    	        ld      (HL),'-'        ; Put '-' in buffer
2DDD: 2F      	        cpl                     ; Negate exponent
2DDE: 3C      	        inc     A
2DDF: 062F    	OUTEXP: ld      B,'0'-1         ; ASCII '0' - 1
2DE1: 04      	EXPTEN: inc     B               ; Count subtractions
2DE2: D60A    	        sub     $0A             ; Tens digit
2DE4: D2E12D  	        jp      NC,EXPTEN       ; More to do
2DE7: C63A    	        add     A,'0'+10        ; Restore and make ASCII
2DE9: 23      	        inc     HL              ; Move on
2DEA: 70      	        ld      (HL),B          ; Save MSB of exponent
2DEB: 23      	JSTZER: inc     HL              ;
2DEC: 77      	        ld      (HL),A          ; Save LSB of exponent
2DED: 23      	        inc     HL
2DEE: 71      	NOENED: ld      (HL),C          ; Mark end of buffer
2DEF: E1      	        pop     HL              ; Restore code string address
2DF0: C9      	        ret
              	
2DF1: 017494  	RNGTST: ld      BC,$9474        ; BCDE = 999999.
2DF4: 11F723  	        ld      DE,$23F7
2DF7: CDFD2B  	        call    CMPNUM          ; Compare numbers
2DFA: B7      	        or      A
2DFB: E1      	        pop     HL              ; Return address to HL
2DFC: E2592D  	        jp      PO,GTSIXD       ; Too big - Divide by ten
2DFF: E9      	        jp      (HL)            ; Otherwise return to caller
              	
2E00: 00000080	HALF:   defb    $00,$00,$00,$80 ; 0.5
              	
2E04: A08601  	POWERS: defb    $A0,$86,$01  ; 100000
2E07: 102700  	        defb    $10,$27,$00  ;  10000
2E0A: E80300  	        defb    $E8,$03,$00  ;   1000
2E0D: 640000  	        defb    $64,$00,$00  ;    100
2E10: 0A0000  	        defb    $0A,$00,$00  ;     10
2E13: 010000  	        defb    $01,$00,$00  ;      1
              	
2E16: 21AB2B  	NEGAFT: ld      HL,INVSGN       ; Negate result
2E19: E3      	        ex      (SP),HL         ; To be done after caller
2E1A: E9      	        jp      (HL)            ; Return to caller
              	
2E1B: CDB32B  	SQR:    call    STAKFP          ; Put value on stack
2E1E: 21002E  	        ld      HL,HALF         ; Set power to 1/2
2E21: CDC02B  	        call    PHLTFP          ; Move 1/2 to FPREG
              	
2E24: C1      	POWER:  pop     BC              ; Get base
2E25: D1      	        pop     DE
2E26: CD822B  	        call    TSTSGN          ; Test sign of power
2E29: 78      	        ld      A,B             ; Get exponent of base
2E2A: CA692E  	        jp      Z,EXP           ; Make result 1 if zero
2E2D: F2342E  	        jp      P,POWER1        ; Positive base - Ok
2E30: B7      	        or      A               ; Zero to negative power?
2E31: CA1E15  	        jp      Z,DZERR         ; Yes - ?/0 Error
2E34: B7      	POWER1: or      A               ; Base zero?
2E35: CA5229  	        jp      Z,SAVEXP        ; Yes - Return zero
2E38: D5      	        push    DE              ; Save base
2E39: C5      	        push    BC
2E3A: 79      	        ld      A,C             ; Get MSB of base
2E3B: F67F    	        or      %01111111       ; Get sign status
2E3D: CDCE2B  	        call    BCDEFP          ; Move power to BCDE
2E40: F2512E  	        jp      P,POWER2        ; Positive base - Ok
2E43: D5      	        push    DE              ; Save power
2E44: C5      	        push    BC
2E45: CD552C  	        call    INT             ; Get integer of power
2E48: C1      	        pop     BC              ; Restore power
2E49: D1      	        pop     DE
2E4A: F5      	        push    AF              ; MSB of base
2E4B: CDFD2B  	        call    CMPNUM          ; Power an integer?
2E4E: E1      	        pop     HL              ; Restore MSB of base
2E4F: 7C      	        ld      A,H             ; but don't affect flags
2E50: 1F      	        rra                     ; Exponent odd or even?
2E51: E1      	POWER2: pop     HL              ; Restore MSB and exponent
2E52: 22CB81  	        ld      (FPREG+2),HL    ; Save base in FPREG
2E55: E1      	        pop     HL              ; LSBs of base
2E56: 22C981  	        ld      (FPREG),HL      ; Save in FPREG
2E59: DC162E  	        call    C,NEGAFT        ; Odd power - Negate result
2E5C: CCAB2B  	        call    Z,INVSGN        ; Negative base - Negate it
2E5F: D5      	        push    DE              ; Save power
2E60: C5      	        push    BC
2E61: CDE529  	        call    LOG             ; Get LOG of base
2E64: C1      	        pop     BC              ; Restore power
2E65: D1      	        pop     DE
2E66: CD262A  	        call    FPMULT          ; Multiply LOG by power
              	
2E69: CDB32B  	EXP:    call    STAKFP          ; Put value on stack
2E6C: 013881  	        ld      BC,$8138        ; BCDE = 1/Ln(2)
2E6F: 113BAA  	        ld      DE,$AA3B
2E72: CD262A  	        call    FPMULT          ; Multiply value by 1/LN(2)
2E75: 3ACC81  	        ld      A,(FPEXP)       ; Get exponent
2E78: FE88    	        cp      $80+8           ; Is it in range?
2E7A: D25E2B  	        jp      NC,OVTST1       ; No - Test for overflow
2E7D: CD552C  	        call    INT             ; Get INT of FPREG
2E80: C680    	        add     A,$80           ; For excess 128
2E82: C602    	        add     A,$02           ; Exponent > 126?
2E84: DA5E2B  	        jp      C,OVTST1        ; Yes - Test for overflow
2E87: F5      	        push    AF              ; Save scaling factor
2E88: 21D429  	        ld      HL,UNITY        ; Point to 1.
2E8B: CDDC28  	        call    ADDPHL          ; Add 1 to FPREG
2E8E: CD1D2A  	        call    MULLN2          ; Multiply by LN(2)
2E91: F1      	        pop     AF              ; Restore scaling factor
2E92: C1      	        pop     BC              ; Restore exponent
2E93: D1      	        pop     DE
2E94: F5      	        push    AF              ; Save scaling factor
2E95: CDE828  	        call    SUBCDE          ; Subtract exponent from FPREG
2E98: CDAB2B  	        call    INVSGN          ; Negate result
2E9B: 21A92E  	        ld      HL,EXPTAB       ; Coefficient table
2E9E: CDD92E  	        call    SMSER1          ; Sum the series
2EA1: 110000  	        ld      DE,$0000        ; Zero LSBs
2EA4: C1      	        pop     BC              ; Scaling factor
2EA5: 4A      	        ld      C,D             ; Zero MSB
2EA6: C3262A  	        jp      FPMULT          ; Scale result to correct value
              	
2EA9: 08      	EXPTAB: defb    $08             ; Table used by EXP
2EAA: 402E9474	        defb    $40,$2E,$94,$74 ; -1/7! (-1/5040)
2EAE: 704F2E77	        defb    $70,$4F,$2E,$77 ;  1/6! ( 1/720)
2EB2: 6E02887A	        defb    $6E,$02,$88,$7A ; -1/5! (-1/120)
2EB6: E6A02A7C	        defb    $E6,$A0,$2A,$7C ;  1/4! ( 1/24)
2EBA: 50AAAA7E	        defb    $50,$AA,$AA,$7E ; -1/3! (-1/6)
2EBE: FFFF7F7F	        defb    $FF,$FF,$7F,$7F ;  1/2! ( 1/2)
2EC2: 00008081	        defb    $00,$00,$80,$81 ; -1/1! (-1/1)
2EC6: 00000081	        defb    $00,$00,$00,$81 ;  1/0! ( 1/1)
              	
2ECA: CDB32B  	SUMSER: call    STAKFP          ; Put FPREG on stack
2ECD: 11242A  	        ld      DE,MULT         ; Multiply by "X"
2ED0: D5      	        push    DE              ; To be done after
2ED1: E5      	        push    HL              ; Save address of table
2ED2: CDCE2B  	        call    BCDEFP          ; Move FPREG to BCDE
2ED5: CD262A  	        call    FPMULT          ; Square the value
2ED8: E1      	        pop     HL              ; Restore address of table
2ED9: CDB32B  	SMSER1: call    STAKFP          ; Put value on stack
2EDC: 7E      	        ld      A,(HL)          ; Get number of coefficients
2EDD: 23      	        inc     HL              ; Point to start of table
2EDE: CDC02B  	        call    PHLTFP          ; Move coefficient to FPREG
2EE1: 06      	        defb    06H             ; Skip "pop AF"
2EE2: F1      	SUMLP:  pop     AF              ; Restore count
2EE3: C1      	        pop     BC              ; Restore number
2EE4: D1      	        pop     DE
2EE5: 3D      	        dec     A               ; Cont coefficients
2EE6: C8      	        ret     Z               ; All done
2EE7: D5      	        push    DE              ; Save number
2EE8: C5      	        push    BC
2EE9: F5      	        push    AF              ; Save count
2EEA: E5      	        push    HL              ; Save address in table
2EEB: CD262A  	        call    FPMULT          ; Multiply FPREG by BCDE
2EEE: E1      	        pop     HL              ; Restore address in table
2EEF: CDD12B  	        call    LOADFP          ; Number at HL to BCDE
2EF2: E5      	        push    HL              ; Save address in table
2EF3: CDEB28  	        call    FPADD           ; Add coefficient to FPREG
2EF6: E1      	        pop     HL              ; Restore address in table
2EF7: C3E22E  	        jp      SUMLP           ; More coefficients
              	
2EFA: CD822B  	RND:    call    TSTSGN          ; Test sign of FPREG
2EFD: 217A80  	        ld      HL,SEED+2       ; Random number seed
2F00: FA5B2F  	        jp      M,RESEED        ; Negative - Re-seed
2F03: 219B80  	        ld      HL,LSTRND       ; Last random number
2F06: CDC02B  	        call    PHLTFP          ; Move last RND to FPREG
2F09: 217A80  	        ld      HL,SEED+2       ; Random number seed
2F0C: C8      	        ret     Z               ; Return if RND(0)
2F0D: 86      	        add     A,(HL)          ; Add (SEED)+2)
2F0E: E607    	        and     %00000111       ; 0 to 7
2F10: 0600    	        ld      B,$00
2F12: 77      	        ld      (HL),A          ; Re-save seed
2F13: 23      	        inc     HL              ; Move to coefficient table
2F14: 87      	        add     A,A             ; 4 bytes
2F15: 87      	        add     A,A             ; per entry
2F16: 4F      	        ld      C,A             ; BC = Offset into table
2F17: 09      	        add     HL,BC           ; Point to coefficient
2F18: CDD12B  	        call    LOADFP          ; Coefficient to BCDE
2F1B: CD262A  	        call    FPMULT  ;       ; Multiply FPREG by coefficient
2F1E: 3A7980  	        ld      A,(SEED+1)      ; Get (SEED+1)
2F21: 3C      	        inc     A               ; Add 1
2F22: E603    	        and     %00000011       ; 0 to 3
2F24: 0600    	        ld      B,$00
2F26: FE01    	        cp      $01             ; Is it zero?
2F28: 88      	        adc     A,B             ; Yes - Make it 1
2F29: 327980  	        ld      (SEED+1),A      ; Re-save seed
2F2C: 215F2F  	        ld      HL,RNDTAB-4     ; Addition table
2F2F: 87      	        add     A,A             ; 4 bytes
2F30: 87      	        add     A,A             ; per entry
2F31: 4F      	        ld      C,A             ; BC = Offset into table
2F32: 09      	        add     HL,BC           ; Point to value
2F33: CDDC28  	        call    ADDPHL          ; Add value to FPREG
2F36: CDCE2B  	RND1:   call    BCDEFP          ; Move FPREG to BCDE
2F39: 7B      	        ld      A,E             ; Get LSB
2F3A: 59      	        ld      E,C             ; LSB = MSB
2F3B: EE4F    	        xor     %01001111       ; Fiddle around
2F3D: 4F      	        ld      C,A             ; New MSB
2F3E: 3680    	        ld      (HL),$80        ; Set exponent
2F40: 2B      	        dec     HL              ; Point to MSB
2F41: 46      	        ld      B,(HL)          ; Get MSB
2F42: 3680    	        ld      (HL),$80        ; Make value -0.5
2F44: 217880  	        ld      HL,SEED         ; Random number seed
2F47: 34      	        inc     (HL)            ; Count seed
2F48: 7E      	        ld      A,(HL)          ; Get seed
2F49: D6AB    	        sub     $AB             ; Do it modulo 171
2F4B: C2522F  	        jp      NZ,RND2         ; Non-zero - Ok
2F4E: 77      	        ld      (HL),A          ; Zero seed
2F4F: 0C      	        inc     C               ; Fillde about
2F50: 15      	        dec     D               ; with the
2F51: 1C      	        inc     E               ; number
2F52: CD3C29  	RND2:   call    BNORM           ; Normalise number
2F55: 219B80  	        ld      HL,LSTRND       ; Save random number
2F58: C3DA2B  	        jp      FPTHL           ; Move FPREG to last and return
              	
2F5B: 77      	RESEED: ld      (HL),A          ; Re-seed random numbers
2F5C: 2B      	        dec     HL
2F5D: 77      	        ld      (HL),A
2F5E: 2B      	        dec     HL
2F5F: 77      	        ld      (HL),A
2F60: C3362F  	        jp      RND1            ; Return RND seed
              	
2F63: 68B14668	RNDTAB: defb    $68,$B1,$46,$68 ; Table used by RND
2F67: 99E99269	        defb    $99,$E9,$92,$69
2F6B: 10D17568	        defb    $10,$D1,$75,$68
              	
2F6F: 21B92F  	COS:    ld      HL,HALFPI       ; Point to PI/2
2F72: CDDC28  	        call    ADDPHL          ; Add it to PPREG
2F75: CDB32B  	SIN:    call    STAKFP          ; Put angle on stack
2F78: 014983  	        ld      BC,$8349        ; BCDE = 2 PI
2F7B: 11DB0F  	        ld      DE,$0FDB
2F7E: CDC32B  	        call    FPBCDE          ; Move 2 PI to FPREG
2F81: C1      	        pop     BC              ; Restore angle
2F82: D1      	        pop     DE
2F83: CDD82A  	        call    DVBCDE          ; Divide angle by 2 PI
2F86: CDB32B  	        call    STAKFP          ; Put it on stack
2F89: CD552C  	        call    INT             ; Get INT of result
2F8C: C1      	        pop     BC              ; Restore number
2F8D: D1      	        pop     DE
2F8E: CDE828  	        call    SUBCDE          ; Make it 0 <= value < 1
2F91: 21BD2F  	        ld      HL,QUARTR       ; Point to 0.25
2F94: CDE228  	        call    SUBPHL          ; Subtract value from 0.25
2F97: CD822B  	        call    TSTSGN          ; Test sign of value
2F9A: 37      	        scf                     ; Flag positive
2F9B: F2A52F  	        jp      P,SIN1          ; Positive - Ok
2F9E: CDD928  	        call    ROUND           ; Add 0.5 to value
2FA1: CD822B  	        call    TSTSGN          ; Test sign of value
2FA4: B7      	        or      A               ; Flag negative
2FA5: F5      	SIN1:   push    AF              ; Save sign
2FA6: F4AB2B  	        call    P,INVSGN        ; Negate value if positive
2FA9: 21BD2F  	        ld      HL,QUARTR       ; Point to 0.25
2FAC: CDDC28  	        call    ADDPHL          ; Add 0.25 to value
2FAF: F1      	        pop     AF              ; Restore sign
2FB0: D4AB2B  	        call    NC,INVSGN       ; Negative - Make positive
2FB3: 21C12F  	        ld      HL,SINTAB       ; Coefficient table
2FB6: C3CA2E  	        jp      SUMSER          ; Evaluate sum of series
              	
2FB9: DB0F4981	HALFPI: defb    $DB,$0F,$49,$81 ; 1.5708 (PI/2)
              	
2FBD: 0000007F	QUARTR: defb    $00,$00,$00,$7F ; 0.25
              	
2FC1: 05      	SINTAB: defb    $05             ; Table used by SIN
2FC2: BAD71E86	        defb    $BA,$D7,$1E,$86 ; 39.711
2FC6: 64269987	        defb    $64,$26,$99,$87 ;-76.575
2FCA: 58342387	        defb    $58,$34,$23,$87 ; 81.602
2FCE: E05DA586	        defb    $E0,$5D,$A5,$86 ;-41.342
2FD2: DA0F4983	        defb    $DA,$0F,$49,$83 ;  6.2832
              	
2FD6: CDB32B  	TAN:    call    STAKFP          ; Put angle on stack
2FD9: CD752F  	        call    SIN             ; Get SIN of angle
2FDC: C1      	        pop     BC              ; Restore angle
2FDD: E1      	        pop     HL
2FDE: CDB32B  	        call    STAKFP          ; Save SIN of angle
2FE1: EB      	        ex      DE,HL           ; BCDE = Angle
2FE2: CDC32B  	        call    FPBCDE          ; Angle to FPREG
2FE5: CD6F2F  	        call    COS             ; Get COS of angle
2FE8: C3D62A  	        jp      DIV             ; TAN = SIN / COS
              	
2FEB: CD822B  	ATN:    call    TSTSGN          ; Test sign of value
2FEE: FC162E  	        call    M,NEGAFT        ; Negate result after if -ve
2FF1: FCAB2B  	        call    M,INVSGN        ; Negate value if -ve
2FF4: 3ACC81  	        ld      A,(FPEXP)       ; Get exponent
2FF7: FE81    	        cp      81H             ; Number less than 1?
2FF9: DA0830  	        jp      C,ATN1          ; Yes - Get arc tangnt
2FFC: 010081  	        ld      BC,$8100        ; BCDE = 1
2FFF: 51      	        ld      D,C
3000: 59      	        ld      E,C
3001: CDD82A  	        call    DVBCDE          ; Get reciprocal of number
3004: 21E228  	        ld      HL,SUBPHL       ; Sub angle from PI/2
3007: E5      	        push    HL              ; Save for angle > 1
3008: 211230  	ATN1:   ld      HL,ATNTAB       ; Coefficient table
300B: CDCA2E  	        call    SUMSER          ; Evaluate sum of series
300E: 21B92F  	        ld      HL,HALFPI       ; PI/2 - angle in case > 1
3011: C9      	        ret                     ; Number > 1 - Sub from PI/2
              	
3012: 09      	ATNTAB: defb    $09             ; Table used by ATN
3013: 4AD73B78	        defb    $4A,$D7,$3B,$78 ; 1/17
3017: 026E847B	        defb    $02,$6E,$84,$7B ;-1/15
301B: FEC12F7C	        defb    $FE,$C1,$2F,$7C ; 1/13
301F: 74319A7D	        defb    $74,$31,$9A,$7D ;-1/11
3023: 843D5A7D	        defb    $84,$3D,$5A,$7D ; 1/9
3027: C87F917E	        defb    $C8,$7F,$91,$7E ;-1/7
302B: E4BB4C7E	        defb    $E4,$BB,$4C,$7E ; 1/5
302F: 6CAAAA7F	        defb    $6C,$AA,$AA,$7F ;-1/3
3033: 00000081	        defb    $00,$00,$00,$81 ; 1/1
              	
              	
3037: C9      	ARET:   ret                     ; A RETurn instruction
              	
3038: D7      	GETINP: rst     $10             ; input a character
3039: C9      	        ret
              	
303A: E5      	CLS:    push    HL
303B: D5      	        push    DE
303C: 3AE081  	        ld      A,(SCR_MODE)    ; check screen mode
303F: FE02    	        cp      $02             ; G2 mode?
3041: CC4E05  	        call    Z,EMPTYVIDBUF   ; yes, reset video buffer
3044: D1      	        pop     DE
3045: E1      	        pop     HL
3046: 3E0C    	        ld      A,CS            ; ASCII Clear screen
3048: CD3D18  	        call    SND2VID         ; send to screen
304B: C30A3A  	        jp      MONOUT          ; Output character
              	
304E: CD2326  	WIDTH:  call    GETINT          ; Get integer 0-255
3051: 7B      	        ld      A,E             ; Width to A
3052: 32A280  	        ld      (LWIDTH),A      ; Set width
3055: C9      	        ret
              	
              	
3056: CDD81A  	DEEK:   call    DEINT           ; Get integer -32768 to 32767
3059: D5      	        push    DE              ; Save number
305A: E1      	        pop     HL              ; Number to HL
305B: 46      	RECWRD: ld      B,(HL)          ; Get LSB of contents
305C: 23      	        inc     HL
305D: 7E      	        ld      A,(HL)          ; Get MSB of contents
305E: C37D22  	        jp      ABPASS          ; Return integer AB
              	
3061: CD971E  	DOKE:   call    GETNUM          ; Get a number
3064: CDD81A  	        call    DEINT           ; Get integer -32768 to 32767
3067: D5      	        push    DE              ; Save address
3068: CDFF17  	        call    CHKSYN          ; Make sure ',' follows
306B: 2C      	        defb    ','
306C: CD971E  	        call    GETNUM          ; Get a number
306F: CDD81A  	        call    DEINT           ; Get integer -32768 to 32767
3072: E3      	        ex      (SP),HL         ; Save value,get address
3073: 73      	        ld      (HL),E          ; Save LSB of value
3074: 23      	        inc     HL
3075: 72      	        ld      (HL),D          ; Save MSB of value
3076: E1      	        pop     HL              ; Restore code string address
3077: C9      	        ret
              	
              	; stop the execution of code for a certain bit of time. The pause
              	; is between $0000 and $FFFF 100ths of second (0~655.5 secs)
3078: CD971E  	PAUSE:  call    GETNUM          ; Get a number
307B: CDD81A  	        call    DEINT           ; Get integer -32768 to 32767
307E: 7A      	        ld      A,D             ; load D into A
307F: B3      	        or      E               ; are D & E equal to $00?
3080: C8      	        ret     Z               ; if yes, then return
3081: C5      	DIR_PAU:push    BC              ; store BC
3082: 3ACE81  	        ld      A,(TMRCNT)      ; Load current value of system timer
3085: 47      	        ld      B,A             ; move it into B
3086: CD4D1A  	RPTPS:  call    TSTBRK          ; Test for break key
3089: 3ACE81  	        ld      A,(TMRCNT)      ; Load current value of system timer
308C: B8      	        cp      B               ; is it the same value?
308D: 28F7    	        jr      Z,RPTPS         ; yes, so read again
308F: 47      	        ld      B,A             ; no, so store the new value
3090: 1B      	        dec     DE              ; decrement interval
3091: 7A      	        ld      A,D             ; load D into A
3092: B3      	        or      E               ; check if DE is equal to 0 (if D & e are $00 then result is 0)
3093: 20F1    	        jr      NZ,RPTPS        ; no, repeat
3095: C1      	        pop     BC              ; yes, recover BC and continue
3096: C9      	        ret
              	
              	; change the screen mode. Usage: SCREEN X[,Y][,Z]
              	; where X is: 0=text mode (40x24),
              	; 1=graphic mode 1 (32x24 chars); 2=graphic mode 2 (256x192 pixels);
              	; 3=multicolor mode (64x48 pixels); 4=extended graphic mode 2 (32x24 chars mixed between G1 and G2)
              	; Y is: 0=8x8 sprites, 1=16x16 sprites
              	; Z is: 0=no sprite magnification; 1=sprite magnification x2 (8x8=>16x16, and 16x16=32x32)
              	; (the latters are accepted only in graphic modes G1, G2, G3, and G4)
3097: AF      	SCREEN: xor     A
3098: 32F181  	        ld      (TMPBFR2),A     ; sprite size & magnif. byte set to 0
309B: CD2326  	        call    GETINT          ; Get integer 0-255
309E: FE05    	        cp      $05             ; is it a valid mode (0~4)?
30A0: D2ED1A  	        jp      NC,FCERR        ; No - Illegal function call Error
30A3: 32EF81  	        ld      (TMPBFR1),A     ; store graphic mode
30A6: A7      	        and     A               ; is it 0 (text mode)?
30A7: CAC330  	        jp      Z,SCVDP         ; yes, ignore other arguments and set mode immediately
30AA: CD0231  	SETVDP: call    CHKSCAR         ; no, check if sprite size follows
30AD: DAB530  	        jp      C,CKMAGN        ; no (set to 0 or missing), so jump over
30B0: 3E02    	        ld      A,$02           ; no, so set sprite size
30B2: 32F181  	        ld      (TMPBFR2),A     ; ...to 16x16
30B5: CD0231  	CKMAGN: call    CHKSCAR         ; check if sprite magnification follows
30B8: DAC330  	        jp      C,SCVDP         ; no (set to 0 or missing), so jump over
30BB: 3AF181  	        ld      A,(TMPBFR2)     ; yes, so retrieve sprite attributes...
30BE: F601    	        or      $01             ; ...set sprite magnification to 2x...
30C0: 32F181  	        ld      (TMPBFR2),A     ; ...and save flags again
30C3: F3      	SCVDP:  di                      ; disable INTs
30C4: D5      	        push    DE              ; store DE
30C5: E5      	        push    HL              ; store HL
30C6: 3AEF81  	        ld      A,(TMPBFR1)     ; recover graphic mode
30C9: 5F      	        ld      E,A             ; and store it into E
30CA: 3AF181  	        ld      A,(TMPBFR2)     ; recover sprite flags
30CD: 57      	        ld      D,A             ; and store them into D
30CE: D5      	        push    DE              ; store D & E
30CF: CD7403  	        call    initVDP         ; initialize VDP with mode pointed by E
30D2: D1      	        pop     DE              ; retrieve D & E
30D3: 7B      	        ld      A,E             ; move graphic mode into A
30D4: 87      	        add     A,A
30D5: 87      	        add     A,A
30D6: 87      	        add     A,A             ; multiply A times 8 to get offset of graphic mode
30D7: 5F      	        ld      E,A             ; and pass it into E
30D8: D5      	        push    DE              ; store sprite flags in E
30D9: 1600    	        ld      D,$00           ; reset D
30DB: 212C0A  	        ld      HL,VDPMODESET+1 ; load address of VDP settings for reg#1
30DE: 19      	        add     HL,DE           ; load correct reg#1 setting
30DF: D1      	        pop     DE              ; retrieve sprite flags from E
30E0: 7E      	        ld      A,(HL)          ; load reg#1 setting
30E1: E6FC    	        and     %11111100       ; reset size & magn. bits
30E3: B2      	        or      D               ; set size & magn. bits
30E4: 5F      	        ld      E,A             ; value into E
30E5: 3E01    	        ld      A,$01           ; reg #1
30E7: CD2A06  	        call    WRITE_VREG      ; send setting to reg #1
30EA: 2AAF80  	        ld      HL,(LINEAT)     ; Get current line number
30ED: 23      	        inc     HL              ; -1 means direct statement
30EE: 7C      	        ld      A,H
30EF: B5      	        or      L
30F0: CC2C08  	        call    Z,CURSOR_ON     ; enable cursor if not in program mode
30F3: FB      	        ei                      ; re-enable interrupts
30F4: E1      	        pop     HL              ; restore HL
30F5: D1      	        pop     DE              ; restore DE
30F6: 3ADF81  	        ld      A,(SCR_SIZE_H)  ; check the screen mode by looking at the screen height
30F9: FE30    	        cp      $30             ; is it 48 chars or 192 pixels (MC and G2 modes)?
30FB: D0      	        ret     NC              ; yes, so exit (in graphics 2 and multicolor no print-on-video)
30FC: 3E01    	        ld      A,$01           ; no (we are in Text, G1 or ExG2), so activate the...
30FE: 32EB81  	        ld      (PRNTVIDEO),A   ; ...video buffer...
3101: C9      	        ret                     ; ...and return to caller
              	
              	; check an additional argument for SCREEN
3102: 2B      	CHKSCAR:dec     HL              ; dec 'cos GETCHR INCs
3103: CD221A  	        call    GETCHR          ; Get next character
3106: 37      	        scf                     ; set carry flag
3107: C8      	        ret     Z               ; return if nothing follows with Carry=1
3108: CDFF17  	        call    CHKSYN          ; Make sure ',' follows
310B: 2C      	        defb    ','
310C: CD2326  	        call    GETINT          ; get value
310F: 1F      	        rra                     ; Carry=bit #0
3110: 3F      	        ccf                     ; invert Carry, so Carry=0 if arg. is 1, and Carry=1 otherwise (arg<>1)
3111: C9      	        ret                     ; return
              	
              	
              	; change the colors of the screen - Syntax is COLOR a,b,c where:
              	; a=foreground color / b=background color / c=border color
              	; a,b,c must be in a range between 1 and 15 (0 is transparent and it's not supported)
3112: CD2326  	COLOR:  call    GETINT          ; get first value
3115: CDB931  	        call    CHKCLR          ; check if it's in range 1~15
3118: 32EF81  	        ld      (TMPBFR1),A     ; store it
311B: 3AE081  	        ld      A,(SCR_MODE)    ; check screen mode
311E: FE03    	        cp      $03             ; is it multicolor mode?
3120: 200D    	        jr      NZ,CNTCKCL      ; no, continue
3122: 3E0F    	        ld      A,$0F           ; white for...
3124: 32ED81  	        ld      (FRGNDCLR),A    ; ...foreground (even it's not used in MC)
3127: 3AEF81  	        ld      A,(TMPBFR1)     ; yes, so we stop here because in MC mode we just support border color
312A: 32F381  	        ld      (TMPBFR3),A     ; move color into temp buffer 3
312D: 1834    	        jr      CLRMC           ; jump to set color
312F: CDFF17  	CNTCKCL:call    CHKSYN          ; Make sure ',' follows
3132: 2C      	        defb    ','
3133: CD2326  	        call    GETINT          ; get second value
3136: CDB931  	        call    CHKCLR          ; check if it's in range 1~15
3139: 32F181  	        ld      (TMPBFR2),A     ; store it
313C: 32EE81  	        ld      (BKGNDCLR),A    ; and set as background color
313F: 3AE081  	        ld      A,(SCR_MODE)    ; check screen mode
3142: A7      	        and     A               ; is it text mode?
3143: 281B    	        jr      Z,CLRTXT        ; yes, stop here because in text mode, background and border colors coincide
3145: CDFF17  	        call    CHKSYN          ; Make sure ',' follows
3148: 2C      	        defb    ','
3149: CD2326  	        call    GETINT          ; get third value
314C: CDB931  	        call    CHKCLR          ; check if it's in range 1~15
314F: 32F381  	        ld      (TMPBFR3),A     ; store it
3152: D5      	        push    DE              ; store DE
3153: 3AE081  	        ld      A,(SCR_MODE)    ; check screen mode
3156: FE01    	        cp      $01             ; is it G1 mode?
3158: 2810    	        jr      Z,CLRG1         ; yes, jump over
315A: FE02    	        cp      $02             ; is it G2 mode?
315C: 2815    	        jr      Z,CLRG2         ; yes, jump over
315E: 181C    	        jr      CLREX2          ; last case can only be ExG2
3160: CDAC31  	CLRTXT: call    MIXCLRS         ; mix foreground and background color nibbles in 1 byte
3163: 32F381  	CLRMC:  ld      (TMPBFR3),A     ; store color settings (for MC mode, we only set border color)
3166: D5      	        push    DE              ; store DE
3167: F3      	        di                      ; disable INTs
3168: 182E    	        jr      SETBRCL         ; set colors and exit
316A: CDAC31  	CLRG1:  call    MIXCLRS         ; mix foreground and background color nibbles in 1 byte
316D: 1601    	        ld      D,$01           ; repeat 1 time
316F: 0620    	        ld      B,$20           ; 32 bytes of colors
3171: 1810    	        jr      LOADCLR         ; load colors
3173: CDAC31  	CLRG2:  call    MIXCLRS         ; mix foreground and background color nibbles in 1 byte
3176: 1618    	        ld      D,$18           ; 18 pages of...
3178: 0600    	        ld      B,$00           ; ...256 bytes each
317A: 1807    	        jr      LOADCLR         ; load colors
317C: CDAC31  	CLREX2: call    MIXCLRS         ; mix foreground and background color nibbles in 1 byte
317F: 1608    	        ld      D,$08           ; 8 pages of...
3181: 0600    	        ld      B,$00           ; ...256 bytes each
3183: E5      	LOADCLR:push    HL              ; store HL
3184: 210020  	        ld      HL,$2000        ; color table start: $2000
3187: F3      	        di                      ; disable INTs
3188: CDE005  	        call    SETVDPADRS
318B: 0E30    	        ld      C,VDP_DAT       ; VDP data mode
318D: ED79    	RPTLDCL:out     (C),A           ; after first byte, the VDP autoincrements VRAM pointer
318F: 00      	        nop
3190: 00      	        nop
3191: 10FA    	        djnz    RPTLDCL         ; repeat for 256 bytes (1 page)
3193: 15      	        dec     D               ; did we fill up all the pages?
3194: 20F7    	        jr      NZ,RPTLDCL      ; no, repeat
3196: FB      	        ei
3197: E1      	        pop     HL              ; retrieve HL
3198: 87      	SETBRCL:add     A,A             ; move high nibble
3199: 87      	        add     A,A             ; to right to get the
319A: 87      	        add     A,A             ; foreground color
319B: 87      	        add     A,A             ; into the low nibble
319C: 32ED81  	        ld      (FRGNDCLR),A    ; store foreground color
319F: 3AF381  	        ld      A,(TMPBFR3)     ; recover border color
31A2: 5F      	        ld      E,A             ; move A into E
31A3: 3E07    	        ld      A,$07           ; VDP register 7
31A5: F3      	        di
31A6: CD2A06  	        call    WRITE_VREG      ; send value to VDP: set border color
31A9: FB      	        ei                      ; re-enable INTs
31AA: D1      	        pop     DE              ; retrieve DE
31AB: C9      	        ret                     ; return to caller
              	
              	
              	; mix 2 color nibbles in 1 byte
31AC: 3AF181  	MIXCLRS:ld      A,(TMPBFR2)     ; retrieve background color
31AF: 47      	        ld      B,A             ; move it into B
31B0: 3AEF81  	        ld      A,(TMPBFR1)     ; retrieve foreground color
31B3: 87      	        add     A,A             ; move foreground color into the high nibble of A
31B4: 87      	        add     A,A
31B5: 87      	        add     A,A
31B6: 87      	        add     A,A
31B7: B0      	        or      B               ; put background color into the low nibble of A
31B8: C9      	        ret                     ; return to caller
              	
              	
              	; check if the color is not 0 and into the range 1~15
31B9: A7      	CHKCLR: and     A               ; is it 0?
31BA: CA1B15  	        jp      Z,SNERR         ; yes, raise a SN error
31BD: FE10    	        cp      $10             ; is it in range 1~15?
31BF: D21B15  	        jp      NC,SNERR        ; no, raise a SN error
31C2: C9      	        ret                     ; param is OK, can return
              	
              	
              	; check if in graphics 2 mode
31C3: 3AE081  	CHKG2M: ld      A,(SCR_MODE)    ; check screen mode
31C6: FE02    	        cp      $02             ; actually, we can paint only in G2
31C8: C2B135  	        jp      NZ,GMERR        ; no G2, print a No Graphics Mode Error
31CB: C9      	        ret                     ; return to caller
              	
              	
              	; POINT(x,y): return if a pixel is set (1) or reset (0)
31CC: CDC331  	POINT:  call    CHKG2M          ; check if in graphic mode 2
31CF: CDFF17  	        call    CHKSYN          ; make sure "(" follows
31D2: 28      	        defb    '('
31D3: CD2326  	        call    GETINT          ; get X coords.
31D6: 32EF81  	        ld      (TMPBFR1),A     ; store it into a temp buffer
31D9: CDFF17  	        call    CHKSYN          ; Make sure ',' follows
31DC: 2C      	        defb    ','
31DD: CD2326  	        call    GETINT          ; get Y coords,
31E0: FEC0    	        cp      $C0             ; check if Y is in range 0~191
31E2: D2ED1A  	        jp      NC,FCERR        ; no, raise an FC error
31E5: 32F181  	        ld      (TMPBFR2),A     ; store into a temp buffer
31E8: CDFF17  	        call    CHKSYN          ; make sure ")" follows
31EB: 29      	        defb    ')'
31EC: E5      	        push    HL              ; store current string address (the point after the ")")...
31ED: FDE1    	        pop     IY              ; ...into IY
31EF: CD5F32  	        call    XY2HL           ; find HL address of pixel at X,Y
31F2: 57      	        ld      D,A             ; store pixel index
31F3: F3      	        di                      ; disable INTs
31F4: CD0006  	        call    READ_VIDEO_LOC  ; read contents of VRAM cell addressed by HL
31F7: FB      	        ei                      ; re-enable INTs
31F8: A2      	        and     D               ; is the pixel ON or OFF?
31F9: E1      	        pop     HL              ; drop original return point
31FA: FDE5    	        push    IY              ; load current string address from IY into stack
31FC: 11821F  	        ld      DE,RETNUM       ; Return number from function
31FF: D5      	        push    DE              ; Save on stack
3200: 3E00    	        LD      A,$00
3202: 0600    	        LD      B,$00           ; Integer AB = 0
3204: CA7D22  	        jp      Z,ABPASS        ; return AB
3207: 04      	        inc     B               ; otherwise, AB = 1
3208: C37D22  	PNTEND: jp      ABPASS          ; return AB
              	
              	
              	; PLOT X,Y[,color]
              	; plot a pixel in graphic mode 2
320B: CDC331  	PLOT:   call    CHKG2M          ; check if in G2 mode
320E: CD2326  	        call    GETINT          ; get X coords.
3211: 32EF81  	        ld      (TMPBFR1),A     ; store it into a temp buffer
3214: CDFF17  	        call    CHKSYN          ; Make sure ',' follows
3217: 2C      	        defb    ','
3218: CD2326  	        call    GETINT          ; get Y coords,
321B: FEC0    	        cp      $C0             ; check if Y is in range 0~191
321D: D2ED1A  	        jp      NC,FCERR        ; no, raise an FC error
3220: 32F181  	        ld      (TMPBFR2),A     ; store into a temp buffer
3223: CD9835  	        call    CLRPRM          ; check if param "color" has been passed
3226: E5      	CNTPLOT:push    HL              ; store HL
3227: C5      	        push    BC              ; store BC
3228: D5      	        push    DE              ; store DE
3229: CD5F32  	        call    XY2HL           ; find VRAM address of byte containing pixel at X,Y & return into HL
322C: D25332  	        jp      NC,NOGD         ; if carry is reset, there was an error -> so leave
322F: 57      	        ld      D,A             ; move pixel value into D
3230: 3AF381  	        ld      A,(TMPBFR3)     ; retrieve color
3233: 87      	        add     A,A             ; now we move low nibble
3234: 87      	        add     A,A             ; in the high nibble
3235: 87      	        add     A,A             ; by adding A to itself
3236: 87      	        add     A,A             ; 4 times (this is a shift left 4)
3237: 5F      	        ld      E,A             ; move it into E
3238: F3      	        di                      ; disable INTs
3239: CD0006  	        call    READ_VIDEO_LOC  ; load original value of VRAM cell pointed by HL
323C: FB      	        ei
323D: B2      	        or      D               ; plot new pixel preserving original pattern
323E: F3      	        di
323F: CD1506  	        call    WRITE_VIDEO_LOC ; write new value into VRAM cell
3242: FB      	        ei
3243: CBEC    	        set     5,H             ; set to write into color VRAM (it's like adding $2000 to HL)
3245: F3      	        di
3246: CD0006  	        call    READ_VIDEO_LOC  ; load original colors of pixel
3249: FB      	        ei
324A: E60F    	        and     %00001111       ; reset high nibble (the foreground color)
324C: B3      	        or      E               ; set new foreground color
324D: F3      	        di
324E: CD1506  	        call    WRITE_VIDEO_LOC ; write new color settings
3251: FB      	        ei                      ; re-enable INTs
3252: 00      	        nop                     ; wait for INTs to be enabled again
3253: D1      	NOGD:   pop     DE              ; retrieve DE
3254: C1      	        pop     BC              ; retrieve BC
3255: E1      	        pop     HL              ; retrieve HL
3256: C9      	        ret                     ; return to caller
3257: 80402010	PXLSET: defb    $80,$40,$20,$10,$08,$04,$02,$01 ; pixel to be set ON
325B: 08040201	
              	        ; where R(X/8)=> 0=80h, 1=40h, 2=20h, 3=10h, 4=08h, 5=04h, 6=02h, 7=$01
              	
              	
              	; compute the VRAM address of the byte containing the pixel
              	; being pointed by X,Y (TMPBFR1,TMPBFR1)
              	; byte address is returned into HL
              	; pixel is returned into A
325F:         	XY2HL:  ; formula is: ADDRESS=(INT(X/8))*8 + (INT(Y/8))*256 + R(Y/8)
              	        ; where R(Y/8) is the remainder of (Y/8)
              	        ; the pixel to be set is given by R(X/8), and data is taken from the array
325F: 3AF181  	        ld      A,(TMPBFR2)     ; retrieve Y
3262: FEC0    	        cp      $C0             ; Y>=192?
3264: D0      	        ret     NC              ; yes, so leave
3265: 1E08    	        ld      E,$08           ; load E with divisor
3267: 57      	        ld      D,A             ; and store into D (dividend)
3268: CD5C3A  	        call    DIV_8_8         ; get Y/8, D is quotient=INT(Y/8), and A is remainder
326B: 4F      	        ld      C,A             ; store remainder into C
326C: 42      	        ld      B,D             ; B=(INT(Y/8))*256 (we simply copy quotient into B)
326D: 6069    	        ld      HL,BC           ; copy BC into HL: now HL has the VRAM address of the byte being set
326F: 3AEF81  	        ld      A,(TMPBFR1)     ; retrieve X
3272: 57      	        ld      D,A             ; and move it into D (dividend)
3273: CD5C3A  	        call    DIV_8_8         ; get X/8, D is quotient=INT(X/8), and A is remainder
3276: 4F      	        ld      C,A             ; store remainder into C
3277: 7A      	        ld      A,D             ; move quotient into A
3278: 87      	        add     A,A
3279: 87      	        add     A,A
327A: 87      	        add     A,A             ; multiply quotient by 8
327B: 5F      	        ld      E,A             ; store result into E
327C: 1600    	        ld      D,$00           ; reset D
327E: 19      	        add     HL,DE           ; add DE to HL, getting the final VRAM address
327F: EB      	        ex      DE,HL           ; move VRAM address into DE
3280: 215732  	        ld      HL,PXLSET       ; starting address of table for pixel to draw
3283: 0600    	        ld      B,$00           ; reset B
3285: 09      	        add     HL,BC           ; add C (remainder of X/8) to get address of pixel to turn on
3286: 7E      	        ld      A,(HL)          ; load pixel data
3287: EB      	        ex      DE,HL           ; retrieve VRAM pattern address into HL
3288: 37      	        scf                     ; set Carry for normal exit
3289: C9      	        ret                     ; return to caller
              	
              	
              	; DRAW X1,Y1,X2,Y2[,color]
              	; Draw a line using Bresenham's line algorithm from X1,Y1 to X2,Y2
              	; X1,Y1 can be either less than or greater than X2,Y2 (meaning that)
              	; the drawing will be ever done from X1,Y2 to X2,Y2, regardless of
              	; the values. If color is not specified, the foreground color set
              	; with COLOR will be used 
81EF:         	X1      equ     TMPBFR1
81F1:         	Y1      equ     TMPBFR2
81F7:         	X2      equ     VIDEOBUFF
81F9:         	Y2      equ     VIDEOBUFF+$02
81FB:         	ER      equ     VIDEOBUFF+$04
81FD:         	E2      equ     VIDEOBUFF+$06
81FF:         	SX      equ     VIDEOBUFF+$08
8201:         	SY      equ     VIDEOBUFF+$0A
8203:         	DX      equ     VIDEOBUFF+$0C
8205:         	DY      equ     VIDEOBUFF+$0E
328A: CDC331  	DRAW:   call    CHKG2M          ; check if in G2 mode
328D: CD8035  	        call    CLRVDBF         ; clear VIDEOBUFF
3290: CD2326  	        call    GETINT          ; get X1 coords.
3293: 32EF81  	        ld      (X1),A          ; store it into a temp buffer
3296: CDFF17  	        call    CHKSYN          ; Make sure ',' follows
3299: 2C      	        defb    ','
329A: CD2326  	        call    GETINT          ; get Y1 coords.
329D: FEC0    	        cp      $C0             ; check if Y1 is in range 0~191
329F: D2ED1A  	        jp      NC,FCERR        ; no, raise an FC error
32A2: 32F181  	        ld      (Y1),A          ; store into a temp buffer
32A5: CDFF17  	        call    CHKSYN          ; Make sure ',' follows
32A8: 2C      	        defb    ','
32A9: CD2326  	        call    GETINT          ; get X2 coords.
32AC: 32F781  	        ld      (X2),A          ; store it into a temp buffer
32AF: CDFF17  	        call    CHKSYN          ; Make sure ',' follows
32B2: 2C      	        defb    ','
32B3: CD2326  	        call    GETINT          ; get Y2 coords
32B6: FEC0    	        cp      $C0             ; check if Y2 is in range 0~191
32B8: D2ED1A  	        jp      NC,FCERR        ; no, raise an FC error
32BB: 32F981  	        ld      (Y2),A          ; store it into a temp buffer
32BE: CD9835  	        call    CLRPRM          ; check for arg. "color" and store it into TMPBFR3
32C1: E5      	        push    HL              ; store register we'll use
32C2: D5      	        push    DE              
32C3: C5      	        push    BC
32C4: ED5BEF81	        ld      DE,(X1)         ; load X1 and
32C8: 2AF781  	        ld      HL,(X2)         ; X2
32CB: B7      	        or      A               ; clear CARRY
32CC: ED52    	        sbc     HL,DE           ; DX=X2-X1
32CE: CD523A  	        call    absHL           ; DX=ABS(DX)
32D1: 220382  	        ld      (DX),HL         ; store DX
32D4: 01FFFF  	        ld      BC,$FFFF        ; SX=-1
32D7: 2AEF81  	        ld      HL,(X1)
32DA: ED5BF781	        ld      DE,(X2)
32DE: CD2D3A  	        call    CMP16           ; X1<X2?
32E1: F2E732  	        jp      P,X1GR          ; no, X1>=X2
32E4: 010100  	        ld      BC,$0001        ; yes, so set SX=1
32E7: ED43FF81	X1GR:   ld      (SX),BC         ; store SX
32EB: ED5BF181	        ld      DE,(Y1)
32EF: 2AF981  	        ld      HL,(Y2)
32F2: B7      	        or      A               ; clear Carry
32F3: ED52    	        sbc     HL,DE           ; DY=Y2-Y1
32F5: CD523A  	        call    absHL           ; DY=ABS(DY)
32F8: 220582  	        ld      (DY),HL         ; store DY
32FB: 01FFFF  	        ld      BC,$FFFF        ; SY=-1
32FE: 2AF181  	        ld      HL,(Y1)
3301: ED5BF981	        ld      DE,(Y2)
3305: CD2D3A  	        call    CMP16           ; is Y1<Y2?
3308: F20E33  	        jp      P,Y1GR          ; no, Y1>=Y2
330B: 010100  	        ld      BC,$0001        ; yes, so set SY=1
330E: ED430182	Y1GR:   ld      (SY),BC         ; store SY
3312: 2A0582  	        ld      HL,(DY)         ; ER=DY
3315: CD553A  	        call    negHL           ; ER=-DY
3318: 22FB81  	        ld      (ER),HL         ; store ER
331B: 2A0382  	        ld      HL,(DX)
331E: ED5B0582	        ld      DE,(DY)
3322: CD2D3A  	        call    CMP16           ; DX>DY?
3325: CA3133  	        jp      Z,ER2           ; no, DX=DY
3328: FA3133  	        jp      M,ER2           ; no, DX<DY
332B: 2A0382  	        ld      HL,(DX)         ; reload DX
332E: 22FB81  	        ld      (ER),HL         ; yes: DX>DY, so ER=DX
3331: 2AFB81  	ER2:    ld      HL,(ER)         ; load ER
3334: CB2C    	        sra     H               ; right shift (and preserve sign)...
3336: CB1D    	        rr      L               ; ...of HL, so ER=INT(ER/2)
3338: 22FB81  	STRE2:  ld      (ER),HL         ; store ER
333B: CD2632  	RPTDRW: call    CNTPLOT         ; plot first pixel
333E: 2AEF81  	        ld      HL,(X1)
3341: ED5BF781	        ld      DE,(X2)
3345: CD2D3A  	        call    CMP16           ; X1=X2?
3348: 200D    	        jr      NZ,CNTDRW       ; no, continue drawing
334A: 2AF181  	        ld      HL,(Y1)         ; yes, so check
334D: ED5BF981	        ld      DE,(Y2)         ; also Y
3351: CD2D3A  	        call    CMP16           ; Y1=Y2?
3354: CAAD33  	        jp      Z,ENDDRAW       ; yes, finished drawing: exit
3357: ED5BFB81	CNTDRW: ld      DE,(ER)
335B: ED53FD81	        ld      (E2),DE         ; E2=ER
335F: 2A0382  	        ld      HL,(DX)
3362: CD553A  	        call    negHL           ; DX=-DX
3365: EB      	        ex      DE,HL           ; invert DE and HL => HL=E2, DE=-DX
3366: CD2D3A  	        call    CMP16           ; E2>-DX?
3369: CA8733  	        jp      Z,DXGR          ; no, E2=-DX: jump
336C: FA8733  	        jp      M,DXGR          ; no, E2<-DX: jump
336F: 2AFB81  	        ld      HL,(ER)         ; yes
3372: ED5B0582	        ld      DE,(DY)
3376: B7      	        or      A               ; clear CARRY
3377: ED52    	        sbc     HL,DE           ; ER=ER-DY
3379: 22FB81  	        ld      (ER),HL
337C: 2AEF81  	        ld      HL,(X1)
337F: ED5BFF81	        ld      DE,(SX)
3383: 19      	        add     HL,DE           ; X1=X1+SX (increment X1)
3384: 22EF81  	        ld      (X1),HL
3387: 2AFD81  	DXGR:   ld      HL,(E2)
338A: ED5B0582	        ld      DE,(DY)
338E: CD2D3A  	        call    CMP16           ; E2<DY?
3391: F23B33  	        jp      P,RPTDRW        ; no, E2>=DY: so jump over
3394: 2AFB81  	        ld      HL,(ER)         ; yes
3397: ED5B0382	        ld      DE,(DX)
339B: 19      	        add     HL,DE           ; ER=ER+DX
339C: 22FB81  	        ld      (ER),HL
339F: 2AF181  	        ld      HL,(Y1)
33A2: ED5B0182	        ld      DE,(SY)
33A6: 19      	        add     HL,DE           ; Y1=Y1+SY (increment Y1)
33A7: 22F181  	        ld      (Y1),HL
33AA: C33B33  	        jp      RPTDRW          ; repeat
33AD: C1      	ENDDRAW:pop     BC              ; retrieve BC
33AE: D1      	        pop     DE              ; retrieve DE
33AF: E1      	        pop     HL              ; retrieve HL
33B0: C9      	        ret                     ; return to caller
              	
              	
              	; CIRCLE X,Y,R[,C]
              	; Draw a circle using Bresenham's circle algorithm with center in X,Y
              	; and radius R, with optional color C. If color is not specified, the
              	; foreground color set with COLOR will be used 
81F7:         	XC      equ     VIDEOBUFF
81F9:         	YC      equ     VIDEOBUFF+$02
81FB:         	RADIUS  equ     VIDEOBUFF+$04
81FD:         	XI      equ     VIDEOBUFF+$06
81FF:         	YI      equ     VIDEOBUFF+$08
8201:         	DC      equ     VIDEOBUFF+$0A
33B1: CDC331  	CIRCLE: call    CHKG2M          ; check if in G2 mode
33B4: CD8035  	        call    CLRVDBF         ; clear VIDEOBUFF
33B7: CD2326  	        call    GETINT          ; get X coords.
33BA: 32F781  	        ld      (XC),A          ; store it into a temp buffer
33BD: CDFF17  	        call    CHKSYN          ; Make sure ',' follows
33C0: 2C      	        defb    ','
33C1: CD2326  	        call    GETINT          ; get Y coords,
33C4: 32F981  	        ld      (YC),A          ; store it into a temp buffer
33C7: CDFF17  	        call    CHKSYN          ; Make sure ',' follows
33CA: 2C      	        defb    ','
33CB: CD2326  	        call    GETINT          ; get radius
33CE: 32FB81  	        ld      (RADIUS),A      ; store it into a temp buffer
33D1: CD9835  	        call    CLRPRM          ; check if param "color" has been passed
33D4: C5      	        push    BC              ; store BC
33D5: D5      	        push    DE              ; store DE
33D6: E5      	        push    HL              ; store HL
33D7: AF      	        xor     A               ; clear A,
33D8: 47      	        ld      B,A             ; B,
33D9: 4F      	        ld      C,A             ; C,
33DA: 57      	        ld      D,A             ; D,
33DB: 67      	        ld      H,A             ; and H
33DC: ED43FD81	        ld      (XI),BC         ; clear XI
33E0: 3AFB81  	        ld      A,(RADIUS)      ; load RADIUS into A
33E3: 6F      	        ld      L,A             ; HL now contains R
33E4: 22FF81  	        ld      (YI),HL         ; YI=RADIUS
33E7: 29      	        add     HL,HL           ; R*2
33E8: EB      	        ex      DE,HL           ; put HL into DE
33E9: 210300  	        ld      HL,$0003        ; now HL is 3
33EC: AF      	        xor     A               ; clear Carry
33ED: ED52    	        sbc     HL,DE           ; HL=>D=3-(2*R)
33EF: 220182  	        ld      (DC),HL         ; store D
33F2: CD5134  	        call    DRWCRL          ; draw initial point
33F5: ED5BFD81	RPTCRL: ld      DE,(XI)         ; load XI
33F9: 2AFF81  	        ld      HL,(YI)         ; load YI
33FC: CD2D3A  	        call    CMP16           ; is YI<DI?
33FF: CA0834  	        jp      Z,RPTCL1        ; no, YI=XI
3402: F20834  	        jp      P,RPTCL1        ; no, YI>XI
3405: C34D34  	        jp      ENDCRL          ; yes, so we've finished
3408: 21FD81  	RPTCL1: ld      HL,XI
340B: 34      	        inc     (HL)            ; XI=XI+1
340C: 2A0182  	        ld      HL,(DC)         ; load D
340F: 7C      	        ld      A,H
3410: B5      	        or      L               ; is D=0? Yes, jump over
3411: CA3534  	        jp      Z,DLSZ
3414: CB7C    	        bit     7,H             ; is D<0?
3416: 201D    	        jr      NZ,DLSZ         ; yes, jump over
3418: ED5BFF81	        ld      DE,(YI)         ; D>0
341C: 1B      	        dec     DE              ; so, YI=YI-1
341D: ED53FF81	        ld      (YI),DE         ; store YI
3421: AF      	        xor     A               ; clear Carry
3422: 2AFD81  	        ld      HL,(XI)
3425: ED52    	        sbc     HL,DE           ; HL=XI-YI
3427: 29      	        add     HL,HL
3428: 29      	        add     HL,HL           ; HL=HL*4
3429: 110A00  	        ld      DE,10
342C: 19      	        add     HL,DE           ; HL=HL+10
342D: ED5B0182	        ld      DE,(DC)         ; load D
3431: EB      	        ex      DE,HL           ; invert DE and HL, so that HL=4*(XI-YI)+10 and DE=D
3432: 19      	        add     HL,DE           ; D=D+4*(XI-YI)+10
3433: 180F    	        jr      PLTCRL          ; plot next pixel
3435: 2AFD81  	DLSZ:   ld      HL,(XI)         ; load XI
3438: 29      	        add     HL,HL
3439: 29      	        add     HL,HL           ; XI=XI*4
343A: 110600  	        ld      DE,$0006
343D: 19      	        add     HL,DE
343E: ED5B0182	        ld      DE,(DC)
3442: EB      	        ex      DE,HL           ; HL=D and DE=4*XI+6
3443: 19      	        add     HL,DE           ; D=D+4*XI+6
3444: 220182  	PLTCRL: ld      (DC),HL         ; store new D
3447: CD5134  	        call    DRWCRL          ; plot pixel
344A: C3F533  	        jp      RPTCRL          ; repeat
344D: E1      	ENDCRL: pop     HL
344E: D1      	        pop     DE
344F: C1      	        pop     BC
3450: C9      	        ret                     ; return to caller
3451: 2AF781  	DRWCRL: ld      HL,(XC)
3454: ED5BFD81	        ld      DE,(XI)
3458: 19      	        add     HL,DE           ; X=XC+XI
3459: 22EF81  	        ld      (X1),HL         ; store X
345C: CD7035  	        call    VALIDX          ; check if X is valid (0~255)
345F: DA7334  	        jp      C,CNTCL1        ; if Carry is set, X is not valid
3462: 2AF981  	        ld      HL,(YC)
3465: ED5BFF81	        ld      DE,(YI)
3469: 19      	        add     HL,DE           ; Y=YC+YI
346A: 22F181  	        ld      (Y1),HL         ; store Y
346D: CD7535  	        call    VALIDY          ; check if Y is valid (0~191)
3470: D42632  	        call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
3473: AF      	CNTCL1: xor     A               ; clear Carry
3474: 2AF781  	        ld      HL,(XC)
3477: ED5BFD81	        ld      DE,(XI)
347B: ED52    	        sbc     HL,DE           ; X=XC-XI
347D: 22EF81  	        ld      (X1),HL         ; store X
3480: CD7035  	        call    VALIDX          ; check if X is valid (0~255)
3483: DA9734  	        jp      C,CNTCL2        ; if Carry is set, X is not valid
3486: 2AF981  	        ld      HL,(YC)
3489: ED5BFF81	        ld      DE,(YI)
348D: 19      	        add     HL,DE           ; Y=YC+YI
348E: 22F181  	        ld      (Y1),HL         ; store Y
3491: CD7535  	        call    VALIDY          ; check if Y is valid (0~191)
3494: D42632  	        call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
3497: 2AF781  	CNTCL2: ld      HL,(XC)
349A: ED5BFD81	        ld      DE,(XI)
349E: 19      	        add     HL,DE           ; X=XC+XI
349F: 22EF81  	        ld      (X1),HL         ; store X
34A2: CD7035  	        call    VALIDX          ; check if X is valid (0~255)
34A5: DABB34  	        jp      C,CNTCL3        ; if Carry is set, X is not valid
34A8: AF      	        xor     A               ; clear Carry
34A9: 2AF981  	        ld      HL,(YC)
34AC: ED5BFF81	        ld      DE,(YI)
34B0: ED52    	        sbc     HL,DE           ; Y=YC-YI
34B2: 22F181  	        ld      (Y1),HL         ; store Y
34B5: CD7535  	        call    VALIDY          ; check if Y is valid (0~191)
34B8: D42632  	        call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
34BB: AF      	CNTCL3: xor     A               ; clear Carry
34BC: 2AF781  	        ld      HL,(XC)
34BF: ED5BFD81	        ld      DE,(XI)
34C3: ED52    	        sbc     HL,DE           ; X=XC-XI
34C5: 22EF81  	        ld      (X1),HL         ; store X
34C8: CD7035  	        call    VALIDX          ; check if X is valid (0~255)
34CB: DAE134  	        jp      C,CNTCL4        ; if Carry is set, X is not valid
34CE: AF      	        xor     A               ; clear Carry
34CF: 2AF981  	        ld      HL,(YC)
34D2: ED5BFF81	        ld      DE,(YI)
34D6: ED52    	        sbc     HL,DE           ; Y=YC-YI
34D8: 22F181  	        ld      (Y1),HL         ; store Y
34DB: CD7535  	        call    VALIDY          ; check if Y is valid (0~191)
34DE: D42632  	        call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
34E1: 2AF781  	CNTCL4: ld      HL,(XC)
34E4: ED5BFF81	        ld      DE,(YI)
34E8: 19      	        add     HL,DE           ; X=XC+YI
34E9: 22EF81  	        ld      (X1),HL         ; store X
34EC: CD7035  	        call    VALIDX          ; check if X is valid (0~255)
34EF: DA0335  	        jp      C,CNTCL5        ; if Carry is set, X is not valid
34F2: 2AF981  	        ld      HL,(YC)
34F5: ED5BFD81	        ld      DE,(XI)
34F9: 19      	        add     HL,DE           ; Y=YC+XI
34FA: 22F181  	        ld      (Y1),HL         ; store Y
34FD: CD7535  	        call    VALIDY          ; check if Y is valid (0~191)
3500: D42632  	        call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
3503: AF      	CNTCL5: xor     A               ; clear Carry
3504: 2AF781  	        ld      HL,(XC)
3507: ED5BFF81	        ld      DE,(YI)
350B: ED52    	        sbc     HL,DE           ; X=XC-YI
350D: 22EF81  	        ld      (X1),HL         ; store X
3510: CD7035  	        call    VALIDX          ; check if X is valid (0~255)
3513: DA2735  	        jp      C,CNTCL6        ; if Carry is set, X is not valid
3516: 2AF981  	        ld      HL,(YC)
3519: ED5BFD81	        ld      DE,(XI)
351D: 19      	        add     HL,DE           ; Y=YC+XI
351E: 22F181  	        ld      (Y1),HL         ; store Y
3521: CD7535  	        call    VALIDY          ; check if Y is valid (0~191)
3524: D42632  	        call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
3527: 2AF781  	CNTCL6: ld      HL,(XC)
352A: ED5BFF81	        ld      DE,(YI)
352E: 19      	        add     HL,DE           ; X=XC+YI
352F: 22EF81  	        ld      (X1),HL         ; store X
3532: CD7035  	        call    VALIDX          ; check if X is valid (0~255)
3535: DA4B35  	        jp      C,CNTCL7        ; if Carry is set, X is not valid
3538: AF      	        xor     A               ; clear Carry
3539: 2AF981  	        ld      HL,(YC)
353C: ED5BFD81	        ld      DE,(XI)
3540: ED52    	        sbc     HL,DE           ; Y=YC-XI
3542: 22F181  	        ld      (Y1),HL         ; store Y
3545: CD7535  	        call    VALIDY          ; check if Y is valid (0~191)
3548: D42632  	        call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
354B: AF      	CNTCL7: xor     A               ; clear Carry
354C: 2AF781  	        ld      HL,(XC)
354F: ED5BFF81	        ld      DE,(YI)
3553: ED52    	        sbc     HL,DE           ; X=XC-YI
3555: 22EF81  	        ld      (X1),HL         ; store X
3558: CD7035  	        call    VALIDX          ; check if X is valid (0~255)
355B: D8      	        ret     C               ; if Carry is set, X is not valid
355C: AF      	        xor     A               ; clear Carry
355D: 2AF981  	        ld      HL,(YC)
3560: ED5BFD81	        ld      DE,(XI)
3564: ED52    	        sbc     HL,DE           ; Y=YC-XI
3566: 22F181  	        ld      (Y1),HL         ; store Y
3569: CD7535  	        call    VALIDY          ; check if Y is valid (0~191)
356C: D42632  	        call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
356F: C9      	        ret                     ; return to caller
              	
              	; check if X,Y coordinates are valid: 0<=X<=255 and 0<=Y<=191
              	; input: HL (value to check), can be negative
              	; output: CARRY flag: reset => VALID  //  set => NOT VALID
              	; destroys: A
3570: AF      	VALIDX: xor     A               ; reset A
3571: B4      	        or      H               ; check if H is 0 (this means that X is in range 0~255 and not negative)
3572: C8      	        ret     Z               ; yes, we can return (C is clear)
3573: 37      	        scf                     ; set Carry flag to raise error
3574: C9      	        ret                     ; return to caller
              	
3575: AF      	VALIDY: xor     A               ; reset A
3576: B4      	        or      H               ; check if H is 0 (this means that Y is in range 0~255 and not negative)
3577: 2802    	        jr      Z,CNTVALY       ; yes, continue checking
3579: 37      	        scf                     ; no, raise error by setting Carry flag
357A: C9      	        ret                     ; return to caller
357B: 7D      	CNTVALY:ld      A,L
357C: FEC0    	        cp      $C0             ; is Y<192? Carry is set if Y<192
357E: 3F      	        ccf                     ; invert Carry, so Carry=0 means OK, Carry=1 means ERROR
357F: C9      	        ret                     ; return to caller
              	
              	
              	; clear VIDEOBUFF before using it as temp buffer
3580: AF      	CLRVDBF:xor     A               ; clear A
3581: C5      	        push    BC              ; store BC
3582: E5      	        push    HL              ; store HL
3583: 21EF81  	        ld      HL,TMPBFR1      ; address of 1st cell
3586: 0606    	        ld      B,$06           ; 6 cells
3588: 77      	RPTCVB1:ld      (HL),A          ; clear cell
3589: 23      	        inc     HL              ; next cell
358A: 10FC    	        djnz    RPTCVB1         ; repeat
358C: 0628    	        ld      B,$28           ; 40 cells
358E: 21F781  	        ld      HL,VIDEOBUFF    ; address of 1st cell
3591: 77      	RPTCVB2:ld      (HL),A          ; clear cell
3592: 23      	        inc     HL              ; next cell
3593: 10FC    	        djnz    RPTCVB2         ; repeat
3595: E1      	        pop     HL              ; retrieve HL
3596: C1      	        pop     BC              ; retrieve BC
3597: C9      	        ret                     ; return to caller
              	
              	
              	; check if a color is passed as argument with PLOT, DRAW, and CIRCLE
              	; commands. If not present, the default foreground color will be used
3598: 3AED81  	CLRPRM: ld      A,(FRGNDCLR)    ; load foreground color
359B: 32F381  	        ld      (TMPBFR3),A     ; store into temp buffer
359E: 2B      	        dec     HL              ; dec 'cos GETCHR INCs
359F: CD221A  	        call    GETCHR          ; Get next character
35A2: C8      	        ret     Z               ; return if nothing follows
35A3: CDFF17  	        call    CHKSYN          ; Make sure ',' follows
35A6: 2C      	        defb    ','
35A7: CD2326  	        call    GETINT          ; get value
35AA: CDB931  	        call    CHKCLR          ; check if color is in range 1~15
35AD: 32F381  	        ld      (TMPBFR3),A     ; store color into temp buffer
35B0: C9      	        ret                     ; return to caller
              	
              	
              	; no graphics mode error: raised when a graphics command is invoked
              	; out of graphic 2 mode.
35B1: 1E2A    	GMERR:  ld      E,GM            ; load Graphics Mode Error flag
35B3: C32F15  	        jp      ERROR           ; print error
              	
              	
              	; set a serial port: params are PORT,BPS,DATA,PARITY,STOP
              	; PORT=1/2; BPS=1,200~57,600 (see below), DATA=5/6/7/8
              	; PARITY: 0=no parity; 1=ODD parity; 2=EVEN parity;
              	; STOP=0/1/2/3: 0=0 bit; 1=1 bit; 2=1.5 bits; 3=2 bits
              	; PORT 1 acts as a char device; PORT 2 acts as a block device
              	; DATA,PARITY, and STOP are optional: if nothing follows BPS,
              	; they are assumed to be 8,0,1 resp.
81F7:         	PRTNUM  equ     VIDEOBUFF
81F8:         	BPS     equ     VIDEOBUFF+$01
81FA:         	DATABT  equ     BPS+$02
81FB:         	PARBT   equ     DATABT+$01
81FC:         	STPBT   equ     PARBT+$01
81FD:         	SIOBFR  equ     STPBT+$01
35B6: CD2326  	SERIAL: call    GETINT          ; get port #
35B9: A7      	        and     A               ; is it zero?
35BA: CAED1A  	        jp      Z,FCERR         ; yes, error
35BD: FE03    	        cp      $03             ; is it 1 or 2?
35BF: D2A037  	        jp      NC,SCERR        ; no, error
35C2: 32F781  	        ld      (PRTNUM),A      ; store port number into a temp buffer
35C5: CDFF17  	        call    CHKSYN          ; Make sure ',' follows
35C8: 2C      	        defb    ','
35C9: CDF21A  	        call    ATOH            ; get bps (returned into DE)
35CC: 7A      	        ld      A,D             ; move MSB into A
35CD: B3      	        or      E               ; LSB OR MSB, to check if bps=0
35CE: 203A    	        jr      NZ,CNTSER       ; no, continue checking
              	        ; if baud rate is 0, then close the serial comm.
35D0: 3AF781  	RSTSER1:ld      A,(PRTNUM)      ; yes, so reset the channel. First, load port number
35D3: 3D      	        dec     A               ; subtract 1, so that serial channel is 0=>A and 1=>B
35D4: C622    	        add     SIO_CA          ; find correct channel
35D6: 4F      	        ld      C,A             ; store serial channel
35D7: F3      	        di                      ; disable INTs
35D8: AF      	        xor     A               ; reset A
35D9: 1601    	        ld      D,$01           ; start from WR1
35DB: 0605    	        ld      B,$05           ; 5 registers
35DD: ED51    	RPTRSSR:out     (C),D           ; select register
35DF: ED79    	        out     (C),A           ; reset register
35E1: 14      	        inc     D               ; next register
35E2: 10F9    	        djnz    RPTRSSR         ; repeat
35E4: 3E30    	        ld      A,%00110000     ; write into WR0: error reset, select WR0
35E6: ED79    	        out     (C),A           ; send command to serial channel
35E8: 3E18    	        ld      A,%00011000     ; write into WR0: channel reset
35EA: ED79    	        out     (C),A           ; send command to serial channel
35EC: FB      	        ei                      ; re-enable INTs
35ED: E5      	        push    HL              ; store HL
35EE: 212E82  	        ld      HL,SERIALS_EN   ; serials enabled status byte
35F1: DB01    	        in      A,(PIO_DB)      ; read status LEDs
35F3: CB41    	        bit     0,C             ; check serial port
35F5: 2009    	        jr      NZ,SRPT2        ; if bit is set, jump to port 2
35F7: CBB7    	        res     6,A             ; it's port 1
35F9: CBA7    	        res     4,A             ; remove possible error LED
35FB: CB86    	        res     0,(HL)          ; disable port 1
35FD: C30636  	        jp      SERLED          ; jump over
3600: CBBF    	SRPT2:  res     7,A             ; it's port 2
3602: CBAF    	        res     5,A             ; remove possible error LED
3604: CB8E    	        res     1,(HL)          ; disable port 2
3606: D301    	SERLED: out     (PIO_DB),A      ; send new configuration
3608: E1      	        pop     HL              ; retrieve HL
3609: C9      	        ret                     ; return to caller
              	        ; check if bps=1, meaning reactivate RX on serial
360A: 7A      	CNTSER: ld      A,D
360B: B2      	        or      D               ; check if bps<>1 by first checking D=0
360C: 203B    	        jr      NZ,CNTSER2      ; if not, jump over
360E: 7B      	        ld      A,E             ; then by checking that
360F: FE01    	        cp      $01             ; E=1
3611: 2036    	        jr      NZ,CNTSER2      ; if not, jump over
3613: 3AF781  	        ld      A,(PRTNUM)      ; load port number
3616: FE01    	        cp      $01             ; is it port 1? (currently do NOT support on port 2)
3618: C2A037  	        jp      NZ,SCERR        ; no, raise error and exit 
361B: 57      	        ld      D,A             ; store port on D
361C: 3A2E82  	        ld      A,(SERIALS_EN)  ; load address of serial status cell
361F: A2      	        and     D               ; check status
3620: CAA037  	        jp      Z,SCERR         ; port not open, raise error
3623: F3      	        di                      ; disable INTs
3624: 7A      	        ld      A,D             ; move port # into A
3625: 5F      	        ld      E,A             ; store original A into E
3626: 87      	        add     A
3627: 87      	        add     A               ; move A to left times 2
3628: 57      	        ld      D,A             ; move value into D
3629: 3A2E82  	        ld      A,(SERIALS_EN)  ; load serial status byte
362C: B2      	        or      D               ; re-enable RX
362D: 322E82  	        ld      (SERIALS_EN),A  ; store new serial status
3630: 7B      	        ld      A,E             ; recover port #
3631: 3D      	        dec     A               ; check port
3632: 200A    	        jr      NZ,CNTRX2       ; port is #2
3634: CD8801  	        call    SIO_A_EI        ; re-enable RX on port 1
3637: DB01    	        in      A,(PIO_DB)      ; load status LEDs
3639: CBA7    	        res     4,A             ; remove error LED
363B: C34536  	        jp      RXEND           ; terminate setting
363E: CD8801  	CNTRX2: call    SIO_A_EI        ; re-enable RX on port 2 -> CURRENTLY only port 1 is supported
3641: DB01    	        in      A,(PIO_DB)      ; load status LEDs
3643: CBAF    	        res     5,A             ; remove error LED
3645: D301    	RXEND:  out     (PIO_DB),A      ; set new status for LEDs
3647: FB      	        ei                      ; re-enable INTs
3648: C9      	        ret                     ; return to caller
              	        ; set serial port comm.
3649: D5      	CNTSER2:push    DE              ; store BPS
364A: 3AF781  	        ld      A,(PRTNUM)      ; load port number
364D: 57      	        ld      D,A             ; move port # into D
364E: 3A2E82  	        ld      A,(SERIALS_EN)  ; check if serial port is already open
3651: A2      	        and     D               ; by ANDing A with D
3652: D1      	        pop     DE              ; retrieve BPS
3653: CA5B36  	        jp      Z,CNTSER3       ; not open, continue
3656: 1E2E    	        ld      E,SA            ; already open, so raise a "Serial Port Already Error"
3658: C32F15  	        jp      ERROR           ; and leave
365B: E5      	CNTSER3:push    HL              ; store HL   
365C: 2100E1  	        ld      HL,$E100        ; check bps. start with HL=57,600
365F: CD2D3A  	        call    CMP16           ; is bps<=57,600?
3662: E1      	        pop     HL              ; but first, recover HL
3663: DAA037  	        jp      C,SCERR         ; no (bps>57,600) then error
3666: ED53F881	        ld      (BPS),DE        ; store bps
366A: 2B      	        dec     HL              ; dec 'cos GETCHR INCs
366B: CD221A  	        call    GETCHR          ; Get next character
366E: CAA536  	        jp      Z,DEFSER        ; defaults if nothing follows
3671: CDFF17  	        call    CHKSYN          ; Make sure ',' follows
3674: 2C      	        defb    ','
3675: CD2326  	        call    GETINT          ; get data bits
3678: FE05    	        cp      $05             ; is it <5?
367A: DAA037  	        jp      C,SCERR         ; yes, error
367D: FE09    	        cp      $09             ; is it >=9?
367F: D2ED1A  	        jp      NC,FCERR        ; no, error
3682: 32FA81  	        ld      (DATABT),A      ; store data bits
3685: CDFF17  	        call    CHKSYN          ; Make sure ',' follows
3688: 2C      	        defb    ','
3689: CD2326  	        call    GETINT          ; get parity bits
368C: FE03    	        cp      A,$03           ; check if parity is in range 0~2
368E: D2A037  	        jp      NC,SCERR        ; no, error
3691: 32FB81  	        ld      (PARBT),A       ; store parity
3694: CDFF17  	        call    CHKSYN          ; Make sure ',' follows
3697: 2C      	        defb    ','
3698: CD2326  	        call    GETINT          ; get stop bits
369B: FE03    	        cp      $03             ; is it >=3?
369D: D2A037  	        jp      NC,SCERR        ; yes, error
36A0: 32FC81  	        ld      (STPBT),A       ; store stop bits
36A3: 180D    	        jr      SETSER          ; jump to set serial
36A5: 3E08    	DEFSER: ld      A,$08           ; 8 bits for data
36A7: 32FA81  	        ld      (DATABT),A
36AA: AF      	        xor     A               ; no parity bit
36AB: 32FB81  	        ld      (PARBT),A
36AE: 3C      	        inc     A               ; 1 bit for stop
36AF: 32FC81  	        ld      (STPBT),A
              	        ; check if bps are legal
36B2: E5      	SETSER: push    HL              ; store HL 
36B3: D5      	        push    DE              ; store DE
36B4: DDE5    	        push    IX              ; store IX
36B6: DD217B37	        ld      IX,SUP_BPS      ; allowed BPSs
36BA: 060B    	        ld      B,$0B           ; 11 items
36BC: 0E00    	        ld      C,$00           ; reset pointer
36BE: 2AF881  	CKBPS:  ld      HL,(BPS)        ; load BPS
36C1: DD5E00  	        ld      E,(IX+0)        ; load LSB of item
36C4: DD5601  	        ld      D,(IX+1)        ; load MSB of item
36C7: CD2D3A  	        call    CMP16           ; is it equal?
36CA: CAD736  	        jp      Z,FNDBPS        ; yes, found correspondance
36CD: DD23    	        inc     IX
36CF: DD23    	        inc     IX              ; no, go to next entry
36D1: 0C      	        inc     C               ; increment pointer
36D2: 10EA    	        djnz    CKBPS           ; repeat for 10 entries
36D4: C39C37  	        jp      SCERR1          ; if nothing found, raise an error
36D7: 3AF781  	FNDBPS: ld      A,(PRTNUM)      ; check serial port
36DA: 3D      	        dec     A               ; is it port 1?
36DB: CAE136  	        jp      Z,SET_P1        ; yes, set port 1
36DE: C39C37  	        jp      SCERR1          ; at the moment, only port 1 can be configured
36E1:         	SET_P1: ;init CTC CH0: CH0 provides RX/TX clock to SIO port A
              	        ; TO0 output frequency=INPUT CLK/time constant. Time constant is set to get 16 times
              	        ; the requested baud rate. I.e., if bps is 19,200 then time constast is set to 6 because
              	        ; 1,843,200/6 = 307,200 Hz (that is 19,200 x 16)
36E1: F3      	        di                      ; disable INTs
36E2: 0600    	        ld      B,$00           ; reset B
36E4: 219137  	        ld      HL,CTC_CFG      ; address of first CTC divider
36E7: 09      	        add     HL,BC           ; adjust for corret CTC divider
36E8: 3E47    	        ld      A,%01000111     ; interrupt off, counter mode, prsc=16 (doesn't matter), ext. start,
              	                                ; start upon loading time constant, time constant follows, sw reset, command word
36EA: D310    	        out     (CTC_CH0),A     ; configure CTC channel 0
36EC: 7E      	        ld      A,(HL)          ; load CTC divider
36ED: D310    	        out     (CTC_CH0),A     ; send divider
              	        ; configure SIO
36EF: 21F102  	        ld      HL,SIO_A_SETS   ; load default settings for SIO
36F2: 11FD81  	        ld      DE,SIOBFR       ; into a temp buffer
36F5: 010A00  	        ld      BC,$000A        ; 10 items to copy
36F8: EDB0    	        ldir                    ; copy SIO settings into TEMP buffer
36FA: 3A0282  	        ld      A,(SIOBFR+5)    ; load WR5 setting
36FD: 47      	        ld      B,A             ; move it into B
36FE: 3AFA81  	        ld      A,(DATABT)      ; load DATA bits
3701: FE05    	        cp      $05             ; is it 5 bits?
3703: 2006    	        jr      NZ,BITS6        ; no, jump over
3705: CBB0    	        res     6,B
3707: CBA8    	        res     5,B             ; set D6 & D5 to 0
3709: 1819    	        jr      SETPAR          ; jump to set parity
370B: FE06    	BITS6:  cp      $06             ; is it 6 bits?
370D: 2006    	        jr      NZ,BITS7        ; no, jump over
370F: CBF0    	        set     6,B
3711: CBA8    	        res     5,B             ; set D6 & D5 to 1,0
3713: 180F    	        jr      SETPAR          ; jump to set parity
3715: FE07    	BITS7:  cp      $07             ; is it 7 bits?
3717: 2007    	        jr      NZ,BITS8        ; no, jump over
3719: CBB0    	        res     6,B
371B: CBE8    	        set     5,B             ; set D6 & D5 to 0,1
371D: C32437  	        jp      SETPAR          ; jump to set parity
3720: CBF0    	BITS8:  set     6,B
3722: CBE8    	        set     5,B             ; set D6 & D5 to 1,1
3724: 78      	SETPAR: ld      A,B
3725: 320282  	        ld      (SIOBFR+5),A    ; save DATA bits
3728: E660    	        and     %01100000       ; filter only D5&D6 bits
372A: 87      	        add     A,A             ; shift left times 1
372B: 322F82  	        ld      (SERABITS),A    ; store for SIO_A_EI & SIO_A_DI functions
372E: 3AFC81  	        ld      A,(STPBT)       ; load STOP bits
3731: 87      	        add     A,A
3732: 87      	        add     A,A             ; 2 left shifts
3733: 47      	        ld      B,A             ; move forming byte into B
3734: 3AFB81  	        ld      A,(PARBT)       ; load PARITY setting
3737: A7      	        and     A               ; is it 0?
3738: CA4337  	        jp      Z,STRPAR        ; yes, jump over
373B: CBC0    	        set     0,B             ; set PARITY on
373D: 3D      	        dec     A               ; is parity ODD?
373E: CA4337  	        jp      Z,STRPAR        ; yes, so jump over
3741: CBC8    	        set     1,B             ; no, it's EVEN so set the corresponding bit
3743: 3A0082  	STRPAR: ld      A,(SIOBFR+3)    ; load WR4 setting
3746: E6F0    	        and     %11110000       ; reset STOP & PARITY bits
3748: B0      	        or      B               ; set new STOP & PARITY bits
3749: 320082  	        ld      (SIOBFR+3),A    ; store new value
              	        ;set up TX and RX:
              	        ; the followings are settings for channel A
374C: 21FD81  	        ld      HL,SIOBFR       ; settings for SIO ch. A
374F: 0606    	        ld      B,$06           ; 6 bytes to send
3751: 0E22    	        ld      C,SIO_CA        ; I/O address of SIO ch.A
3753: EDB3    	        otir                    ; send bytes to SIO
              	        ; the following are settings for channel B (don't need to load HL since settings are contigous)
3755: 0604    	        ld      B,$04           ; other 4 bytes to send
3757: 0E23    	        ld      C,SIO_CB        ; I/O address of SIO ch.B
3759: EDB3    	        otir                    ; send bytes to SIO
              	        ; the following are settings for channel A
375B: 3E01    	        ld      A,$01           ; write into WR0: select WR1
375D: D322    	        out     (SIO_CA),A
375F: 3E18    	        ld      A,%00011000     ; interrupts on every RX char; parity is no special condition;
              	                                ; buffer overrun is special condition
3761: D322    	        out     (SIO_CA),A
3763: CD8801  	        call    SIO_A_EI        ; enable RX on SIO channel A
3766: 212E82  	EXITSER:ld      HL,SERIALS_EN
3769: CBC6    	        set     0,(HL)          ; set serial port 1 status ON
376B: CBD6    	        set     2,(HL)          ; set serial port 1 RX ON
              	        ; back to normal running
376D: FB      	        ei                      ; re-enable INTs
376E: DB01    	        in      A,(PIO_DB)      ; load status LEDs
3770: CBF7    	        set     6,A             ; set status LED on
3772: CBA7    	        res     4,A             ; set error LED off
3774: D301    	        out     (PIO_DB),A      ; send new configuration
3776: DDE1    	        pop     IX              ; retrieve IX
3778: D1      	        pop     DE              ; retrieve DE
3779: E1      	        pop     HL              ; retrieve HL
377A: C9      	        ret                     ; return to caller
              	
              	; allowed bps (Bauds per second)
377B: 00E10096	SUP_BPS:defw    57600,38400,28800,19200,14400,9600,4800,3600,2400,1200,600
377F: 8070004B	
3783: 40388025	
3787: C012100E	
378B: 6009B004	
378F: 5802    	
              	; corresponding CTC divider
3791: 02030406	CTC_CFG:defb    2,3,4,6,8,12,24,32,48,96,192
3795: 080C1820	
3799: 3060C0  	
              	
              	; serial configuration error
379C: DDE1    	SCERR1: pop     IX              ; retrieve IX
379E: D1      	        pop     DE              ; retrieve DE
379F: E1      	        pop     HL              ; retrieve HL
37A0: 1E2C    	SCERR:  ld      E,SC            ; Serial Configuration Error
37A2: C32F15  	        jp      ERROR           ; print error
              	
              	; check for direct mode
37A5: E5      	DIRMOD: push    HL              ; Save code string address
37A6: 2AAF80  	        ld      HL,(LINEAT)     ; Get current line number
37A9: 23      	        inc     HL              ; -1 means direct statement
37AA: 7C      	        ld      A,H
37AB: B5      	        or      L
37AC: E1      	        pop     HL              ; Restore code string address
37AD: C2C737  	        jp      NZ,HLPERR       ; raise error if in indirect mode
37B0: C9      	        ret
              	
              	
              	; HELP lists the line program where an error was found
37B1: CDA537  	HELP:   call    DIRMOD          ; check if in direct mode
37B4: E5      	        push    HL              ; store HL
37B5: 2AB180  	        ld      HL,(HLPLN)      ; load HELP line
37B8: 23      	        inc     HL              ; increment HL
37B9: 7C      	        ld      A,H
37BA: B5      	        or      L               ; check if there is a line into the HELP reg.
37BB: E1      	        pop     HL
37BC: CAC737  	        jp      Z,HLPERR        ; no line found, raise error
37BF: ED5BB180	        ld      DE,(HLPLN)      ; recover line
37C3: C1      	        pop     BC              ; remove BC from stack since it's not needed anymore for LIST
37C4: C38D18  	        jp      LST01H          ; jump to list line
37C7: 1E30    	HLPERR: ld      E,HP            ; HELP call error
37C9: C32F15  	        jp      ERROR           ; raise error
              	
              	
              	; KEY command to list/modify function keys
37CC: 2B      	KEY:    dec     HL              ; dec 'cos GETCHR INCs
37CD: CD221A  	        call    GETCHR          ; Get next character
37D0: CA5038  	        jp      Z,LSTKEYS       ; jump if nothing follows
              	                                ; change FN keys
37D3: CD2326  	        call    GETINT          ; get a number
37D6: A7      	        and     A               ; is it 0?
37D7: 2010    	        jr      NZ,KEYCH        ; no, jump over         
37D9: E5      	        push    HL              ; yes - reset FN keys to defaults
37DA: D5      	        push    DE              ; store HL & DE
37DB: 210B14  	        ld      HL,DEFFNKS      ; pointer to default FN keys texts
37DE: 11B380  	        ld      DE,FNKEYS       ; pointer to destination
37E1: 018000  	        ld      BC,$0080        ; 128 chars to be copied
37E4: EDB0    	        ldir                    ; restore default texts
37E6: D1      	        pop     DE              ; retrieve DE
37E7: E1      	        pop     HL              ; retrieve HL
37E8: C9      	        ret                     ; return to caller
37E9: FE09    	KEYCH:  cp      $09             ; is it >= 9?
37EB: D21B15  	        jp      NC,SNERR        ; yes - syntax error
37EE: 3D      	        dec     A               ; FN key in range 0~7
37EF: 87      	        add     A,A             ; multiply A...
37F0: 87      	        add     A,A             ; ... times 4...
37F1: 87      	        add     A,A             ; ... to get the correct...
37F2: 87      	        add     A,A             ; ... offset fo FN key text
37F3: 32EF81  	        ld      (TMPBFR1),A     ; store FN key offset...
37F6: AF      	        xor     A               ; ...in a...
37F7: 32F081  	        ld      (TMPBFR1+1),A   ; ...16-bit register
37FA: CDFF17  	        call    CHKSYN          ; Make sure ',' follows
37FD: 2C      	        defb    ','
37FE: 444D    	        ld      BC,HL           ; copy address into BC
3800: CDA91E  	        call    EVAL            ; Evaluate expression (in E there is the length)
3803: E5      	        push    HL              ; store string pointer
3804: 3A9281  	        ld      A,(TYPE)        ; Get variable type
3807: B7      	        or      A               ; Is it a string variable?
3808: CA1B15  	        jp      Z,SNERR         ; no - syntax error
380B: CDDE24  	        call    GSTRCU          ; Current string to pool
380E: CDD12B  	        call    LOADFP          ; Move string block data to (BC=pointer, DE=length)
3811: 7B      	        ld      A,E             ; copy length into A
3812: FE11    	        cp      $11             ; is length > 16?
3814: DA1938  	        jp      C,DECLN1        ; no, jump over
3817: 1E10    	        ld      E,$10           ; yes, so set length to 16
3819: 3E10    	DECLN1: ld      A,$10           ; calculate how many...
381B: 93      	        sub     E               ; ...null chars needed to fill up...
381C: 57      	        ld      D,A             ; ...the FN key text
381D: C5      	        push    BC              ; store address of string 
381E: ED4BEF81	        ld      BC,(TMPBFR1)    ; load FN key offset
3822: 21B380  	        ld      HL,FNKEYS       ; load address of FN keys texts
3825: 09      	        add     HL,BC           ; get corrected address
3826: C1      	        pop     BC              ; retrieve address of string chars
3827: 0A      	CPKEY:  ld      A,(BC)          ; load char from string
3828: FE0D    	        cp      CR              ; return?
382A: CA3738  	        jp      Z,CPKEY2        ; yes, store char
382D: FE7B    	        cp      $7B             ; if char > "z" ?
382F: D21B15  	        jp      NC,SNERR        ; yes - syntax error
3832: FE20    	        cp      $20             ; is char < space?
3834: DA1B15  	        jp      C,SNERR         ; yes - syntax error
3837: FE61    	CPKEY2: cp      $61             ; is it >= 'a'?
3839: DA3E38  	        jp      C,CPKEY3        ; no, continue
383C: E65F    	        and     %01011111       ; set letters to uppercase
383E: 77      	CPKEY3: ld      (HL),A          ; store char
383F: 23      	        inc     HL              ; next string char
3840: 03      	        inc     BC              ; next free cell
3841: 1D      	        dec     E               ; decrement E
3842: 20E3    	        jr      NZ,CPKEY        ; repeat until 0
3844: AF      	        xor     A               ; null char
3845: 14      	        inc     D               ; +1 to decrement below
3846: 15      	CPKEY1: dec     D               ; how many null chars to insert?
3847: CA4E38  	        jp      Z,CPKYEND       ; no more nulls, so exit
384A: 77      	        ld      (HL),A          ; store it
384B: 23      	        inc     HL              ; next cell
384C: 18F8    	        jr      CPKEY1          ; repeat
384E: E1      	CPKYEND:pop     HL              ; retrieve pointer to string
384F: C9      	        ret                     ; return to caller
              	                                ; list FN keys
3850: E5      	LSTKEYS:push    HL              ; Save code string address
3851: 2AAF80  	        ld      HL,(LINEAT)     ; Get current line number
3854: 23      	        inc     HL              ; -1 means direct statement
3855: 7C      	        ld      A,H
3856: B5      	        or      L
3857: E1      	        pop     HL              ; Restore code string address
3858: C21B15  	        jp      NZ,SNERR        ; raise error if in indirect mode
385B: E5      	        push    HL              ; store HL
385C: D5      	        push    DE              ; store DE
385D: 21B380  	        ld      HL,FNKEYS       ; load starting address of FN keys text
3860: 0E01    	        ld      C,$01           ; 8 function keys
3862: 0610    	PRTK4:  ld      B,$10           ; 16 chars each
3864: 110339  	PRTK2:  ld      DE,CHKEY1       ; message "KEY "
3867: CDF438  	        call    PRTCKEY         ; print it
386A: 79      	        ld      A,C             ; load FN key
386B: C630    	        add     $30             ; get number in ASCI code
386D: CD0A18  	        call    OUTC            ; print it
3870: 110839  	        ld      DE,CHKEY2       ; message ": ""
3873: CDF438  	        call    PRTCKEY         ; print it
3876: 3E01    	        ld      A,$01           ; " opened
3878: 32EF81  	        ld      (TMPBFR1),A
387B: 7E      	LDKEY:  ld      A,(HL)          ; retrieve char
387C: A7      	        and     A               ; is it zero?
387D: CA9038  	        jp      Z,CNTLTK        ; yes, go next char
3880: CDDC38  	        call    OPNQT           ; check if quotes are opened
3883: FE22    	        cp      $22             ; check if char is "?
3885: CAA538  	        jp      Z,PRTCHR        ; yes, print "chr$("
3888: FE0D    	        cp      CR              ; is it a CR?
388A: CAA538  	        jp      Z,PRTCHR        ; yes, print "chr$("
388D: CD0A18  	PRTK3:  call    OUTC            ; no, just print it
3890: 23      	CNTLTK: inc     HL              ; next char
3891: 10E8    	        djnz    LDKEY           ; continue until finished
3893: CDCA38  	        call    CLSQT           ; check if quotes are still open
3896: 3E0D    	        ld      A,CR            ; go next line
3898: CD0A18  	        call    OUTC            ; print it
389B: 0C      	        inc     C               ; next FN key
389C: 79      	        ld      A,C             ; check if...
389D: FE09    	        cp      $09             ; finished keys?
389F: DA6238  	        jp      C,PRTK4         ; no, repeat 1 more time
38A2: D1      	        pop     DE              ; retrieve DE
38A3: E1      	        pop     HL              ; retrieve HL
38A4: C9      	        ret                     ; return to caller
              	
38A5: E5      	PRTCHR: push    HL              ; store HL
38A6: CDCA38  	        call    CLSQT           ; check if quotes are closed
38A9: 3E2B    	        ld      A,'+'           ; '+' char
38AB: CD0A18  	        call    OUTC            ; print it
38AE: 110B39  	        ld      DE,CHKEY3       ; address of "CHR$("
38B1: CDF438  	        call    PRTCKEY         ; print it
38B4: E1      	        pop     HL              ; recover HL
38B5: 23      	        inc     HL              ; next char
38B6: 05      	        dec     B               ; increment char counter
38B7: 111139  	        ld      DE,CHKEY4       ; load address of RETURN
38BA: 7E      	        ld      A,(HL)          ; load char
38BB: FE0D    	        cp      CR              ; is it a RETURN?
38BD: 2003    	        jr      NZ,PTCHR1       ; no, jump over
38BF: 111439  	        ld      DE,CHKEY5       ; yes, load address of "
38C2: CDF438  	PTCHR1: call    PRTCKEY         ; print it
38C5: 3E29    	        ld      A,')'           ; char )
38C7: C38D38  	        jp      PRTK3           ; continue
              	
38CA: F5      	CLSQT:  push    AF              ; store A
38CB: 3AEF81  	        ld      A,(TMPBFR1)     ; quote status
38CE: A7      	        and     A               ; are they closed?
38CF: 2809    	        jr      Z,CLSQT1        ; if yes, return
38D1: 3E22    	        ld      A,$22           ; no, so close them
38D3: CD0A18  	        call    OUTC            ; print "
38D6: AF      	        xor     A               ; set quotes
38D7: 32EF81  	        ld      (TMPBFR1),A     ; as closed
38DA: F1      	CLSQT1: pop     AF              ; retrieve A
38DB: C9      	        ret                     ; return to caller
              	
38DC: F5      	OPNQT:  push    AF              ; store A
38DD: 3AEF81  	        ld      A,(TMPBFR1)     ; quote status
38E0: A7      	        and     A               ; are they open?
38E1: 200F    	        jr      NZ,OPNQT1       ; if yes, return
38E3: 3E2B    	        ld      A,'+'           ; no, so add '+
38E5: CD0A18  	        call    OUTC            ; print it
38E8: 3E22    	        ld      A,$22           ; and then open quotes
38EA: CD0A18  	        call    OUTC            ; print them
38ED: 3E01    	        ld      A,$01           ; set quotes
38EF: 32EF81  	        ld      (TMPBFR1),A     ; as opened
38F2: F1      	OPNQT1: pop     AF              ; retrieve A
38F3: C9      	        ret                     ; return to caller
              	
38F4: F5      	PRTCKEY:push    AF              ; store original char
38F5: 1A      	PRTK1:  ld      A,(DE)          ; load char
38F6: A7      	        and     A               ; is it 0?
38F7: CA0139  	        jp      Z,PRTEND        ; yes, finished printing
38FA: CD0A18  	        call    OUTC            ; no, print char
38FD: 13      	        inc     DE              ; next char
38FE: C3F538  	        jp      PRTK1           ; repeat
3901: F1      	PRTEND: pop     AF              ; retrieve AF
3902: C9      	        ret                     ; return to caller
              	
3903: 4B455920	CHKEY1: defb    "KEY ",0
3907: 00      	
3908: 3A2200  	CHKEY2: defb    ":",34,0
390B: 63687224	CHKEY3: defb    "chr$(",0
390F: 2800    	
3911: 313300  	CHKEY4: defb    "13",0
3914: 333400  	CHKEY5: defb    "34",0
              	
              	
              	; HEX$(nn) Convert 16 bit number to Hexadecimal string
3917: CD9A1E  	HEX: 	call	TSTNUM          ; Verify it's a number
391A: CDD81A  	        call	DEINT           ; Get integer -32768 to 32767
391D: C5      	        push	BC              ; Save contents of BC
391E: 213082  	        ld      HL,PBUFF        ; load address of PBUFF into HL
3921: 7A      	        ld      A,D             ; Get MSB into A
3922: B7      	        or      A               ; OR with LSB to see if param=0
3923: 280C    	        jr      Z,HEX2          ; Skip output if both high digits are zero
3925: CD4D39  	        call    BYT2ASC         ; Convert D to ASCII
3928: 78      	        ld      A,B             ; cechk if B
3929: FE30    	        cp      '0'             ; is 0
392B: 2802    	        jr      Z,HEX1          ; Don't store high digit if zero
392D: 70      	        ld      (HL),B          ; Store it to PBUFF
392E: 23      	        inc     HL              ; Next location
392F: 71      	HEX1:   ld      (HL),C          ; Store C to PBUFF+1
3930: 23      	        inc     HL              ; Next location
3931: 7B      	HEX2:   ld      A,E             ; Get lower byte
3932: CD4D39  	        call    BYT2ASC         ; Convert E to ASCII
3935: 7A      	        ld      A,D
3936: B7      	        or      A
3937: 2005    	        jr      NZ,HEX3         ; If upper byte was not zero then always print lower byte
3939: 78      	        ld      A,B
393A: FE30    	        cp      '0'             ; If high digit of lower byte is zero then don't print
393C: 2802    	        jr      Z,HEX4
393E: 70      	HEX3:   ld      (HL),B          ; to PBUFF+2
393F: 23      	        inc     HL              ; Next location
3940: 71      	HEX4:   ld      (HL),C          ; to PBUFF+3
3941: 23      	        inc     HL              ; PBUFF+4 to zero
3942: AF      	        xor     A               ; Terminating character
3943: 77      	        ld      (HL),A          ; Store zero to terminate
3944: 23      	        inc     HL              ; Make sure PBUFF is terminated
3945: 77      	        ld      (HL),A          ; Store the double zero there
3946: C1      	        pop     BC              ; Get BC back
3947: 213082  	        ld      HL,PBUFF        ; Reset to start of PBUFF
394A: C32B23  	        jp      STR1            ; Convert the PBUFF to a string and return it
394D: 47      	BYT2ASC	ld      B,A             ; Save original value
394E: E60F    	        and     $0F             ; Strip off upper nybble
3950: FE0A    	        cp      $0A             ; 0-9?
3952: 3802    	        jr      C,ADD30         ; If A-F, add 7 more
3954: C607    	        add     A,$07           ; Bring value up to ASCII A-F
3956: C630    	ADD30	add     A,$30           ; And make ASCII
3958: 4F      	        ld      C,A             ; Save converted char to C
3959: 78      	        ld      A,B             ; Retrieve original value
395A: 0F      	        rrca                    ; and Rotate it right
395B: 0F      	        rrca
395C: 0F      	        rrca
395D: 0F      	        rrca
395E: E60F    	        and     $0F             ; Mask off upper nybble
3960: FE0A    	        cp      $0A             ; 0-9? < A hex?
3962: 3802    	        jr      C,ADD301        ; Skip Add 7
3964: C607    	        add     A,$07           ; Bring it up to ASCII A-F
3966: C630    	ADD301	add     A,$30           ; And make it full ASCII
3968: 47      	        ld      B,A             ; Store high order byte
3969: C9      	        ret
              	
              	; Convert "&Hnnnn" to FPREG
              	; Gets a character from (HL) checks for Hexadecimal ASCII numbers "&Hnnnn"
              	; Char is in A, NC if char is ;<=>?@ A-z, CY is set if 0-9
396A: EB      	HEXTFP  ex      DE,HL           ; Move code string pointer to DE
396B: 210000  	        ld      HL,$0000        ; Zero out the value
396E: CD8339  	        call    GETHEX          ; Check the number for valid hex
3971: DAA339  	        jp      C,HXERR         ; First value wasn't hex, HX error
3974: 1805    	        jr      HEXLP1          ; Convert first character
3976: CD8339  	HEXLP   call    GETHEX          ; Get second and addtional characters
3979: 381F    	        jr      C,HEXIT         ; Exit if not a hex character
397B: 29      	HEXLP1  add     HL,HL           ; Rotate 4 bits to the left
397C: 29      	        add     HL,HL
397D: 29      	        add     HL,HL
397E: 29      	        add     HL,HL
397F: B5      	        or      L               ; Add in D0-D3 into L
3980: 6F      	        ld      L,A             ; Save new value
3981: 18F3    	        jr      HEXLP           ; And continue until all hex characters are in
              	
3983: 13      	GETHEX  inc     DE              ; Next location
3984: 1A      	        ld      A,(DE)          ; Load character at pointer
3985: FE20    	        cp      SPC
3987: CA8339  	        jp      Z,GETHEX        ; Skip spaces
398A: D630    	        sub     $30             ; Get absolute value
398C: D8      	        ret     C               ; < "0", error
398D: FE0A    	        cp      $0A
398F: 3805    	        jr      C,NOSUB7        ; Is already in the range 0-9
3991: D607    	        sub     $07             ; Reduce to A-F
3993: FE0A    	        cp      $0A             ; Value should be $0A-$0F at this point
3995: D8      	        ret     C               ; CY set if was :            ; < = > ? @
3996: FE10    	NOSUB7  cp      $10             ; > Greater than "F"?
3998: 3F      	        ccf
3999: C9      	        ret                     ; CY set if it wasn't valid hex
              	
399A: EB      	HEXIT   ex      DE,HL           ; Value into DE, Code string into HL
399B: 7A      	        ld      A,D             ; Load DE into AC
399C: 4B      	        ld      C,E             ; For prep to
399D: E5      	        push    HL
399E: CD7C22  	        call    ACPASS          ; ACPASS to set AC as integer into FPREG
39A1: E1      	        pop     HL
39A2: C9      	        ret
              	
39A3: 1E26    	HXERR:  ld      E,HX            ; ?HEX Error
39A5: C32F15  	        jp      ERROR
              	
              	; BIN$(NN) Convert integer to a 1-16 char binary string
39A8: CD9A1E  	BIN:    call    TSTNUM          ; Verify it's a number
39AB: CDD81A  	        call    DEINT           ; Get integer -32768 to 32767
39AE: C5      	BIN2:   push    BC              ; Save contents of BC
39AF: 213082  	        ld      HL,PBUFF
39B2: 0611    	        ld      B,$11           ; One higher than max char count (16+1)
39B4:         	ZEROSUP:                        ; Suppress leading zeros
39B4: 05      	        dec     B               ; Max 16 chars
39B5: 78      	        ld      A,B
39B6: FE01    	        cp      $01
39B8: 2808    	        jr      Z,BITOUT        ; Always output at least one character
39BA: CB13    	        rl      E
39BC: CB12    	        rl      D
39BE: 30F4    	        jr      NC,ZEROSUP
39C0: 1804    	        jr      BITOUT2
39C2: CB13    	BITOUT: rl      E
39C4: CB12    	        rl      D               ; Top bit now in carry
39C6: 3E30    	BITOUT2:ld      A,'0'           ; Char for '0'
39C8: CE00    	        adc     A,$00           ; If carry set then '0' --> '1'
39CA: 77      	        ld      (HL),A
39CB: 23      	        inc     HL
39CC: 05      	        dec     B
39CD: 20F3    	        jr      NZ,BITOUT
39CF: AF      	        xor     A               ; Terminating character
39D0: 77      	        ld      (HL),A          ; Store zero to terminate
39D1: 23      	        inc     HL              ; Make sure PBUFF is terminated
39D2: 77      	        ld      (HL),A          ; Store the double zero there
39D3: C1      	        pop     BC
39D4: 213082  	        ld      HL,PBUFF
39D7: C32B23  	        jp      STR1
              	
              	; Convert "&Bnnnn" to FPREG
              	; Gets a character from (HL) checks for Binary ASCII numbers "&Bnnnn"
39DA: EB      	BINTFP: ex      DE,HL           ; Move code string pointer to DE
39DB: 210000  	        ld      HL,$0000        ; Zero out the value
39DE: CDF739  	        call    CHKBIN          ; Check the number for valid bin
39E1: DA053A  	        jp      C,BINERR        ; First value wasn't bin, HX error
39E4: D630    	BINIT:  sub     '0'
39E6: 29      	        add     HL,HL           ; Rotate HL left
39E7: B5      	        or      L
39E8: 6F      	        ld      L,A
39E9: CDF739  	        call    CHKBIN          ; Get second and addtional characters
39EC: 30F6    	        jr      NC,BINIT        ; Process if a bin character
39EE: EB      	        ex      DE,HL           ; Value into DE, Code string into HL
39EF: 7A      	        ld      A,D             ; Load DE into AC
39F0: 4B      	        ld      C,E             ; For prep to
39F1: E5      	        push    HL
39F2: CD7C22  	        call    ACPASS          ; ACPASS to set AC as integer into FPREG
39F5: E1      	        pop     HL
39F6: C9      	        ret
              	
              	; Char is in A, NC if char is 0 or 1
39F7: 13      	CHKBIN: inc     DE
39F8: 1A      	        ld      A,(DE)
39F9: FE20    	        cp      SPC
39FB: CAF739  	        jp      Z,CHKBIN        ; Skip spaces
39FE: FE30    	        cp      '0'             ; Set C if < '0'
3A00: D8      	        ret     C
3A01: FE32    	        cp      '2'
3A03: 3F      	        ccf                     ; Set C if > '1'
3A04: C9      	        ret
              	
3A05: 1E28    	BINERR: ld      E,BN            ; ?BIN Error
3A07: C32F15  	        jp      ERROR
              	
              	
3A0A: C30800  	MONOUT: jp      $0008           ; output a char
              	
              	
3A0D: 3A2E82  	RESET:  ld      A,(SERIALS_EN)
3A10: E601    	        and     $01             ; is serial port #1 open?
3A12: C4D035  	        call    NZ,RSTSER1      ; yes, reset serial 1
3A15: C30000  	        jp      $0000           ; Restart
              	
              	
3A18: 3E00    	INITST: ld      A,$00           ; Clear break flag
3A1A: 32A980  	        ld      (BRKFLG),A
3A1D: C3D20E  	        jp      INIT
              	
              	
3A20: F5      	TSTBIT: push    AF              ; Save bit mask
3A21: A0      	        and     B               ; Get common bits
3A22: C1      	        pop     BC              ; Restore bit mask
3A23: B8      	        cp      B               ; Same bit set?
3A24: 3E00    	        ld      A,$00           ; Return 0 in A
3A26: C9      	        ret
              	
3A27: CD0A18  	OUTNCR: call    OUTC            ; Output character in A
3A2A: C3DB1C  	        jp      PRNTCRLF        ; Output CRLF
              	; ------------------------------------------------------------------------------
              	; LM80C - UTILITY ROUTINES - R1.1
              	; ------------------------------------------------------------------------------
              	; The following code is intended to be used with LM80C Z80-based computer
              	; designed by Leonardo Miliani. More info at
              	; www DOT leonardomiliani DOT com
              	;
              	; *ALS are routines from "Z80 Assembly Language Subroutines" by Lance
              	; A. Leventhal and Winthrop Saville - Ed. Osborne/McGraw-Hill (1983)
              	;
              	; * WKT are routines from WikiTI:
              	; http://wikiti.brandonw.net/index.php?title=WikiTI_Home
              	;
              	; * LAC are routines from Learn@Cemetch
              	; https://learn.cemetech.net/index.php/Main_Page
              	;
              	; ------------------------------------------------------------------------------
              	; Code Revision:
              	; R1.0 - 20200110 - First release: 16-bit comparision/multiplication/negation
              	; R1.1 - 20200413 - Second release: added ABS(HL) 
              	;
              	; ------------------------------------------------------------------------------
              	
              	; compare two 16-bit registers, HL (minuend) and DE (subtrahend)
              	; values can be both signed or unsigned words
              	; inputs: HL, DE
              	; destroys: A,F,HL
              	; returns: if both registers are 2's complement, use Z and S flags;
              	; otherwise:
              	; if HL=DE: Z,P,NC  - Z=1, S=0; C=0
              	; if HL>DE: NZ,P,NC - Z=0, S=0; C=0
              	; if HL<DE: NZ,M,C  - Z=0, S=1; C=1
              	; Source: ALS
              	
3A2D: B7      	CMP16:  or      A           ; clear CARRY
3A2E: ED52    	        sbc     HL,DE       ; subtract DE from HL
3A30: E0      	        ret     PO          ; return if no overflow
3A31: 7C      	        ld      A,H         ; overflow - invert SIGN flag
3A32: 1F      	        rra                 ; save CARRY flag in bit 7
3A33: EE40    	        xor     %01000000   ; complement bit 6 (SIGN bit)
3A35: 37      	        scf                 ; ensure a Non-Zero result
3A36: 8F      	        adc     A,A         ; restore CARRY, complemented SIGN
              	                            ; ZERO flag = 0 for sure
3A37: C9      	        ret                 ; return
              	
              	; ----------------------------------------------------------------------
              	
              	; multiply 2 signed/unsigned 16-bit words and return a 16-bit
              	; signed/unsigned product
              	; inputs: HL (multiplicand); DE (multiplier)
              	; destroys: A,F
              	; returns: HL (product)
              	; Source: ALS
              	
              	; initialize partial product, bit count
3A38: C5      	MUL16:  push    BC
3A39: 4D      	        ld      C,L         ; BC = multiplier
3A3A: 44      	        ld      B,H
3A3B: 210000  	        ld      HL,0        ; product = 0
3A3E: 3E0F    	        ld      A,$0F       ; count = bit lenght - 1 (16-1)
              	        ; shift-and-add algorithm
              	        ; if MSB of multiplier is 1, add multiplicand to partial product
              	        ; shift partial product, multiplier left 1 bit
3A40: CB23    	MLP:    sla     E           ; shift multiplier left 1 bit
3A42: CB12    	        rl      D
3A44: 3001    	        jr      NC,MLP1     ; jump if MSB of multiplier = 0
3A46: 09      	        add     HL,BC       ; add multiplicand to partial product
3A47: 29      	MLP1:   add     HL,HL       ; shift partial product left
3A48: 3D      	        dec     A
3A49: 20F5    	        jr      NZ,MLP      ; continue until count = 0
              	        ; add multiplicand one last time if MSB of multiplier is 1
3A4B: B2      	        or      D           ; sign flag = MSB of multiplier
3A4C: F2503A  	        jp      P,EXMUL16   ; exit if MSB of multiplier is 0
3A4F: 09      	        add     HL,BC       ; add multiplicand to product
3A50: C1      	EXMUL16:pop     BC
3A51: C9      	        ret
              	
              	; ----------------------------------------------------------------------
              	; absolute value of HL (same applies to other 16-bit register pairs)
              	; also, invert value of HL (or any other 16-bit register, just adjust the code)
              	;
              	; inputs: HL
              	; destroys: A
              	; operation: ABS(HL)
              	; returns: HL with no sign or negated
              	; Source: WKT
              	
3A52: CB7C    	absHL:  bit     7,H
3A54: C8      	        ret     Z
3A55: AF      	negHL:  xor     A
3A56: 95      	        sub     L
3A57: 6F      	        ld      L,A
3A58: 9F      	        sbc     A,A
3A59: 94      	        sub     H
3A5A: 67      	        ld      H,A
3A5B: C9      	        ret
              	
              	; ------------------------------------------------------------------------------
              	
              	; 8/8 division
              	; INPUT: D (dividend), E (divisor)
              	; OPERATION: D/E
              	; OUTPUT: D (quotient), A (remainder)
3A5C: AF      	DIV_8_8:    xor     A
3A5D: C5      	            push    BC
3A5E: 0608    	            ld      B,08h
3A60: CB22    	DIV_8_8LOOP:sla     D
3A62: 17      	            rla
3A63: BB      	            cp      E
3A64: 3802    	            jr      C,$+4
3A66: 93      	            sub     E
3A67: 14      	            inc     D
3A68: 10F6    	            djnz    DIV_8_8LOOP
3A6A: C1      	            pop     BC
3A6B: C9      	            ret
              	
              	; ----------------------------------------------------------------------
              	; divide a 16-bit number by an 8-bit number
              	; (16/8 division)
              	;
              	; inputs: HL (Dividend), C (divisor)
              	; destroys: A
              	; OPERATION: HL/C
              	; returns: HL (quotient), A (remainder)
              	; source: WKT
              	
3A6C: AF      	DIV_16_8:   xor     A
3A6D: 0610    	            ld      B,16
3A6F: 29      	DIV_16_8LP: add     HL,HL
3A70: 17      	            rla
3A71: 3803    	            jr      C,$+5
3A73: B9      	            cp      C
3A74: 3802    	            jr      C,$+4
3A76: 91      	            sub     C
3A77: 2C      	            inc     L
3A78: 10F5    	            djnz    DIV_16_8LP
3A7A: C9      	            ret; ------------------------------------------------------------------------------
              	; LM80C - 6x8 CHARSET - R1.4
              	; ------------------------------------------------------------------------------
              	; The following code is intended to be used with LM80C Z80-based computer
              	; designed by Leonardo Miliani. More info at
              	; www DOT leonardomiliani DOT com
              	; ------------------------------------------------------------------------------
              	; Code Revision:
              	; R1.0 - 20190511 - First revision: ASCII chars (from 0 to 127)
              	; R1.1 - 20190521 - Expanded to 255 chars
              	; R1.2 - 20191209 - Start adding graphic chars to be coherent with 8x8 fonts
              	; R1.3 - 20191226 - Added extended char codes (128-255)
              	; R1.4 - 20200228 - adopted more usual hexadecimal & binary prefixes
              	; ------------------------------------------------------------------------------
              	;
              	;-------------------------------------------------------------------------------
              	;
              	;               6 x 8    C  H  A  R  S  E  T
              	;
              	;-------------------------------------------------------------------------------
              	;
              	;       6X8 CHARS, DESIGNED FOR TEXT BUT USABLE IN GRAPHICS 1 MODE TOO
              	;       UPDATE: NOW GRAPHICS 1 MODE HAS ITS OWN CHAR SET
              	
3A7B:         	CHRST68 equ $
3A7B: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 0 (null char)
3A7F: 00000000	
3A83: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 1 F1
3A87: 00000000	
3A8B: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 2 F2
3A8F: 00000000	
3A93: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 3 CTRL-C
3A97: 00000000	
3A9B: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 4 F3
3A9F: 00000000	
3AA3: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 5 F4
3AA7: 00000000	
3AAB: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 6 F5
3AAF: 00000000	
3AB3: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 7 (bell)
3AB7: 00000000	
3ABB: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 8 (backspace)
3ABF: 00000000	
3AC3: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 9 (H. tab)
3AC7: 00000000	
3ACB: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 10 (line feed)
3ACF: 00000000	
3AD3: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 11 
3AD7: 00000000	
3ADB: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 12 Form feed (clear screen)
3ADF: 00000000	
3AE3: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 13 (carriage return)
3AE7: 00000000	
3AEB: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 14 CTRL
3AEF: 00000000	
3AF3: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 15 CTRL-O
3AF7: 00000000	
3AFB: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 16 C=/Graphic key
3AFF: 00000000	
3B03: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 17 CTRL-Q
3B07: 00000000	
3B0B: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 18 CTRL-R
3B0F: 00000000	
3B13: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 19 CTRL-S
3B17: 00000000	
3B1B: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 20 SHIFT
3B1F: 00000000	
3B23: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 21 CTRL-U
3B27: 00000000	
3B2B: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 22 F6
3B2F: 00000000	
3B33: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 23 F7
3B37: 00000000	
3B3B: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 24 HELP
3B3F: 00000000	
3B43: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 25 (home)
3B47: 00000000	
3B4B: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 26
3B4F: 00000000	
3B53: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 27 (escape)
3B57: 00000000	
3B5B: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 28 (cursor left)
3B5F: 00000000	
3B63: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 29 (cursor right)
3B67: 00000000	
3B6B: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 30 (cursor up)
3B6F: 00000000	
3B73: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 31 (cursor down)
3B77: 00000000	
3B7B: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 32: space
3B7F: 00000000	
3B83: 20202020	        defb $20,$20,$20,$20,$20,$00,$20,$00 ; char 33: !
3B87: 20002000	
3B8B: 50500000	        defb $50,$50,$00,$00,$00,$00,$00,$00 ; char 34: "
3B8F: 00000000	
3B93: 5050F850	        defb $50,$50,$f8,$50,$f8,$50,$50,$00 ; char 35: #
3B97: F8505000	
3B9B: 2078A070	        defb $20,$78,$a0,$70,$28,$f0,$20,$00 ; char 36: $
3B9F: 28F02000	
3BA3: C0C81020	        defb $c0,$c8,$10,$20,$40,$98,$18,$00 ; char 37: %
3BA7: 40981800	
3BAB: 6090A040	        defb $60,$90,$a0,$40,$a8,$90,$68,$00 ; char 38: &
3BAF: A8906800	
3BB3: 60204000	        defb $60,$20,$40,$00,$00,$00,$00,$00 ; char 39: '
3BB7: 00000000	
3BBB: 10204040	        defb $10,$20,$40,$40,$40,$20,$10,$00 ; char 40: (
3BBF: 40201000	
3BC3: 40201010	        defb $40,$20,$10,$10,$10,$20,$40,$00 ; char 41: )
3BC7: 10204000	
3BCB: 0020A870	        defb $00,$20,$a8,$70,$a8,$20,$00,$00 ; char 42: *
3BCF: A8200000	
3BD3: 002020F8	        defb $00,$20,$20,$f8,$20,$20,$00,$00 ; char 43: +
3BD7: 20200000	
3BDB: 00000000	        defb $00,$00,$00,$00,$60,$20,$40,$00 ; char 44: ,
3BDF: 60204000	
3BE3: 000000F8	        defb $00,$00,$00,$f8,$00,$00,$00,$00 ; char 45: -
3BE7: 00000000	
3BEB: 00000000	        defb $00,$00,$00,$00,$00,$60,$60,$00 ; char 46: .
3BEF: 00606000	
3BF3: 00081020	        defb $00,$08,$10,$20,$40,$80,$00,$00 ; char 47: /
3BF7: 40800000	
3BFB: 708898A8	        defb $70,$88,$98,$a8,$c8,$88,$70,$00 ; char 48: 0
3BFF: C8887000	
3C03: 20602020	        defb $20,$60,$20,$20,$20,$20,$70,$00 ; char 49: 1
3C07: 20207000	
3C0B: 70880810	        defb $70,$88,$08,$10,$20,$40,$f8,$00 ; char 50: 2
3C0F: 2040F800	
3C13: F8102010	        defb $f8,$10,$20,$10,$08,$88,$70,$00 ; char 51: 3
3C17: 08887000	
3C1B: 10305090	        defb $10,$30,$50,$90,$f8,$10,$10,$00 ; char 52: 4
3C1F: F8101000	
3C23: F880F008	        defb $f8,$80,$f0,$08,$08,$88,$70,$00 ; char 53: 5
3C27: 08887000	
3C2B: 304080F8	        defb $30,$40,$80,$f8,$88,$88,$70,$00 ; char 54: 6
3C2F: 88887000	
3C33: F8081020	        defb $f8,$08,$10,$20,$40,$40,$40,$00 ; char 55: 7
3C37: 40404000	
3C3B: 70888870	        defb $70,$88,$88,$70,$88,$88,$70,$00 ; char 56: 8
3C3F: 88887000	
3C43: 70888878	        defb $70,$88,$88,$78,$08,$10,$60,$00 ; char 57: 9
3C47: 08106000	
3C4B: 00303000	        defb $00,$30,$30,$00,$30,$30,$00,$00 ; char 58: :
3C4F: 30300000	
3C53: 00303000	        defb $00,$30,$30,$00,$30,$10,$20,$00 ; char 59: ;
3C57: 30102000	
3C5B: 10204080	        defb $10,$20,$40,$80,$40,$20,$10,$00 ; char 60: <
3C5F: 40201000	
3C63: 0000F800	        defb $00,$00,$f8,$00,$f8,$00,$00,$00 ; char 61: =
3C67: F8000000	
3C6B: 40201008	        defb $40,$20,$10,$08,$10,$20,$40,$00 ; char 62: >
3C6F: 10204000	
3C73: 70880810	        defb $70,$88,$08,$10,$20,$00,$20,$00 ; char 63: ?
3C77: 20002000	
3C7B: 70880868	        defb $70,$88,$08,$68,$a8,$a8,$70,$00 ; char 64: @
3C7F: A8A87000	
3C83: 70888888	        defb $70,$88,$88,$88,$f8,$88,$88,$00 ; char 65: A
3C87: F8888800	
3C8B: F08888F0	        defb $f0,$88,$88,$f0,$88,$88,$f0,$00 ; char 66: B
3C8F: 8888F000	
3C93: 70888080	        defb $70,$88,$80,$80,$80,$88,$70,$00 ; char 67: C
3C97: 80887000	
3C9B: E0908888	        defb $e0,$90,$88,$88,$88,$90,$e0,$00 ; char 68: D
3C9F: 8890E000	
3CA3: F88080F0	        defb $f8,$80,$80,$f0,$80,$80,$f8,$00 ; char 69: E
3CA7: 8080F800	
3CAB: F88080F0	        defb $f8,$80,$80,$f0,$80,$80,$80,$00 ; char 70: F
3CAF: 80808000	
3CB3: 708880B8	        defb $70,$88,$80,$b8,$88,$88,$78,$00 ; char 71: G
3CB7: 88887800	
3CBB: 888888F8	        defb $88,$88,$88,$f8,$88,$88,$88,$00 ; char 72: H
3CBF: 88888800	
3CC3: 70202020	        defb $70,$20,$20,$20,$20,$20,$70,$00 ; char 73: I
3CC7: 20207000	
3CCB: 38101010	        defb $38,$10,$10,$10,$10,$90,$60,$00 ; char 74: J
3CCF: 10906000	
3CD3: 8890A0C0	        defb $88,$90,$a0,$c0,$a0,$90,$88,$00 ; char 75: K
3CD7: A0908800	
3CDB: 80808080	        defb $80,$80,$80,$80,$80,$80,$f8,$00 ; char 76: L
3CDF: 8080F800	
3CE3: 88D8A8A8	        defb $88,$d8,$a8,$a8,$88,$88,$88,$00 ; char 77: M
3CE7: 88888800	
3CEB: 88C8A898	        defb $88,$c8,$a8,$98,$88,$88,$88,$00 ; char 78: N
3CEF: 88888800	
3CF3: 70888888	        defb $70,$88,$88,$88,$88,$88,$70,$00 ; char 79: O
3CF7: 88887000	
3CFB: F08888F0	        defb $f0,$88,$88,$f0,$80,$80,$80,$00 ; char 80: P
3CFF: 80808000	
3D03: 70888888	        defb $70,$88,$88,$88,$a8,$90,$68,$00 ; char 81: Q
3D07: A8906800	
3D0B: F08888F0	        defb $f0,$88,$88,$f0,$a0,$90,$88,$00 ; char 82: R
3D0F: A0908800	
3D13: 78808070	        defb $78,$80,$80,$70,$08,$08,$f0,$00 ; char 83: S
3D17: 0808F000	
3D1B: F8202020	        defb $f8,$20,$20,$20,$20,$20,$20,$00 ; char 84: T
3D1F: 20202000	
3D23: 88888888	        defb $88,$88,$88,$88,$88,$88,$70,$00 ; char 85: U
3D27: 88887000	
3D2B: 88888888	        defb $88,$88,$88,$88,$88,$50,$20,$00 ; char 86: V
3D2F: 88502000	
3D33: 88888888	        defb $88,$88,$88,$88,$a8,$a8,$50,$00 ; char 87: W
3D37: A8A85000	
3D3B: 88885020	        defb $88,$88,$50,$20,$50,$88,$88,$00 ; char 88: X
3D3F: 50888800	
3D43: 88888850	        defb $88,$88,$88,$50,$20,$20,$20,$00 ; char 89: Y
3D47: 20202000	
3D4B: F8081020	        defb $f8,$08,$10,$20,$40,$80,$f8,$00 ; char 90: Z
3D4F: 4080F800	
3D53: 70404040	        defb $70,$40,$40,$40,$40,$40,$70,$00 ; char 91: [
3D57: 40407000	
3D5B: 00804020	        defb $00,$80,$40,$20,$10,$08,$00,$00 ; char 92: \
3D5F: 10080000	
3D63: 70101010	        defb $70,$10,$10,$10,$10,$10,$70,$00 ; char 93: ]
3D67: 10107000	
3D6B: 20508800	        defb $20,$50,$88,$00,$00,$00,$00,$00 ; char 94: ^
3D6F: 00000000	
3D73: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$FC ; char 95: _ (underscore)
3D77: 000000FC	
3D7B: 40201000	        defb $40,$20,$10,$00,$00,$00,$00,$00 ; char 96: `
3D7F: 00000000	
3D83: 00007008	        defb $00,$00,$70,$08,$78,$88,$78,$00 ; char 97: a
3D87: 78887800	
3D8B: 808080B0	        defb $80,$80,$80,$b0,$c8,$88,$f0,$00 ; char 98: b
3D8F: C888F000	
3D93: 00007080	        defb $00,$00,$70,$80,$80,$88,$70,$00 ; char 99: c
3D97: 80887000	
3D9B: 08080868	        defb $08,$08,$08,$68,$98,$88,$78,$00 ; char 100: d
3D9F: 98887800	
3DA3: 00007088	        defb $00,$00,$70,$88,$f8,$80,$70,$00 ; char 101: e
3DA7: F8807000	
3DAB: 304840E0	        defb $30,$48,$40,$e0,$40,$40,$40,$00 ; char 102: f
3DAF: 40404000	
3DB3: 00007888	        defb $00,$00,$78,$88,$78,$08,$70,$00 ; char 103: g
3DB7: 78087000	
3DBB: 8080B0C8	        defb $80,$80,$b0,$c8,$88,$88,$88,$00 ; char 104: h
3DBF: 88888800	
3DC3: 00200020	        defb $00,$20,$00,$20,$20,$20,$20,$00 ; char 105: i
3DC7: 20202000	
3DCB: 00100030	        defb $00,$10,$00,$30,$10,$90,$60,$00 ; char 106: j
3DCF: 10906000	
3DD3: 808090A0	        defb $80,$80,$90,$a0,$c0,$a0,$90,$00 ; char 107: k
3DD7: C0A09000	
3DDB: 60202020	        defb $60,$20,$20,$20,$20,$20,$70,$00 ; char 108: l
3DDF: 20207000	
3DE3: 0000D0A8	        defb $00,$00,$d0,$a8,$a8,$88,$88,$00 ; char 109: m
3DE7: A8888800	
3DEB: 0000B0C8	        defb $00,$00,$b0,$c8,$88,$88,$88,$00 ; char 110: n
3DEF: 88888800	
3DF3: 00007088	        defb $00,$00,$70,$88,$88,$88,$70,$00 ; char 111: o
3DF7: 88887000	
3DFB: 0000F088	        defb $00,$00,$f0,$88,$f0,$80,$80,$00 ; char 112: p
3DFF: F0808000	
3E03: 00007888	        defb $00,$00,$78,$88,$78,$08,$08,$00 ; char 113: q
3E07: 78080800	
3E0B: 0000B0C8	        defb $00,$00,$b0,$c8,$80,$80,$80,$00 ; char 114: r
3E0F: 80808000	
3E13: 00007080	        defb $00,$00,$70,$80,$70,$08,$f0,$00 ; char 115: s
3E17: 7008F000	
3E1B: 4040E040	        defb $40,$40,$e0,$40,$40,$48,$30,$00 ; char 116: t
3E1F: 40483000	
3E23: 00008888	        defb $00,$00,$88,$88,$88,$98,$68,$00 ; char 117: u
3E27: 88986800	
3E2B: 00008888	        defb $00,$00,$88,$88,$88,$50,$20,$00 ; char 118: v
3E2F: 88502000	
3E33: 00008888	        defb $00,$00,$88,$88,$a8,$a8,$50,$00 ; char 119: w
3E37: A8A85000	
3E3B: 00008850	        defb $00,$00,$88,$50,$20,$50,$88,$00 ; char 120: x
3E3F: 20508800	
3E43: 00008898	        defb $00,$00,$88,$98,$68,$08,$70,$00 ; char 121: y
3E47: 68087000	
3E4B: 0000F810	        defb $00,$00,$f8,$10,$20,$40,$f8,$00 ; char 122: z
3E4F: 2040F800	
3E53: 10202040	        defb $10,$20,$20,$40,$20,$20,$10,$00 ; char 123: {
3E57: 20201000	
3E5B: 20202020	        defb $20,$20,$20,$20,$20,$20,$20,$00 ; char 124: |
3E5F: 20202000	
3E63: 20101008	        defb $20,$10,$10,$08,$10,$10,$20,$00 ; char 125: }
3E67: 10102000	
3E6B: 00285000	        defb $00,$28,$50,$00,$00,$00,$00,$00 ; char 126: ~
3E6F: 00000000	
3E73: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 127: (delete) - here end the standard ASCII (0-127)
3E77: 00000000	
3E7B: 7884CC84	        defb %01111000,%10000100,%11001100,%10000100,%10110100,%10000100,%01111000,%00000000 ; char 128 (open face)
3E7F: B4847800	
3E83: 78FCB4FC	        defb %01111000,%11111100,%10110100,%11111100,%10110100,%11001100,%01111000,%00000000 ; char 129 (full face)
3E87: B4CC7800	
3E8B: 48FCFCFC	        defb %01001000,%11111100,%11111100,%11111100,%11111100,%01111000,%00110000,%00000000 ; char 130 (hearts)
3E8F: FC783000	
3E93: 002070F8	        defb %00000000,%00100000,%01110000,%11111000,%11111000,%01110000,%00100000,%00000000 ; char 131 (diamonds)
3E97: F8702000	
3E9B: 7020A8F8	        defb %01110000,%00100000,%10101000,%11111000,%10101000,%00100000,%01110000,%00000000 ; char 132 (clubs)
3E9F: A8207000	
3EA3: 2070F8F8	        defb %00100000,%01110000,%11111000,%11111000,%10101000,%00100000,%01110000,%00000000 ; char 133 (spades)
3EA7: A8207000	
3EAB: 303030FC	        defb %00110000,%00110000,%00110000,%11111100,%11111100,%00110000,%00110000,%00110000 ; char 134 
3EAF: FC303030	
3EB3: 0000003C	        defb %00000000,%00000000,%00000000,%00111100,%00111100,%00110000,%00110000,%00110000 ; char 135 
3EB7: 3C303030	
3EBB: 000000F0	        defb %00000000,%00000000,%00000000,%11110000,%11110000,%00110000,%00110000,%00110000 ; char 136 
3EBF: F0303030	
3EC3: 303030F0	        defb %00110000,%00110000,%00110000,%11110000,%11110000,%00000000,%00000000,%00000000 ; char 137 
3EC7: F0000000	
3ECB: 3030303C	        defb %00110000,%00110000,%00110000,%00111100,%00111100,%00000000,%00000000,%00000000 ; char 138 
3ECF: 3C000000	
3ED3: 303030FC	        defb %00110000,%00110000,%00110000,%11111100,%11111100,%00000000,%00000000,%00000000 ; char 139 
3ED7: FC000000	
3EDB: 3030303C	        defb %00110000,%00110000,%00110000,%00111100,%00111100,%00110000,%00110000,%00110000 ; char 140 
3EDF: 3C303030	
3EE3: 000000FC	        defb %00000000,%00000000,%00000000,%11111100,%11111100,%00110000,%00110000,%00110000 ; char 141 
3EE7: FC303030	
3EEB: 303030F0	        defb %00110000,%00110000,%00110000,%11110000,%11110000,%00110000,%00110000,%00110000 ; char 142 
3EEF: F0303030	
3EF3: 000000FC	        defb %00000000,%00000000,%00000000,%11111100,%11111100,%00000000,%00000000,%00000000 ; char 143 
3EF7: FC000000	
3EFB: 30303030	        defb %00110000,%00110000,%00110000,%00110000,%00110000,%00110000,%00110000,%00110000 ; char 144 
3EFF: 30303030	
3F03: 0C1C1838	        defb %00001100,%00011100,%00011000,%00111000,%01110000,%01100000,%11100000,%11000000 ; char 145 
3F07: 7060E0C0	
3F0B: C0E06070	        defb %11000000,%11100000,%01100000,%01110000,%00111000,%00011000,%00011100,%00001100 ; char 146 
3F0F: 38181C0C	
3F13: CCCC7830	        defb %11001100,%11001100,%01111000,%00110000,%00110000,%01111000,%11001100,%11001100 ; char 147 
3F17: 3078CCCC	
3F1B: 202020FC	        defb %00100000,%00100000,%00100000,%11111100,%00100000,%00100000,%00100000,%00100000 ; char 148 
3F1F: 20202020	
3F23: 0000003C	        defb %00000000,%00000000,%00000000,%00111100,%00100000,%00100000,%00100000,%00100000 ; char 149 
3F27: 20202020	
3F2B: 000000E0	        defb %00000000,%00000000,%00000000,%11100000,%00100000,%00100000,%00100000,%00100000 ; char 150 
3F2F: 20202020	
3F33: 202020E0	        defb %00100000,%00100000,%00100000,%11100000,%00000000,%00000000,%00000000,%00000000 ; char 151 
3F37: 00000000	
3F3B: 2020203C	        defb %00100000,%00100000,%00100000,%00111100,%00000000,%00000000,%00000000,%00000000 ; char 152 
3F3F: 00000000	
3F43: 202020FC	        defb %00100000,%00100000,%00100000,%11111100,%00000000,%00000000,%00000000,%00000000 ; char 153 
3F47: 00000000	
3F4B: 2020203C	        defb %00100000,%00100000,%00100000,%00111100,%00100000,%00100000,%00100000,%00100000 ; char 154 
3F4F: 20202020	
3F53: 000000FC	        defb %00000000,%00000000,%00000000,%11111100,%00100000,%00100000,%00100000,%00100000 ; char 155 
3F57: 20202020	
3F5B: 202020E0	        defb %00100000,%00100000,%00100000,%11100000,%00100000,%00100000,%00100000,%00100000 ; char 156 
3F5F: 20202020	
3F63: 000000FC	        defb %00000000,%00000000,%00000000,%11111100,%00000000,%00000000,%00000000,%00000000 ; char 157 
3F67: 00000000	
3F6B: 20202020	        defb %00100000,%00100000,%00100000,%00100000,%00100000,%00100000,%00100000,%00100000 ; char 158 
3F6F: 20202020	
3F73: 04080810	        defb %00000100,%00001000,%00001000,%00010000,%00100000,%01000000,%01000000,%10000000 ; char 159 
3F77: 20404080	
3F7B: 80404020	        defb %10000000,%01000000,%01000000,%00100000,%00010000,%00001000,%00001000,%00000100 ; char 160 
3F7F: 10080804	
3F83: 84484830	        defb %10000100,%01001000,%01001000,%00110000,%00110000,%01001000,%01001000,%10000100 ; char 161 
3F87: 30484884	
3F8B: 00000000	        defb %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%11111100,%11111100 ; char 162 
3F8F: 0000FCFC	
3F93: 00000000	        defb %00000000,%00000000,%00000000,%00000000,%11111100,%11111100,%11111100,%11111100 ; char 163 
3F97: FCFCFCFC	
3F9B: 0000FCFC	        defb %00000000,%00000000,%11111100,%11111100,%11111100,%11111100,%11111100,%11111100 ; char 164 
3F9F: FCFCFCFC	
3FA3: FCFC0000	        defb %11111100,%11111100,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 165 
3FA7: 00000000	
3FAB: FCFCFCFC	        defb %11111100,%11111100,%11111100,%11111100,%00000000,%00000000,%00000000,%00000000 ; char 166 
3FAF: 00000000	
3FB3: FCFCFCFC	        defb %11111100,%11111100,%11111100,%11111100,%11111100,%11111100,%00000000,%00000000 ; char 167 
3FB7: FCFC0000	
3FBB: 80808080	        defb %10000000,%10000000,%10000000,%10000000,%10000000,%10000000,%10000000,%10000000 ; char 168 
3FBF: 80808080	
3FC3: E0E0E0E0	        defb %11100000,%11100000,%11100000,%11100000,%11100000,%11100000,%11100000,%11100000 ; char 169 
3FC7: E0E0E0E0	
3FCB: F8F8F8F8	        defb %11111000,%11111000,%11111000,%11111000,%11111000,%11111000,%11111000,%11111000 ; char 170 
3FCF: F8F8F8F8	
3FD3: 04040404	        defb %00000100,%00000100,%00000100,%00000100,%00000100,%00000100,%00000100,%00000100 ; char 171 
3FD7: 04040404	
3FDB: 1C1C1C1C	        defb %00011100,%00011100,%00011100,%00011100,%00011100,%00011100,%00011100,%00011100 ; char 172 
3FDF: 1C1C1C1C	
3FE3: 7C7C7C7C	        defb %01111100,%01111100,%01111100,%01111100,%01111100,%01111100,%01111100,%01111100 ; char 173 
3FE7: 7C7C7C7C	
3FEB: FC848484	        defb %11111100,%10000100,%10000100,%10000100,%10000100,%10000100,%10000100,%11111100 ; char 174 
3FEF: 848484FC	
3FF3: 00000000	        defb %00000000,%00000000,%00000000,%00000000,%11100000,%11100000,%11100000,%11100000 ; char 175 
3FF7: E0E0E0E0	
3FFB: 00000000	        defb %00000000,%00000000,%00000000,%00000000,%00011100,%00011100,%00011100,%00011100 ; char 176 
3FFF: 1C1C1C1C	
4003: 1C1C1C1C	        defb %00011100,%00011100,%00011100,%00011100,%00000000,%00000000,%00000000,%00000000 ; char 177 
4007: 00000000	
400B: E0E0E0E0	        defb %11100000,%11100000,%11100000,%11100000,%00000000,%00000000,%00000000,%00000000 ; char 178 
400F: 00000000	
4013: E0E0E0E0	        defb %11100000,%11100000,%11100000,%11100000,%00011100,%00011100,%00011100,%00011100 ; char 179 
4017: 1C1C1C1C	
401B: 1C1C1C1C	        defb %00011100,%00011100,%00011100,%00011100,%11100000,%11100000,%11100000,%11100000 ; char 180 
401F: E0E0E0E0	
4023: 78787878	        defb %01111000,%01111000,%01111000,%01111000,%01111000,%01111000,%01111000,%01111000 ; char 181 
4027: 78787878	
402B: CCCCCCCC	        defb %11001100,%11001100,%11001100,%11001100,%11001100,%11001100,%11001100,%11001100 ; char 182 
402F: CCCCCCCC	
4033: FCFC0000	        defb %11111100,%11111100,%00000000,%00000000,%00000000,%00000000,%11111100,%11111100 ; char 183 
4037: 0000FCFC	
403B: 0000FCFC	        defb %00000000,%00000000,%11111100,%11111100,%11111100,%11111100,%00000000,%00000000 ; char 184 
403F: FCFC0000	
4043: 3030CCCC	        defb %00110000,%00110000,%11001100,%11001100,%00110000,%00110000,%11001100,%11001100 ; char 185 
4047: 3030CCCC	
404B: 54A854A8	        defb %01010100,%10101000,%01010100,%10101000,%01010100,%10101000,%01010100,%10101000 ; char 186 
404F: 54A854A8	
4053: 643098CC	        defb %01100100,%00110000,%10011000,%11001100,%01100100,%00110000,%10011000,%11001100 ; char 187 
4057: 643098CC	
405B: CC643098	        defb %11001100,%01100100,%00110000,%10011000,%11001100,%01100100,%00110000,%10011000 ; char 188 
405F: CC643098	
4063: 3098CC64	        defb %00110000,%10011000,%11001100,%01100100,%00110000,%10011000,%11001100,%01100100 ; char 189 
4067: 3098CC64	
406B: 64CC9830	        defb %01100100,%11001100,%10011000,%00110000,%01100100,%11001100,%10011000,%00110000 ; char 190 
406F: 64CC9830	
4073: 2020F820	        defb %00100000,%00100000,%11111000,%00100000,%00100000,%00000000,%11111000,%00000000 ; char 191 ()
4077: 2000F800	
407B: C0300830	        defb %11000000,%00110000,%00001000,%00110000,%11000000,%00000000,%11111000,%00000000 ; char 192 ()
407F: C000F800	
4083: 18608060	        defb %00011000,%01100000,%10000000,%01100000,%00011000,%00000000,%11111000,%00000000 ; char 193 ()
4087: 1800F800	
408B: 3C202020	        defb %00111100,%00100000,%00100000,%00100000,%10100000,%01100000,%00100000,%00000000 ; char 194 (square root)
408F: A0602000	
4093: 30484830	        defb %00110000,%01001000,%01001000,%00110000,%00000000,%00000000,%00000000,%00000000 ; char 195 ()
4097: 00000000	
409B: 60103040	        defb %01100000,%00010000,%00110000,%01000000,%01110000,%00000000,%00000000,%00000000 ; char 196 ()
409F: 70000000	
40A3: 000054A8	        defb %00000000,%00000000,%01010100,%10101000,%00000000,%11111100,%00000000,%00000000 ; char 197
40A7: 00FC0000	
40AB: 0054A800	        defb %00000000,%01010100,%10101000,%00000000,%01010100,%10101000,%00000000,%00000000 ; char 198 ()
40AF: 54A80000	
40B3: 0080C0E0	        defb %00000000,%10000000,%11000000,%11100000,%11100000,%11000000,%10000000,%00000000 ; char 199
40B7: E0C08000	
40BB: FC783000	        defb %11111100,%01111000,%00110000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 200
40BF: 00000000	
40C3: 00040C1C	        defb %00000000,%00000100,%00001100,%00011100,%00011100,%00001100,%00000100,%00000000 ; char 201
40C7: 1C0C0400	
40CB: 00000000	        defb %00000000,%00000000,%00000000,%00000000,%00000000,%00110000,%01111000,%11111100 ; char 202 
40CF: 003078FC	
40D3: 2070F820	        defb %00100000,%01110000,%11111000,%00100000,%00100000,%00100000,%00100000,%00000000 ; char 203 (up arrow)
40D7: 20202000	
40DB: 3C1C1C24	        defb %00111100,%00011100,%00011100,%00100100,%01000000,%10000000,%00000000,%00000000 ; char 204 (up right arrow)
40DF: 40800000	
40E3: 001018FC	        defb %00000000,%00010000,%00011000,%11111100,%00011000,%00010000,%00000000,%00000000 ; char 205 (right arrow)
40E7: 18100000	
40EB: 00008040	        defb %00000000,%00000000,%10000000,%01000000,%00100100,%00011100,%00011100,%00111100 ; char 206 (down right arrow)
40EF: 241C1C3C	
40F3: 00202020	        defb %00000000,%00100000,%00100000,%00100000,%00100000,%11111000,%01110000,%00100000 ; char 207 (down arrow)
40F7: 20F87020	
40FB: 00000408	        defb %00000000,%00000000,%00000100,%00001000,%10010000,%11100000,%11100000,%11110000 ; char 208 (down left arrow)
40FF: 90E0E0F0	
4103: 002060FC	        defb %00000000,%00100000,%01100000,%11111100,%01100000,%00100000,%00000000,%00000000 ; char 209 (left arrow)
4107: 60200000	
410B: F0E0E090	        defb %11110000,%11100000,%11100000,%10010000,%00001000,%00000100,%00000000,%00000000 ; char 210 (up left arrow)
410F: 08040000	
4113: 3844F040	        defb %00111000,%01000100,%11110000,%01000000,%11110000,%01000100,%00111000,%00000000 ; char 211 (euro)
4117: F0443800	
411B: 000478A8	        defb %00000000,%00000100,%01111000,%10101000,%00101000,%00101000,%00101000,%00000000 ; char 212 (greek pi)
411F: 28282800	
4123: 00000000	        defb %00000000,%00000000,%00000000,%00000000,%00011100,%00100000,%00100000,%00100000 ; char 213
4127: 1C202020	
412B: 00000000	        defb %00000000,%00000000,%00000000,%00000000,%11100000,%00010000,%00010000,%00010000 ; char 214
412F: E0101010	
4133: 101010E0	        defb %00010000,%00010000,%00010000,%11100000,%00000000,%00000000,%00000000,%00000000 ; char 215
4137: 00000000	
413B: 2020201C	        defb %00100000,%00100000,%00100000,%00011100,%00000000,%00000000,%00000000,%00000000 ; char 216
413F: 00000000	
4143: 0000001C	        defb %00000000,%00000000,%00000000,%00011100,%00111100,%00110000,%00110000,%00110000 ; char 217
4147: 3C303030	
414B: 000000E0	        defb %00000000,%00000000,%00000000,%11100000,%11110000,%00110000,%00110000,%00110000 ; char 218
414F: F0303030	
4153: 303030F0	        defb %00110000,%00110000,%00110000,%11110000,%11100000,%00000000,%00000000,%00000000 ; char 219
4157: E0000000	
415B: 3030303C	        defb %00110000,%00110000,%00110000,%00111100,%00011100,%00000000,%00000000,%00000000 ; char 220
415F: 1C000000	
4163: 00304848	        defb %00000000,%00110000,%01001000,%01001000,%01001000,%00110000,%00000000,%00000000 ; char 221
4167: 48300000	
416B: 00307878	        defb %00000000,%00110000,%01111000,%01111000,%01111000,%00110000,%00000000,%00000000 ; char 222
416F: 78300000	
4173: 003078FC	        defb %00000000,%00110000,%01111000,%11111100,%11111100,%01111000,%00110000,%00000000 ; char 223
4177: FC783000	
417B: FCF8F0E0	        defb %11111100,%11111000,%11110000,%11100000,%11100000,%11000000,%10000000,%10000000 ; char 224
417F: E0C08080	
4183: FC7C3C1C	        defb %11111100,%01111100,%00111100,%00011100,%00011100,%00001100,%00000100,%00000100 ; char 225
4187: 1C0C0404	
418B: 04040C1C	        defb %00000100,%00000100,%00001100,%00011100,%00011100,%00111100,%01111100,%11111100 ; char 226
418F: 1C3C7CFC	
4193: 8080C0E0	        defb %10000000,%10000000,%11000000,%11100000,%11100000,%11110000,%11111000,%11111100 ; char 227
4197: E0F0F8FC	
419B: 00040CD8	        defb %00000000,%00000100,%00001100,%11011000,%11110000,%11100000,%11000000,%00000000 ; char 228 (checkmark)
419F: F0E0C000	
41A3: 00CC7830	        defb %00000000,%11001100,%01111000,%00110000,%01111000,%11001100,%00000000,%00000000 ; char 229 (x)
41A7: 78CC0000	
41AB: 70888888	        defb %01110000,%10001000,%10001000,%10001000,%01110000,%00100000,%01110000,%00100000 ; char 230 (female)
41AF: 70207020	
41B3: 001C0C74	        defb %00000000,%00011100,%00001100,%01110100,%10010000,%10010000,%01100000,%00000000 ; char 231 (male)
41B7: 90906000	
41BB: F8848484	        defb %11111000,%10000100,%10000100,%10000100,%10000100,%10000100,%10000100,%11111100 ; char 232 (new doc)
41BF: 848484FC	
41C3: 00F0FC84	        defb %00000000,%11110000,%11111100,%10000100,%10000100,%10000100,%10000100,%11111100 ; char 233 (folder)
41C7: 848484FC	
41CB: 3078FC48	        defb %00110000,%01111000,%11111100,%01001000,%01001000,%01001000,%01001000,%01111000 ; char 234 (trash bin)
41CF: 48484878	
41D3: FC848484	        defb %11111100,%10000100,%10000100,%10000100,%11111100,%10110100,%10110100,%11111100 ; char 235 (floppy disk)
41D7: FCB4B4FC	
41DB: 0000D4D8	        defb %00000000,%00000000,%11010100,%11011000,%11010100,%11010100,%00000000,%00000000 ; char 236 (OK)
41DF: D4D40000	
41E3: 3078FC78	        defb %00110000,%01111000,%11111100,%01111000,%01111000,%01001000,%01001000,%01001000 ; char 237 (home)
41E7: 78484848	
41EB: 7884A4A4	        defb %01111000,%10000100,%10100100,%10100100,%10110100,%10000100,%01111000,%00000000 ; char 238 (clock)
41EF: B4847800	
41F3: 000008F4	        defb %00000000,%00000000,%00001000,%11110100,%10101000,%10000000,%00000000,%00000000 ; char 239 (key)
41F7: A8800000	
41FB: 203078B0	        defb %00100000,%00110000,%01111000,%10110000,%10100000,%10001000,%01110000,%00000000 ; char 240 (undo)
41FF: A0887000	
4203: 00FCCCB4	        defb %00000000,%11111100,%11001100,%10110100,%10000100,%10000100,%11111100,%00000000 ; char 241 (letter)
4207: 8484FC00	
420B: 609090F0	        defb %01100000,%10010000,%10010000,%11110000,%11110000,%11110000,%11110000,%00000000 ; char 242 (lock)
420F: F0F0F000	
4213: 081414F0	        defb %00001000,%00010100,%00010100,%11110000,%11110000,%11110000,%11110000,%00000000 ; char 243 (unlock)
4217: F0F0F000	
421B: FCFC84B4	        defb %11111100,%11111100,%10000100,%10110100,%10010100,%10010100,%10000100,%11111100 ; char 244 (calendar)
421F: 949484FC	
4223: 00043858	        defb %00000000,%00000100,%00111000,%01011000,%01101000,%01110000,%10000000,%00000000 ; char 245 (diameter)
4227: 68708000	
422B: 78848484	        defb %01111000,%10000100,%10000100,%10000100,%01101100,%00011000,%00001000,%00000000 ; char 246 (baloon)
422F: 6C180800	
4233: 30282828	        defb %00110000,%00101000,%00101000,%00101000,%00100000,%01100000,%11100000,%01000000 ; char 247 (note)
4237: 2060E040	
423B: 2068E4E4	        defb %00100000,%01101000,%11100100,%11100100,%11100100,%01101000,%00100000,%00000000 ; char 248 (audio on)
423F: E4682000	
4243: 2060E0E0	        defb %00100000,%01100000,%11100000,%11100000,%11100000,%01100000,%00100000,%00000000 ; char 249 (audio off)
4247: E0602000	
424B: 80C0E0F0	        defb %10000000,%11000000,%11100000,%11110000,%11111000,%11111100,%11110000,%10010000 ; char 250 (pointer)
424F: F8FCF090	
4253: 7884B4A4	        defb %01111000,%10000100,%10110100,%10100100,%10110100,%10000100,%01111000,%00000000 ; char 251 ()
4257: B4847800	
425B: 30484040	        defb %00110000,%01001000,%01000000,%01000000,%11100000,%01000000,%01000100,%10111000 ; char 252 ()
425F: E04044B8	
4263: 7884F048	        defb %01111000,%10000100,%11110000,%01001000,%01001000,%00111100,%10000100,%01111000 ; char 253 ()
4267: 483C8478	
426B: 00002000	        defb %00000000,%00000000,%00100000,%00000000,%11111000,%00000000,%00100000,%00000000 ; char 254 ()
426F: F8002000	
4273: FCFCFCFC	        defb %11111100,%11111100,%11111100,%11111100,%11111100,%11111100,%11111100,%11111100 ; char 255 (cursor)
4277: FCFCFCFC	
              	        ; here ends the ASCII table
              	; ------------------------------------------------------------------------------
              	; LM80C - 8x8 CHARSET - R1.7
              	; ------------------------------------------------------------------------------
              	; The following code is intended to be used with LM80C Z80-based computer
              	; designed by Leonardo Miliani. More info at
              	; www DOT leonardomiliani DOT com
              	; ------------------------------------------------------------------------------
              	; Code Revision:
              	; R1.0 - 20190615 - First revision: ASCII chars (from 0 to 255) - actually, they are 6x8 pixels
              	; R1.1 - 20190616 - Converted to 8x8 pixels
              	; R1.2 - 20191013 - Added new graphic chars and reorganized previous ones
              	; R1.3 - 20191015 - More graphic chars
              	; R1.4 - 20191202 - Fixed char 11/12, added new special chars
              	; R1.5 - 20191210 - Changed several graphic chars
              	; R1.6 - 20200125 - Removed double chars, changed with new ones
              	; R1.7 - 20200228 - adopted more usual hexadecimal & binary prefixes
              	; ------------------------------------------------------------------------------
              	;
              	;-------------------------------------------------------------------------------
              	;
              	;               8 x 8    C  H  A  R  S  E  T
              	;
              	;-------------------------------------------------------------------------------
              	;
              	;       8X8 CHARS, DESIGNED FOR GRAPHICS 1 MODE
              	
427B:         	CHRST88 equ $
427B: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 0 (null char)
427F: 00000000	
4283: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 1 F1
4287: 00000000	
428B: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 2 F2
428F: 00000000	
4293: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 3 CTRL-C
4297: 00000000	
429B: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 4 F3
429F: 00000000	
42A3: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 5 F4
42A7: 00000000	
42AB: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 6 F5
42AF: 00000000	
42B3: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 7 (bell)
42B7: 00000000	
42BB: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 8 (backspace)
42BF: 00000000	
42C3: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 9 (H. tab)
42C7: 00000000	
42CB: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 10 (line feed)
42CF: 00000000	
42D3: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 11 
42D7: 00000000	
42DB: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 12 Form feed (clear screen)
42DF: 00000000	
42E3: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 13 (carriage return)
42E7: 00000000	
42EB: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 14 CTRL
42EF: 00000000	
42F3: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 15 CTRL-O
42F7: 00000000	
42FB: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 16 C=/Graphic key
42FF: 00000000	
4303: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 17 CTRL-Q
4307: 00000000	
430B: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 18 CTRL-R
430F: 00000000	
4313: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 19 CTRL-S
4317: 00000000	
431B: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 20 SHIFT
431F: 00000000	
4323: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 21 CTRL-U
4327: 00000000	
432B: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 22 F6
432F: 00000000	
4333: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 23 F7
4337: 00000000	
433B: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 24 HELP
433F: 00000000	
4343: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 25 (home)
4347: 00000000	
434B: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 26
434F: 00000000	
4353: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 27 (escape)
4357: 00000000	
435B: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 28 (cursor left)
435F: 00000000	
4363: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 29 (cursor right)
4367: 00000000	
436B: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 30 (cursor up)
436F: 00000000	
4373: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 31 (cursor down)
4377: 00000000	
437B: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 32 - space
437F: 00000000	
4383: 10101010	        defb %00010000,%00010000,%00010000,%00010000,%00010000,%00000000,%00010000,%00000000 ; char 33 - !
4387: 10001000	
438B: 28282800	        defb %00101000,%00101000,%00101000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 34 - "
438F: 00000000	
4393: 2828FE28	        defb %00101000,%00101000,%11111110,%00101000,%11111110,%00101000,%00101000,%00000000 ; char 35 - #
4397: FE282800	
439B: 103C5038	        defb %00010000,%00111100,%01010000,%00111000,%00010100,%01111000,%00010000,%00000000 ; char 36 - $
439F: 14781000	
43A3: 00626408	        defb %00000000,%01100010,%01100100,%00001000,%00010000,%00100110,%01000110,%00000000 ; char 37 - %
43A7: 10264600	
43AB: 00304830	        defb %00000000,%00110000,%01001000,%00110000,%01001010,%01000100,%00111010,%00000000 ; char 38 - &
43AF: 4A443A00	
43B3: 08102000	        defb %00001000,%00010000,%00100000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 39 - '
43B7: 00000000	
43BB: 08102020	        defb %00001000,%00010000,%00100000,%00100000,%00100000,%00010000,%00001000,%00000000 ; char 40 - (
43BF: 20100800	
43C3: 20100808	        defb %00100000,%00010000,%00001000,%00001000,%00001000,%00010000,%00100000,%00000000 ; char 41 - )
43C7: 08102000	
43CB: 00105438	        defb %00000000,%00010000,%01010100,%00111000,%00111000,%01010100,%00010000,%00000000 ; char 42 - *
43CF: 38541000	
43D3: 0010107C	        defb %00000000,%00010000,%00010000,%01111100,%00010000,%00010000,%00000000,%00000000 ; char 43 - +
43D7: 10100000	
43DB: 00000000	        defb %00000000,%00000000,%00000000,%00000000,%00000000,%00011000,%00001000,%00010000 ; char 44 - ,
43DF: 00180810	
43E3: 0000007C	        defb %00000000,%00000000,%00000000,%01111100,%00000000,%00000000,%00000000,%00000000 ; char 45 - -
43E7: 00000000	
43EB: 00000000	        defb %00000000,%00000000,%00000000,%00000000,%00000000,%00011000,%00011000,%00000000 ; char 46 - .
43EF: 00181800	
43F3: 00020408	        defb %00000000,%00000010,%00000100,%00001000,%00010000,%00100000,%01000000,%00000000 ; char 47 - /
43F7: 10204000	
43FB: 38444C54	        defb %00111000,%01000100,%01001100,%01010100,%01100100,%01000100,%00111000,%00000000 ; char 48 - 0
43FF: 64443800	
4403: 10305010	        defb %00010000,%00110000,%01010000,%00010000,%00010000,%00010000,%01111100,%00000000 ; char 49 - 1
4407: 10107C00	
440B: 38440408	        defb %00111000,%01000100,%00000100,%00001000,%00010000,%00100000,%01111100,%00000000 ; char 50 - 2
440F: 10207C00	
4413: 7C081008	        defb %01111100,%00001000,%00010000,%00001000,%00000100,%01000100,%00111000,%00000000 ; char 51 - 3
4417: 04443800	
441B: 08182848	        defb %00001000,%00011000,%00101000,%01001000,%01111100,%00001000,%00001000,%00000000 ; char 52 - 4
441F: 7C080800	
4423: 7C407804	        defb %01111100,%01000000,%01111000,%00000100,%00000100,%01000100,%00111000,%00000000 ; char 53 - 5
4427: 04443800	
442B: 38444078	        defb %00111000,%01000100,%01000000,%01111000,%01000100,%01000100,%00111000,%00000000 ; char 54 - 6
442F: 44443800	
4433: 7C040810	        defb %01111100,%00000100,%00001000,%00010000,%00100000,%00100000,%00100000,%00000000 ; char 55 - 7
4437: 20202000	
443B: 38444438	        defb %00111000,%01000100,%01000100,%00111000,%01000100,%01000100,%00111000,%00000000 ; char 56 - 8
443F: 44443800	
4443: 3844443C	        defb %00111000,%01000100,%01000100,%00111100,%00000100,%01000100,%00111000,%00000000 ; char 57 - 9
4447: 04443800	
444B: 00181800	        defb %00000000,%00011000,%00011000,%00000000,%00011000,%00011000,%00000000,%00000000 ; char 58 - :
444F: 18180000	
4453: 00181800	        defb %00000000,%00011000,%00011000,%00000000,%00011000,%00001000,%00010000,%00000000 ; char 59 - ;
4457: 18081000	
445B: 04081020	        defb %00000100,%00001000,%00010000,%00100000,%00010000,%00001000,%00000100,%00000000 ; char 60 - <
445F: 10080400	
4463: 00007E00	        defb %00000000,%00000000,%01111110,%00000000,%01111110,%00000000,%00000000,%00000000 ; char 61 - =
4467: 7E000000	
446B: 20100804	        defb %00100000,%00010000,%00001000,%00000100,%00001000,%00010000,%00100000,%00000000 ; char 62 - >
446F: 08102000	
4473: 38440408	        defb %00111000,%01000100,%00000100,%00001000,%00010000,%00000000,%00010000,%00000000 ; char 63 - ?
4477: 10001000	
447B: 7884BCAC	        defb %01111000,%10000100,%10111100,%10101100,%10111000,%10000000,%10000100,%01111000 ; char 64 - @
447F: B8808478	
4483: 38444444	        defb %00111000,%01000100,%01000100,%01000100,%01111100,%01000100,%01000100,%00000000 ; char 65 - A
4487: 7C444400	
448B: 78444478	        defb %01111000,%01000100,%01000100,%01111000,%01000100,%01000100,%01111000,%00000000 ; char 66 - B
448F: 44447800	
4493: 38444040	        defb %00111000,%01000100,%01000000,%01000000,%01000000,%01000100,%00111000,%00000000 ; char 67 - C
4497: 40443800	
449B: 78444444	        defb %01111000,%01000100,%01000100,%01000100,%01000100,%01000100,%01111000,%00000000 ; char 68 - D
449F: 44447800	
44A3: 7C404070	        defb %01111100,%01000000,%01000000,%01110000,%01000000,%01000000,%01111100,%00000000 ; char 69 - E
44A7: 40407C00	
44AB: 7C404070	        defb %01111100,%01000000,%01000000,%01110000,%01000000,%01000000,%01000000,%00000000 ; char 70 - F
44AF: 40404000	
44B3: 38444040	        defb %00111000,%01000100,%01000000,%01000000,%01011100,%01000100,%00111000,%00000000 ; char 71 - G
44B7: 5C443800	
44BB: 4444447C	        defb %01000100,%01000100,%01000100,%01111100,%01000100,%01000100,%01000100,%00000000 ; char 72 - H
44BF: 44444400	
44C3: 38101010	        defb %00111000,%00010000,%00010000,%00010000,%00010000,%00010000,%00111000,%00000000 ; char 73 - I
44C7: 10103800	
44CB: 3C040404	        defb %00111100,%00000100,%00000100,%00000100,%00000100,%01000100,%00111000,%00000000 ; char 74 - J
44CF: 04443800	
44D3: 44444870	        defb %01000100,%01000100,%01001000,%01110000,%01001000,%01000100,%01000100,%00000000 ; char 75 - K
44D7: 48444400	
44DB: 40404040	        defb %01000000,%01000000,%01000000,%01000000,%01000000,%01000000,%01111100,%00000000 ; char 76 - L
44DF: 40407C00	
44E3: 42665A42	        defb %01000010,%01100110,%01011010,%01000010,%01000010,%01000010,%01000010,%00000000 ; char 77 - M
44E7: 42424200	
44EB: 4464544C	        defb %01000100,%01100100,%01010100,%01001100,%01000100,%01000100,%01000100,%00000000 ; char 78 - N
44EF: 44444400	
44F3: 38444444	        defb %00111000,%01000100,%01000100,%01000100,%01000100,%01000100,%00111000,%00000000 ; char 79 - O
44F7: 44443800	
44FB: 78444444	        defb %01111000,%01000100,%01000100,%01000100,%01111000,%01000000,%01000000,%00000000 ; char 80 - P
44FF: 78404000	
4503: 38444444	        defb %00111000,%01000100,%01000100,%01000100,%01010100,%01001000,%00110100,%00000000 ; char 81 - Q
4507: 54483400	
450B: 78444444	        defb %01111000,%01000100,%01000100,%01000100,%01111000,%01001000,%01000100,%00000000 ; char 82 - R
450F: 78484400	
4513: 3C404038	        defb %00111100,%01000000,%01000000,%00111000,%00000100,%00000100,%01111000,%00000000 ; char 83 - S
4517: 04047800	
451B: 7C101010	        defb %01111100,%00010000,%00010000,%00010000,%00010000,%00010000,%00010000,%00000000 ; char 84 - T
451F: 10101000	
4523: 44444444	        defb %01000100,%01000100,%01000100,%01000100,%01000100,%01000100,%00111000,%00000000 ; char 85 - U
4527: 44443800	
452B: 44444444	        defb %01000100,%01000100,%01000100,%01000100,%01000100,%00101000,%00010000,%00000000 ; char 86 - V
452F: 44281000	
4533: 42424242	        defb %01000010,%01000010,%01000010,%01000010,%01011010,%01011010,%00100100,%00000000 ; char 87 - W
4537: 5A5A2400	
453B: 44442810	        defb %01000100,%01000100,%00101000,%00010000,%00101000,%01000100,%01000100,%00000000 ; char 88 - X
453F: 28444400	
4543: 44444428	        defb %01000100,%01000100,%01000100,%00101000,%00010000,%00010000,%00010000,%00000000 ; char 89 - Y
4547: 10101000	
454B: 7C040810	        defb %01111100,%00000100,%00001000,%00010000,%00100000,%01000000,%01111100,%00000000 ; char 90 - Z
454F: 20407C00	
4553: 38202020	        defb %00111000,%00100000,%00100000,%00100000,%00100000,%00100000,%00111000,%00000000 ; char 91 - [
4557: 20203800	
455B: 00402010	        defb %00000000,%01000000,%00100000,%00010000,%00001000,%00000100,%00000010,%00000000 ; char 92 - \
455F: 08040200	
4563: 38080808	        defb %00111000,%00001000,%00001000,%00001000,%00001000,%00001000,%00111000,%00000000 ; char 93 - ]
4567: 08083800	
456B: 10284400	        defb %00010000,%00101000,%01000100,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 94 - ^
456F: 00000000	
4573: 00000000	        defb %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%01111110,%00000000 ; char 95 _ (underscore)
4577: 00007E00	
457B: 20100800	        defb %00100000,%00010000,%00001000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 96 - `
457F: 00000000	
4583: 00003804	        defb %00000000,%00000000,%00111000,%00000100,%00111100,%01000100,%00111100,%00000000 ; char 97 - a
4587: 3C443C00	
458B: 40404078	        defb %01000000,%01000000,%01000000,%01111000,%01000100,%01000100,%01111000,%00000000 ; char 98 - b
458F: 44447800	
4593: 00003840	        defb %00000000,%00000000,%00111000,%01000000,%01000000,%01000100,%00111000,%00000000 ; char 99 - c
4597: 40443800	
459B: 0404043C	        defb %00000100,%00000100,%00000100,%00111100,%01000100,%01000100,%00111100,%00000000 ; char 100 - d
459F: 44443C00	
45A3: 00003844	        defb %00000000,%00000000,%00111000,%01000100,%01111100,%01000000,%00111000,%00000000 ; char 101 - e
45A7: 7C403800	
45AB: 18242070	        defb %00011000,%00100100,%00100000,%01110000,%00100000,%00100000,%00100000,%00000000 ; char 102 - f
45AF: 20202000	
45B3: 00003C44	        defb %00000000,%00000000,%00111100,%01000100,%01000100,%00111100,%00000100,%00111000 ; char 103 - g
45B7: 443C0438	
45BB: 40405864	        defb %01000000,%01000000,%01011000,%01100100,%01000100,%01000100,%01000100,%00000000 ; char 104 - h
45BF: 44444400	
45C3: 00100010	        defb %00000000,%00010000,%00000000,%00010000,%00010000,%00010000,%00010000,%00000000 ; char 105 - i
45C7: 10101000	
45CB: 08001808	        defb %00001000,%00000000,%00011000,%00001000,%00001000,%00001000,%01001000,%00110000 ; char 106 - j
45CF: 08084830	
45D3: 40404850	        defb %01000000,%01000000,%01001000,%01010000,%01100000,%01010000,%01001000,%00000000 ; char 107 - k
45D7: 60504800	
45DB: 30101010	        defb %00110000,%00010000,%00010000,%00010000,%00010000,%00010000,%00111000,%00000000 ; char 108 - l
45DF: 10103800	
45E3: 0000546A	        defb %00000000,%00000000,%01010100,%01101010,%01001010,%01000010,%01000010,%00000000 ; char 109 - m
45E7: 4A424200	
45EB: 00005864	        defb %00000000,%00000000,%01011000,%01100100,%01000100,%01000100,%01000100,%00000000 ; char 110 - n
45EF: 44444400	
45F3: 00003844	        defb %00000000,%00000000,%00111000,%01000100,%01000100,%01000100,%00111000,%00000000 ; char 111: o
45F7: 44443800	
45FB: 00007844	        defb %00000000,%00000000,%01111000,%01000100,%01000100,%01111000,%01000000,%01000000 ; char 112: p
45FF: 44784040	
4603: 00003C44	        defb %00000000,%00000000,%00111100,%01000100,%01000100,%00111100,%00000100,%00000100 ; char 113: q
4607: 443C0404	
460B: 00005864	        defb %00000000,%00000000,%01011000,%01100100,%01000000,%01000000,%01000000,%00000000 ; char 114: r
460F: 40404000	
4613: 00003840	        defb %00000000,%00000000,%00111000,%01000000,%00111000,%00000100,%01111000,%00000000 ; char 115: s
4617: 38047800	
461B: 20207020	        defb %00100000,%00100000,%01110000,%00100000,%00100000,%00100100,%00011000,%00000000 ; char 116: t
461F: 20241800	
4623: 00004444	        defb %00000000,%00000000,%01000100,%01000100,%01000100,%01001100,%00110100,%00000000 ; char 117: u
4627: 444C3400	
462B: 00004444	        defb %00000000,%00000000,%01000100,%01000100,%01000100,%00101000,%00010000,%00000000 ; char 118: v
462F: 44281000	
4633: 00004444	        defb %00000000,%00000000,%01000100,%01000100,%01010100,%01010100,%00101000,%00000000 ; char 119: w
4637: 54542800	
463B: 00004428	        defb %00000000,%00000000,%01000100,%00101000,%00010000,%00101000,%01000100,%00000000 ; char 120: x
463F: 10284400	
4643: 00004444	        defb %00000000,%00000000,%01000100,%01000100,%01001100,%00110100,%00000100,%00111000 ; char 121: y
4647: 4C340438	
464B: 00007C08	        defb %00000000,%00000000,%01111100,%00001000,%00010000,%00100000,%01111100,%00000000 ; char 122: z
464F: 10207C00	
4653: 18202040	        defb %00011000,%00100000,%00100000,%01000000,%00100000,%00100000,%00011000,%00000000 ; char 123: {
4657: 20201800	
465B: 10101010	        defb %00010000,%00010000,%00010000,%00010000,%00010000,%00010000,%00010000,%00000000 ; char 124: |
465F: 10101000	
4663: 30080804	        defb %00110000,%00001000,%00001000,%00000100,%00001000,%00001000,%00110000,%00000000 ; char 125: }
4667: 08083000	
466B: 20540800	        defb %00100000,%01010100,%00001000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 126: ~
466F: 00000000	
4673: 00000000	        defb %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 127 (delete) - end the standard ASCII (0-127)
4677: 00000000	
467B: 3C42A581	        defb %00111100,%01000010,%10100101,%10000001,%10100101,%10011001,%01000010,%00111100 ; char 128 (open face)
467F: A599423C	
4683: 3C7EDBFF	        defb %00111100,%01111110,%11011011,%11111111,%11011011,%11100111,%01111110,%00111100 ; char 129 (full face)
4687: DBE77E3C	
468B: 6CFEFEFE	        defb %01101100,%11111110,%11111110,%11111110,%01111100,%00111000,%00010000,%00000000 ; char 130 (hearts)
468F: 7C381000	
4693: 10387CFE	        defb %00010000,%00111000,%01111100,%11111110,%01111100,%00111000,%00010000,%00000000 ; char 131 (diamonds)
4697: 7C381000	
469B: 103854FE	        defb %00010000,%00111000,%01010100,%11111110,%01010100,%00010000,%01111100,%00000000 ; char 132 (clus)
469F: 54107C00	
46A3: 10387CFE	        defb %00010000,%00111000,%01111100,%11111110,%11010110,%00010000,%01111100,%00000000 ; char 133 (spades)
46A7: D6107C00	
46AB: 181818FF	        defb %00011000,%00011000,%00011000,%11111111,%11111111,%00011000,%00011000,%00011000 ; char 134
46AF: FF181818	
46B3: 0000001F	        defb %00000000,%00000000,%00000000,%00011111,%00011111,%00011000,%00011000,%00011000 ; char 135
46B7: 1F181818	
46BB: 000000F8	        defb %00000000,%00000000,%00000000,%11111000,%11111000,%00011000,%00011000,%00011000 ; char 136
46BF: F8181818	
46C3: 181818F8	        defb %00011000,%00011000,%00011000,%11111000,%11111000,%00000000,%00000000,%00000000 ; char 137
46C7: F8000000	
46CB: 1818181F	        defb %00011000,%00011000,%00011000,%00011111,%00011111,%00000000,%00000000,%00000000 ; char 138
46CF: 1F000000	
46D3: 181818FF	        defb %00011000,%00011000,%00011000,%11111111,%11111111,%00000000,%00000000,%00000000 ; char 139
46D7: FF000000	
46DB: 1818181F	        defb %00011000,%00011000,%00011000,%00011111,%00011111,%00011000,%00011000,%00011000 ; char 140
46DF: 1F181818	
46E3: 000000FF	        defb %00000000,%00000000,%00000000,%11111111,%11111111,%00011000,%00011000,%00011000 ; char 141
46E7: FF181818	
46EB: 181818F8	        defb %00011000,%00011000,%00011000,%11111000,%11111000,%00011000,%00011000,%00011000 ; char 142
46EF: F8181818	
46F3: 000000FF	        defb %00000000,%00000000,%00000000,%11111111,%11111111,%00000000,%00000000,%00000000 ; char 143
46F7: FF000000	
46FB: 18181818	        defb %00011000,%00011000,%00011000,%00011000,%00011000,%00011000,%00011000,%00011000 ; char 144
46FF: 18181818	
4703: 03070E1C	        defb %00000011,%00000111,%00001110,%00011100,%00111000,%01110000,%11100000,%11000000 ; char 145
4707: 3870E0C0	
470B: C0E07038	        defb %11000000,%11100000,%01110000,%00111000,%00011100,%00001110,%00000111,%00000011 ; char 146
470F: 1C0E0703	
4713: C3E77E3C	        defb %11000011,%11100111,%01111110,%00111100,%00111100,%01111110,%11100111,%11000011 ; char 147
4717: 3C7EE7C3	
471B: 101010FF	        defb %00010000,%00010000,%00010000,%11111111,%00010000,%00010000,%00010000,%00010000 ; char 148
471F: 10101010	
4723: 0000001F	        defb %00000000,%00000000,%00000000,%00011111,%00010000,%00010000,%00010000,%00010000 ; char 149
4727: 10101010	
472B: 000000F0	        defb %00000000,%00000000,%00000000,%11110000,%00010000,%00010000,%00010000,%00010000 ; char 150
472F: 10101010	
4733: 101010F0	        defb %00010000,%00010000,%00010000,%11110000,%00000000,%00000000,%00000000,%00000000 ; char 151
4737: 00000000	
473B: 1010101F	        defb %00010000,%00010000,%00010000,%00011111,%00000000,%00000000,%00000000,%00000000 ; char 152
473F: 00000000	
4743: 101010FF	        defb %00010000,%00010000,%00010000,%11111111,%00000000,%00000000,%00000000,%00000000 ; char 153
4747: 00000000	
474B: 1010101F	        defb %00010000,%00010000,%00010000,%00011111,%00010000,%00010000,%00010000,%00010000 ; char 154
474F: 10101010	
4753: 000000FF	        defb %00000000,%00000000,%00000000,%11111111,%00010000,%00010000,%00010000,%00010000 ; char 155
4757: 10101010	
475B: 101010F0	        defb %00010000,%00010000,%00010000,%11110000,%00010000,%00010000,%00010000,%00010000 ; char 156
475F: 10101010	
4763: 000000FF	        defb %00000000,%00000000,%00000000,%11111111,%00000000,%00000000,%00000000,%00000000 ; char 157
4767: 00000000	
476B: 10101010	        defb %00010000,%00010000,%00010000,%00010000,%00010000,%00010000,%00010000,%00010000 ; char 158
476F: 10101010	
4773: 01020408	        defb %00000001,%00000010,%00000100,%00001000,%00010000,%00100000,%01000000,%10000000 ; char 159
4777: 10204080	
477B: 80402010	        defb %10000000,%01000000,%00100000,%00010000,%00001000,%00000100,%00000010,%00000001 ; char 160
477F: 08040201	
4783: 81422418	        defb %10000001,%01000010,%00100100,%00011000,%00011000,%00100100,%01000010,%10000001 ; char 161
4787: 18244281	
478B: 00000000	        defb %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%11111111,%11111111 ; char 162
478F: 0000FFFF	
4793: 00000000	        defb %00000000,%00000000,%00000000,%00000000,%11111111,%11111111,%11111111,%11111111 ; char 163
4797: FFFFFFFF	
479B: 0000FFFF	        defb %00000000,%00000000,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111 ; char 164
479F: FFFFFFFF	
47A3: FFFF0000	        defb %11111111,%11111111,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 165
47A7: 00000000	
47AB: FFFFFFFF	        defb %11111111,%11111111,%11111111,%11111111,%00000000,%00000000,%00000000,%00000000 ; char 166
47AF: 00000000	
47B3: FFFFFFFF	        defb %11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%00000000,%00000000 ; char 167
47B7: FFFF0000	
47BB: C0C0C0C0	        defb %11000000,%11000000,%11000000,%11000000,%11000000,%11000000,%11000000,%11000000 ; char 168
47BF: C0C0C0C0	
47C3: F0F0F0F0	        defb %11110000,%11110000,%11110000,%11110000,%11110000,%11110000,%11110000,%11110000 ; char 169
47C7: F0F0F0F0	
47CB: FCFCFCFC	        defb %11111100,%11111100,%11111100,%11111100,%11111100,%11111100,%11111100,%11111100 ; char 170
47CF: FCFCFCFC	
47D3: 03030303	        defb %00000011,%00000011,%00000011,%00000011,%00000011,%00000011,%00000011,%00000011 ; char 171
47D7: 03030303	
47DB: 0F0F0F0F	        defb %00001111,%00001111,%00001111,%00001111,%00001111,%00001111,%00001111,%00001111 ; char 172
47DF: 0F0F0F0F	
47E3: 3F3F3F3F	        defb %00111111,%00111111,%00111111,%00111111,%00111111,%00111111,%00111111,%00111111 ; char 173
47E7: 3F3F3F3F	
47EB: FF818181	        defb %11111111,%10000001,%10000001,%10000001,%10000001,%10000001,%10000001,%11111111 ; char 174
47EF: 818181FF	
47F3: 00000000	        defb %00000000,%00000000,%00000000,%00000000,%11110000,%11110000,%11110000,%11110000 ; char 175
47F7: F0F0F0F0	
47FB: 00000000	        defb %00000000,%00000000,%00000000,%00000000,%00001111,%00001111,%00001111,%00001111 ; char 176
47FF: 0F0F0F0F	
4803: 0F0F0F0F	        defb %00001111,%00001111,%00001111,%00001111,%00000000,%00000000,%00000000,%00000000 ; char 177
4807: 00000000	
480B: F0F0F0F0	        defb %11110000,%11110000,%11110000,%11110000,%00000000,%00000000,%00000000,%00000000 ; char 178
480F: 00000000	
4813: F0F0F0F0	        defb %11110000,%11110000,%11110000,%11110000,%00001111,%00001111,%00001111,%00001111 ; char 179
4817: 0F0F0F0F	
481B: 0F0F0F0F	        defb %00001111,%00001111,%00001111,%00001111,%11110000,%11110000,%11110000,%11110000 ; char 180
481F: F0F0F0F0	
4823: 3C3C3C3C	        defb %00111100,%00111100,%00111100,%00111100,%00111100,%00111100,%00111100,%00111100 ; char 181
4827: 3C3C3C3C	
482B: C3C3C3C3	        defb %11000011,%11000011,%11000011,%11000011,%11000011,%11000011,%11000011,%11000011 ; char 182
482F: C3C3C3C3	
4833: FFFF0000	        defb %11111111,%11111111,%00000000,%00000000,%00000000,%00000000,%11111111,%11111111 ; char 183
4837: 0000FFFF	
483B: 0000FFFF	        defb %00000000,%00000000,%11111111,%11111111,%11111111,%11111111,%00000000,%00000000 ; char 184
483F: FFFF0000	
4843: 3333CCCC	        defb %00110011,%00110011,%11001100,%11001100,%00110011,%00110011,%11001100,%11001100 ; char 185
4847: 3333CCCC	
484B: 55AA55AA	        defb %01010101,%10101010,%01010101,%10101010,%01010101,%10101010,%01010101,%10101010 ; char 186
484F: 55AA55AA	
4853: 663399CC	        defb %01100110,%00110011,%10011001,%11001100,%01100110,%00110011,%10011001,%11001100 ; char 187
4857: 663399CC	
485B: CC993366	        defb %11001100,%10011001,%00110011,%01100110,%11001100,%10011001,%00110011,%01100110 ; char 188
485F: CC993366	
4863: 3399CC66	        defb %00110011,%10011001,%11001100,%01100110,%00110011,%10011001,%11001100,%01100110 ; char 189
4867: 3399CC66	
486B: 66CC9933	        defb %01100110,%11001100,%10011001,%00110011,%01100110,%11001100,%10011001,%00110011 ; char 190
486F: 66CC9933	
4873: 10107C10	        defb %00010000,%00010000,%01111100,%00010000,%00010000,%00000000,%01111100,%00000000 ; char 191 ()
4877: 10007C00	
487B: 60180618	        defb %01100000,%00011000,%00000110,%00011000,%01100000,%00000000,%01111110,%00000000 ; char 192 ()
487F: 60007E00	
4883: 06186018	        defb %00000110,%00011000,%01100000,%00011000,%00000110,%00000000,%01111110,%00000000 ; char 193 ()
4887: 06007E00	
488B: 3E202020	        defb %00111110,%00100000,%00100000,%00100000,%10100000,%01100000,%00100000,%00000000 ; char 194 (square root)
488F: A0602000	
4893: 30484830	        defb %00110000,%01001000,%01001000,%00110000,%00000000,%00000000,%00000000,%00000000 ; char 195 ()
4897: 00000000	
489B: 60103040	        defb %01100000,%00010000,%00110000,%01000000,%01110000,%00000000,%00000000,%00000000 ; char 196 ()
489F: 70000000	
48A3: 00002A54	        defb %00000000,%00000000,%00101010,%01010100,%00000000,%01111110,%00000000,%00000000 ; char 197 
48A7: 007E0000	
48AB: 0054A800	        defb %00000000,%01010100,%10101000,%00000000,%01010100,%10101000,%00000000,%00000000 ; char 198 ()
48AF: 54A80000	
48B3: 80C0E0F0	        defb %10000000,%11000000,%11100000,%11110000,%11100000,%11000000,%10000000,%00000000 ; char 199
48B7: E0C08000	
48BB: FE7C3810	        defb %11111110,%01111100,%00111000,%00010000,%00000000,%00000000,%00000000,%00000000 ; char 200
48BF: 00000000	
48C3: 0103070F	        defb %00000001,%00000011,%00000111,%00001111,%00000111,%00000011,%00000001,%00000000 ; char 201
48C7: 07030100	
48CB: 00000000	        defb %00000000,%00000000,%00000000,%00000000,%00010000,%00111000,%01111100,%11111110 ; char 202
48CF: 10387CFE	
48D3: 10387C10	        defb %00010000,%00111000,%01111100,%00010000,%00010000,%00010000,%00010000,%00000000 ; char 203 (up arrow)
48D7: 10101000	
48DB: 1E0E0E12	        defb %00011110,%00001110,%00001110,%00010010,%00100000,%01000000,%00000000,%00000000 ; char 204 (up right arrow)
48DF: 20400000	
48E3: 00080CFE	        defb %00000000,%00001000,%00001100,%11111110,%00001100,%00001000,%00000000,%00000000 ; char 205 (right arrow)
48E7: 0C080000	
48EB: 00402012	        defb %00000000,%01000000,%00100000,%00010010,%00001110,%00001110,%00011110,%00000000 ; char 206 (down right arrow)
48EF: 0E0E1E00	
48F3: 10101010	        defb %00010000,%00010000,%00010000,%00010000,%01111100,%00111000,%00010000,%00000000 ; char 207 (down arrow)
48F7: 7C381000	
48FB: 00040890	        defb %00000000,%00000100,%00001000,%10010000,%11100000,%11100000,%11110000,%00000000 ; char 208 (down left arrow)
48FF: E0E0F000	
4903: 002060FE	        defb %00000000,%00100000,%01100000,%11111110,%01100000,%00100000,%00000000,%00000000 ; char 209 (left arrow)
4907: 60200000	
490B: F0E0E090	        defb %11110000,%11100000,%11100000,%10010000,%00001000,%00000100,%00000000,%00000000 ; char 210 (up left arrow)
490F: 08040000	
4913: 3844F040	        defb %00111000,%01000100,%11110000,%01000000,%11110000,%01000100,%00111000,%00000000 ; char 211 (euro)
4917: F0443800	
491B: 00027CA8	        defb %00000000,%00000010,%01111100,%10101000,%00101000,%00101000,%00101000,%00000000 ; char 212 (greek pi)
491F: 28282800	
4923: 00000007	        defb %00000000,%00000000,%00000000,%00000111,%00001000,%00010000,%00010000,%00010000 ; char 213
4927: 08101010	
492B: 000000E0	        defb %00000000,%00000000,%00000000,%11100000,%00010000,%00001000,%00001000,%00001000 ; char 214
492F: 10080808	
4933: 08080810	        defb %00001000,%00001000,%00001000,%00010000,%11100000,%00000000,%00000000,%00000000 ; char 215
4937: E0000000	
493B: 10101008	        defb %00010000,%00010000,%00010000,%00001000,%00000111,%00000000,%00000000,%00000000 ; char 216
493F: 07000000	
4943: 00000007	        defb %00000000,%00000000,%00000000,%00000111,%00001111,%00011100,%00011000,%00011000 ; char 217
4947: 0F1C1818	
494B: 000000E0	        defb %00000000,%00000000,%00000000,%11100000,%11110000,%00111000,%00011000,%00011000 ; char 218
494F: F0381818	
4953: 181838F0	        defb %00011000,%00011000,%00111000,%11110000,%11100000,%00000000,%00000000,%00000000 ; char 219
4957: E0000000	
495B: 18181C0F	        defb %00011000,%00011000,%00011100,%00001111,%00000111,%00000000,%00000000,%00000000 ; char 220
495F: 07000000	
4963: 003C4242	        defb %00000000,%00111100,%01000010,%01000010,%01000010,%01000010,%00111100,%00000000 ; char 221
4967: 42423C00	
496B: 003C7E7E	        defb %00000000,%00111100,%01111110,%01111110,%01111110,%01111110,%00111100,%00000000 ; char 222
496F: 7E7E3C00	
4973: 00183C7E	        defb %00000000,%00011000,%00111100,%01111110,%01111110,%00111100,%00011000,%00000000 ; char 223
4977: 7E3C1800	
497B: FFFEFCF8	        defb %11111111,%11111110,%11111100,%11111000,%11110000,%11100000,%11000000,%10000000 ; char 224
497F: F0E0C080	
4983: FF7F3F1F	        defb %11111111,%01111111,%00111111,%00011111,%00001111,%00000111,%00000011,%00000001 ; char 225
4987: 0F070301	
498B: 0103070F	        defb %00000001,%00000011,%00000111,%00001111,%00011111,%00111111,%01111111,%11111111 ; char 226
498F: 1F3F7FFF	
4993: 80C0E0F0	        defb %10000000,%11000000,%11100000,%11110000,%11111000,%11111100,%11111110,%11111111 ; char 227
4997: F8FCFEFF	
499B: 0002066C	        defb %00000000,%00000010,%00000110,%01101100,%01111000,%01110000,%01100000,%00000000 ; char 228 (checkmark)
499F: 78706000	
49A3: 00663C18	        defb %00000000,%01100110,%00111100,%00011000,%00111100,%01100110,%00000000,%00000000 ; char 229 (x)
49A7: 3C660000	
49AB: 38444444	        defb %00111000,%01000100,%01000100,%01000100,%00111000,%00010000,%00111000,%00010000 ; char 230 (female)
49AF: 38103810	
49B3: 07033D44	        defb %00000111,%00000011,%00111101,%01000100,%01000100,%01000100,%00111000,%00000000 ; char 231 (male)
49B7: 44443800	
49BB: 78444242	        defb %01111000,%01000100,%01000010,%01000010,%01000010,%01000010,%01000010,%01111110 ; char 232 (new doc)
49BF: 4242427E	
49C3: 00F8FF81	        defb %00000000,%11111000,%11111111,%10000001,%10000001,%10000001,%10000001,%11111111 ; char 233 (folder)
49C7: 818181FF	
49CB: 107CFE54	        defb %00010000,%01111100,%11111110,%01010100,%01010100,%01010100,%01010100,%01111100 ; char 234 (trash bin)
49CF: 5454547C	
49D3: FF818181	        defb %11111111,%10000001,%10000001,%10000001,%10111101,%10101101,%10101101,%11111111 ; char 235 (floppy disk)
49D7: BDADADFF	
49DB: 00EAAAAC	        defb %00000000,%11101010,%10101010,%10101100,%10101100,%10101010,%11101010,%00000000 ; char 236 (OK)
49DF: ACAAEA00	
49E3: 187EFF7E	        defb %00011000,%01111110,%11111111,%01111110,%01111110,%01100110,%01100110,%01100110 ; char 237 (home)
49E7: 7E666666	
49EB: 3C429191	        defb %00111100,%01000010,%10010001,%10010001,%10011101,%10000001,%01000010,%00111100 ; char 238 (clock)
49EF: 9D81423C	
49F3: 000205FD	        defb %00000000,%00000010,%00000101,%11111101,%10100101,%10100010,%00000000,%00000000 ; char 239 (key)
49F7: A5A20000	
49FB: 080C3E4C	        defb %00001000,%00001100,%00111110,%01001100,%01001000,%01000010,%01000010,%00111100 ; char 240 (undo)
49FF: 4842423C	
4A03: 00FFC3A5	        defb %00000000,%11111111,%11000011,%10100101,%10011001,%10000001,%11111111,%00000000 ; char 241 (letter)
4A07: 9981FF00	
4A0B: 3844447C	        defb %00111000,%01000100,%01000100,%01111100,%01111100,%01111100,%01111100,%00000000 ; char 242 (lock)
4A0F: 7C7C7C00	
4A13: 060909F8	        defb %00000110,%00001001,%00001001,%11111000,%11111000,%11111000,%11111000,%00000000 ; char 243 (unlock)
4A17: F8F8F800	
4A1B: FFFF81AD	        defb %11111111,%11111111,%10000001,%10101101,%10100101,%10100101,%10000001,%11111111 ; char 244 (calendar)
4A1F: A5A581FF	
4A23: 011A244A	        defb %00000001,%00011010,%00100100,%01001010,%01010010,%00100100,%01011000,%10000000 ; char 245 (diameter)
4A27: 52245880	
4A2B: 7E818181	        defb %01111110,%10000001,%10000001,%10000001,%10000001,%01110110,%00001100,%00000100 ; char 246 (baloon)
4A2F: 81760C04	
4A33: 0C0A0A0A	        defb %00001100,%00001010,%00001010,%00001010,%00001000,%00011000,%00111000,%00010000 ; char 247 (note)
4A37: 08183810	
4A3B: 1231F5F5	        defb %00010010,%00110001,%11110101,%11110101,%11110101,%11110101,%00110001,%00010010 ; char 248 (audio on)
4A3F: F5F53112	
4A43: 1030F0F0	        defb %00010000,%00110000,%11110000,%11110000,%11110000,%11110000,%00110000,%00010000 ; char 249 (audio off)
4A47: F0F03010	
4A4B: 40607078	        defb %01000000,%01100000,%01110000,%01111000,%01111100,%01111110,%01111000,%01001000 ; char 250 (pointer)
4A4F: 7C7E7848	
4A53: 3C4299A1	        defb %00111100,%01000010,%10011001,%10100001,%10100001,%10011001,%01000010,%00111100 ; char 251 ()
4A57: A199423C	
4A5B: 30484040	        defb %00110000,%01001000,%01000000,%01000000,%11110000,%01000000,%01000010,%10111100 ; char 252 ()
4A5F: F04042BC	
4A63: 3C427824	        defb %00111100,%01000010,%01111000,%00100100,%00100100,%00011110,%01000010,%00111100 ; char 253 ()
4A67: 241E423C	
4A6B: 00001000	        defb %00000000,%00000000,%00010000,%00000000,%01111100,%00000000,%00010000,%00000000 ; char 254 ()
4A6F: 7C001000	
4A73: FFFFFFFF	        defb %11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111 ; char 255 (cursor)
4A77: FFFFFFFF	
              	
              	; ------------------------------------------------------------------------------
              	; LM80C - LOGO CHARSET - R1.1
              	; ------------------------------------------------------------------------------
              	; The following code is intended to be used with LM80C Z80-based computer
              	; designed by Leonardo Miliani. More info at
              	; www DOT leonardomiliani DOT com
              	; ------------------------------------------------------------------------------
              	; Code Revision:
              	; R1.0 - 20200124 - First revision: logo chars
              	; R1.1 - 20200229 - Adopted usual hexadecimal & binary prefixes
              	; ------------------------------------------------------------------------------
              	
4A7B:         	LOGOFONT:   equ $
4A7B: 00000000	            defb %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000 ; 0
4A7F: 00000000	
4A83: FFFFFFFF	            defb %11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111 ; 1
4A87: FFFFFFFF	
4A8B: FFFFFFFF	            defb %11111111,%11111111,%11111111,%11111111,%00000000,%00000000,%00000000,%00000000 ; 2
4A8F: 00000000	
4A93: 0F0F0F0F	            defb %00001111,%00001111,%00001111,%00001111,%00001111,%00001111,%00001111,%00001111 ; 3
4A97: 0F0F0F0F	
4A9B: 00000000	            defb %00000000,%00000000,%00000000,%00000000,%11111111,%11111111,%11111111,%11111111 ; 4
4A9F: FFFFFFFF	
4AA3: F0F0F0F0	            defb %11110000,%11110000,%11110000,%11110000,%11110000,%11110000,%11110000,%11110000 ; 5
4AA7: F0F0F0F0	
4AAB: 00000000	            defb %00000000,%00000000,%00000000,%00000000,%00001111,%00001111,%00001111,%00001111 ; 6
4AAF: 0F0F0F0F	
4AB3: 00000000	            defb %00000000,%00000000,%00000000,%00000000,%11110000,%11110000,%11110000,%11110000 ; 7
4AB7: F0F0F0F0	
4ABB: F0F0F0F0	            defb %11110000,%11110000,%11110000,%11110000,%00000000,%00000000,%00000000,%00000000 ; 8
4ABF: 00000000	
4AC3: 0F0F0F0F	            defb %00001111,%00001111,%00001111,%00001111,%00000000,%00000000,%00000000,%00000000 ; 9
4AC7: 00000000	
4ACB: 000000FC	            defb %00000000,%00000000,%00000000,%11111100,%11111111,%00000111,%00000011,%00000000 ; 10
4ACF: FF070300	
4AD3: 0000003F	            defb %00000000,%00000000,%00000000,%00111111,%11111111,%11100000,%11000000,%00000000 ; 11
4AD7: FFE0C000	
4ADB: 18181F19	            defb %00011000,%00011000,%00011111,%00011001,%00011001,%00011111,%00011000,%00011000 ; 12
4ADF: 191F1818	
4AE3: 1818F898	            defb %00011000,%00011000,%11111000,%10011000,%10011000,%11111000,%00011000,%00011000 ; 13
4AE7: 98F81818	
4AEB: 18181C1F	            defb %00011000,%00011000,%00011100,%00011111,%00001111,%00000000,%00000000,%00000000 ; 14
4AEF: 0F000000	
4AF3: 0000000F	            defb %00000000,%00000000,%00000000,%00001111,%00011111,%00011100,%00011000,%00011000 ; 15
4AF7: 1F1C1818	
4AFB: 000000F0	            defb %00000000,%00000000,%00000000,%11110000,%11111000,%00111000,%00011000,%00011000 ; 16
4AFF: F8381818	
4B03: 181838F8	            defb %00011000,%00011000,%00111000,%11111000,%11110000,%00000000,%00000000,%00000000 ; 17
4B07: F0000000	
4B0B: 000000FF	            defb %00000000,%00000000,%00000000,%11111111,%11111111,%00000000,%00000000,%00000000 ; 18
4B0F: FF000000	
4B13: 0F0F0F0F	            defb %00001111,%00001111,%00001111,%00001111,%11111111,%11111111,%11111111,%11111111 ; 19
4B17: FFFFFFFF	
4B1B: F0F0F0F0	            defb %11110000,%11110000,%11110000,%11110000,%11111111,%11111111,%11111111,%11111111 ; 20
4B1F: FFFFFFFF	
4B23: FFFFFFFF	            defb %11111111,%11111111,%11111111,%11111111,%11110000,%11110000,%11110000,%11110000 ; 21
4B27: F0F0F0F0	
4B2B: FFFFFFFF	            defb %11111111,%11111111,%11111111,%11111111,%00001111,%00001111,%00001111,%00001111 ; 22
4B2F: 0F0F0F0F	
4B33: 00307878	            defb %00000000,%00110000,%01111000,%01111000,%00110000,%00000000,%00000000,%00000000 ; 23
4B37: 30000000	
              	            ; ------------------------------------------------------------------------------
              	; LM80C - FIRMWARE - R3.9
              	; ------------------------------------------------------------------------------
              	; The following code is intended to be used with LM80C Z80-based computer
              	; designed by Leonardo Miliani. More info at
              	; www DOT leonardomiliani DOT com
              	; ------------------------------------------------------------------------------
              	; Coding/Editing/Compiling:
              	; Original init code for MC68B05 by Grant Searle
              	; Original SIO/CTC/PIO init code by Mario Blunk
              	; NASCOM BASIC originally modified by Gran Searle
              	; Code modified and adapted for LM80C by Leonardo Miliani
              	;
              	; Edited with Atom Editor
              	;
              	; Compiled with ZASM assembler 4.2.4
              	; https://k1.spdns.de/Develop/Projects/zasm-4.0/Distributions/
              	; ------------------------------------------------------------------------------
              	; Copyright notes:
              	; Parts of the code (c) Grant Searle - free for non commercial use
              	; Please include this advice and the note to the attribution of the original
              	; version to Grant Searle if you intend to redistribuite it
              	; http://searle.hostei.com/grant/index.html
              	; eMail: home.micros01@btinternet.com
              	;
              	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
              	; Parts of the code (c) Mario Blunk
              	; http://www.trainz.de
              	;
              	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
              	; NASCOM ROM BASIC Ver 4.7, (C) 1978 Microsoft
              	; Scanned from source published in 80-BUS NEWS from Vol 2, Issue 3
              	; (May-June 1983) to Vol 3, Issue 3 (May-June 1984)
              	; Adapted for the freeware Zilog Macro Assembler 2.10 to produce
              	; the original ROM code (checksum A934H). PA
              	;
              	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
              	; The following code is intended to be used with LM80C Z80-based computer
              	; designed by Leonardo Miliani. Code and computer schematics are released under
              	; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
              	; kind of warranty: you can use them at your own risk.
              	; You are free to use them for any non-commercial use: you are only asked to
              	; maintain the copyright notices, include this advice and the note to the 
              	; attribution of the original version to Leonardo Miliani, if you intend to
              	; redistribuite them.
              	; https://www.leonardomiliani.com
              	; 
              	; Please support me by visiting the following links:
              	; Main project page: https://www.leonardomiliani.com
              	; Schematics and code: https://github.com/leomil72/LM80C
              	; Videos about the computer: https://www.youtube.com/user/leomil72/videos
              	; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
              	; ------------------------------------------------------------------------------
              	
              	
              	; ------------------------------------------------------------------------------
              	; this line instructs the assembler to prepare a file for a ROM target
              	; meaning that blank cells will be filled up with $FF
              	#target rom
              	
              	; this line instructs the assembler to compile taking account that code
              	; starts at $0000 (the address reached by Z80 upon reset)
0000:         	#code BOOT, $0000
              	
              	
              	; END OF ASSEMBLY SOURCE
              	#end
              	
              	;-------------------------------------------------------------------------------


; +++ segments +++

#CODE          = $0000 =     0,  size = $4B3B = 19259
#CODE BOOT     = $0000 =     0,  size = $0000 =     0

; +++ global symbols +++

ABPASS           = $227D =  8829          rom.asm:4631
ABS              = $2BA7 = 11175          rom.asm:6081
ACCSUM           = $1AB7 =  6839          rom.asm:3502 (unused)
ACPASS           = $227C =  8828          rom.asm:4630
ADD30            = $3956 = 14678          rom.asm:7997
ADD301           = $3966 = 14694          rom.asm:8008
ADDEXP           = $2B40 = 11072          rom.asm:6016
ADDIG            = $2CE6 = 11494          rom.asm:6306
ADDNEWLINE       = $0962 =  2402          rom.asm:1406
ADDPHL           = $28DC = 10460          rom.asm:5624
ALLFOL           = $254B =  9547          rom.asm:5079
ANTVLU           = $1DBC =  7612          rom.asm:3912
ARET             = $3037 = 12343          rom.asm:6746 (unused)
ARLDSV           = $2186 =  8582          rom.asm:4471
ARREND           = $81BF = 33215          rom.asm:2028
ARRLP            = $2416 =  9238          rom.asm:4870
ASC              = $251C =  9500          rom.asm:5049
ASCTFP           = $2C89 = 11401          rom.asm:6252
ASPCS            = $1D1D =  7453          rom.asm:3834
ATHOME           = $05F6 =  1526          rom.asm:896
ATN              = $2FEB = 12267          rom.asm:6717
ATN1             = $3008 = 12296          rom.asm:6729
ATNTAB           = $3012 = 12306          rom.asm:6734
ATOH             = $1AF2 =  6898          rom.asm:3535
A_RTS_OFF        = $0160 =   352          rom.asm:196
A_RTS_ON         = $016E =   366          rom.asm:207
BACKSPACE        = $075F =  1887          rom.asm:1117
BADINP           = $1D40 =  7488          rom.asm:3846
BAKSTK           = $14A4 =  5284          rom.asm:2608
BAKTMP           = $24FC =  9468          rom.asm:5027
BASTXT           = $8133 = 33075          rom.asm:2004
BCDEFP           = $2BCE = 11214          rom.asm:6110
BEEPOFF          = $0520 =  1312          rom.asm:763
BFREE            = $0F68 =  3944          rom.asm:2197
BIN              = $39A8 = 14760          rom.asm:8057
BIN2             = $39AE = 14766          rom.asm:8059 (unused)
BINERR           = $3A05 = 14853          rom.asm:8118
BINIT            = $39E4 = 14820          rom.asm:8093
BINTFP           = $39DA = 14810          rom.asm:8089
BITOUT           = $39C2 = 14786          rom.asm:8071
BITOUT2          = $39C6 = 14790          rom.asm:8073
BITS6            = $370B = 14091          rom.asm:7679
BITS7            = $3715 = 14101          rom.asm:7684
BITS8            = $3720 = 14112          rom.asm:7689
BKGNDCLR         = $81EE = 33262          rom.asm:2055
BKSP             = $0008 =     8          rom.asm:1953
BN               = $0028 =    40          rom.asm:2106
BNMSG            = $1330 =  4912          rom.asm:2516
BNORM            = $293C = 10556          rom.asm:5683
BNPTR            = $13AC =  5036          rom.asm:2543 (unused)
BNRMLP           = $293F = 10559          rom.asm:5686
BOOT             = $0000 =     0  BOOT    rom.asm:8945 (unused)
BOOT_end         = $0000 =     0  BOOT    rom.asm:8945 (unused)
BOOT_size        = $0000 =     0  BOOT    rom.asm:8945 (unused)
BPS              = $81F8 = 33272          rom.asm:7500
BRK              = $1A65 =  6757          rom.asm:3459
BRKFLG           = $80A9 = 32937          rom.asm:1998
BRKLIN           = $81B3 = 33203          rom.asm:2022
BRKMSG           = $149E =  5278          rom.asm:2606
BRKRET           = $0F5F =  3935          rom.asm:2193
BS               = $0010 =    16          rom.asm:2094
BSERR            = $21B9 =  8633          rom.asm:4502
BSMSG            = $125F =  4703          rom.asm:2504
BSPTR            = $1394 =  5012          rom.asm:2531 (unused)
BUFFER           = $8136 = 33078          rom.asm:2005
BYT2ASC          = $394D = 14669          rom.asm:7992
BYTSFT           = $2A74 = 10868          rom.asm:5894
CFEVAL           = $211C =  8476          rom.asm:4402
CH3_TIMER        = $0232 =   562          rom.asm:347
CHABFREMPTY      = $01C3 =   451          rom.asm:261
CHAR2VID         = $06A2 =  1698          rom.asm:1015
CHARINTOBFR      = $0133 =   307          rom.asm:166
CHARTY           = $20CA =  8394          rom.asm:4358
CHASNDDTN        = $8223 = 33315          rom.asm:2066
CHBSNDDTN        = $8225 = 33317          rom.asm:2067
CHCKYPOS         = $0785 =  1925          rom.asm:1136
CHCKYPOS2        = $07F0 =  2032          rom.asm:1196
CHCSNDDTN        = $8227 = 33319          rom.asm:2068
CHECKALT         = $0C76 =  3190          rom.asm:1715
CHECKCTRL        = $0C84 =  3204          rom.asm:1721
CHECKKBD         = $0C92 =  3218          rom.asm:1727
CHECKWARM        = $02B2 =   690          rom.asm:413
CHEKFN           = $2314 =  8980          rom.asm:4723
CHKALT           = $0D0A =  3338          rom.asm:1787
CHKBIN           = $39F7 = 14839          rom.asm:8108
CHKBKSP          = $06CC =  1740          rom.asm:1035
CHKCLR           = $31B9 = 12729          rom.asm:6982
CHKCR            = $06C3 =  1731          rom.asm:1031
CHKCRSDWN        = $06F0 =  1776          rom.asm:1051
CHKCRSLFT        = $06D5 =  1749          rom.asm:1039
CHKCRSR          = $0241 =   577          rom.asm:357
CHKCRSRGT        = $06E7 =  1767          rom.asm:1047
CHKCRSUP         = $06DE =  1758          rom.asm:1043
CHKCS            = $06BA =  1722          rom.asm:1027
CHKCTRL          = $0D01 =  3329          rom.asm:1783
CHKEY1           = $3903 = 14595          rom.asm:7950
CHKEY2           = $3908 = 14600          rom.asm:7951
CHKEY3           = $390B = 14603          rom.asm:7952
CHKEY4           = $3911 = 14609          rom.asm:7953
CHKEY5           = $3914 = 14612          rom.asm:7954
CHKFNK           = $0D3D =  3389          rom.asm:1812
CHKG2M           = $31C3 = 12739          rom.asm:6990
CHKINK           = $28BB = 10427          rom.asm:5603
CHKLF            = $06F9 =  1785          rom.asm:1055
CHKLN            = $0CED =  3309          rom.asm:1774
CHKLTR           = $1AC4 =  6852          rom.asm:3511
CHKSCAR          = $3102 = 12546          rom.asm:6878
CHKSNDCH         = $0BFF =  3071          rom.asm:1643
CHKSTK           = $14D8 =  5336          rom.asm:2645
CHKSUM           = $80A6 = 32934          rom.asm:1996
CHKSYN           = $17FF =  6143          rom.asm:3114
CHKTYP           = $1E9C =  7836          rom.asm:4027
CHKYPOS          = $07AC =  1964          rom.asm:1157
CHR              = $252D =  9517          rom.asm:5061
CHR4VID          = $81EC = 33260          rom.asm:2053
CHRST68          = $3A7B = 14971          rom.asm:8305
CHRST88          = $427B = 17019          rom.asm:8589
CIRCLE           = $33B1 = 13233          rom.asm:7250
CKBPS            = $36BE = 14014          rom.asm:7639
CKINCHAR         = $021F =   543          rom.asm:328
CKMAGN           = $30B5 = 12469          rom.asm:6831
CLEAR            = $1B17 =  6935          rom.asm:3559
CLEARVIDBUF      = $05E9 =  1513          rom.asm:889
CLOTST           = $184B =  6219          rom.asm:3161
CLREG            = $1667 =  5735          rom.asm:2888
CLREX2           = $317C = 12668          rom.asm:6938
CLRG1            = $316A = 12650          rom.asm:6930
CLRG2            = $3173 = 12659          rom.asm:6934
CLRG2PTNTBL      = $0589 =  1417          rom.asm:827
CLRMC            = $3163 = 12643          rom.asm:6926
CLRPRM           = $3598 = 13720          rom.asm:7473
CLRPSGREGS       = $0B9D =  2973          rom.asm:1588
CLRPTR           = $1642 =  5698          rom.asm:2868
CLRTABLE         = $0549 =  1353          rom.asm:794
CLRTXT           = $3160 = 12640          rom.asm:6925
CLRVDBF          = $3580 = 13696          rom.asm:7453
CLS              = $303A = 12346          rom.asm:6751
CLSQT            = $38CA = 14538          rom.asm:7916
CLSQT1           = $38DA = 14554          rom.asm:7924
CMP16            = $3A2D = 14893          rom.asm:8179
CMPFP            = $2C17 = 11287          rom.asm:6168
CMPLG1           = $2030 =  8240          rom.asm:4264
CMPLOG           = $202E =  8238          rom.asm:4263
CMPNUM           = $2BFD = 11261          rom.asm:6151
CMPRES           = $2072 =  8306          rom.asm:4312
CMPSTR           = $205A =  8282          rom.asm:4292
CMP_A            = $28A2 = 10402          rom.asm:5590
CN               = $0020 =    32          rom.asm:2102
CNMSG            = $12F0 =  4848          rom.asm:2512
CNPTR            = $13A4 =  5028          rom.asm:2539 (unused)
CNTCHKSND        = $0C36 =  3126          rom.asm:1676
CNTCKCL          = $312F = 12591          rom.asm:6904
CNTCL1           = $3473 = 13427          rom.asm:7337
CNTCL2           = $3497 = 13463          rom.asm:7350
CNTCL3           = $34BB = 13499          rom.asm:7363
CNTCL4           = $34E1 = 13537          rom.asm:7377
CNTCL5           = $3503 = 13571          rom.asm:7389
CNTCL6           = $3527 = 13607          rom.asm:7402
CNTCL7           = $354B = 13643          rom.asm:7415
CNTDRW           = $3357 = 13143          rom.asm:7204
CNTEND           = $1CE5 =  7397          rom.asm:3804
CNTFNK           = $0D98 =  3480          rom.asm:1862
CNTKBCK          = $0D37 =  3383          rom.asm:1810
CNTLGC           = $1FEF =  8175          rom.asm:4218
CNTLTK           = $3890 = 14480          rom.asm:7885
CNTNULL          = $08F2 =  2290          rom.asm:1349
CNTNULL2         = $091C =  2332          rom.asm:1371
CNTPLOT          = $3226 = 12838          rom.asm:7041
CNTRX2           = $363E = 13886          rom.asm:7580
CNTRXCHA         = $011D =   285          rom.asm:150
CNTSER           = $360A = 13834          rom.asm:7551
CNTSER2          = $3649 = 13897          rom.asm:7587
CNTSER3          = $365B = 13915          rom.asm:7596
CNTTXA           = $01FC =   508          rom.asm:300
CNTVALY          = $357B = 13691          rom.asm:7446
CNTWTSP          = $1962 =  6498          rom.asm:3295
CNVNUM           = $2C95 = 11413          rom.asm:6258
COLD             = $0EBE =  3774          rom.asm:2112
COLDSTART        = $02AA =   682          rom.asm:410
COLOR            = $3112 = 12562          rom.asm:6893
COMMAN           = $80A3 = 32931          rom.asm:1993
COMPL            = $299C = 10652          rom.asm:5757
CONCAT           = $2491 =  9361          rom.asm:4960
CONEXP           = $2CC5 = 11461          rom.asm:6282
CONPOS           = $2939 = 10553          rom.asm:5681
CONT             = $1A9E =  6814          rom.asm:3489
CONTAD           = $81B9 = 33209          rom.asm:2025
CONTCRSLFT       = $0796 =  1942          rom.asm:1144
CONTCRSRGT       = $0803 =  2051          rom.asm:1206
CONTROLKEYS      = $822D = 33325          rom.asm:2073
CONT_POS_CURS    = $0682 =  1666          rom.asm:992
CONVAR           = $1F87 =  8071          rom.asm:4151
CORW             = $029E =   670          rom.asm:405
COS              = $2F6F = 12143          rom.asm:6665
COUNTER          = $02E6 =   742          rom.asm:443
CPDEHL           = $17F9 =  6137          rom.asm:3107
CPKEY            = $3827 = 14375          rom.asm:7830
CPKEY1           = $3846 = 14406          rom.asm:7847
CPKEY2           = $3837 = 14391          rom.asm:7837
CPKEY3           = $383E = 14398          rom.asm:7840
CPKYEND          = $384E = 14414          rom.asm:7852
CPYLIT           = $173C =  5948          rom.asm:3007
CR               = $000D =    13          rom.asm:1956
CRARLP           = $21D9 =  8665          rom.asm:4522
CREARY           = $21BE =  8638          rom.asm:4505
CRESTR           = $1C1E =  7198          rom.asm:3702
CRGRETURN        = $08C4 =  2244          rom.asm:1325
CRNCLP           = $169D =  5789          rom.asm:2915
CRSDN            = $001F =    31          rom.asm:1970
CRSLFT           = $001C =    28          rom.asm:1967
CRSRGT           = $001D =    29          rom.asm:1968
CRSR_STATE       = $81E9 = 33257          rom.asm:2050
CRSUP            = $001E =    30          rom.asm:1969
CRTMST           = $234D =  9037          rom.asm:4756
CRTST            = $2359 =  9049          rom.asm:4767
CRTSTE           = $236F =  9071          rom.asm:4781
CRUNCH           = $1694 =  5780          rom.asm:2911
CS               = $000C =    12          rom.asm:1955
CSTART           = $0ECB =  3787          rom.asm:2118
CTC0IV           = $81D2 = 33234          rom.asm:2036
CTC1IV           = $81D5 = 33237          rom.asm:2037
CTC2IV           = $81D8 = 33240          rom.asm:2038
CTC3IV           = $81DB = 33243          rom.asm:2039
CTCCONF          = $0325 =   805          rom.asm:501
CTC_CFG          = $3791 = 14225          rom.asm:7745
CTC_CH0          = $0010 =    16          rom.asm:36
CTC_CH1          = $0011 =    17          rom.asm:37
CTC_CH2          = $0012 =    18          rom.asm:38
CTC_CH3          = $0013 =    19          rom.asm:39
CTLOFG           = $80A5 = 32933          rom.asm:1995
CTRLC            = $0003 =     3          rom.asm:1951
CTRLG            = $0007 =     7          rom.asm:1952
CTRLO            = $000F =    15          rom.asm:1957
CTRLQ            = $0011 =    17          rom.asm:1958
CTRLR            = $0012 =    18          rom.asm:1959
CTRLS            = $0013 =    19          rom.asm:1960
CTRLU            = $0015 =    21          rom.asm:1961
CTSNDC           = $2786 = 10118          rom.asm:5432
CUROPR           = $81AA = 33194          rom.asm:2016
CURPOS           = $8190 = 33168          rom.asm:2007
CURSORDOWN       = $080C =  2060          rom.asm:1214
CURSORLEFT       = $0772 =  1906          rom.asm:1127
CURSORRIGHT      = $07D7 =  2007          rom.asm:1183
CURSORUP         = $07BE =  1982          rom.asm:1168
CURSOR_OFF       = $0842 =  2114          rom.asm:1247
CURSOR_ON        = $082C =  2092          rom.asm:1234
CUR_POS          = $81EF = 33263          rom.asm:1322
DATA             = $1BC5 =  7109          rom.asm:3654
DATABT           = $81FA = 33274          rom.asm:7501
DATFLG           = $8193 = 33171          rom.asm:2010
DATLIN           = $81AE = 33198          rom.asm:2018
DATSNR           = $1515 =  5397          rom.asm:2687
DC               = $8201 = 33281          rom.asm:7249
DCBCDE           = $2C4E = 11342          rom.asm:6211
DD               = $0012 =    18          rom.asm:2095
DDERR            = $1524 =  5412          rom.asm:2695
DDMSG            = $126D =  4717          rom.asm:2505
DDPTR            = $1396 =  5014          rom.asm:2532 (unused)
DECLN1           = $3819 = 14361          rom.asm:7822
DEC_D            = $04E0 =  1248          rom.asm:722
DEC_E            = $02E4 =   740          rom.asm:442
DEEK             = $3056 = 12374          rom.asm:6768
DEF              = $2291 =  8849          rom.asm:4644
DEFFNKS          = $140B =  5131          rom.asm:2589
DEFSER           = $36A5 = 13989          rom.asm:7626
DEFSIZ           = $21E1 =  8673          rom.asm:4526
DEINT            = $1AD8 =  6872          rom.asm:3522
DEL              = $007F =   127          rom.asm:1965
DELCHR           = $176C =  5996          rom.asm:3037
DEPINT           = $1AD2 =  6866          rom.asm:3520
DETHL4           = $2BDD = 11229          rom.asm:6122
DETHLB           = $2BDF = 11231          rom.asm:6123
DIGTXT           = $2D8F = 11663          rom.asm:6404
DIM              = $209C =  8348          rom.asm:4338
DIMRET           = $2093 =  8339          rom.asm:4333
DINPOS           = $182E =  6190          rom.asm:3141
DINT             = $2A79 = 10873          rom.asm:5902
DIRMOD           = $37A5 = 14245          rom.asm:7755
DIR_PAU          = $3081 = 12417          rom.asm:6797 (unused)
DIV              = $2AD6 = 10966          rom.asm:5943
DIV1             = $806B = 32875          rom.asm:1984
DIV10            = $2ACA = 10954          rom.asm:5938
DIV2             = $806F = 32879          rom.asm:1985
DIV3             = $8073 = 32883          rom.asm:1986
DIV4             = $8076 = 32886          rom.asm:1987
DIVLP            = $2AFD = 11005          rom.asm:5967
DIVSUP           = $806A = 32874          rom.asm:1983
DIV_16_8         = $3A6C = 14956          rom.asm:8271
DIV_16_8LP       = $3A6F = 14959          rom.asm:8273
DIV_8_8          = $3A5C = 14940          rom.asm:8248
DIV_8_8LOOP      = $3A60 = 14944          rom.asm:8251
DLSZ             = $3435 = 13365          rom.asm:7310
DOAGN            = $1680 =  5760          rom.asm:2901
DOCOM            = $1CEA =  7402          rom.asm:3808
DODEL            = $174C =  5964          rom.asm:3021
DOEBIT           = $2DCF = 11727          rom.asm:6447
DOFN             = $22BE =  8894          rom.asm:4672
DOKE             = $3061 = 12385          rom.asm:6776
DOSPC            = $1D18 =  7448          rom.asm:3831
DOTAB            = $1D03 =  7427          rom.asm:3820
DPOINT           = $2CC1 = 11457          rom.asm:6280
DRAW             = $328A = 12938          rom.asm:7131
DRWCRL           = $3451 = 13393          rom.asm:7325
DTSTR            = $235D =  9053          rom.asm:4770
DVBCDE           = $2AD8 = 10968          rom.asm:5945
DX               = $8203 = 33283          rom.asm:7129
DXGR             = $3387 = 13191          rom.asm:7221
DY               = $8205 = 33285          rom.asm:7130
DZ               = $0014 =    20          rom.asm:2096
DZERR            = $151E =  5406          rom.asm:2691
DZMSG            = $1282 =  4738          rom.asm:2506
DZPTR            = $1398 =  5016          rom.asm:2533 (unused)
E2               = $81FD = 33277          rom.asm:7126
ECHDEL           = $1760 =  5984          rom.asm:3030
ECHO_CHAR        = $02BC =   700          rom.asm:419
EDIGIT           = $2D08 = 11528          rom.asm:6329
EMPTSNDBFR       = $0B99 =  2969          rom.asm:1585
EMPTVRM          = $09DA =  2522          rom.asm:1435
EMPTYCHABFR      = $01B5 =   437          rom.asm:254
EMPTYG2          = $0577 =  1399          rom.asm:819
EMPTYMC          = $05A8 =  1448          rom.asm:845
EMPTYVIDBUF      = $054E =  1358          rom.asm:798
EMPTY_RAM        = $09E3 =  2531          rom.asm:1443
EMPTY_VRAM       = $09CF =  2511          rom.asm:1428
ENDBUF           = $1743 =  5955          rom.asm:3013
ENDCON           = $2CD4 = 11476          rom.asm:6292
ENDCRL           = $344D = 13389          rom.asm:7321
ENDCTRLCK        = $0CD8 =  3288          rom.asm:1763
ENDDIM           = $2240 =  8768          rom.asm:4595
ENDDRAW          = $33AD = 13229          rom.asm:7234
ENDINK           = $28CD = 10445          rom.asm:5614
ENDINK2          = $28D6 = 10454          rom.asm:5621 (unused)
ENDINP           = $1CD1 =  7377          rom.asm:3795
ENDNAM           = $20BE =  8382          rom.asm:4354
ENDPRG           = $1A74 =  6772          rom.asm:3469
ENDTXT           = $81F3 = 33267          rom.asm:1324
ENDVDPSET        = $047D =  1149          rom.asm:667
ENFMEM           = $14E1 =  5345          rom.asm:2651
ER               = $81FB = 33275          rom.asm:7125
ER2              = $3331 = 13105          rom.asm:7191
ERASECLRTBL      = $04FC =  1276          rom.asm:739
ERRIN            = $1553 =  5459          rom.asm:2719
ERRINT           = $1A98 =  6808          rom.asm:3485
ERRLIN           = $81B7 = 33207          rom.asm:2024
ERRMSG           = $148D =  5261          rom.asm:2602
ERROR            = $152F =  5423          rom.asm:2703
ERRORS           = $11EA =  4586          rom.asm:2495 (unused)
ERRTBL           = $1384 =  4996          rom.asm:2522
ESC              = $001B =    27          rom.asm:1963
EVAL             = $1EA9 =  7849          rom.asm:4035
EVAL1            = $1EAC =  7852          rom.asm:4037
EVAL2            = $1EB5 =  7861          rom.asm:4041
EVAL3            = $1EB8 =  7864          rom.asm:4042
EVLPAR           = $1F6E =  8046          rom.asm:4137
EVNOT            = $207C =  8316          rom.asm:4320
EXCUTE           = $1A02 =  6658          rom.asm:3389
EXG2MD           = $043F =  1087          rom.asm:635
EXITCHAR2VID     = $072D =  1837          rom.asm:1081
EXITCURSORDOWN   = $0829 =  2089          rom.asm:1228
EXITCURSORLEFT   = $0799 =  1945          rom.asm:1145
EXITCURSORRGHT   = $0809 =  2057          rom.asm:1208
EXITCURSORUP     = $07D5 =  2005          rom.asm:1178
EXITCURSOR_ON    = $0840 =  2112          rom.asm:1243
EXITGM           = $14F5 =  5365          rom.asm:2667
EXITSER          = $3766 = 14182          rom.asm:7728 (unused)
EXMUL16          = $3A50 = 14928          rom.asm:8219
EXP              = $2E69 = 11881          rom.asm:6534
EXPLP            = $2CB3 = 11443          rom.asm:6272
EXPTAB           = $2EA9 = 11945          rom.asm:6562
EXPTEN           = $2DE1 = 11745          rom.asm:6457
EXTIG            = $1E18 =  7704          rom.asm:3960
EXTXA            = $0210 =   528          rom.asm:311
FANDT            = $1E41 =  7745          rom.asm:3978
FC               = $0008 =     8          rom.asm:2090
FCERR            = $1AED =  6893          rom.asm:3532
FCMSG            = $1223 =  4643          rom.asm:2500
FCPTR            = $138C =  5004          rom.asm:2527 (unused)
FDTLP            = $1E28 =  7720          rom.asm:3962
FINDEL           = $221C =  8732          rom.asm:4567
FINDKEY          = $0CEB =  3307          rom.asm:1773
FLASHCURSOR      = $073B =  1851          rom.asm:1094
FLGDIF           = $2B8D = 11149          rom.asm:6064
FLGREL           = $2B94 = 11156          rom.asm:6070
FNARG            = $81C5 = 33221          rom.asm:2031
FNCTAB           = $0FB1 =  4017          rom.asm:2214
FNDARY           = $218C =  8588          rom.asm:4475
FNDBPS           = $36D7 = 14039          rom.asm:7649
FNDELP           = $2221 =  8737          rom.asm:4572
FNDEND           = $1615 =  5653          rom.asm:2831
FNDNUM           = $2620 =  9760          rom.asm:5211
FNDTOK           = $1924 =  6436          rom.asm:3260
FNDVAR           = $2103 =  8451          rom.asm:4386
FNDWRD           = $16C7 =  5831          rom.asm:2935
FNKEYS           = $80B3 = 32947          rom.asm:2003
FNKEYSORD        = $0DB6 =  3510          rom.asm:1879
FNOFST           = $1F98 =  8088          rom.asm:4161
FNRGNM           = $81C3 = 33219          rom.asm:2030
FNTHR            = $2111 =  8465          rom.asm:4394
FNVAL            = $1FC4 =  8132          rom.asm:4185
FOPRND           = $1EE1 =  7905          rom.asm:4063
FOR              = $1969 =  6505          rom.asm:3300
FORFLG           = $81B0 = 33200          rom.asm:2019
FORFND           = $1999 =  6553          rom.asm:3328
FORSLP           = $197D =  6525          rom.asm:3309
FPADD            = $28EB = 10475          rom.asm:5632
FPBCDE           = $2BC3 = 11203          rom.asm:6101
FPEXP            = $81CC = 33228          rom.asm:2033
FPINT            = $2C2A = 11306          rom.asm:6188
FPMULT           = $2A26 = 10790          rom.asm:5843
FPREG            = $81C9 = 33225          rom.asm:2032
FPROND           = $2983 = 10627          rom.asm:5733
FPSINT           = $1ACC =  6860          rom.asm:3518
FPTHL            = $2BDA = 11226          rom.asm:6121
FRE              = $225B =  8795          rom.asm:4613
FRENUM           = $2277 =  8823          rom.asm:4625
FRGNDCLR         = $81ED = 33261          rom.asm:2054
FRMEVL           = $1F8A =  8074          rom.asm:4152
FWVER            = $00E0 =   224          rom.asm:134 (unused)
G1MD             = $03BE =   958          rom.asm:574
G2MD             = $03FA =  1018          rom.asm:605
GARBGE           = $23DE =  9182          rom.asm:4843
GARBLP           = $23E1 =  9185          rom.asm:4844
GETCHR           = $1A22 =  6690          rom.asm:3412
GETCMD           = $1582 =  5506          rom.asm:2743
GETHEX           = $3983 = 14723          rom.asm:8030
GETINP           = $3038 = 12344          rom.asm:6748
GETINT           = $2623 =  9763          rom.asm:5212
GETLEN           = $2511 =  9489          rom.asm:5041
GETLIN           = $177D =  6013          rom.asm:3045
GETLN            = $1AF3 =  6899          rom.asm:3536
GETNUM           = $1E97 =  7831          rom.asm:4024
GETNXT           = $16E2 =  5858          rom.asm:2950
GETSTR           = $24DB =  9435          rom.asm:5007
GETVAR           = $20A1 =  8353          rom.asm:4341
GM               = $002A =    42          rom.asm:2107
GMERR            = $35B1 = 13745          rom.asm:7488
GMMSG            = $133B =  4923          rom.asm:2517
GMNCR            = $17D4 =  6100          rom.asm:3087
GMPRT            = $13AE =  5038          rom.asm:2544 (unused)
GNXARY           = $2415 =  9237          rom.asm:4869
GOFUNC           = $1FCC =  8140          rom.asm:4189
GOSUB            = $1B71 =  7025          rom.asm:3605
GOTO             = $1B82 =  7042          rom.asm:3617
GRBARY           = $2435 =  9269          rom.asm:4888
GRBDON           = $23B6 =  9142          rom.asm:4818
GRBLP            = $23EF =  9199          rom.asm:4850
GSTRCU           = $24DE =  9438          rom.asm:5008
GSTRDE           = $24E2 =  9442          rom.asm:5010
GSTRHL           = $24E1 =  9441          rom.asm:5009
GTFLNM           = $2520 =  9504          rom.asm:5051 (unused)
GTFNAM           = $20A6 =  8358          rom.asm:4344
GTLNLP           = $1AF6 =  6902          rom.asm:3537
GTSIXD           = $2D59 = 11609          rom.asm:6373
GTVLUS           = $1D94 =  7572          rom.asm:3890
HALF             = $2E00 = 11776          rom.asm:6478
HALFPI           = $2FB9 = 12217          rom.asm:6696
HELLOWRLD        = $02D6 =   726          rom.asm:434
HELP             = $37B1 = 14257          rom.asm:7766
HEX              = $3917 = 14615          rom.asm:7958
HEX1             = $392F = 14639          rom.asm:7971
HEX2             = $3931 = 14641          rom.asm:7973
HEX3             = $393E = 14654          rom.asm:7981
HEX4             = $3940 = 14656          rom.asm:7983
HEXIT            = $399A = 14746          rom.asm:8045
HEXLP            = $3976 = 14710          rom.asm:8020
HEXLP1           = $397B = 14715          rom.asm:8022
HEXTFP           = $396A = 14698          rom.asm:8015
HL2XY            = $0691 =  1681          rom.asm:1003
HLPERR           = $37C7 = 14279          rom.asm:7777
HLPLN            = $80B1 = 32945          rom.asm:2002
HOME             = $0019 =    25          rom.asm:1962
HP               = $0030 =    48          rom.asm:2110
HPMSG            = $137A =  4986          rom.asm:2520
HPPTR            = $13B4 =  5044          rom.asm:2547 (unused)
HX               = $0026 =    38          rom.asm:2105
HXERR            = $39A3 = 14755          rom.asm:8053
HXMSG            = $1325 =  4901          rom.asm:2515
HXPTR            = $13AA =  5034          rom.asm:2542 (unused)
ID               = $0016 =    22          rom.asm:2097
IDMSG            = $1293 =  4755          rom.asm:2507
IDPTR            = $139A =  5018          rom.asm:2534 (unused)
IDTEST           = $2306 =  8966          rom.asm:4713
IF               = $1C54 =  7252          rom.asm:3735
IFGO             = $1C62 =  7266          rom.asm:3742
IFJMP            = $1A09 =  6665          rom.asm:3392
INCHL            = $2BD8 = 11224          rom.asm:6118
INCLEN           = $182A =  6186          rom.asm:3139
INCTMR3          = $023B =   571          rom.asm:353
INDFND           = $14BE =  5310          rom.asm:2627
INEWLN           = $15DD =  5597          rom.asm:2791
INIT             = $0ED2 =  3794          rom.asm:2122
INITAB           = $13B6 =  5046          rom.asm:2551
INITBE           = $148D =  5261          rom.asm:2598
INITST           = $3A18 = 14872          rom.asm:8131
INIT_HW          = $0251 =   593          rom.asm:372
INKEY            = $2897 = 10391          rom.asm:5585
INKEY2           = $28B1 = 10417          rom.asm:5598
INMSG            = $1494 =  5268          rom.asm:2603
INP              = $25E0 =  9696          rom.asm:5180
INPBIN           = $1DE6 =  7654          rom.asm:3934
INPBRK           = $1A71 =  6769          rom.asm:3467
INPORT           = $80A0 = 32928          rom.asm:1991
INPSUB           = $809F = 32927          rom.asm:1990
INPUT            = $1D51 =  7505          rom.asm:3854
INRNG            = $2D62 = 11618          rom.asm:6378
INT              = $2C55 = 11349          rom.asm:6219
INTVAR           = $1651 =  5713          rom.asm:2879
INVSGN           = $2BAB = 11179          rom.asm:6083
ITMSEP           = $1DD7 =  7639          rom.asm:3925
JSTZER           = $2DEB = 11755          rom.asm:6463
KBDNPT           = $8229 = 33321          rom.asm:2069
KBMAP            = $0DBE =  3518          rom.asm:1882
KBMAP_ALT        = $0E3E =  3646          rom.asm:1902
KBMAP_CTRL       = $0E7E =  3710          rom.asm:1912
KBMAP_SFT        = $0DFE =  3582          rom.asm:1892
KBTMP            = $822A = 33322          rom.asm:2070
KEY              = $37CC = 14284          rom.asm:7782
KEYBOARD         = $0C56 =  3158          rom.asm:1699
KEYCH            = $37E9 = 14313          rom.asm:7798
KILFOR           = $1E87 =  7815          rom.asm:4015
KILIN            = $1777 =  6007          rom.asm:3042
LASTKEYPRSD      = $822C = 33324          rom.asm:2072
LCRFLG           = $8191 = 33169          rom.asm:2008
LDCLRTBEX2       = $0474 =  1140          rom.asm:660
LDCLRTBMD1       = $03F1 =  1009          rom.asm:598
LDCOLSTOEMPTY    = $0568 =  1384          rom.asm:809
LDFNKEYCHR       = $0D84 =  3460          rom.asm:1852
LDG1             = $1502 =  5378          rom.asm:2673
LDG1ND           = $1513 =  5395          rom.asm:2683
LDKEY            = $387B = 14459          rom.asm:7876
LDREGVLS         = $0A00 =  2560          rom.asm:1463
LEDLIGHT         = $02E0 =   736          rom.asm:440
LEFT             = $253D =  9533          rom.asm:5069
LEN              = $250D =  9485          rom.asm:5039
LET              = $1BDC =  7132          rom.asm:3670
LETNUM           = $1C2F =  7215          rom.asm:3712
LETSTR           = $1BF7 =  7159          rom.asm:3683
LF               = $000A =    10          rom.asm:1954
LFRGNM           = $25D6 =  9686          rom.asm:5171
LINEAT           = $80AF = 32943          rom.asm:2001
LINEIN           = $2D14 = 11540          rom.asm:6339
LINFND           = $15C6 =  5574          rom.asm:2777
LIST             = $185E =  6238          rom.asm:3173
LISTLP           = $18E1 =  6369          rom.asm:3222
LM80CLOGO        = $0A53 =  2643          rom.asm:1548
LOADCHARSET      = $0A0A =  2570          rom.asm:1472
LOADCLR          = $3183 = 12675          rom.asm:6941
LOADFP           = $2BD1 = 11217          rom.asm:6111
LOADLOGOCHRS     = $0528 =  1320          rom.asm:769
LOADMAP          = $0D11 =  3345          rom.asm:1790
LOADNEXTCOL      = $0874 =  2164          rom.asm:1274
LOAD_CRSR_POS    = $066D =  1645          rom.asm:981
LOCATE           = $26F0 =  9968          rom.asm:5346
LOG              = $29E5 = 10725          rom.asm:5811
LOGOFONT         = $4A7B = 19067          rom.asm:8859
LOGTAB           = $29D8 = 10712          rom.asm:5806
LOKFOR           = $14A8 =  5288          rom.asm:2610
LOOPST           = $81AC = 33196          rom.asm:2017
LS               = $001C =    28          rom.asm:2100
LSBTMR           = $2254 =  8788          rom.asm:4607
LSMSG            = $12C5 =  4805          rom.asm:2510
LSPTR            = $13A0 =  5024          rom.asm:2537 (unused)
LST01            = $188A =  6282          rom.asm:3190
LST01H           = $188D =  6285          rom.asm:3191
LST03            = $18C7 =  6343          rom.asm:3211
LST04            = $18A4 =  6308          rom.asm:3199 (unused)
LST05            = $18D5 =  6357          rom.asm:3218
LST06            = $18AB =  6315          rom.asm:3201
LST07            = $1906 =  6406          rom.asm:3242
LST08            = $1903 =  6403          rom.asm:3241
LSTALL           = $18AF =  6319          rom.asm:3203
LSTBIN           = $81B1 = 33201          rom.asm:2020
LSTCSRSTA        = $81EA = 33258          rom.asm:2051
LSTKEYS          = $3850 = 14416          rom.asm:7855
LSTLP2           = $1912 =  6418          rom.asm:3251
LSTLP3           = $1915 =  6421          rom.asm:3252
LSTRAM           = $8194 = 33172          rom.asm:2011
LSTRND           = $809B = 32923          rom.asm:1989
LTSTND           = $1DF1 =  7665          rom.asm:3939
LVKBRDCHK        = $0D6B =  3435          rom.asm:1833
LVKBRDCHK2       = $0D67 =  3431          rom.asm:1831
LVRXCHA          = $012E =   302          rom.asm:158
LWIDTH           = $80A2 = 32930          rom.asm:1992
MAKINT           = $2626 =  9766          rom.asm:5213
MAKNUM           = $2D7E = 11646          rom.asm:6393
MANLP            = $2C9D = 11421          rom.asm:6264
MATCH            = $1714 =  5908          rom.asm:2982
MCMD             = $041C =  1052          rom.asm:620
MEMMSG           = $0FA6 =  4006          rom.asm:2203
MID              = $2577 =  9591          rom.asm:5109
MID1             = $2543 =  9539          rom.asm:5073
MIDNUM           = $25DB =  9691          rom.asm:5174
MINCDE           = $292B = 10539          rom.asm:5667
MINUS            = $1F76 =  8054          rom.asm:4142
MIXCLRS          = $31AC = 12716          rom.asm:6970
MKTMST           = $234A =  9034          rom.asm:4755
MLDBLP           = $2C76 = 11382          rom.asm:6240
MLDEBC           = $2C6E = 11374          rom.asm:6235
MLOOP            = $0F00 =  3840          rom.asm:2140
MLP              = $3A40 = 14912          rom.asm:8208
MLP1             = $3A47 = 14919          rom.asm:8212
MLSP10           = $2B6B = 11115          rom.asm:6044
MNGSNDS          = $0BF5 =  3061          rom.asm:1639
MNOASK           = $0EFD =  3837          rom.asm:2139
MO               = $0024 =    36          rom.asm:2104
MOD              = $2A81 = 10881          rom.asm:5912
MOMSG            = $1315 =  4885          rom.asm:2514
MONOUT           = $3A0A = 14858          rom.asm:8122
MOPTR            = $13A8 =  5032          rom.asm:2541 (unused)
MORDT            = $1DFD =  7677          rom.asm:3944
MORINP           = $1786 =  6022          rom.asm:3050
MOVBUF           = $15FC =  5628          rom.asm:2812
MOVCRS           = $0646 =  1606          rom.asm:959
MOVDIR           = $171C =  5916          rom.asm:2990
MOVLP            = $14CD =  5325          rom.asm:2637
MOVSTR           = $14CA =  5322          rom.asm:2634
MOVUP            = $14C7 =  5319          rom.asm:2633
MRPRNT           = $1C74 =  7284          rom.asm:3749
MSGTXT1          = $0331 =   817          rom.asm:506
MSGTXT2          = $035A =   858          rom.asm:508
MSIZE            = $0EED =  3821          rom.asm:2133
MUL16            = $3A38 = 14904          rom.asm:8200
MUL8LP           = $2A51 = 10833          rom.asm:5866
MULLN2           = $2A1D = 10781          rom.asm:5837
MULT             = $2A24 = 10788          rom.asm:5841
MULT8            = $2A48 = 10824          rom.asm:5860
MULTEN           = $2CDF = 11487          rom.asm:6300
MULVAL           = $823D = 33341          rom.asm:2079
MVCRS2LFT        = $079B =  1947          rom.asm:1149
MVSTPT           = $1C26 =  7206          rom.asm:3706
NEDMOR           = $1D90 =  7568          rom.asm:3888
NEGAFT           = $2E16 = 11798          rom.asm:6487
NEW              = $1641 =  5697          rom.asm:2867
NEWCRSRCOORD     = $064F =  1615          rom.asm:965
NEXITM           = $1D27 =  7463          rom.asm:3840
NEXT             = $1E4C =  7756          rom.asm:3983
NEXT1            = $1E4F =  7759          rom.asm:3984
NF               = $0000 =     0          rom.asm:2086
NFERR            = $1521 =  5409          rom.asm:2693
NFMSG            = $11EA =  4586          rom.asm:2496
NFPTR            = $1384 =  4996          rom.asm:2523 (unused)
NLLCR            = $0000 =     0          rom.asm:1950
NM1              = $264F =  9807          rom.asm:5237
NMI              = $2634 =  9780          rom.asm:5224
NMI2             = $2660 =  9824          rom.asm:5245
NMIDINT          = $266B =  9835          rom.asm:5254
NMIEINT          = $2664 =  9828          rom.asm:5250
NMIFLG           = $80A8 = 32936          rom.asm:1997
NMIINT           = $266E =  9838          rom.asm:5255
NMIUSR           = $8061 = 32865          rom.asm:1979
NMIVR1           = $267A =  9850          rom.asm:5266
NOBEEP           = $0BC7 =  3015          rom.asm:1608
NOBPDAT          = $0BE3 =  3043          rom.asm:1622
NOCHNG           = $170C =  5900          rom.asm:2977
NOENED           = $2DEE = 11758          rom.asm:6466
NOGD             = $3253 = 12883          rom.asm:7070
NOISUP           = $280B = 10251          rom.asm:5500
NOKEYPRSD        = $0CDC =  3292          rom.asm:1765
NOLIN            = $1A87 =  6791          rom.asm:3478
NOMADD           = $2A62 = 10850          rom.asm:5877
NOMLAD           = $2C84 = 11396          rom.asm:6248
NOPMPT           = $1D6B =  7531          rom.asm:3866
NORMAL           = $2956 = 10582          rom.asm:5702
NOS1             = $2828 = 10280          rom.asm:5513
NOS2             = $283A = 10298          rom.asm:5525
NOS3             = $2852 = 10322          rom.asm:5543
NOSPC            = $1703 =  5891          rom.asm:2972
NOSUB7           = $3996 = 14742          rom.asm:8041
NOSWAP           = $2905 = 10501          rom.asm:5648
NOSYSPR          = $26A9 =  9897          rom.asm:5295
NOTAMP           = $1F4B =  8011          rom.asm:4123
NOTFULL          = $013D =   317          rom.asm:172
NOTRDWRAP        = $01DD =   477          rom.asm:279
NOTSTR           = $20D9 =  8409          rom.asm:4366
NOTWRAP          = $0149 =   329          rom.asm:178
NOXOR            = $2606 =  9734          rom.asm:5197
NSCFOR           = $20E9 =  8425          rom.asm:4374
NULFLG           = $80A4 = 32932          rom.asm:1994
NUMASC           = $2D27 = 11559          rom.asm:6349
NXTARY           = $21A0 =  8608          rom.asm:4487
NXTBYT           = $16F2 =  5874          rom.asm:2962
NXTCHAR          = $0A1D =  2589          rom.asm:1483
NXTCHR           = $1733 =  5939          rom.asm:3002
NXTDAT           = $81C1 = 33217          rom.asm:2029
NXTDTA           = $1BC4 =  7108          rom.asm:3652
NXTITM           = $1D88 =  7560          rom.asm:3883
NXTLN            = $193C =  6460          rom.asm:3273
NXTOPR           = $81B5 = 33205          rom.asm:2023
NXTSTL           = $1BCB =  7115          rom.asm:3657
NXTSTT           = $1BCE =  7118          rom.asm:3660
OD               = $0006 =     6          rom.asm:2089
ODMSG            = $1217 =  4631          rom.asm:2499
ODPTR            = $138A =  5002          rom.asm:2526 (unused)
OKMSG            = $1499 =  5273          rom.asm:2605
OM               = $000C =    12          rom.asm:2092
OMERR            = $14F0 =  5360          rom.asm:2662
OMMSG            = $1242 =  4674          rom.asm:2502
OMPTR            = $1390 =  5008          rom.asm:2529 (unused)
ON               = $1C36 =  7222          rom.asm:3718
ONGO             = $1C45 =  7237          rom.asm:3726
ONGOLP           = $1C46 =  7238          rom.asm:3727
ONJMP            = $1A0A =  6666          rom.asm:3394
OPNPAR           = $1EA5 =  7845          rom.asm:4033
OPNQT            = $38DC = 14556          rom.asm:7927
OPNQT1           = $38F2 = 14578          rom.asm:7937
OPRND            = $1F20 =  7968          rom.asm:4106
OS               = $001A =    26          rom.asm:2099
OSMSG            = $12B1 =  4785          rom.asm:2509
OSPTR            = $139E =  5022          rom.asm:2536 (unused)
OTKLN            = $1774 =  6004          rom.asm:3041
OTPORT           = $8068 = 32872          rom.asm:1982
OUTC             = $180A =  6154          rom.asm:3122
OUTEXP           = $2DDF = 11743          rom.asm:6456
OUTIT            = $17EE =  6126          rom.asm:3101
OUTNBS           = $17F1 =  6129          rom.asm:3103
OUTNCR           = $3A27 = 14887          rom.asm:8143
OUTSUB           = $8067 = 32871          rom.asm:1981
OUTWRD           = $192E =  6446          rom.asm:3266
OV               = $000A =    10          rom.asm:2091
OVERR            = $152A =  5418          rom.asm:2699
OVMSG            = $1239 =  4665          rom.asm:2501
OVPTR            = $138E =  5006          rom.asm:2528 (unused)
OVTST1           = $2B5E = 11102          rom.asm:6036
OVTST2           = $2B63 = 11107          rom.asm:6039
OVTST3           = $2B64 = 11108          rom.asm:6040
PADD             = $2D03 = 11523          rom.asm:6325
PAND             = $1FE5 =  8165          rom.asm:4211
PAND1            = $200A =  8202          rom.asm:4234 (unused)
PARBT            = $81FB = 33275          rom.asm:7502
PASSA            = $228C =  8844          rom.asm:4640
PAUSE            = $3078 = 12408          rom.asm:6792
PBUFF            = $8230 = 33328          rom.asm:2078
PEEK             = $26B6 =  9910          rom.asm:5307
PEND             = $1A6C =  6764          rom.asm:3464
PHLTFP           = $2BC0 = 11200          rom.asm:6100
PIO_CA           = $0002 =     2          rom.asm:32 (unused)
PIO_CB           = $0003 =     3          rom.asm:33
PIO_DA           = $0000 =     0          rom.asm:30 (unused)
PIO_DB           = $0001 =     1          rom.asm:31
PKEPRMS          = $26CA =  9930          rom.asm:5322
PLOT             = $320B = 12811          rom.asm:7031
PLTCRL           = $3444 = 13380          rom.asm:7318
PLUCDE           = $2990 = 10640          rom.asm:5744
PNORM            = $295E = 10590          rom.asm:5710
PNT2VD           = $0D64 =  3428          rom.asm:1830
PNTEND           = $3208 = 12808          rom.asm:7026 (unused)
POINT            = $31CC = 12748          rom.asm:6997
POKE             = $26E0 =  9952          rom.asm:5332
POPAF            = $23D0 =  9168          rom.asm:4833
POPHL            = $24FA =  9466          rom.asm:5024
POPHRT           = $2A72 = 10866          rom.asm:5891
POPNOK           = $1574 =  5492          rom.asm:2735
POR              = $1FE8 =  8168          rom.asm:4213
POR1             = $200F =  8207          rom.asm:4239
POS              = $2289 =  8841          rom.asm:4639
POSINT           = $1ACF =  6863          rom.asm:3519
POS_CURSOR       = $063C =  1596          rom.asm:953
POS_TB_CRS_32    = $096F =  2415          rom.asm:1418
POS_TB_CRS_40    = $099F =  2463          rom.asm:1422
POUT             = $25EC =  9708          rom.asm:5185
POWER            = $2E24 = 11812          rom.asm:6495
POWER1           = $2E34 = 11828          rom.asm:6503
POWER2           = $2E51 = 11857          rom.asm:6521
POWERS           = $2E04 = 11780          rom.asm:6480
PRINT            = $1C78 =  7288          rom.asm:3751
PRITAB           = $11CC =  4556          rom.asm:2463
PRNTCRLF         = $1CDB =  7387          rom.asm:3800
PRNTFNK          = $0DA9 =  3497          rom.asm:1870
PRNTFNKEY        = $0D6C =  3436          rom.asm:1835
PRNTHL           = $2D1C = 11548          rom.asm:6343
PRNTLP           = $1C7B =  7291          rom.asm:3752
PRNTNB           = $1CBE =  7358          rom.asm:3784
PRNTOK           = $1575 =  5493          rom.asm:2738
PRNTRETURN       = $094E =  2382          rom.asm:1395
PRNTST           = $1CC2 =  7362          rom.asm:3786
PRNTVIDEO        = $81EB = 33259          rom.asm:2052
PRNUMS           = $239A =  9114          rom.asm:4802
PROCES           = $179F =  6047          rom.asm:3061
PROGND           = $81BB = 33211          rom.asm:2026
PROGST           = $8240 = 33344          rom.asm:2080
PROMPT           = $1684 =  5764          rom.asm:2904
PRS              = $239B =  9115          rom.asm:4803
PRS1             = $239E =  9118          rom.asm:4804
PRSLP            = $23A5 =  9125          rom.asm:4807
PRTCHR           = $38A5 = 14501          rom.asm:7898
PRTCKEY          = $38F4 = 14580          rom.asm:7940
PRTEND           = $3901 = 14593          rom.asm:7947
PRTK1            = $38F5 = 14581          rom.asm:7941
PRTK2            = $3864 = 14436          rom.asm:7867 (unused)
PRTK3            = $388D = 14477          rom.asm:7884
PRTK4            = $3862 = 14434          rom.asm:7866
PRTNUM           = $81F7 = 33271          rom.asm:7499
PSG_DAT          = $0041 =    65          rom.asm:53
PSG_REG          = $0040 =    64          rom.asm:52
PSUB             = $28E6 = 10470          rom.asm:5629
PTCHR1           = $38C2 = 14530          rom.asm:7912
PTLN             = $1570 =  5488          rom.asm:2732
PTRLP            = $1609 =  5641          rom.asm:2821
PUTBUF           = $17DA =  6106          rom.asm:3090
PUTCHRBUF        = $0D57 =  3415          rom.asm:1825
PUTCHRBUF1       = $0D9E =  3486          rom.asm:1865
PUTCRSCHR        = $075B =  1883          rom.asm:1112
PUTCTL           = $17DF =  6111          rom.asm:3092
PUTFID           = $19DE =  6622          rom.asm:3366
PXLSET           = $3257 = 12887          rom.asm:7074
PXOR             = $1FED =  8173          rom.asm:4216
PXOR1            = $2017 =  8215          rom.asm:4245
QTSTLP           = $2360 =  9056          rom.asm:4772
QTSTR            = $235A =  9050          rom.asm:4768
QUARTR           = $2FBD = 12221          rom.asm:6698
RADIUS           = $81FB = 33275          rom.asm:7246
RAWPRINT         = $0224 =   548          rom.asm:334
READ             = $1D83 =  7555          rom.asm:3880
READFG           = $81B2 = 33202          rom.asm:2021
READKBLN         = $0C41 =  3137          rom.asm:1685
READ_VIDEO_LOC   = $0600 =  1536          rom.asm:903
READ_VSTAT       = $0635 =  1589          rom.asm:946
RECWRD           = $305B = 12379          rom.asm:6771 (unused)
REDO             = $1D2E =  7470          rom.asm:3844
REM              = $1BC7 =  7111          rom.asm:3655
RESDIV           = $2B10 = 11024          rom.asm:5980
RESEED           = $2F5B = 12123          rom.asm:6654
RESET            = $3A0D = 14861          rom.asm:8125
RESTMR           = $0320 =   800          rom.asm:496
RESTNL           = $1A47 =  6727          rom.asm:3435
RESTOR           = $1A32 =  6706          rom.asm:3424
RESZER           = $2951 = 10577          rom.asm:5698
RETADR           = $2150 =  8528          rom.asm:4434
RETINT           = $2B99 = 11161          rom.asm:6072
RETLIN           = $1BBF =  7103          rom.asm:3649
RETNAD           = $1718 =  5912          rom.asm:2986
RETNUL           = $2153 =  8531          rom.asm:4438
RETNUM           = $1F82 =  8066          rom.asm:4147
RETREL           = $2B8B = 11147          rom.asm:6062
RETURN           = $1BA0 =  7072          rom.asm:3633
RG               = $0004 =     4          rom.asm:2088
RGMSG            = $1202 =  4610          rom.asm:2498
RGPTR            = $1388 =  5000          rom.asm:2525 (unused)
RIGHT            = $256D =  9581          rom.asm:5102
RIGHT1           = $2541 =  9537          rom.asm:5071
RINPUT           = $80AA = 32938          rom.asm:1999
RLTLP            = $1EC5 =  7877          rom.asm:4049
RND              = $2EFA = 12026          rom.asm:6601
RND1             = $2F36 = 12086          rom.asm:6632
RND2             = $2F52 = 12114          rom.asm:6650
RNDTAB           = $2F63 = 12131          rom.asm:6661
RNGTST           = $2DF1 = 11761          rom.asm:6470
RONDB            = $2972 = 10610          rom.asm:5722
RONDUP           = $2971 = 10609          rom.asm:5721
ROUND            = $28D9 = 10457          rom.asm:5623
RPT100           = $050A =  1290          rom.asm:746
RPT101           = $04B1 =  1201          rom.asm:694
RPT102           = $04B4 =  1204          rom.asm:696
RPT103           = $04CA =  1226          rom.asm:709
RPT104           = $04D2 =  1234          rom.asm:713
RPTCL1           = $3408 = 13320          rom.asm:7288
RPTCRL           = $33F5 = 13301          rom.asm:7282
RPTCVB1          = $3588 = 13704          rom.asm:7458
RPTCVB2          = $3591 = 13713          rom.asm:7463
RPTDRW           = $333B = 13115          rom.asm:7195
RPTEMPTYBUF      = $056E =  1390          rom.asm:813
RPTEMPTYROW      = $08B8 =  2232          rom.asm:1310
RPTFLL1          = $05D6 =  1494          rom.asm:873
RPTKBDRD         = $0C96 =  3222          rom.asm:1729
RPTLDCL          = $318D = 12685          rom.asm:6946
RPTNLLSRC        = $08E2 =  2274          rom.asm:1339
RPTNLLSRC2       = $090D =  2317          rom.asm:1363
RPTPS            = $3086 = 12422          rom.asm:6800
RPTRSSR          = $35DD = 13789          rom.asm:7526
RPTWLCMBP        = $0BCD =  3021          rom.asm:1611
RPVOLCG          = $2763 = 10083          rom.asm:5407
RSCALE           = $2CFD = 11517          rom.asm:6323
RST00            = $0000 =     0          rom.asm:75 (unused)
RST08            = $0008 =     8          rom.asm:81 (unused)
RST10            = $0010 =    16          rom.asm:96 (unused)
RST18            = $0018 =    24          rom.asm:102 (unused)
RSTCHRCRS        = $0664 =  1636          rom.asm:975
RSTPSG           = $0BA4 =  2980          rom.asm:1591
RSTSER1          = $35D0 = 13776          rom.asm:7518
RSTSTR           = $2590 =  9616          rom.asm:5122
RSTVDPRAMREG     = $09E9 =  2537          rom.asm:1447
RUN              = $1B5D =  7005          rom.asm:3596
RUNCNT           = $19E2 =  6626          rom.asm:3370
RUNFST           = $164D =  5709          rom.asm:2876
RUNLIN           = $1B81 =  7041          rom.asm:3616
RXA              = $01C8 =   456          rom.asm:268
RXA_EXIT         = $01EE =   494          rom.asm:286
RXEND            = $3645 = 13893          rom.asm:7583
RX_CHA_AVAIL     = $0100 =   256          rom.asm:138
SA               = $002E =    46          rom.asm:2109
SAMSG            = $1361 =  4961          rom.asm:2519
SAPTR            = $13B2 =  5042          rom.asm:2546 (unused)
SAVEXP           = $2952 = 10578          rom.asm:5699
SAVSTP           = $19D5 =  6613          rom.asm:3359
SAVSTR           = $2335 =  9013          rom.asm:4739
SBSCPT           = $215E =  8542          rom.asm:4444
SC               = $002C =    44          rom.asm:2108
SCALE            = $29B0 = 10672          rom.asm:5776
SCALLP           = $29B2 = 10674          rom.asm:5777
SCALMI           = $2CC8 = 11464          rom.asm:6285
SCALPL           = $2CDE = 11486          rom.asm:6299
SCERR            = $37A0 = 14240          rom.asm:7751
SCERR1           = $379C = 14236          rom.asm:7748
SCMSG            = $134C =  4940          rom.asm:2518
SCNEND           = $246C =  9324          rom.asm:4929
SCPTLP           = $2164 =  8548          rom.asm:4448
SCPTR            = $13B0 =  5040          rom.asm:2545 (unused)
SCREEN           = $3097 = 12439          rom.asm:6819
SCROLLNXTRW      = $0862 =  2146          rom.asm:1266
SCROLLUP         = $0849 =  2121          rom.asm:1254
SCR_CURS_X       = $81E4 = 33252          rom.asm:2045
SCR_CURS_Y       = $81E5 = 33253          rom.asm:2046
SCR_CUR_NX       = $81E6 = 33254          rom.asm:2047
SCR_CUR_NY       = $81E7 = 33255          rom.asm:2048
SCR_MODE         = $81E0 = 33248          rom.asm:2043
SCR_NAM_TB       = $81E2 = 33250          rom.asm:2044
SCR_ORG_CHR      = $81E8 = 33256          rom.asm:2049
SCR_SIZE_H       = $81DF = 33247          rom.asm:2042
SCR_SIZE_W       = $81DE = 33246          rom.asm:2041
SCVDP            = $30C3 = 12483          rom.asm:6836
SEARCH           = $16E0 =  5856          rom.asm:2948
SEED             = $8078 = 32888          rom.asm:1988
SENDCHRPTRNS     = $0A21 =  2593          rom.asm:1485
SENDSND          = $0BCA =  3018          rom.asm:1609
SERABITS         = $822F = 33327          rom.asm:2077
SERBUF_START     = $8000 = 32768          rom.asm:63
SERIAL           = $35B6 = 13750          rom.asm:7505
SERIALS_EN       = $822E = 33326          rom.asm:2076
SERLED           = $3606 = 13830          rom.asm:7547
SER_BUFSIZE      = $0058 =    88          rom.asm:59
SER_EMPTYSIZE    = $0005 =     5          rom.asm:61
SER_FULLSIZE     = $0050 =    80          rom.asm:60
SETBEEP          = $0514 =  1300          rom.asm:755
SETBRCL          = $3198 = 12696          rom.asm:6954
SETCRSRY         = $0722 =  1826          rom.asm:1076
SETCSRCOORDS     = $0723 =  1827          rom.asm:1077
SETIO            = $2610 =  9744          rom.asm:5204
SETLIT           = $172A =  5930          rom.asm:2998
SETNAMETABLE     = $05CD =  1485          rom.asm:868
SETPAR           = $3724 = 14116          rom.asm:7691
SETPTR           = $1604 =  5636          rom.asm:2818
SETSER           = $36B2 = 14002          rom.asm:7633
SETSNDREG        = $0BEB =  3051          rom.asm:1626
SETTOP           = $0F24 =  3876          rom.asm:2165
SETVDP           = $30AA = 12458          rom.asm:6827 (unused)
SETVDPADRS       = $05E0 =  1504          rom.asm:882
SET_GFX_MODE     = $09EE =  2542          rom.asm:1454
SET_GFX_MODE2    = $09F6 =  2550          rom.asm:1458
SET_P1           = $36E1 = 14049          rom.asm:7653
SFTPRG           = $15CE =  5582          rom.asm:2781
SGN              = $2B91 = 11153          rom.asm:6069
SGNEXP           = $1FD5 =  8149          rom.asm:4197
SGNRES           = $81CD = 33229          rom.asm:2034
SHOW_LOGO        = $0488 =  1160          rom.asm:675
SHRITE           = $29BF = 10687          rom.asm:5785
SHRLP            = $29C2 = 10690          rom.asm:5787
SHRT1            = $29C6 = 10694          rom.asm:5791
SIGNON           = $0F75 =  3957          rom.asm:2199
SIGNS            = $2BE8 = 11240          rom.asm:6131
SIN              = $2F75 = 12149          rom.asm:6667
SIN1             = $2FA5 = 12197          rom.asm:6687
SINTAB           = $2FC1 = 12225          rom.asm:6700
SIOBFR           = $81FD = 33277          rom.asm:7504
SIO_A_DI         = $017C =   380          rom.asm:217
SIO_A_EI         = $0188 =   392          rom.asm:226
SIO_A_SETS       = $02F1 =   753          rom.asm:453
SIO_B_SETS       = $02F7 =   759          rom.asm:459 (unused)
SIO_CA           = $0022 =    34          rom.asm:42
SIO_CB           = $0023 =    35          rom.asm:43
SIO_DA           = $0020 =    32          rom.asm:44
SIO_DB           = $0021 =    33          rom.asm:45 (unused)
SIXDIG           = $2D44 = 11588          rom.asm:6363
SMPVAR           = $2400 =  9216          rom.asm:4857
SMSER1           = $2ED9 = 11993          rom.asm:6579
SN               = $0002 =     2          rom.asm:2087
SND1             = $27CF = 10191          rom.asm:5466
SND2VID          = $183D =  6205          rom.asm:3152
SNDCHRTOBFR      = $092F =  2351          rom.asm:1379
SNDCLRSET        = $05C3 =  1475          rom.asm:859
SNDKEYTOBFR      = $0D45 =  3397          rom.asm:1817
SNDLOGPT         = $053F =  1343          rom.asm:785
SNDOVR           = $2804 = 10244          rom.asm:5496
SNDREGCFG        = $0BB1 =  2993          rom.asm:1600
SNERR            = $151B =  5403          rom.asm:2689
SNMSG            = $11FB =  4603          rom.asm:2497
SNPTR            = $1386 =  4998          rom.asm:2524 (unused)
SOUND            = $277A = 10106          rom.asm:5425
SPC              = $0020 =    32          rom.asm:1964
SPCFST           = $2D35 = 11573          rom.asm:6355
SPCLP            = $1D1F =  7455          rom.asm:3836
SPEC_RX_CONDITON = $0196 =   406          rom.asm:239
SQR              = $2E1B = 11803          rom.asm:6491
SRCHLIN          = $194A =  6474          rom.asm:3279
SRCHLN           = $1621 =  5665          rom.asm:2840
SRCHLP           = $1624 =  5668          rom.asm:2841
SREG             = $2722 = 10018          rom.asm:5374
SRPT2            = $3600 = 13824          rom.asm:7544
SRTTXT           = $81F1 = 33265          rom.asm:1323
SSTAT            = $2885 = 10373          rom.asm:5574
SSTSA            = $24C8 =  9416          rom.asm:4989
ST               = $001E =    30          rom.asm:2101
STACK            = $813B = 33083          rom.asm:2006
STAKFP           = $2BB3 = 11187          rom.asm:6089
STALL            = $1A5B =  6747          rom.asm:3452
STARTB           = $0EC4 =  3780          rom.asm:2115
STARTEMPTY       = $05BF =  1471          rom.asm:857
STKTHS           = $1F09 =  7945          rom.asm:4090
STLOOK           = $82A4 = 33444          rom.asm:2081
STMSG            = $12D5 =  4821          rom.asm:2511
STOP             = $1A6A =  6762          rom.asm:3462
STORED           = $1B3A =  6970          rom.asm:3576
STPBT            = $81FC = 33276          rom.asm:7503
STPOOL           = $2443 =  9283          rom.asm:4894
STPTR            = $13A2 =  5026          rom.asm:2538 (unused)
STR              = $2325 =  8997          rom.asm:4732
STR1             = $232B =  9003          rom.asm:4734
STRADD           = $2446 =  9286          rom.asm:4896
STRBOT           = $81A8 = 33192          rom.asm:2015
STRE2            = $3338 = 13112          rom.asm:7194 (unused)
STRENT           = $1DDA =  7642          rom.asm:3927
STRPAR           = $3743 = 14147          rom.asm:7707
STRSPC           = $80AD = 32941          rom.asm:2000
STTLIN           = $1CC9 =  7369          rom.asm:3790
SUBCDE           = $28E8 = 10472          rom.asm:5631
SUBPHL           = $28E2 = 10466          rom.asm:5627
SUMLP            = $2EE2 = 12002          rom.asm:6584
SUMSER           = $2ECA = 11978          rom.asm:6572
SUPTLZ           = $2DC3 = 11715          rom.asm:6440
SUP_BPS          = $377B = 14203          rom.asm:7743
SVNAM2           = $20BD =  8381          rom.asm:4353
SVSTAD           = $2353 =  9043          rom.asm:4760
SX               = $81FF = 33279          rom.asm:7127
SY               = $8201 = 33281          rom.asm:7128
SYS              = $268E =  9870          rom.asm:5283
SYSRET           = $26B4 =  9908          rom.asm:5302
TAN              = $2FD6 = 12246          rom.asm:6707
TEMPSTACK        = $818D = 33165          rom.asm:69
TESTALT          = $0CC5 =  3269          rom.asm:1754
TESTCTRL         = $0CD2 =  3282          rom.asm:1760
TESTOS           = $23D2 =  9170          rom.asm:4836
TESTR            = $23B4 =  9140          rom.asm:4816
TM               = $0018 =    24          rom.asm:2098
TMERR            = $152D =  5421          rom.asm:2701
TMMSG            = $12A2 =  4770          rom.asm:2508
TMPBFR1          = $81EF = 33263          rom.asm:2056
TMPBFR2          = $81F1 = 33265          rom.asm:2057
TMPBFR3          = $81F3 = 33267          rom.asm:2058
TMPBFR4          = $81F5 = 33269          rom.asm:2059
TMPKEYBFR        = $822B = 33323          rom.asm:2071
TMPSTR           = $81A4 = 33188          rom.asm:2014
TMPTR            = $139C =  5020          rom.asm:2535 (unused)
TMR              = $2244 =  8772          rom.asm:4598
TMRCNT           = $81CE = 33230          rom.asm:2035
TMSTPL           = $8198 = 33176          rom.asm:2013
TMSTPT           = $8196 = 33174          rom.asm:2012
TOPOOL           = $2539 =  9529          rom.asm:5066
TOSTRA           = $24D1 =  9425          rom.asm:4998
TRYAGN           = $2D9E = 11678          rom.asm:6413
TSALP            = $24D2 =  9426          rom.asm:4999
TSTBIT           = $3A20 = 14880          rom.asm:8136 (unused)
TSTBRK           = $1A4D =  6733          rom.asm:3441
TSTMEM           = $0F12 =  3858          rom.asm:2153
TSTNUM           = $1E9A =  7834          rom.asm:4025
TSTOPL           = $237B =  9083          rom.asm:4788
TSTRED           = $201C =  8220          rom.asm:4251
TSTREM           = $172D =  5933          rom.asm:2999
TSTSGN           = $2B82 = 11138          rom.asm:6057
TSTSPC           = $1950 =  6480          rom.asm:3286
TSTSTR           = $1E9B =  7835          rom.asm:4026
TTYLIN           = $177D =  6013          rom.asm:3046
TXA              = $01F2 =   498          rom.asm:294
TXA_EXIT         = $020B =   523          rom.asm:308
TXTMD            = $0399 =   921          rom.asm:555 (unused)
TX_EMP           = $0213 =   531          rom.asm:317
TYPE             = $8192 = 33170          rom.asm:2009
UF               = $0022 =    34          rom.asm:2103
UFERR            = $1527 =  5415          rom.asm:2697
UFMSG            = $12FF =  4863          rom.asm:2513
UFPTR            = $13A6 =  5030          rom.asm:2540 (unused)
UL               = $000E =    14          rom.asm:2093
ULERR            = $1B9B =  7067          rom.asm:3630
ULMSG            = $1250 =  4688          rom.asm:2503
ULPTR            = $1392 =  5010          rom.asm:2530 (unused)
UNITY            = $29D4 = 10708          rom.asm:5804
UPDATA           = $1A48 =  6728          rom.asm:3436
USR              = $8064 = 32868          rom.asm:1980
VAL              = $25A7 =  9639          rom.asm:5141
VAL1             = $25C5 =  9669          rom.asm:5161
VAL2             = $25CF =  9679          rom.asm:5165
VAL3             = $25D2 =  9682          rom.asm:5166
VALIDX           = $3570 = 13680          rom.asm:7435
VALIDY           = $3575 = 13685          rom.asm:7441
VAREND           = $81BD = 33213          rom.asm:2027
VDPMODESET       = $0A2B =  2603          rom.asm:1499
VDPMODESET1      = $0A33 =  2611          rom.asm:1508 (unused)
VDPMODESET2      = $0A3B =  2619          rom.asm:1518 (unused)
VDPMODESETEX2    = $0A4B =  2635          rom.asm:1538 (unused)
VDPMODESETMC     = $0A43 =  2627          rom.asm:1528 (unused)
VDP_DAT          = $0030 =    48          rom.asm:48
VDP_SET          = $0032 =    50          rom.asm:49
VIDEOBUFF        = $81F7 = 33271          rom.asm:2060
VIDTMP1          = $821F = 33311          rom.asm:2061
VIDTMP2          = $8221 = 33313          rom.asm:2062
VOLCH            = $276F = 10095          rom.asm:5414
VOLUME           = $2741 = 10049          rom.asm:5392
VPEEK            = $26BD =  9917          rom.asm:5312
VPOKE            = $26E5 =  9957          rom.asm:5337
VREG             = $285E = 10334          rom.asm:5552
VSTAT            = $287A = 10362          rom.asm:5567
WAIT             = $25F2 =  9714          rom.asm:5188
WAITLP           = $2607 =  9735          rom.asm:5198
WARM             = $0EC1 =  3777          rom.asm:2113
WARMST           = $0F5C =  3932          rom.asm:2192
WIDTH            = $304E = 12366          rom.asm:6762
WLCBPDAT         = $0BDB =  3035          rom.asm:1621
WLCMBEEP         = $0BC1 =  3009          rom.asm:1606
WORDS            = $0FF3 =  4083          rom.asm:2252
WORDTB           = $1168 =  4456          rom.asm:2364
WRITEBUF         = $089D =  2205          rom.asm:1295
WRITE_VIDEO_LOC  = $0615 =  1557          rom.asm:920
WRITE_VREG       = $062A =  1578          rom.asm:937
WRKSPC           = $805E = 32862          rom.asm:1978
WRTSND           = $2849 = 10313          rom.asm:5534
WRTSNDREG        = $0BF0 =  3056          rom.asm:1631
WTSPC            = $1956 =  6486          rom.asm:3289
X1               = $81EF = 33263          rom.asm:7121
X1GR             = $32E7 = 13031          rom.asm:7167
X2               = $81F7 = 33271          rom.asm:7123
XC               = $81F7 = 33271          rom.asm:7244
XI               = $81FD = 33277          rom.asm:7247
XY2HL            = $325F = 12895          rom.asm:7082
Y1               = $81F1 = 33265          rom.asm:7122
Y1GR             = $330E = 13070          rom.asm:7180
Y2               = $81F9 = 33273          rom.asm:7124
YC               = $81F9 = 33273          rom.asm:7245
YI               = $81FF = 33279          rom.asm:7248
ZDATA            = $0083 =   131          rom.asm:2428
ZDINT            = $00BE =   190          rom.asm:2448 (unused)
ZDIV             = $00BC =   188          rom.asm:2446 (unused)
ZEND             = $0080 =   128          rom.asm:2426
ZEQUAL           = $00C4 =   196          rom.asm:2451
ZERARY           = $21FF =  8703          rom.asm:4547
ZERBYT           = $1498 =  5272          rom.asm:2604
ZEROLP           = $2142 =  8514          rom.asm:4425
ZEROSUP          = $39B4 = 14772          rom.asm:8062
ZFN              = $00B4 =   180          rom.asm:2437
ZFOR             = $0081 =   129          rom.asm:2427
ZGOSUB           = $008C =   140          rom.asm:2430
ZGOTO            = $0088 =   136          rom.asm:2429
ZGTR             = $00C3 =   195          rom.asm:2450
ZLEFT            = $00E4 =   228          rom.asm:2457
ZLTH             = $00C5 =   197          rom.asm:2452
ZMINUS           = $00BA =   186          rom.asm:2444
ZMOD             = $00BD =   189          rom.asm:2447 (unused)
ZNEW             = $00B1 =   177          rom.asm:2433
ZNOT             = $00B7 =   183          rom.asm:2440
ZONELP           = $1CF8 =  7416          rom.asm:3814
ZOR              = $00C2 =   194          rom.asm:2449
ZPLUS            = $00B9 =   185          rom.asm:2443
ZPOINT           = $00DC =   220          rom.asm:2455
ZPRINT           = $00AB =   171          rom.asm:2432
ZREM             = $008E =   142          rom.asm:2431
ZSGN             = $00C6 =   198          rom.asm:2454
ZSPC             = $00B5 =   181          rom.asm:2438
ZSTEP            = $00B8 =   184          rom.asm:2441
ZTAB             = $00B2 =   178          rom.asm:2435
ZTHEN            = $00B6 =   182          rom.asm:2439
ZTIMES           = $00BB =   187          rom.asm:2445 (unused)
ZTO              = $00B3 =   179          rom.asm:2436
_end             = $4B3B = 19259          rom.asm:73 (unused)
_size            = $4B3B = 19259          rom.asm:73 (unused)
absHL            = $3A52 = 14930          rom.asm:8232
basicStarted     = $805D = 32861          rom.asm:67
bufWrap          = $0058 =    88          rom.asm:68
initCTC          = $02FB =   763          rom.asm:468
initPSG          = $0B93 =  2963          rom.asm:1582
initVDP          = $0374 =   884          rom.asm:535
negHL            = $3A55 = 14933          rom.asm:8234
serBufUsed       = $805C = 32860          rom.asm:66
serInPtr         = $8058 = 32856          rom.asm:64
serRdPtr         = $805A = 32858          rom.asm:65


total time: 0.1256 sec.
no errors
