              	; --------------------------------------
              	; zasm: assemble "rom.asm"
              	; date: 2020-04-28 19:30:15
              	; --------------------------------------


              	; 
              	; ------------------------------------------------------------------------------
              	; LM80C - BOOTLOADER - R3.6
              	; ------------------------------------------------------------------------------
              	; The following code is intended to be used with LM80C Z80-based computer
              	; designed by Leonardo Miliani. Code and computer schematics are released under
              	; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
              	; kind of warranty: you can use them at your own risk.
              	; You are free to use them for any non-commercial use: you are only asked to
              	; maintain the copyright notices, include this advice and the note to the 
              	; attribution of the original version to Leonardo Miliani, if you intend to
              	; redistribuite them.
              	; https://www.leonardomiliani.com
              	; 
              	; Please support me by visiting the following links:
              	; Main project page: https://www.leonardomiliani.com
              	; Schematics and code: https://github.com/leomil72/LM80C
              	; Videos about the computer: https://www.youtube.com/user/leomil72/videos
              	; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
              	; ------------------------------------------------------------------------------
              	; Code Revision:
              	; R1.1   - 20190518
              	; R1.2   - 20190521 - Video cursor management - preliminary
              	; R1.3   - 20190601 - Cursor management integrated into VDP module
              	; R1.4   - 20190606 - Removed messages about wrong HW systems
              	; R1.9   - 20190620 - Aligned release version with firmware #
              	; R2.0   - 20190714 - Added SREG & SSTAT to write to/read from PSG
              	; R2.1   - 20190818 - Added SOUND command to play simple tones and VOLUME command
              	; R2.1a  - 20190908 - Cursor management improvements
              	; R2.2   - 20190920 - Fixed cursor bug within SCREEN statement; new command PAUSE
              	; R2.3   - 20190930 - Fixed bugs in SOUND command
              	; R2.4   - 20191013 - Added new graphic chars and reorganized previous ones
              	; R2.4a  - 20191015 - More graphic chars
              	; R2.5   - 20191026 - Revision of init PSG code; revision of serial buffer exp. code;
              	;                     fixed a bug into the video buffer manager
              	; R2.6   - 20191102 - New function INKEY to read a key without a prompt;
              	;                     source code cleaning
              	; R2.7   - 20191116 - Fixed a bug into the INKEY code
              	; R2.8   - 20191207 - Minor bug fixes; added support for built-in keyboard;
              	;                     revision of some char codes;
              	; R2.8.1 - 20191208 - Introduced support for SHIFT key for uppercase letters & alternate chars
              	; R2.8.2 - 20191215 - Fixed a bug introduced with 2.8.1 that lead to wrong functioning of
              	;                     several BASIC statements (system tick counter, Locate, etc..)
              	; R2.9   - 20191222 - Code cleaning; improved SOUND statement; revision of PSG code;
              	;                     revision of release notes; add support for cursor keys & cursor movements
              	; R2.10  - 20191226 - SIO init code cleaning & improved support for serial RX; added extended
              	;                     char codes (128-255) for 6x8 fonts; removed double chars in 8x8 fonts
              	; R2.11  - 20200110 - Set graphics 2 VRAM in a better way; fixed TAB() function; new SCREEN 4 mode;
              	;                     new PLOT, DRAW, and CIRCLE commands
              	; R2.12  - 20200124 - Code optimizing; fixed a bug into the CIRCLE routine; new splash screen
              	;                     with a graphic logo
              	; R2.13  - 20200127 - Implemented ALT & CTRL keys to print graphic chars with keyboard;
              	;                     code improvements; faster cursor flashing
              	; R2.14  - 20200203 - Better CLS code (no more color flashes in graphics modes); added SYS command
              	; R2.15  - 20200225 - Now the computer starts as a stand-alone system, with serial disabled;
              	;                     new SERIAL command
              	; R3.0   - 20200228 - Major changes to kernel, now the computer has a full-screen inline editor:
              	;                     it now acts as an old home computer of the '80s, getting statements from
              	;                     anywhere the cursor is; removed MONITOR statement; code cleaning & optimization;
              	;                     adopted usual hexadecimal & binary prefixes
              	; R3.1   - 20200304 - Added XOR statement; fixed a bug for SERIAL (chars sent over serial were $01);
              	;                     removed NULL statement; added compilation date & time into ROM file
              	; R3.2   - 20200309 - Added sprite size and sprite magnification settings to SCREEN statement;
              	;                     fixed a bug in warm/cold reset input routine
              	; R3.3   - 20200315 - Code cleaning; improved LIST command
              	; R3.4   - 20200329 - Removed POINT and SET statements and their legacies; changed default colors for
              	;                     screens 1 & 4; enhanced serial communication on port 1, fixed freezing bug and
              	;                     added new function to SERIAL statement; fixed TAB function
              	; R3.5   - 20200408 - Fixed a bug into the new code of LIST statement; serial & BASIC buffers expanded
              	;                     to 88 chars; fixed a little bug into editor (pressing RETURN over a multi-line text
              	;                     did not reposition the cursor after the end of it)
              	; R3.6   - 20200419 - Minor improvement in LIST code; fixed a bug in sound management (automatic cutting down
              	;                     of a sound wrongly altered the sound mixer); added management of noise from PSG;
              	;                     fixed some timing issues in VDP access that lead to graphic glitches in graphic mode 2;
              	;                     code improvements
              	;
              	; ------------------------------------------------------------------------------
              	
              	; ADDRESS DECODING (bits A6/A5/A4)
              	; 0000xxxx : PIO
              	; 0001xxxx : CTC
              	; 0010xxxx : SIO
              	; 0011xxxx : VDP
              	; 0100xxxx : PSG
              	
              	; label defining for PIO (Parallel Input/Output)
0000:         	PIO_DA          equ %00000000
0001:         	PIO_DB          equ %00000001
0002:         	PIO_CA          equ %00000010
0003:         	PIO_CB          equ %00000011
              	
              	; label defining for CTC (Counter Timer Circuit)
0010:         	CTC_CH0         equ %00010000
0011:         	CTC_CH1         equ %00010001
0012:         	CTC_CH2         equ %00010010
0013:         	CTC_CH3         equ %00010011
              	
              	;label defining for SIO (Serial Input/Output)
0022:         	SIO_CA          equ %00100010
0023:         	SIO_CB          equ %00100011
0020:         	SIO_DA          equ %00100000
0021:         	SIO_DB          equ %00100001
              	
              	;label defining for VDP (Video Display Processor)
0030:         	VDP_DAT         equ %00110000
0032:         	VDP_SET         equ %00110010
              	
              	; label defining for PSG (Programmable Sound Generator)
0040:         	PSG_REG         equ %01000000
0041:         	PSG_DAT         equ %01000001
              	
              	; Interrupt-driven serial I/O interface lead by the Z80 SIO to run modified
              	; NASCOM Basic 4.7 - Full input buffering with incoming data hardware handshaking
              	; Handshake shows full before the buffer is totally filled to allow run-on from the sender
              	
0058:         	SER_BUFSIZE     equ     $58
0050:         	SER_FULLSIZE    equ     $50
0005:         	SER_EMPTYSIZE   equ     $05
              	
8000:         	SERBUF_START    equ     $8000           ; RAM starts here
8058:         	serInPtr        equ     SERBUF_START + SER_BUFSIZE
805A:         	serRdPtr        equ     serInPtr+2
805C:         	serBufUsed      equ     serRdPtr+2
805D:         	basicStarted    equ     serBufUsed+1
0058:         	bufWrap         equ     (SERBUF_START + SER_BUFSIZE) & $FF
8108:         	TEMPSTACK       equ     CURPOS - 3      ; top of BASIC line input buffer so is "free ram" when BASIC resets
              	
              	;------------------------------------------------------------------------------
              	; BASE MEMORY - RESET LOCATION - $0000
              	; the CPU jumps to 0000h after a reset
0000:         	                org     $0000
0000: F3      	RST00:          di                      ; be sure that INTs are disabled
0001: C35102  	                jp      INIT_HW         ; jump to system initialization
              	
              	;------------------------------------------------------------------------------
              	; send a character over serial
0004: FFFFFFFF	                org     $0008
0008: C3F201  	RST08:          jp      TXA
              	
              	;------------------------------------------------------------------------------
              	; interrupt vector when SIO has a char available in its buffer
000B: FF      	                org     $000C
000C: 0001    	                defw    RX_CHA_AVAIL
              	
              	;------------------------------------------------------------------------------
              	; interrupt vector for SIO special conditions (i.e. buf overrun)
              	                org     $000E
000E: 9601    	                defw    SPEC_RX_CONDITON
              	
              	;------------------------------------------------------------------------------
              	; receive a character over serial
              	                org     $0010
0010: C3C801  	RST10:          jp      RXA
              	
              	;------------------------------------------------------------------------------
              	; interrupt vector for CH3 Timer - used for 100ths/s counter
0013: FFFFFF  	                org     $0016
0016: 3202    	                defw    CH3_TIMER
              	
              	;------------------------------------------------------------------------------
              	; check serial status
              	
              	                org     $0018
0018: C31F02  	RST18:          jp      CKINCHAR
              	
              	;------------------------------------------------------------------------------
              	; interrupt routine for NMI (currently NOT used)
001B: FFFFFFFF	                org     $0066
001F: FF...   	
0066: ED45    	                retn                    ; return from NMI
              	
              	;------------------------------------------------------------------------------
              	
0068: FFFFFFFF	                org     $00A0
006C: FF...   	
00A0: 4C4D3830	                defb    $4C,$4D,$38,$30,$43,$20,$43,$4F
00A4: 4320434F	
00A8: 4C4F5200	                defb    $4C,$4F,$52,$00,$00,$00,$00,$00
00AC: 00000000	
00B0: 434F4D50	                defb    $43,$4F,$4D,$50,$55,$54,$45,$52
00B4: 55544552	
00B8: 20283230	                defb    $20,$28,$32,$30,$32,$30,$29,$00
00BC: 32302900	
00C0: 44657369	                defb    $44,$65,$73,$69,$67,$6E,$65,$64
00C4: 676E6564	
00C8: 20627900	                defb    $20,$62,$79,$00,$00,$00,$00,$00
00CC: 00000000	
00D0: 4C656F6E	                defb    $4C,$65,$6F,$6E,$61,$72,$64,$6F
00D4: 6172646F	
00D8: 204D696C	                defb    $20,$4D,$69,$6C,$69,$61,$6E,$69
00DC: 69616E69	
00E0: 46572033	FWVER:          defm    'FW 3.6',$20,__date__,$20,__time__,$00
00E4: 2E362032	
00E8: 3032302D	
00EC: 30342D32	
00F0: 38203139	
00F4: 3A33303A	
00F8: 313500  	
              	;------------------------------------------------------------------------------
              	; interrupt driven routine to get chars from Z80 SIO
00FB: FFFFFFFF	                org     $0100
00FF: FF      	
0100: F5      	RX_CHA_AVAIL:   push    AF              ; store A
0101: E5      	                push    HL              ; and HL
0102: CD6001  	                call    A_RTS_OFF       ; disable RTS line
0105: DB20    	                in      A,(SIO_DA)      ; read char from RX buffer into A
0107: 329A81  	                ld      (TMPKEYBFR),A   ; store it into the temp key buffer
010A: CD3301  	                call    CHARINTOBFR     ; sub-routine to put the char into the input buffer
010D: 3A9A81  	                ld      A,(TMPKEYBFR)   ; retrieve char
0110: 325B81  	                ld      (CHR4VID),A     ; write into buffer for video printing
0113: FE0D    	                cp      CR              ; is it RETURN?
0115: CA1D01  	                jp      Z,CNTRXCHA      ; yes, continue
0118: FE20    	                cp      $20             ; is it another control char (code < 32)?
011A: DA2E01  	                jp      C,LVRXCHA       ; yes, leave w/o printing it on video nor sending back to serial
011D: F5      	CNTRXCHA:       push    AF              ; store char
011E: AF      	                xor     A
011F: 329881  	                ld      (KBDNPT),A      ; a char from serial is like a char printed by BASIC
0122: 3A5A81  	                ld      A,(PRNTVIDEO)   ; load status of print-on-video
0125: FE01    	                cp      $01             ; is the print on video on?
0127: CC8B06  	                call    Z,CHAR2VID      ; yes, print on screen
012A: F1      	                pop     AF              ; retrieve char
012B: CDF201  	                call    TXA             ; send back to serial
012E: E1      	LVRXCHA:        pop     HL              ; retrieve HL
012F: F1      	                pop     AF              ; and A
0130: FB      	                ei                      ; re-enable interrupts
0131: ED4D    	                reti                    ; and exit
              	
              	; put a char into the input buffer, char is into A
              	; this sub is called both from the ISR "RX_CHA_AVAIL" and when
              	; the RETURN key is pressed on the keyboard
0133: F5      	CHARINTOBFR:    push    AF              ; store it
0134: 3A5C80  	                ld      A,(serBufUsed)  ; load buffer size
0137: FE58    	                cp      SER_BUFSIZE     ; if buffer is not full
0139: 2002    	                jr      NZ,NOTFULL      ; then store the char
013B: F1      	                pop     AF              ; else drop it
013C: C9      	                ret                     ; and exit
013D: 2A5880  	NOTFULL:        ld      HL,(serInPtr)   ; buffer is not full, can store the char
0140: 23      	                inc     HL              ; load pointer to find first free cell
0141: 7D      	                ld      A,L             ; only check low byte because buffer<256
0142: FE58    	                cp      bufWrap         ; check if the pointer is at the last cell
0144: 2003    	                jr      NZ,NOTWRAP      ; if not then continue
0146: 210080  	                ld      HL,SERBUF_START ; else load the address of the first cell
0149: 225880  	NOTWRAP:        ld      (serInPtr),HL   ; store the new pointer
014C: F1      	                pop     AF              ; then recover the char
014D: 77      	                ld      (HL),A          ; and store it in the appropriate cell
014E: 3A5C80  	                ld      A,(serBufUsed)  ; load the size of the input buffer
0151: 3C      	                inc     A               ; increment it
0152: 325C80  	                ld      (serBufUsed),A  ; and store the new size
0155: FE50    	                cp      SER_FULLSIZE    ; check if input buffer is full
0157: D8      	                ret     C               ; exit if buffer is not full
0158: 3A9D81  	                ld      A,(SERIALS_EN)  ; check if serial 1 is open
015B: 1F      	                rra                     ; bit 0 into Carry: if Carry is 1 then serial 0 is open and...
015C: DC6001  	                call    C,A_RTS_OFF     ; ...stop receiving further chars
015F: C9      	                ret
              	
              	;-------------------------------------------------------------------------------
              	; Z80 SIO MANAGEMENT
              	;-------------------------------------------------------------------------------
              	; disable RTS:
              	; by resetting RTS bit (set to 0), the RTS line is disabled (HIGH)
0160: F5      	A_RTS_OFF:      push    AF              ; store A
0161: 3E05    	                ld      A,%00000101     ; write into WR0: select WR5
0163: D322    	                out     (SIO_CA),A
0165: 3A9E81  	                ld      A,(SERABITS)    ; load data bits
0168: F628    	                or      %00101000       ; TX enable; RTS disable
016A: D322    	                out     (SIO_CA),A      ; send setting
016C: F1      	                pop     AF              ; retrieve A
016D: C9      	                ret                     ; exit
              	
              	; enable RTS
              	; by setting RTS bit (set to 1), the RTS line is enabled (LOW)
016E: F5      	A_RTS_ON:       push    AF              ; store A
016F: 3E05    	                ld      A,%00000101     ; write into WR0: select WR5
0171: D322    	                out     (SIO_CA),A
0173: 3A9E81  	                ld      A,(SERABITS)    ; load data bits
0176: F62A    	                or      %00101010       ; TX enable; RTS enable
0178: D322    	                out     (SIO_CA),A      ; send setting
017A: F1      	                pop     AF              ; retrieve A
017B: C9      	                ret                     ; return
              	
              	; disable SIO RX channel A
017C: F5      	SIO_A_DI:       push    AF              ; store A
017D: 3E03    	                ld      A,%00000011     ; write into WR0: select WR3
017F: D322    	                out     (SIO_CA),A
0181: 3A9E81  	                ld      A,(SERABITS)    ; load the serial bits; RX disabled; auto enable is OFF
0184: D322    	                out     (SIO_CA),A
0186: F1      	                pop     AF              ; retrieve A
0187: C9      	                ret                     ; return
              	
              	; enable SIO RX channel A
0188: F5      	SIO_A_EI:       push    AF              ; store A
0189: 3E03    	                ld      A,%00000011     ; write into WR0: select WR3
018B: D322    	                out     (SIO_CA),A      ; select register
018D: 3A9E81  	                ld      A,(SERABITS)    ; load the serial data bits
0190: CBC7    	                set     0,A             ; set RX enabled; auto enable is OFF
0192: D322    	                out     (SIO_CA),A      ; send setting to SIO
0194: F1      	                pop     AF              ; retrieve A
0195: C9      	                ret
              	
              	
              	; special SIO condition (i.e., buffer overrun)
              	; if buffer overruns then show an error, empty the RX buffer and send
              	; a break char
0196:         	SPEC_RX_CONDITON:
0196: F5      	                push    AF
0197: E5      	                push    HL
0198: CD6001  	                call    A_RTS_OFF       ; disable RTS
019B: CD7C01  	                call    SIO_A_DI        ; disable RX on ch. A
019E: 3A9D81  	                ld      A,(SERIALS_EN)  ; load serial status
01A1: CB97    	                res     2,A             ; disable RX on port 1
01A3: 329D81  	                ld      (SERIALS_EN),A  ; store new serial status 
01A6: DB01    	                in      A,(PIO_DB)      ; read status LEDs
01A8: CBE7    	                set     4,A             ; set 5th pin ON
01AA: D301    	                out     (PIO_DB),A      ; send new setting
01AC: 3E30    	                ld      A,%00110000     ; write into WR0: error reset, select WR0
01AE: D322    	                out     (SIO_CA),A      ; send command to SIO
01B0: 3E03    	                ld      A,CTRLC
01B2: CD3301  	                call    CHARINTOBFR     ; send CTRL-C to BASIC
01B5: AF      	EMPTYCHABFR:    xor     A
01B6: D322    	                out     (SIO_CA),A      ; write to WR0, select RR0
01B8: DB22    	                in      A,(SIO_CA)      ; read RR0 register
01BA: E601    	                and     $01             ; check if input buffer if empty
01BC: CAC301  	                jp      Z,CHABFREMPTY   ; if yes (bit 0 = 0) then leave
01BF: DB20    	                in      A,(SIO_DA)      ; read chars
01C1: 18F2    	                jr      EMPTYCHABFR     ; repeat
01C3: E1      	CHABFREMPTY:    pop     HL
01C4: F1      	                pop     AF
01C5: FB      	                ei                      ; re-enable interrupts
01C6: ED4D    	                reti                    ; return from interrupt
              	
              	;------------------------------------------------------------------------------
              	; retrieve a char from the input buffer
01C8: 3A5C80  	RXA:            ld      A,(serBufUsed)  ; load the buffer size
01CB: A7      	                and     A               ; check if it's 0 (empty)
01CC: CAC801  	                jp      Z,RXA           ; if it's empty, wait for a char
01CF: F3      	                di                      ; disable interrupts
01D0: E5      	                push    HL              ; store HL
01D1: 2A5A80  	                ld      HL,(serRdPtr)   ; load pointer to first available char
01D4: 23      	                inc     HL              ; increment it (go to the next char)
01D5: 7D      	                ld      A,L             ; check if the end of the buffer has been reached
01D6: FE58    	                cp      bufWrap         ; (only check low byte because buffer<256)
01D8: 2003    	                jr      NZ,NOTRDWRAP    ; if not, jump straight
01DA: 210080  	                ld      HL,SERBUF_START ; else reload the starting address of the buffer
01DD: 225A80  	NOTRDWRAP:      ld      (serRdPtr),HL   ; store new pointer to the next char to read
01E0: 3A5C80  	                ld      A,(serBufUsed)  ; load buffer size
01E3: 3D      	                dec     A               ; decrement it
01E4: 325C80  	                ld      (serBufUsed),A  ; and store the new size
01E7: FE05    	                cp      SER_EMPTYSIZE   ; check if input buffer can be considered empty
01E9: 3003    	                jr      NC,RXA_EXIT     ; if not empty yet, then exit
01EB: CD6E01  	                call    A_RTS_ON        ; else re-enable receiving chars
01EE: 7E      	RXA_EXIT:       ld      A,(HL)          ; recover the char and return it into A
01EF: E1      	                pop     HL              ; retrieve HL
01F0: FB      	                ei                      ; re-enable interrupts
01F1: C9      	                ret                     ; return
              	
              	;------------------------------------------------------------------------------
              	; sends a char over the serial (trick for INTs from WikiTI)
              	; char is into A
01F2: F5      	TXA:            push    AF              ; store AF
01F3: C5      	                push    BC              ; store BC
01F4: 47      	                ld      B,A             ; store char
01F5: ED57    	                ld      A,I             ; when loading I into A, P/V is set to the value of IFF (P/V is set if INTs enabled)
01F7: EAFC01  	                jp      PE,CNTTXA       ; if set, jump over
01FA: ED57    	                ld      A,I             ; if not set, test again to fix "false negative" from interrupt occurring at first test
01FC: F5      	CNTTXA:         push    AF              ; store current P/V flag
01FD: F3      	                di                      ; disable INTs
01FE: 3A9D81  	                ld      A,(SERIALS_EN)  ; load serial status
0201: FE05    	                cp      %00000101       ; check if serial 1 is open and RX/TX is enabled 
0203: 2006    	                jr      NZ,TXA_EXIT     ; no, jump over
0205: 78      	                ld      A,B             ; retrieve char
0206: D320    	                out     (SIO_DA),A      ; send char to the SIO
0208: CD1302  	                call    TX_EMP          ; wait for outgoing char to be sent
020B: F1      	TXA_EXIT:       pop     AF              ; retrieve P/V flag
020C: E21002  	                jp      PO,EXTXA        ; if P is reset, INTs were disabled so we can leave right now
020F: FB      	                ei                      ; INTs were enabled, so re-enable interrupts
0210: C1      	EXTXA:          pop     BC              ; retrieve BC
0211: F1      	                pop     AF              ; retrieve AF
0212: C9      	                ret                     ; return
              	
              	;------------------------------------------------------------------------------
              	; wait until outgoing serial has been sent
0213: 97      	TX_EMP:         sub     A               ; set A to 0
0214: 3C      	                inc     A               ; set A to 1
0215: D322    	                out     (SIO_CA),A      ; write to WR0, select RR1
0217: DB22    	                in      A,(SIO_CA)      ; read RR1 register
0219: CB47    	                bit     0,A             ; check if all chars have been sent
021B: CA1302  	                jp      Z,TX_EMP        ; if not (bit 0 = 0) then retrieve
021E: C9      	                ret                     ; else exit
              	
              	
              	;------------------------------------------------------------------------------
              	; check if there is some chars into the buffer
021F: 3A5C80  	CKINCHAR        ld      A,(serBufUsed)  ; load char in buffer
0222: A7      	                and     A               ; compare to 0
0223: C9      	                ret                     ; return
              	
              	;------------------------------------------------------------------------------
              	; print a text from memory, and terminate when $00 is found
0224: 7E      	RAWPRINT:       ld      A,(HL)          ; load character from memory cell pointed by HL
0225: B7      	                or      A               ; is it $00 (end string)?
0226: C8      	                ret     Z               ; Yes, then return
0227: 325B81  	                ld      (CHR4VID),A     ; store char
022A: F3      	                di
022B: CD8B06  	                call    CHAR2VID        ; and send it to screen
022E: FB      	                ei
022F: 23      	                inc     HL              ; and select the next one
0230: 18F2    	                jr      RAWPRINT        ; repeat
              	
              	;-------------------------------------------------
              	; Interrupt service routine (ISR) for CH3 timer
              	; this is used to increment the 100ths of a second counter and for cursor flashing
0232: F5      	CH3_TIMER:      push    AF              ; save regs. A,
0233: C5      	                push    BC              ; BC,
0234: D5      	                push    DE              ; DE,
0235: E5      	                push    HL              ; HL
0236: 214981  	                ld      HL,TMRCNT       ; load starting address of the timer
0239: 0604    	                ld      B,$04           ; 4 bytes to check
023B: 34      	INCTMR3:        inc     (HL)            ; increment timer
023C: 2003    	                jr      NZ,CHKCRSR      ; if not zero then exit (finished increment)
023E: 23      	                inc     HL              ; if yes, there was an overflow, so increment next byte
023F: 10FA    	                djnz    INCTMR3         ; repeat for 4 bytes
0241: CD2407  	CHKCRSR:        call    FLASHCURSOR     ; call the flashing cursor routine
0244: CDDE0B  	                call    MNGSNDS         ; call the tone managemenet
0247: CD3F0C  	                call    KEYBOARD        ; read the keyboard inputs
024A: E1      	                pop     HL              ; retrieve HL,
024B: D1      	                pop     DE              ; DE,
024C: C1      	                pop     BC              ; BC,
024D: F1      	                pop     AF              ; and A
024E: FB      	                ei                      ; re-enable interrupts
024F: ED4D    	                reti                    ; exit from ISR
              	
              	;------------------------------------------------------------------------------
              	;------------------------------------------------------------------------------
              	; HARDWARE INITIALISATION
              	; first run - setup HW & SW
              	;
0251: 210881  	INIT_HW:        ld      HL,TEMPSTACK    ; load temp stack pointer
0254: F9      	                ld      SP,HL           ; set stack to temp stack pointer
0255: 210080  	                ld      HL,SERBUF_START ; set beginning of input buffer
0258: 225880  	                ld      (serInPtr),HL   ; for incoming chars to store into buffer
025B: 225A80  	                ld      (serRdPtr),HL   ; and for chars to be read from buffer
025E: AF      	                xor     A               ; reset A
025F: 325C80  	                ld      (serBufUsed),A  ; actual buffer size is 0
0262: 329D81  	                ld      (SERIALS_EN),A  ; set serial ports status to OFF
0265: CDD602  	                call    HELLOWRLD       ; little serial blink with LEDs
0268: CDFB02  	                call    initCTC         ; configure CTC, then...
026B: CD7C0B  	                call    initPSG         ; ...configure PSG
026E: CD7104  	                call    SHOW_LOGO       ; show computer logo
0271: 1E01    	                ld      E,$01           ; E chooses the video mode: 1:graphics 1
0273: CD5D03  	                call    initVDP         ; set video display
0276: AF      	                xor     A
0277: ED47    	                ld      I,A             ; set high byte of interrupt vectors to point to page 0
0279: ED5E    	                im      2               ; interrupt mode 2
027B: FB      	                ei                      ; enable interrupts
              	                ; print system messages
027C: AF      	                xor     A               ; A=0 so...
027D: 329881  	                ld      (KBDNPT),A      ; ...inputs don't come from keyboard
0280: 3C      	                inc     A               ; A=1...
0281: 325A81  	                ld      (PRNTVIDEO),A   ; ...to activate the print-on-video
0284: 211A03  	                ld      HL,MSGTXT1      ; sign-on message
0287: CD2402  	                call    RAWPRINT        ; print message
028A: CD1508  	                call    CURSOR_ON       ; enable cursor
028D: 3A5D80  	                ld      A,(basicStarted); check if BASIC is already started
0290: FE59    	                cp      'Y'             ; to see if this is a power-up
0292: 2016    	                jr      NZ,COLDSTART    ; if not, then do a COLD start
0294: 214303  	                ld      HL,MSGTXT2      ; message to choose kind of start
0297: CD2402  	                call    RAWPRINT        ; print message
029A: AF      	                xor     A
029B: 325A81  	                ld      (PRNTVIDEO),A   ; disable print-on-video
029E: CDC801  	CORW:           call    RXA             ; look for a pressed key
02A1: E6DF    	                and     %11011111       ; only UPPERCASE char
02A3: FE43    	                cp      'C'             ; cold start?
02A5: 200B    	                jr      NZ,CHECKWARM    ; no, let's check for warm start
02A7: CDBC02  	                call    ECHO_CHAR       ; echoes the char
02AA: 3E59    	COLDSTART:      ld      A,'Y'           ; yes, set the "BASIC started" flag
02AC: 325D80  	                ld      (basicStarted),A
02AF: C3470E  	                jp      COLD            ; start BASIC COLD
02B2: FE57    	CHECKWARM:      cp      'W'
02B4: 20E8    	                jr      NZ,CORW         ; char not recognized, wait again
02B6: CDBC02  	                call    ECHO_CHAR       ; echoes the char
02B9: C34A0E  	                jp      WARM            ; start BASIC WARM
              	
              	;-------------------------------------------------------------------------------
02BC: 325B81  	ECHO_CHAR:      ld      (CHR4VID),A     ; set char for video printing
02BF: AF      	                xor     A
02C0: 329881  	                ld      (KBDNPT),A      ; input is not from keyboard
02C3: F3      	                di                      ; disable INTs
02C4: CD8B06  	                call    CHAR2VID        ; echoes back the pressed key,
02C7: 3E0D    	                ld      A,CR            ; then set a CR
02C9: 325B81  	                ld      (CHR4VID),A     ; set char for video printing
02CC: CD8B06  	                call    CHAR2VID        ; and send it to screen
02CF: FB      	                ei                      ; re-enable INTs
02D0: 3E01    	                ld      A,$01
02D2: 325A81  	                ld      (PRNTVIDEO),A   ; re-enable video printing
02D5: C9      	                ret                     ; return to caller
              	                
              	;-------------------------------------------------------------------------------
              	; little serial blink with LEDs
02D6: 0E09    	HELLOWRLD:      ld      C,$09           ; 8 LEDs to be turned off + 1 more step to turn off the last LED
02D8: 3ECF    	                ld      A,%11001111     ; set mode 3 (mode control)
02DA: D303    	                out     (PIO_CB),A      ; for PIO port B
02DC: AF      	                xor     A               ; set pins to OUTPUT
02DD: D303    	                out     (PIO_CB),A      ; for port B
02DF: 3C      	                inc     A               ; LSB on
02E0: D301    	LEDLIGHT:       out     (PIO_DB),A      ; turn LEDs on/off for a "Supercar" sequence
02E2: 1E20    	                ld      E,$20           ; little delay
02E4: 0600    	DEC_E:          ld      B,$00           ; count to 256
02E6: 10FE    	COUNTER:        djnz    COUNTER         ; decrement inner counter
02E8: 1D      	                dec     E               ; decrement outer counter
02E9: 20F9    	                jr      NZ,DEC_E        ; finish delay
02EB: CB27    	                sla     A               ; shift reg.A to left 1 bit
02ED: 0D      	                dec     C               ; next LED
02EE: 20F0    	                jr      NZ,LEDLIGHT     ; all LEDs done? no, repeat
02F0: C9      	                ret                     ; return to caller
              	
              	;-------------------------------------------------------------------------------
              	; Z80 SIO default settings for channel A
02F1: 30      	SIO_A_SETS:     defb    %00110000       ; write into WR0: error reset, select WR0
02F2: 18      	                defb    %00011000       ; write into WR0: channel reset
02F3: 04      	                defb    %00000100       ; write into WR0: select WR4
02F4: 44      	                defb    %01000100       ; write into WR4: presc. 16x, 1 stop bit, no parity
02F5: 05      	                defb    %00000101       ; write into WR0: select WR5
02F6: E8      	                defb    %11101000       ; write into WR5: DTR on, TX 8 bits, BREAK off, TX on, RTS off
02F7: 01      	SIO_B_SETS:     defb    %00000001       ; write into WR0: select WR1
02F8: 04      	                defb    %00000100       ; write into WR1: status affects interrupt vectors
02F9: 02      	                defb    %00000010       ; write into WR0: select WR2
02FA: 00      	                defb    %00000000       ; write into WR2: set interrupt vector, but bits D3/D2/D1 of this vector
              	                                        ; will be affected by the channel & condition that raised the interrupt
              	                                        ; (see datasheet): in our example, 0x0C for Ch.A receiving A char, 0x0E
              	                                        ; for special conditions
              	;------------------------------------------------------------------------------
              	; Z80 CTC setting up
02FB:         	initCTC:
              	;CH0, CH1, & CH2 disabled
02FB: 3E03    	                ld      A,%00000011     ; interrupt off, timer mode, prescaler=16, don't care ext. TRG edge,
              	                                        ; start timer on loading constant, no time constant follows, software reset, command word
02FD: D310    	                out     (CTC_CH0),A     ; set CH0
02FF: D311    	                out     (CTC_CH1),A     ; set CH1
0301: D312    	                out     (CTC_CH2),A     ; set CH2
              	
              	;init CH3
              	;CH3 divides CPU CLK by 144*256 providing an interrupt signal at 100 Hz (1/100 sec).
              	;f = CPU_CLK/(144*256) => 3,686,400 / ( 36,864 ) => 100Hz
0303: 3EA7    	                ld      A,%10100111     ; interrupt on; timer mode; prescaler=256; don't care ext; automatic trigger;
              	                                        ; time constant follows; cont. operation; command word
0305: D313    	                out     (CTC_CH3),A     ; send to CH3
0307: 3E90    	                ld      A,$90           ; time constant - 90$ (144d)
0309: D313    	                out     (CTC_CH3),A     ; send to CH3
030B: 3E10    	                ld      A,%00010000     ; D7..D3 provide the first part of the int vector (in our case, $10), followed by
              	                                        ; D2..D1, provided by the CTC (they point to the channel), d0=interrupt word
              	                                        ; so int vector is 00010xx00
030D: D310    	                out     (CTC_CH0),A     ; send to CTC
              	                ; reset cells of 100ths of a second counter
030F: AF      	                xor     A               ; reset A
0310: 214981  	                ld      HL,TMRCNT       ; load TMR pointer
0313: 0604    	                ld      B,$04           ; 4 memory cells
0315: 77      	RESTMR:         ld      (HL),A          ; reset n-cell of TMR
0316: 23      	                inc     HL              ; next cell
0317: 10FC    	                djnz    RESTMR          ; repeat for 4 cells
0319: C9      	                ret
              	
              	;------------------------------------------------------------------------------
031A: 4C4D3830	MSGTXT1:        defm    "LM80C by Leonardo Miliani",CR
031E: 43206279	
0322: 204C656F	
0326: 6E617264	
032A: 6F204D69	
032E: 6C69616E	
0332: 690D    	
0334: 4669726D	                defm    "Firmware R3.6",CR,0
0338: 77617265	
033C: 2052332E	
0340: 360D00  	
0343: 0D      	MSGTXT2:        defb    CR
0344: 3C433E6F	                defm    "<C>old or <W>arm start? ",0
0348: 6C64206F	
034C: 72203C57	
0350: 3E61726D	
0354: 20737461	
0358: 72743F20	
035C: 00      	
              	; ------------------------------------------------------------------------------
              	; LM80C - VDP ROUTINES - R3.6
              	; ------------------------------------------------------------------------------
              	; The following code is intended to be used with LM80C Z80-based computer
              	; designed by Leonardo Miliani. Code and computer schematics are released under
              	; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
              	; kind of warranty: you can use them at your own risk.
              	; You are free to use them for any non-commercial use: you are only asked to
              	; maintain the copyright notices, include this advice and the note to the 
              	; attribution of the original version to Leonardo Miliani, if you intend to
              	; redistribuite them.
              	; https://www.leonardomiliani.com
              	; 
              	; Please support me by visiting the following links:
              	; Main project page: https://www.leonardomiliani.com
              	; Schematics and code: https://github.com/leomil72/LM80C
              	; Videos about the computer: https://www.youtube.com/user/leomil72/videos
              	; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
              	; ------------------------------------------------------------------------------
              	; Code Revision:
              	; R1.0   - 20190511 - First version
              	; R1.1   - 20190512
              	; R1.2   - 20190515
              	; R1.3   - 20190521 - Video cursor management - preliminary
              	; R1.4   - 20190524 - Added scrolling capabilities
              	; R1.5   - 20190524 - Added backspace functionality
              	; R1.6   - 20190601 - Fixed scrolling bugs
              	; R1.7   - 20190606 - Show the computer name only at powerup
              	; R1.8   - 20190615 - Better cursor integration; added VPOKE & VPEEK statements; 6x8 & 8x8 fonts
              	; R1.9   - 20190620 - Added functions to read/write VDP registers
              	; R2.0   - 20190714 - Added SREG & SSTAT to write to/read from PSG
              	; R2.1   - 20190818 - Added SOUND command to play simple tones and VOLUME command
              	; R2.1a  - 20190908 - Cursor management improvements
              	; R2.2   - 20190920 - Fixed cursor bug within SCREEN statement; new command PAUSE
              	; R2.3   - 20190930 - Fixed bugs in SOUND command
              	; R2.4   - 20191013 - Added new graphic chars and reorganized previous ones
              	; R2.4a  - 20191015 - More graphic chars
              	; R2.5   - 20191026 - Revision of init PSG code; revision of serial buffer exp. code;
              	;                     fixed a bug into the video buffer manager
              	; R2.6   - 20191102 - New function INKEY to read a key without a prompt;
              	;                     source code cleaning
              	; R2.7   - 20191116 - Fixed a bug into the INKEY code
              	; R2.8   - 20191207 - Minor bug fixes; added support for built-in keyboard;
              	;                     revision of some char codes;
              	; R2.8.1 - 20191208 - Introduced support for SHIFT key for uppercase letters & alternate chars
              	; R2.8.2 - 20191215 - Fixed a bug introduced with 2.8 that lead to wrong functioning of
              	;                     several BASIC statements (system tick counter, Locate, etc..)
              	; R2.9   - 20191222 - Code cleaning; improved SOUND statement; revision of PSG code;
              	;                     revision of release notes; add support for cursor keys & cursor movements
              	; R2.10  - 20191226 - SIO init code cleaning & improved support for serial RX; added extended
              	;                     char codes (128-255) for 6x8 fonts; removed double chars in 8x8 fonts
              	; R2.11  - 20200110 - Set graphics 2 VRAM in a better way; fixed TAB() function; new SCREEN 4 mode;
              	;                     new PLOT, DRAW, and CIRCLE commands
              	; R2.12  - 20200124 - Code optimizing; fixed a bug into the CIRCLE routine; new splash screen
              	;                     with a graphic logo
              	; R2.13  - 20200127 - Implemented ALT & CTRL keys to print graphic chars with keyboard;
              	;                     code improvements; faster cursor flashing
              	; R2.14  - 20200203 - Better CLS code (no more color flashes in graphics modes); added SYS command
              	; R2.15  - 20200225 - Now the computer starts as a stand-alone system, with serial disabled;
              	;                     new SERIAL command
              	; R3.0   - 20200228 - Major changes to kernel, now the computer has a full-screen inline editor:
              	;                     it now acts as an old home computer of the '80s, getting statements from
              	;                     anywhere the cursor is; removed MONITOR statement; code cleaning & optimization;
              	;                     adopted usual hexadecimal & binary prefixes
              	; R3.1   - 20200304 - Added XOR statement; fixed a bug for SERIAL (chars sent over serial were $01);
              	;                     removed NULL statement; added compilation date & time into ROM file
              	; R3.2   - 20200309 - Added sprite size and sprite magnification settings to SCREEN statement;
              	;                     fixed a bug in warm/cold reset input routine
              	; R3.3   - 20200315 - Code cleaning; improved LIST command
              	; R3.4   - 20200329 - Removed POINT and SET statements and their legacies; changed default colors for
              	;                     screens 1 & 4; enhanced serial communication on port 1, fixed freezing bug and
              	;                     added new function to SERIAL statement; fixed TAB function
              	; R3.5   - 20200408 - Fixed a bug into the new code of LIST statement; serial & BASIC buffers expanded
              	;                     to 88 chars; fixed a little bug into editor (pressing RETURN over a multi-line text
              	;                     did not reposition the cursor after the end of it)
              	; R3.6   - 20200419 - Minor improvement in LIST code; fixed a bug in sound management (automatic cutting down
              	;                     of a sound wrongly altered the sound mixer); added management of noise from PSG;
              	;                     fixed some timing issues in VDP access that lead to graphic glitches in graphic mode 2;
              	;                     code improvements
              	;
              	; ------------------------------------------------------------------------------
              	
              	;------------------------------------------------------------------------------
              	; VDP INITIALISATION
              	; initialize VDP for a specific graphics mode
              	; INPUT: E -> contains the graphics mode:
              	; 0=text; 1=graphics 1; 2=graphics 2; 3=multicolor; 4=extended graphics 2
035D: D5      	initVDP:        push    DE              ; store E
035E: CDB809  	                call    EMPTY_VRAM      ; reset VRAM
0361: CDD709  	                call    SET_GFX_MODE    ; load register settings
0364: CDCC09  	                call    EMPTY_RAM       ; reset RAM registers
0367: D1      	                pop     DE              ; restore reg. E
0368: AF      	                xor     A               ; reset A
0369: 47      	                ld      B,A             ; reset B (will be used later)
036A: 7B      	                ld      A,E             ; move E into A
036B: 324F81  	                ld      (SCR_MODE),A    ; store screen mode
036E: FE01    	                cp      $01             ; is it graphics 1 (A=1)?
0370: CAA703  	                jp      Z,G1MD          ; yes, jump over
0373: FE02    	                cp      $02             ; is it graphics 2 (A=2)?
0375: CAE303  	                jp      Z,G2MD          ; yes, jump over
0378: FE03    	                cp      $03             ; is it multicolor (A=3)?
037A: CA0504  	                jp      Z,MCMD          ; yes, jump over
037D: FE04    	                cp      $04             ; is it extended graphics 2 (A=4)?
037F: CA2804  	                jp      Z,EXG2MD        ; yes, jump over; otherwise, it must be $00 so we assume that it's text mode
              	
              	                ; LOAD VDP SETTINGS FOR SELECTED VIDEO MODE:
              	                ; TEXT MODE (G0)
0382:         	TXTMD:          ; load charset
0382: 60      	                ld      H,B
0383: 68      	                ld      L,B             ; HL=first pattern cell $0000
0384: CDF309  	                call    LOADCHARSET     ; load patterns into VRAM
              	                ; set cursor & video overlay
0387: AF      	                xor     A               ; reset A
0388: 325381  	                ld      (SCR_CURS_X),A  ; set cursor position at X=0
038B: 325481  	                ld      (SCR_CURS_Y),A  ; and Y=0
038E: 3E05    	                ld      A,$05           ; light blue
0390: 325D81  	                ld      (BKGNDCLR),A    ; set background/border color
0393: 3E28    	                ld      A,$28
0395: 324D81  	                ld      (SCR_SIZE_W),A  ; screen width = 40 cols
0398: 3E18    	                ld      A,$18
039A: 324E81  	                ld      (SCR_SIZE_H),A  ; screen height = 24 rows
039D: 110008  	                ld      DE,$0800
03A0: ED535181	                ld      (SCR_NAM_TB),DE ; set name table address
03A4: C36604  	                jp      ENDVDPSET       ; execute the rest of the video setting
              	
              	                ; GRAPHICS 1 MODE (G1)
03A7:         	G1MD:           ; load pattern table
03A7: 68      	                ld      L,B
03A8: 60      	                ld      H,B             ; HL=first pattern cell $0000
03A9: CDF309  	                call    LOADCHARSET     ; load patterns into VRAM
              	                ; set cursor & video overlay
03AC: AF      	                xor     A               ; position cursor
03AD: 325381  	                ld      (SCR_CURS_X),A  ; at X=0
03B0: 325481  	                ld      (SCR_CURS_Y),A  ; and Y=0
03B3: 3E20    	                ld      A,$20
03B5: 324D81  	                ld      (SCR_SIZE_W),A  ; screen width = 32 cols
03B8: 3E18    	                ld      A,$18
03BA: 324E81  	                ld      (SCR_SIZE_H),A  ; screen height = 24 rows
03BD: 110018  	                ld      DE,$1800
03C0: ED535181	                ld      (SCR_NAM_TB),DE ; set name table address
              	                ; load color table
03C4: 210020  	                ld      HL,$2000        ; color table start: $2000
03C7: CDC905  	                call    SETVDPADRS
03CA: 3E01    	                ld      A,$01           ; foreground color...
03CC: 325C81  	                ld      (FRGNDCLR),A    ; ...set to black
03CF: 3E0F    	                ld      A,$0F           ; background color...
03D1: 325D81  	                ld      (BKGNDCLR),A    ; ...set to white
03D4: 3E1F    	                ld      A,$1F           ; reg.A loaded with colors for chars: bloack pixels on white background
03D6: 0620    	                ld      B,$20           ; 32 bytes of colors
03D8: 0E30    	                ld      C,VDP_DAT       ; VDP data mode
03DA: ED79    	LDCLRTBMD1:     out     (C),A           ; after first byte, the VDP autoincrements VRAM pointer
03DC: 00      	                nop
03DD: 00      	                nop
03DE: 10FA    	                djnz    LDCLRTBMD1      ; repeat for 32 bytes
03E0: C36604  	                jp      ENDVDPSET       ; execute the rest of the video setting
              	
              	                ; GRAPHICS 2 MODE (G2)
03E3: AF      	G2MD:           xor     A               ; position cursor
03E4: 325381  	                ld      (SCR_CURS_X),A  ; at X=0
03E7: 325481  	                ld      (SCR_CURS_Y),A  ; and Y=0
03EA: 324D81  	                ld      (SCR_SIZE_W),A  ; screen width = 256 pixels (0=256)
03ED: 3C      	                inc     A               ; black on...
03EE: 325C81  	                ld      (FRGNDCLR),A    ; ...foreground
03F1: 3E0F    	                ld      A,$0F           ; white on...
03F3: 325D81  	                ld      (BKGNDCLR),A    ; ...background
03F6: 3EC0    	                ld      A,$C0
03F8: 324E81  	                ld      (SCR_SIZE_H),A  ; screen height = 192 pixels
03FB: 110018  	                ld      DE,$1800
03FE: ED535181	                ld      (SCR_NAM_TB),DE ; set name table address
0402: C36604  	                jp      ENDVDPSET       ; execute the rest of the video setting
              	
              	                ; MULTICOLOR MODE (G3)
0405: AF      	MCMD:           xor     A               ; position cursor
0406: 325381  	                ld      (SCR_CURS_X),A  ; at X=0
0409: 325481  	                ld      (SCR_CURS_Y),A  ; and Y=0
040C: 3E0F    	                ld      A,$0F           ; white color for...
040E: 325D81  	                ld      (BKGNDCLR),A    ; ...background and...
0411: 325C81  	                ld      (FRGNDCLR),A    ; ...foreground (even this is not used in MC)
0414: 3E40    	                ld      A,$40
0416: 324D81  	                ld      (SCR_SIZE_W),A  ; screen width = 64 blocks
0419: 3E30    	                ld      A,$30
041B: 324E81  	                ld      (SCR_SIZE_H),A  ; screen height = 48 blocks
041E: 110008  	                ld      DE,$0800
0421: ED535181	                ld      (SCR_NAM_TB),DE ; set name table address
0425: C36604  	                jp      ENDVDPSET       ; execute the rest of the video setting
              	
              	                ; EXTENDED GRAPHICS 2 (G4)
0428:         	EXG2MD:         ; load pattern table
0428: 60      	                ld      H,B
0429: 68      	                ld      L,B             ; HL=first pattern cell $0000
042A: CDF309  	                call    LOADCHARSET     ; load patterns into VRAM
              	                ; set cursor & video overlay
042D: AF      	                xor     A               ; position cursor
042E: 325381  	                ld      (SCR_CURS_X),A  ; at X=0
0431: 325481  	                ld      (SCR_CURS_Y),A  ; and Y=0
0434: 3E20    	                ld      A,$20
0436: 324D81  	                ld      (SCR_SIZE_W),A  ; screen width = 32 cols
0439: 3E18    	                ld      A,$18
043B: 324E81  	                ld      (SCR_SIZE_H),A  ; screen height = 24 rows
043E: 110038  	                ld      DE,$3800
0441: ED535181	                ld      (SCR_NAM_TB),DE ; set name table address
              	                 ; load color table
0445: 210020  	                ld      HL,$2000        ; color table start: $2000
0448: CDC905  	                call    SETVDPADRS
044B: 3E01    	                ld      A,$01           ; foreground color is...
044D: 325C81  	                ld      (FRGNDCLR),A    ; ...set to black
0450: 3E0F    	                ld      A,$0F           ; whitefor...
0452: 325D81  	                ld      (BKGNDCLR),A    ; ...background
0455: 3E1F    	                ld      A,$1F           ; reg.A loaded with colors for chars: bloack pixels on white background
0457: 1608    	                ld      D,$08           ; 8 pages of 
0459: 0600    	                ld      B,$00           ; 256 bytes of colors (total of 2,048 cells)
045B: 0E30    	                ld      C,VDP_DAT       ; VDP data mode
045D: ED79    	LDCLRTBEX2:     out     (C),A           ; after first byte, the VDP autoincrements VRAM pointer
045F: 00      	                nop
0460: 00      	                nop
0461: 10FA    	                djnz    LDCLRTBEX2      ; repeat for 256 bytes
0463: 15      	                dec     D               ; did we fill up all the cells?
0464: 20F7    	                jr      NZ,LDCLRTBEX2   ; no, repeat
              	                ; LAST VDP SETTINGS
0466: CD2B08  	ENDVDPSET:      call    CURSOR_OFF      ; disable cursor
0469: CD3705  	                call    EMPTYVIDBUF     ; empty video buffer
046C: AF      	                xor     A
046D: 325781  	                ld      (SCR_ORG_CHR),A ; store byte used tochar used to empty the video buffer
0470: C9      	                ret                     ; return to caller
              	
              	
              	; show initial logo
0471: CDB809  	SHOW_LOGO:      call    EMPTY_VRAM      ; reset VRAM
              	                ; set VDP for G2 mode
0474: 0607    	                ld      B,$07           ; set only the first 7 registers
0476: 111000  	                ld      DE,$0010        ; load settings for G2 mode
0479: CDDF09  	                call    SET_GFX_MODE2   ; load register settings
047C: 1601    	                ld      D,$01           ; backdrop color set to black
047E: ED51    	                out     (C),D           ; send data to VDP
0480: ED79    	                out     (C),A           ; indicate the register to send data to
              	                ; set name table 
0482: 210018  	                ld      HL,$1800        ; name table address
0485: CDB605  	                call    SETNAMETABLE    ; set name table (load names into table)
0488: CDE504  	                call    ERASECLRTBL     ; erase color table (set foreground & background to black)
              	                ; set colors for logo
048B: 210028  	                ld      HL,$2800        ; 2nd page of color table
048E: CDC905  	                call    SETVDPADRS
0491: 0605    	                ld      B,5             ; 5 bands
0493: 213205  	                ld      HL,CLRTABLE
0496: 0E30    	                ld      C,VDP_DAT
0498: 1E08    	                ld      E,$08           ; 8 pixels each pattern        
049A: 1640    	RPT101:         ld      D,$40           ; 64 chars each band
049C: 7E      	                ld      A,(HL)
049D: ED79    	RPT102:         out     (C),A
049F: 00      	                nop
04A0: 1D      	                dec     E
04A1: 20FA    	                jr      NZ,RPT102
04A3: 1E08    	                ld      E,$08
04A5: 15      	                dec     D
04A6: 20F5    	                jr      NZ,RPT102
04A8: 23      	                inc     HL
04A9: 10EF    	                djnz    RPT101
              	                ; set pattern table
04AB: 210008  	                ld      HL,$0800        ; address of first cell of 2nd area of pattern table
04AE: 113C0A  	                ld      DE,LM80CLOGO    ; pointer to logo pattern
04B1: 0600    	                ld      B,$00           ; 256 bytes, 8 rows
04B3: CD1105  	RPT103:         call    LOADLOGOCHRS
04B6: 13      	                inc     DE              ; next logo pattern
04B7: 10FA    	                djnz    RPT103
04B9: 0620    	                ld      B,$20           ; repeat for another 2 rows
04BB: CD1105  	RPT104:         call    LOADLOGOCHRS
04BE: 13      	                inc     DE              ; next logo pattern
04BF: 10FA    	                djnz    RPT104
              	                ; show logo/message, play a beep and wait a while
04C1: 0602    	                ld      B,$02
04C3: AF      	                xor     A
04C4: 57      	                ld      D,A             ; 256 times
04C5: 5F      	                ld      E,A             ; x 256 times
04C6: 325E81  	                ld      (TMPBFR1),A     ; sound flag set to 0
04C9: 00      	DEC_D:          nop                     ; does nothing...
04CA: 00      	                nop
04CB: 00      	                nop
04CC: 00      	                nop
04CD: 00      	                nop
04CE: 00      	                nop
04CF: 1D      	                dec     E               ; decrement E
04D0: 20F7    	                jr      NZ,DEC_D        ; repeat until $00
04D2: 7A      	                ld      A,D
04D3: FE40    	                cp      $40             ; ...equal to 64
04D5: CCFD04  	                call    Z,SETBEEP       ; if yes, start sound
04D8: 15      	                dec     D
04D9: 20EE    	                jr      NZ,DEC_D        ; repeat
04DB: 3A5E81  	                ld      A,(TMPBFR1)
04DE: FE02    	                cp      $02
04E0: C40905  	                call    NZ,BEEPOFF
04E3: 10E4    	                djnz    DEC_D
04E5:         	ERASECLRTBL:    ; erase color table
04E5: 3E11    	                ld      A,$11           ; foreground and background set to black
04E7: 160A    	                ld      D,$0A           ; 10 pages
04E9: 0600    	                ld      B,$00           ; 256 color cells per page
04EB: 210028  	                ld      HL,$2800        ; first cell of 2nd color table
04EE: CDC905  	                call    SETVDPADRS      ; send address
04F1: 0E30    	                ld      C,VDP_DAT       ; VDP address for passing data
04F3: ED79    	RPT100:         out     (C),A           ; send data
04F5: 00      	                nop
04F6: 00      	                nop                     ; little delay
04F7: 10FA    	                djnz    RPT100          ; repeat for entire page
04F9: 15      	                dec     D
04FA: 20F7    	                jr      NZ,RPT100       ; repeat for all the pages ($0A00 cells)
04FC: C9      	                ret                     ; return to caller
              	
              	; play a beep
04FD: 3A5E81  	SETBEEP:        ld      A,(TMPBFR1)     ; check the already-beeped flag?
0500: B7      	                or      A               ; is it 0?
0501: C0      	                ret     NZ              ; no, exit
0502: 3C      	                inc     A               ; flag to 1
0503: 325E81  	                ld      (TMPBFR1),A     ; set sound
0506: C3AA0B  	                jp      WLCMBEEP        ; play a beep & return
              	
              	; beep off
0509: 3E02    	BEEPOFF:        ld      A,$02           ; flag for sound off
050B: 325E81  	                ld      (TMPBFR1),A     ; set flag
050E: C3B00B  	                jp      NOBEEP          ; stop beep and return
              	
              	
              	; used to load the chars that will compose the logo of the splash screen
0511: 1A      	LOADLOGOCHRS:   ld      A,(DE)          ; load a pattern char of the logo
0512: 87      	                add     A,A
0513: 87      	                add     A,A
0514: 87      	                add     A,A             ; multiply times 8 to get the offset
0515: C5      	                push    BC
0516: D5      	                push    DE              ; store BC and DE
0517: E5      	                push    HL              ; store VRAM address to write to
0518: 218E46  	                ld      HL,LOGOFONT     ; start of logo font data
051B: 5F      	                ld      E,A
051C: 1600    	                ld      D,$00           ; put offset (A) into DE
051E: 19      	                add     HL,DE           ; get address of pattern data
051F: EB      	                ex      DE,HL           ; move address into DE
0520: E1      	                pop     HL              ; retrieve VRAM address
0521: 0608    	                ld      B,$08           ; 8 bytes per pattern
0523: CDC905  	                call    SETVDPADRS      ; set VDP address
0526: 0E30    	                ld      C,VDP_DAT
0528: 1A      	SNDLOGPT:       ld      A,(DE)          ; load data from RAM
0529: ED79    	                out     (C),A           ; and send to VRAM
052B: 13      	                inc     DE              ; next byte into RAM
052C: 23      	                inc     HL              ; next byte into VRAM (used in future iterations)
052D: 10F9    	                djnz    SNDLOGPT        ; repeat 8 times
052F: D1      	                pop     DE
0530: C1      	                pop     BC              ; retrieve BC & DE
0531: C9      	                ret                     ; return to caller
              	
0532:         	CLRTABLE:       equ $
0532: 181B1314	                defb    $18,$1B,$13,$14,$1D ; colors of background bands of the logo
0536: 1D      	
              	                
              	; empty video buffer
0537: 3A4F81  	EMPTYVIDBUF:    ld      A,(SCR_MODE)    ; check screen mode
053A: FE02    	                cp      $02             ; is it G2 mode?
053C: CA6005  	                jp      Z,EMPTYG2       ; yes, jump over
053F: FE03    	                cp      $03             ; is it MC mode?
0541: CA9105  	                jp      Z,EMPTYMC       ; yes, jump over
0544: 3A4E81  	                ld      A,(SCR_SIZE_H)  ; load height of screen
0547: 47      	                ld      B,A             ; move rows into B
0548: AF      	                xor     A               ; filling char is $00
0549: 2A5181  	                ld      HL,(SCR_NAM_TB) ; load the name table address
054C: CDC905  	                call    SETVDPADRS      ; send address to VDP
054F: 0E30    	                ld      C,VDP_DAT       ; VDP address for passing data
0551: 5F      	LDCOLSTOEMPTY:  ld      E,A             ; store filling char into E
0552: 3A4D81  	                ld      A,(SCR_SIZE_W)  ; load # of cols to empty into A
0555: 57      	                ld      D,A             ; move A into D
0556: 7B      	                ld      A,E             ; recover filling char
0557: ED79    	RPTEMPTYBUF:    out     (C),A           ; write empty byte into VRAM
0559: 00      	                nop
055A: 15      	                dec     D               ; decr. D
055B: 20FA    	                jr      NZ,RPTEMPTYBUF  ; repeat for the # of cols
055D: 10F2    	                djnz    LDCOLSTOEMPTY   ; repeat for the # of rows
055F: C9      	                ret                     ; return to caller
0560: 2A5181  	EMPTYG2:        ld      HL,(SCR_NAM_TB) ; yes, additional setup for G2 - load G2 name table address (usually $1800)
0563: CDB605  	                call    SETNAMETABLE    ; set name table
0566: 210000  	                ld      HL,$0000        ; set pattern table
0569: CDC905  	                call    SETVDPADRS      ; send address to VDP
056C: AF      	                xor     A               ; empty pattern
056D: 1618    	                ld      D,$18           ; 6144 ($1800) cell to clean, 24 pages ($18)
056F: 47      	                ld      B,A             ; 256 bytes for page
0570: 0E30    	                ld      C,VDP_DAT       ; VDP data mode
0572: ED79    	CLRG2PTNTBL:    out     (C),A           ; clear pattern
0574: 00      	                nop                     ; little delay
0575: 00      	                nop
0576: 10FA    	                djnz    CLRG2PTNTBL     ; repeat for 1 page
0578: 15      	                dec     D               ; next page
0579: 20F7    	                jr      NZ,CLRG2PTNTBL  ; repeat
057B: 210020  	                ld      HL,$2000        ; load the color table address
057E: CDC905  	                call    SETVDPADRS      ; send address to VDP
0581: 3A5C81  	                ld      A,(FRGNDCLR)    ; load foreground
0584: 87      	                add     A,A
0585: 87      	                add     A,A
0586: 87      	                add     A,A
0587: 87      	                add     A,A             ; move to high nibble
0588: 57      	                ld      D,A             ; store into D
0589: 3A5D81  	                ld      A,(BKGNDCLR)    ; load background color
058C: B2      	                or      D               ; combine with background color
058D: 1618    	                ld      D,$18           ; 6144 ($1800) cells to fill, so 24 pages ($18)
058F: 1817    	                jr      STARTEMPTY
0591: 210008  	EMPTYMC:        ld      HL,$0800        ; MC name table
0594: CDB605  	                call    SETNAMETABLE    ; set name table
0597: 210000  	                ld      HL,$0000        ; color table address
059A: CDC905  	                call    SETVDPADRS      ; send address to VDP
059D: 3A5D81  	                ld      A,(BKGNDCLR)    ; load background
05A0: 57      	                ld      D,A             ; store into D
05A1: 87      	                add     A,A
05A2: 87      	                add     A,A
05A3: 87      	                add     A,A
05A4: 87      	                add     A,A             ; move to high nibble
05A5: B2      	                or      D               ; set background color for high and low nibble
05A6: 1608    	                ld      D,$08           ; 2048 ($0800) cells to fill, so 8 pages ($08)
05A8: 0E30    	STARTEMPTY:     ld      C,VDP_DAT       ; VDP address for passing data
05AA: 0600    	                ld      B,$00           ; 256 bytes each page ($00=256)
05AC: ED79    	SNDCLRSET:      out     (C),A           ; send color setting
05AE: 00      	                nop                     ; wait a while
05AF: 00      	                nop
05B0: 10FA    	                djnz    SNDCLRSET       ; repeat for 1 page
05B2: 15      	                dec     D               ; have we filled all the pages?
05B3: 20F7    	                jr      NZ,SNDCLRSET    ; no, repeat
05B5: C9      	                ret                     ; return to caller
              	
              	; set name table for G2 mode (patterns from $00 to $FF for each of the 3 areas of the screen)
05B6: CDC905  	SETNAMETABLE:   call    SETVDPADRS      ; send address to VDP
05B9: 0E30    	                ld      C,VDP_DAT       ; VDP address for passing data
05BB: 1603    	                ld      D,$03           ; 3 pages to fill into VRAM (768 cells)
05BD: AF      	                xor     A               ; starting char name #0 (chars go from 0 to 255)
05BE: 47      	                ld      B,A             ; reset B
05BF: ED79    	RPTFLL1:        out     (C),A           ; send name to VRAM
05C1: 00      	                nop
05C2: 3C      	                inc     A               ; increment # of name
05C3: 10FA    	                djnz    RPTFLL1         ; repeat for 256 cells (1 page)
05C5: 15      	                dec     D               ; did we fill all the pages?
05C6: 20F7    	                jr      NZ,RPTFLL1      ; no, continue
05C8: C9      	                ret                     ; return to caller
              	
              	; set an address into VRAM: address is in HL
05C9: 0E32    	SETVDPADRS:     ld      C,VDP_SET       ; VDP address mode
05CB: CBF4    	                set     6,H             ; set bit #6 of address, to write to VRAM
05CD: ED69    	                out     (C),L           ; send low and...
05CF: ED61    	                out     (C),H           ; ...high byte of the first cell
05D1: C9      	                ret                     ; return to caller
              	
              	; clear the video buffer and position the cursor at 0,0
05D2: CD3705  	CLEARVIDBUF:    call    EMPTYVIDBUF     ; clear video buffer
05D5: AF      	                xor     A               ; reset A
05D6: 325381  	                ld      (SCR_CURS_X),A  ; cursor X to 0
05D9: 325481  	                ld      (SCR_CURS_Y),A  ; cursor Y to 0
05DC: C32506  	                jp      POS_CURSOR      ; position cursor & return to caller
              	
              	; HOME: position the cursor at coords. 0,0 
05DF: AF      	ATHOME:         xor     A               ; position cursor at 0,0 by storing...
05E0: 325681  	                ld      (SCR_CUR_NY),A  ; ...new Y...
05E3: 325581  	                ld      (SCR_CUR_NX),A  ; ...and new X
05E6: C32F06  	                jp      MOVCRS          ; move cursor to new location & return to caller
              	
              	; load the char or byte at the VRAM position set by HL
              	; value is returned into A
05E9: C5      	READ_VIDEO_LOC: push    BC              ; store BC
05EA: 0E32    	                ld      C,VDP_SET       ; VDP setting mode
05EC: 44      	                ld      B,H
05ED: CBB8    	                res     7,B
05EF: CBB0    	                res     6,B
05F1: ED69    	                out     (C),L           ; low byte then...
05F3: ED41    	                out     (C),B           ; high byte
05F5: 0E30    	                ld      C,VDP_DAT       ; VDP data mode
05F7: 00      	                nop                     ; wait...
05F8: 00      	                nop                     ; ...a while
05F9: 00      	                nop
05FA: ED78    	                in      A,(C)           ; read byte at current VRAM location
05FC: C1      	                pop     BC              ; restore BC
05FD: C9      	                ret                     ; return to caller
              	
              	; write a byte at the VRAM position pointed by HL
              	; value is in A
05FE: C5      	WRITE_VIDEO_LOC:push    BC              ; store BC
05FF: 0E32    	                ld      C,VDP_SET       ; VDP setting mode
0601: 44      	                ld      B,H             ; copy H into B
0602: CBB8    	                res     7,B
0604: CBF0    	                set     6,B             ; write to VRAM
0606: ED69    	                out     (C),L           ; low byte then...
0608: ED41    	                out     (C),B           ; high byte of VRAM address
060A: 0E30    	                ld      C,VDP_DAT       ; VDP data mode
060C: 00      	                nop                     ; wait...
060D: 00      	                nop                     ; ...a while
060E: 00      	                nop
060F: ED79    	                out     (C),A           ; write byte into VRAM
0611: C1      	                pop     BC              ; restore BC
0612: C9      	                ret                     ; return to caller
              	
              	; write a value into a specific VDP register
              	; value is in E, register is in A
0613: C5      	WRITE_VREG:     push    BC              ; store BC
0614: C680    	                add     A,$80           ; set VDP to write to registers
0616: 0E32    	                ld      C,VDP_SET       ; VDP setting mode
0618: ED59    	                out     (C),E           ; send data to VDP
061A: ED79    	                out     (C),A           ; select the destination register
061C: C1      	                pop     BC              ; restore BC
061D: C9      	                ret                     ; return to caller
              	
              	; read VDP status register and return value into A
061E: C5      	READ_VSTAT:     push    BC              ; store BC
061F: 0E32    	                ld      C,VDP_SET       ; VDP register access
0621: ED78    	                in      A,(C)           ; read status register
0623: C1      	                pop     BC              ; restore BC
0624: C9      	                ret                     ; return to caller
              	
              	; position the cursor at the current coordinates, preserving underlying char
0625: CD5606  	POS_CURSOR:     call    LOAD_CRSR_POS   ; load the VRAM address of cursor into HL
0628: CDE905  	                call    READ_VIDEO_LOC  ; load the current char at the cursor position (return in A)
062B: 325781  	                ld      (SCR_ORG_CHR),A ; store the current char
062E: C9      	                ret
              	
              	; move cursor to new X,Y coordinates
062F: CD4D06  	MOVCRS:         call    RSTCHRCRS       ; restore the char in the current cursor position
0632: CD3806  	                call    NEWCRSRCOORD    ; set new cursor's coordinates
0635: C32506  	                jp      POS_CURSOR      ; position cursor into new location & return to caller
              	
              	
              	; set new cursor's coordinates:
0638: 3A5581  	NEWCRSRCOORD:   ld      A,(SCR_CUR_NX)  ; load new X
063B: 325381  	                ld      (SCR_CURS_X),A  ; write new X
063E: 3A5681  	                ld      A,(SCR_CUR_NY)  ; load new Y
0641: 325481  	                ld      (SCR_CURS_Y),A  ; write new Y
0644: 3EFF    	                ld      A,$FF           ; delete new values
0646: 325581  	                ld      (SCR_CUR_NX),A  ; of X
0649: 325681  	                ld      (SCR_CUR_NY),A  ; and Y
064C: C9      	                ret
              	
              	; recover char under the cursor and prints it onto the screen
064D: CD5606  	RSTCHRCRS:      call    LOAD_CRSR_POS   ; recover old cursor position
0650: 3A5781  	                ld      A,(SCR_ORG_CHR) ; recover old char
0653: C3FE05  	                jp      WRITE_VIDEO_LOC ; write char into VRAM & return
              	
              	; retrieve cursor position from either current coordinates or next place
              	; return address position into HL
0656: 3A5481  	LOAD_CRSR_POS:  ld      A,(SCR_CURS_Y)  ; load cursor Y
0659: 6F      	                ld      L,A             ; move it into reg.L
065A: AF      	                xor     A               ; reset A
065B: 67      	                ld      H,A             ; reset H
065C: 47      	                ld      B,A             ; reset B
065D: 29      	                add     HL,HL           ; create offset (each address is 2-bytes long so we need to double HL)
065E: 118809  	                ld      DE,POS_TB_CRS_40; load position table address of cursor for 40 cols
0661: 3A4D81  	                ld      A,(SCR_SIZE_W)  ; load screen width
0664: FE28    	                cp      $28             ; is it 40 cols?
0666: 2803    	                jr      Z,CONT_POS_CURS ; yes, jump over
0668: 115809  	                ld      DE,POS_TB_CRS_32; no, load position table address of cursor for 32 cols
066B: 19      	CONT_POS_CURS:  add     HL,DE           ; the correct starting address of the required row is now into HL
066C: 5E23562B	                ld      DE,(HL)         ; load starting address of the required row into DE
0670: 2A5181  	                ld      HL,(SCR_NAM_TB) ; load starting address of name table
0673: 19      	                add     HL,DE           ; starting address of the current row into name table
0674: 3A5381  	                ld      A,(SCR_CURS_X)  ; load cursor X
0677: 4F      	                ld      C,A             ; transfer A into C
0678: 09      	                add     HL,BC           ; add X offset: now HL contains the address of the current cursor position
0679: C9      	                ret
              	
              	; find X,Y coordinates of a screen address pointed in VRAM by HL
              	; return them into L & A for X,Y
067A: D5      	HL2XY:          push    DE              ; store DE
067B: ED5B5181	                ld      DE,(SCR_NAM_TB) ; load starting address of name table into DE
067F: AF      	                xor     A               ; clear Carry
0680: ED52    	                sbc     HL,DE           ; find position relative to screen (from 0,0)
0682: D1      	                pop     DE
0683: 3A4D81  	                ld      A,(SCR_SIZE_W)  ; load screen width
0686: 4F      	                ld      C,A             ; move it into C
0687: CD7F36  	                call    DIV_16_8        ; divide position by C: return Y into L and X into A
068A: C9      	                ret                     ; return to caller
              	
              	;-------------------------------------------------------------------------------
              	; send current char to video buffer
068B: F5      	CHAR2VID:       push    AF              ; store AF
068C: C5      	                push    BC              ; store BC
068D: D5      	                push    DE              ; store DE
068E: E5      	                push    HL              ; store HL
068F: 3A5881  	                ld      A,(CRSR_STATE)  ; store cursor state...
0692: F5      	                push    AF              ; into stack
0693: CD2B08  	                call    CURSOR_OFF      ; cursor off
0696: 3A5B81  	                ld      A,(CHR4VID)     ; recover char
0699: FE19    	                cp      HOME            ; is it HOME char ($19?)
069B: 2006    	                jr      NZ,CHKCS        ; no, check over
069D: CDDF05  	                call    ATHOME          ; yes, move the cursor to 0,0
06A0: C31607  	                jp      EXITCHAR2VID    ; exit
06A3: FE0C    	CHKCS:          cp      CS              ; is it the CLEAR char ($0C)?
06A5: 2005    	                jr      NZ,CHKCR        ; no, check over
06A7: CDD205  	                call    CLEARVIDBUF     ; yes, clear video buffer and position cursor at 0,0
06AA: 186A    	                jr      EXITCHAR2VID    ; exit
06AC: FE0D    	CHKCR:          cp      CR              ; is it a carriage return ($0D)?
06AE: 2005    	                jr      NZ,CHKBKSP      ; no, jump over
06B0: CDAD08  	                call    CRGRETURN       ; yes, go to the beginning of the next line
06B3: 1861    	                jr      EXITCHAR2VID    ; exit
06B5: FE08    	CHKBKSP:        cp      BKSP            ; is it the backspace ($08)?
06B7: 2005    	                jr      NZ,CHKCRSLFT    ; no, jump over
06B9: CD4807  	                call    BACKSPACE       ; move cursor left 1 position
06BC: 1858    	                jr      EXITCHAR2VID    ; exit
06BE: FE1C    	CHKCRSLFT:      cp      CRSLFT          ; is it cursor left?
06C0: 2005    	                jr      NZ,CHKCRSUP     ; no, jump over
06C2: CD5B07  	                call    CURSORLEFT      ; move cursor left...
06C5: 184F    	                jr      EXITCHAR2VID    ; ...and exit
06C7: FE1E    	CHKCRSUP:       cp      CRSUP           ; is it cursor up?
06C9: 2005    	                jr      NZ,CHKCRSRGT    ; no, jump over
06CB: CDA707  	                call    CURSORUP        ; move cursor up...
06CE: 1846    	                jr      EXITCHAR2VID    ; ...and exit
06D0: FE1D    	CHKCRSRGT:      cp      CRSRGT          ; is it cursor right?
06D2: 2005    	                jr      NZ,CHKCRSDWN    ; no, jump over
06D4: CDC007  	                call    CURSORRIGHT     ; move cursor right...
06D7: 183D    	                jr      EXITCHAR2VID    ; ...and exit
06D9: FE1F    	CHKCRSDWN:      cp      CRSDN           ; is it cursor down?
06DB: 2005    	                jr      NZ,CHKLF        ; no, jump over
06DD: CDF507  	                call    CURSORDOWN      ; move cursor up...
06E0: 1834    	                jr      EXITCHAR2VID    ; ...and exit
06E2: FE0A    	CHKLF:          cp      LF              ; is it a line feed ($0A)?
06E4: 2830    	                jr      Z,EXITCHAR2VID  ; CURRENTLY WE DON'T PRINT LF, WE JUST USE CR TO SUBSTITUTE CR+LF COMBINATION
06E6: CD5606  	                call    LOAD_CRSR_POS   ; recover position of cursor
06E9: 3A5B81  	                ld      A,(CHR4VID)     ; recover char to print
06EC: CDFE05  	                call    WRITE_VIDEO_LOC ; write A into VRAM at (HL)
06EF: 3A5481  	                ld      A,(SCR_CURS_Y)  ; load cursor Y into A
06F2: 5F      	                ld      E,A             ; store cursor Y into E
06F3: 3A5381  	                ld      A,(SCR_CURS_X)  ; load cursor X
06F6: 3C      	                inc     A               ; move 1 step to right
06F7: 214D81  	                ld      HL,SCR_SIZE_W   ; cell that keeps the width of screen
06FA: BE      	                cp      (HL)            ; have we reached the most right position?
06FB: 200F    	                jr      NZ,SETCSRCOORDS ; no, go over
06FD: 1C      	                inc     E               ; yes, increment cursor Y (go to next line)
06FE: 7B      	                ld      A,E             ; move cursor Y into A
06FF: 214E81  	                ld      HL,SCR_SIZE_H   ; cell that keeps the height of screen
0702: BE      	                cp      (HL)            ; have we reached the bottom of the screen?
0703: 2006    	                jr      NZ,SETCRSRY     ; no, jump over
0705: D5      	                push    DE
0706: CD3208  	                call    SCROLLUP        ; scroll screen up
0709: D1      	                pop     DE
070A: 1D      	                dec     E               ; decrement 1 row, to set cursor Y on the last line
070B: AF      	SETCRSRY:       xor     A               ; then set cursor X to 0 (go to beginning of line)
070C: 325381  	SETCSRCOORDS:   ld      (SCR_CURS_X),A  ; store current cursor X
070F: 7B      	                ld      A,E             ; recover Y
0710: 325481  	                ld      (SCR_CURS_Y),A  ; store current cursor Y
0713: CD2506  	                call    POS_CURSOR      ; position cursor to new location
0716: AF      	EXITCHAR2VID:   xor     A               ; reset char
0717: 325B81  	                ld      (CHR4VID),A     ; to be sent to screen
071A: F1      	                pop     AF              ; recover cursor state
071B: A7      	                and     A               ; was it off (A=0)?
071C: C41508  	                call    NZ,CURSOR_ON    ; no, set cursor on
071F: E1      	                pop     HL              ; restore HL
0720: D1      	                pop     DE              ; restore DE
0721: C1      	                pop     BC              ; restore BC
0722: F1      	                pop     AF              ; restore AF
0723: C9      	                ret                     ; return to caller
              	
              	; flash the cursor at the current position
              	; (this sub-routine is called by CH3 timer ISR)
0724: 3A5881  	FLASHCURSOR:    ld      A,(CRSR_STATE)  ; now, check the cursor
0727: A7      	                and     A               ; cursor off (A=0)?
0728: C8      	                ret     Z               ; yes, return
0729: 3A4981  	                ld      A,(TMRCNT)      ; no, load the first byte of the 100ths of A second's counter
072C: E620    	                and     $20             ; check if it's time to flash the cursor (check bit #6)
072E: 215981  	                ld      HL,LSTCSRSTA    ; load address of cell that stores the last cursor state
0731: 46      	                ld      B,(HL)          ; load last state
0732: B8      	                cp      B               ; compare current state with last state
0733: C8      	                ret     Z               ; same state, no change required - exit
0734: 77      	                ld      (HL),A          ; save new state
0735: F5      	                push    AF              ; store A (keep state for later use)
0736: CD5606  	                call    LOAD_CRSR_POS   ; load current cursor position into HL
0739: F1      	                pop     AF              ; recover current state
073A: 06FF    	                ld      B,$FF           ; cursor char
073C: FE20    	                cp      $20             ; is the cursor on video (A == $20)?
073E: 2804    	                jr      Z,PUTCRSCHR     ; yes, jump over
0740: 3A5781  	                ld      A,(SCR_ORG_CHR) ; no, load the original char
0743: 47      	                ld      B,A             ; move char into B
0744: 78      	PUTCRSCHR:      ld      A,B             ; recover char from B
0745: C3FE05  	                jp      WRITE_VIDEO_LOC ; print cursor/char at the current position & return
              	
              	
              	; delete the char at the left of the cursor
0748: CD8407  	BACKSPACE:      call    MVCRS2LFT       ; prepare to move cursor to left
074B: CD4D06  	                call    RSTCHRCRS       ; restore char under the cursor
074E: CD3806  	                call    NEWCRSRCOORD    ; set new cursor's coordinates
0751: CD5606  	                call    LOAD_CRSR_POS   ; find address of new video cell
0754: AF      	                xor     A               ; null char
0755: CDFE05  	                call    WRITE_VIDEO_LOC ; write into video cell
0758: C32506  	                jp      POS_CURSOR      ; position cursor and return
              	
              	
              	; move cursor to left
075B: F5      	CURSORLEFT:     push    AF              ; store A
075C: 3A5381  	                ld      A,(SCR_CURS_X)  ; load cursor X into A
075F: A7      	                and     A               ; is it at the most left of the screen (X=0)?
0760: 280C    	                jr      Z,CHCKYPOS      ; yes, check Y position
0762: 3D      	                dec     A               ; no, decrement X
0763: 325581  	                ld      (SCR_CUR_NX),A  ; store new X
0766: 3A5481  	                ld      A,(SCR_CURS_Y)  ; load current cursor Y
0769: 325681  	                ld      (SCR_CUR_NY),A  ; no move over Y axis
076C: 1811    	                jr      CONTCRSLFT      ; go on moving cursor
076E: 3A5481  	CHCKYPOS:       ld      A,(SCR_CURS_Y)  ; load cursor Y
0771: A7      	                and     A               ; is it at the most top of the screen (Y=0)?
0772: 280E    	                jr      Z,EXITCURSORLEFT; yes, exit doing nothing
0774: 3D      	                dec     A               ; no, decrement Y
0775: 325681  	                ld      (SCR_CUR_NY),A  ; store new Y
0778: 3A4D81  	                ld      A,(SCR_SIZE_W)  ; load current screen width
077B: 3D      	                dec     A               ; cursor to the most right position (width-0)
077C: 325581  	                ld      (SCR_CUR_NX),A  ; set new cursor X
077F: CD2F06  	CONTCRSLFT:     call    MOVCRS          ; move cursor into new position
0782: F1      	EXITCURSORLEFT: pop     AF              ; restore A
0783: C9      	                ret                     ; return to caller
              	
              	; move cursor 1 position to the left
0784: 3A5381  	MVCRS2LFT:      ld      A,(SCR_CURS_X)  ; load cursor X into A
0787: A7      	                and     A               ; is it at the most left of the screen (X=0)?
0788: 280B    	                jr      Z,CHKYPOS       ; yes, check Y position
078A: 3D      	                dec     A               ; no, decrement X
078B: 325581  	                ld      (SCR_CUR_NX),A  ; store new X
078E: 3A5481  	                ld      A,(SCR_CURS_Y)  ; load current cursor Y
0791: 325681  	                ld      (SCR_CUR_NY),A  ; no move over Y axis
0794: C9      	                ret                     ; go on moving cursor
0795: 3A5481  	CHKYPOS:        ld      A,(SCR_CURS_Y)  ; load cursor Y
0798: A7      	                and     A               ; is it at the most top of the screen (Y=0)?
0799: 28E7    	                jr      Z,EXITCURSORLEFT; yes, exit doing nothing
079B: 3D      	                dec     A               ; no, decrement Y
079C: 325681  	                ld      (SCR_CUR_NY),A  ; store new Y
079F: 3A4D81  	                ld      A,(SCR_SIZE_W)  ; load current screen width
07A2: 3D      	                dec     A               ; cursor to the most right position (width-1)
07A3: 325581  	                ld      (SCR_CUR_NX),A  ; set new cursor X
07A6: C9      	                ret                     ; return to caller
              	
              	; move cursor up
07A7: F5      	CURSORUP:       push    AF              ; store A
07A8: 3A5481  	                ld      A,(SCR_CURS_Y)  ; load cursor Y into A
07AB: A7      	                and     A               ; is it at the most top of the screen (Y=0)?
07AC: 2810    	                jr      Z,EXITCURSORUP  ; yes, exit doing nothing
07AE: 3D      	                dec     A               ; no, decrement Y
07AF: 325681  	                ld      (SCR_CUR_NY),A  ; store new Y
07B2: 3A5381  	                ld      A,(SCR_CURS_X)  ; load current cursor X
07B5: 325581  	                ld      (SCR_CUR_NX),A  ; set new cursor X
07B8: CD4D06  	                call    RSTCHRCRS       ; restore char under the cursor and print it
07BB: CD2F06  	                call    MOVCRS          ; move cursor into new position
07BE: F1      	EXITCURSORUP:   pop     AF              ; restore A
07BF: C9      	                ret                     ; return to caller
              	
              	
              	; move cursor to right
07C0: F5      	CURSORRIGHT:    push    AF              ; store A
07C1: C5      	                push    BC              ; store B
07C2: 3A4D81  	                ld      A,(SCR_SIZE_W)  ; load current screen width (in text modes it's 32 or 40)
07C5: 3D      	                dec     A               ; decrement it (most right can only be 31 or 39)
07C6: 47      	                ld      B,A             ; move A into B
07C7: 3A5381  	                ld      A,(SCR_CURS_X)  ; load cursor X into A    
07CA: B8      	                cp      B               ; is cursor at the most right position on the screen?
07CB: 300C    	                jr      NC,CHCKYPOS2    ; yes, so jump to check Y position
07CD: 3C      	                inc     A               ; no, so increment X
07CE: 325581  	                ld      (SCR_CUR_NX),A  ; store new X
07D1: 3A5481  	                ld      A,(SCR_CURS_Y)  ; load current cursor Y
07D4: 325681  	                ld      (SCR_CUR_NY),A  ; no move over Y axis
07D7: 1813    	                jr      CONTCRSRGT      ; go on moving cursor
07D9: 3A4E81  	CHCKYPOS2:      ld      A,(SCR_SIZE_H)  ; load screen height
07DC: 3D      	                dec     A               ; decrement it (last row can only be 23)
07DD: 47      	                ld      B,A             ; move bottom into B
07DE: 3A5481  	                ld      A,(SCR_CURS_Y)  ; load cursor Y into A
07E1: B8      	                cp      B               ; is the cursor at the bottom of the screen?
07E2: 300E    	                jr      NC,EXITCURSORRGHT; yes, exit doing nothing
07E4: 3C      	                inc     A               ; no, increment Y
07E5: 325681  	                ld      (SCR_CUR_NY),A  ; store new Y
07E8: AF      	                xor     A               ; move cursor to top left
07E9: 325581  	                ld      (SCR_CUR_NX),A  ; store new X
07EC: CD4D06  	CONTCRSRGT:     call    RSTCHRCRS       ; restore char under the cursor and print it
07EF: CD2F06  	                call    MOVCRS          ; move cursor into new position
07F2: C1      	EXITCURSORRGHT: pop     BC              ; retrieve BC
07F3: F1      	                pop     AF              ; restore A
07F4: C9      	                ret                     ; return to caller
              	
              	
              	; move cursor down
07F5: F5      	CURSORDOWN:     push    AF              ; store A
07F6: C5      	                push    BC              ; store B
07F7: 3A4E81  	                ld      A,(SCR_SIZE_H)  ; load current screen height (in text modes it's 24)
07FA: 3D      	                dec     A               ; decrement it (positions can only vary between 0 and 23)
07FB: 47      	                ld      B,A             ; move X into B
07FC: 3A5481  	                ld      A,(SCR_CURS_Y)  ; load cursor Y into A             
07FF: B8      	                cp      B               ; is current cursor position < 23?
0800: 3010    	                jr      NC,EXITCURSORDOWN; no, exit doing nothing
0802: 3C      	                inc     A               ; yes, increment Y
0803: 325681  	                ld      (SCR_CUR_NY),A  ; store new Y
0806: 3A5381  	                ld      A,(SCR_CURS_X)  ; load current cursor X
0809: 325581  	                ld      (SCR_CUR_NX),A  ; set new cursor X
080C: CD4D06  	                call    RSTCHRCRS       ; restore char under the cursor and print it
080F: CD2F06  	                call    MOVCRS          ; move cursor into new position
0812: C1      	EXITCURSORDOWN: pop     BC              ; retrieve BC
0813: F1      	                pop     AF              ; retrieve A
0814: C9      	                ret                     ; return to caller
              	
              	
              	; set cursor on (visible on screen)
0815: F5      	CURSOR_ON:      push    AF              ; store AF
0816: 3A5881  	                ld      A,(CRSR_STATE)  ; load cursor state
0819: FE01    	                cp      $01             ; is it on?
081B: 280C    	                jr      Z,EXITCURSOR_ON ; yes, so nothing to do
081D: 3A4E81  	                ld      A,(SCR_SIZE_H)  ; check the video mode
0820: FE30    	                cp      $30             ; graphics 2 or 3 (if value>=48)?
0822: 3005    	                jr      NC,EXITCURSOR_ON; yes, so exit (no cursor in graphics 2 or 3)
0824: 3E01    	                ld      A,$01           ; cursor state ON
0826: 325881  	                ld      (CRSR_STATE),A  ; set state
0829: F1      	EXITCURSOR_ON:  pop     AF              ; restore AF
082A: C9      	                ret                     ; return to caller
              	
              	; set cursor off (invisible on screen)
082B: F5      	CURSOR_OFF:     push    AF              ; store AF
082C: AF      	                xor     A               ; cursor state OFF
082D: 325881  	                ld      (CRSR_STATE),A  ; set state
0830: F1      	                pop     AF              ; restore AF
0831: C9      	                ret
              	
              	; scroll the screen 1 row up
0832: AF      	SCROLLUP:       xor     A
0833: 325A81  	                ld      (PRNTVIDEO),A
0836: 2A5181  	                ld      HL,(SCR_NAM_TB) ; start address of the name table
0839: 228E81  	                ld      (VIDTMP1),HL    ; store address of the destination row (1st row of the screen)
083C: 3A4D81  	                ld      A,(SCR_SIZE_W)  ; load the screen width
083F: 5F      	                ld      E,A             ; move width into E
0840: 1600    	                ld      D,$00           ; reset D
0842: 19      	                add     HL,DE           ; HL now contains the address of the source row (2nd row of the screen)
0843: 229081  	                ld      (VIDTMP2),HL    ; store address of source row
0846: 3A4E81  	                ld      A,(SCR_SIZE_H)  ; load the screen height
0849: 3D      	                dec     A               ; decrement the # of rows: now, A contains the # of rows to be moved
084A: 47      	                ld      B,A             ; move # of rows into B
084B: 3A4D81  	SCROLLNXTRW:    ld      A,(SCR_SIZE_W)  ; (re)load the screen width
084E: 5F      	                ld      E,A             ; move width into E
084F: 2A9081  	                ld      HL,(VIDTMP2)    ; load source address
0852: 0E32    	                ld      C,VDP_SET       ; VDP setting mode
0854: ED69    	                out     (C),L           ; low byte of source
0856: ED61    	                out     (C),H           ; high byte of source
0858: 216681  	                ld      HL,VIDEOBUFF    ; load address of the first cell of the video buffer
085B: 0E30    	                ld      C,VDP_DAT       ; VDP data mode
085D: ED78    	LOADNEXTCOL:    in      A,(C)           ; load char
085F: 77      	                ld      (HL),A          ; store char
0860: 23      	                inc     HL              ; next cell of the buffer
0861: 1D      	                dec     E               ; count the chars to be read
0862: 20F9    	                jr      NZ,LOADNEXTCOL  ; repeat until we read the entire row
0864: 3A4D81  	                ld      A,(SCR_SIZE_W)  ; reload the screen width
0867: 5F      	                ld      E,A             ; move # of rows into E
0868: 1600    	                ld      D,$00           ; reset D
086A: 2A8E81  	                ld      HL,(VIDTMP1)    ; load address of destination row
086D: E5      	                push    HL              ; store HL
086E: 2A9081  	                ld      HL,(VIDTMP2)    ; current source will be..
0871: 228E81  	                ld      (VIDTMP1),HL    ; ..new destination
0874: 19      	                add     HL,DE           ; address of new
0875: 229081  	                ld      (VIDTMP2),HL    ; source row
0878: E1      	                pop     HL              ; restore address of current destination row
0879: CBF4    	                set     6,H             ; writing mode
087B: 0E32    	                ld      C,VDP_SET       ; VDP setting mode
087D: ED69    	                out     (C),L           ; low byte
087F: ED61    	                out     (C),H           ; high byte of address
0881: 216681  	                ld      HL,VIDEOBUFF    ; video buffer address
0884: 0E30    	                ld      C,VDP_DAT       ; VDP data mode
0886: 7E      	WRITEBUF:       ld      A,(HL)          ; load char
0887: ED79    	                out     (C),A           ; send char
0889: 23      	                inc     HL              ; increment buffer index
088A: 1D      	                dec     E               ; next row
088B: 20F9    	                jr      NZ,WRITEBUF     ; repeat until 0
088D: 10BC    	                djnz    SCROLLNXTRW     ; repeat for the entire screen
088F: 3A4D81  	                ld      A,(SCR_SIZE_W)  ; reload screen width
0892: 47      	                ld      B,A             ; cells to empty into B
0893: AF      	                xor     A               ; null char
0894: 0E32    	                ld      C,VDP_SET       ; VDP set mode
0896: 2A8E81  	                ld      HL,(VIDTMP1)    ; load address of the last row
0899: CBF4    	                set     6,H             ; writing mode
089B: ED69    	                out     (C),L           ; low byte then..
089D: ED61    	                out     (C),H           ; high byte of address
089F: 0E30    	                ld      C,VDP_DAT       ; VDP data mode
08A1: ED79    	RPTEMPTYROW:    out     (C),A           ; empty cell
08A3: 00      	                nop                     ; delay
08A4: 00      	                nop
08A5: 10FA    	                djnz    RPTEMPTYROW     ; repeat until the last row has been cleaned
08A7: 3E01    	                ld      A,$01
08A9: 325A81  	                ld      (PRNTVIDEO),A   ; set print-on-video on
08AC: C9      	                ret                     ; return to caller
              	
              	; carriage return: first, it looks for char $00 at the beginning of the line (look for the first null char),
              	; then it starts sendind every char it finds on the screen to the terminal buffer of the BASIC interpreter
              	; until another null char is found. Finally, move to the next line and position the cursor at the beginning
              	; of the row (equivalent to CR+LF), then gets back control to the screen editor to let it interpret the line
815E:         	CUR_POS         equ     TMPBFR1         ; cursor position
8160:         	SRTTXT          equ     TMPBFR2         ; start of text line
8162:         	ENDTXT          equ     TMPBFR3         ; end of text line
08AD:         	CRGRETURN:      ; preliminary: disable cursor if on, and retrieve char under it
08AD: 3A5881  	                ld      A,(CRSR_STATE)  ; recover cursor state
08B0: 326481  	                ld      (TMPBFR4),A     ; store status
08B3: A7      	                and     A               ; is cursor on?
08B4: C42B08  	                call    NZ,CURSOR_OFF   ; yes, so set cursor off
08B7: CD4D06  	                call    RSTCHRCRS       ; restore char under it
              	                ; first, check if cursor if off, so that we just interpret return as a new line command
08BA: 3A9881  	                ld      A,(KBDNPT)      ; check if input from keyboad
08BD: A7      	                and     A               ; if 0, input is not from keyboard...
08BE: CA3709  	                jp      Z,PRNTRETURN    ; ...so just print a carriage return; otherwise, interpret the return
              	                ; first part: look for the beginning of the text line on screen
08C1: CD5606  	                call    LOAD_CRSR_POS   ; load cursor position into HL
08C4: 225E81  	                ld      (CUR_POS),HL    ; store it
08C7: ED5B5181	                ld      DE,(SCR_NAM_TB) ; load VRAM address of top-left cell of screen ("home")
08CB: E5      	RPTNLLSRC:      push    HL
08CC: CD4036  	                call    CMP16           ; check if at "home"
08CF: E1      	                pop     HL
08D0: CADB08  	                jp      Z,CNTNULL       ; yes, exit because there is nothing before
08D3: 2B      	                dec     HL              ; go 1 step back
08D4: CDE905  	                call    READ_VIDEO_LOC  ; read char of current position
08D7: A7      	                and     A               ; is it $00 (null char)?
08D8: 20F1    	                jr      NZ,RPTNLLSRC    ; no, continue searching
08DA: 23      	                inc     HL              ; move 1 step forward to go back to the last cell with something in
              	                ; second part: look for the ending of the text on screen
08DB: 226081  	CNTNULL:        ld      (SRTTXT),HL     ; store beginning of text
08DE: 3A4E81  	                ld      A,(SCR_SIZE_H)
08E1: 5F      	                ld      E,A             ; load screen height into DE
08E2: 3A4D81  	                ld      A,(SCR_SIZE_W)
08E5: 6F      	                ld      L,A             ; load screen width into HL
08E6: AF      	                xor     A
08E7: 67      	                ld      H,A
08E8: 57      	                ld      D,A
08E9: CD4B36  	                call    MUL16           ; multiply HL times DE to get the screen size
08EC: ED5B5181	                ld      DE,(SCR_NAM_TB) ; load screen name table start address into DE
08F0: 19      	                add     HL,DE           ; get the address...
08F1: 2B      	                dec     HL              ; ...of the "last" video cell
08F2: EB      	                ex      DE,HL           ; store address into DE
08F3: 2A5E81  	                ld      HL,(CUR_POS)    ; retrieve original cursor position
08F6: E5      	RPTNLLSRC2:     push    HL
08F7: CD4036  	                call    CMP16           ; check if at last position on screen (bottom right corner)
08FA: E1      	                pop     HL
08FB: CA0509  	                jp      Z,CNTNULL2      ; if yes, exit because these is nothing after
08FE: 23      	                inc     HL              ; 1 more step forward
08FF: CDE905  	                call    READ_VIDEO_LOC  ; read char of current position
0902: A7      	                and     A               ; is it $00 (null char)?
0903: 20F1    	                jr      NZ,RPTNLLSRC2   ; no, continue searching
0905: 226281  	CNTNULL2:       ld      (ENDTXT),HL     ; store ending of text line
0908: ED5B6081	                ld      DE,(SRTTXT)     ; load beginning of text line
090C: A7      	                and     A               ; clear Carry
090D: ED52    	                sbc     HL,DE           ; how many chars?
090F: 2826    	                jr      Z,PRNTRETURN    ; no chars found (HL-DE=0), so just print return & leave
              	                ;---    central part: send the text on the screen to the interpreter
0911: 2A6081  	                ld      HL,(SRTTXT)     ; load beginning of text line
0914: ED5B6281	                ld      DE,(ENDTXT)     ; load ending of text line
0918: CDE905  	SNDCHRTOBFR:    call    READ_VIDEO_LOC  ; read char
091B: E5      	                push    HL
091C: CD3301  	                call    CHARINTOBFR     ; send char to buffer
091F: E1      	                pop     HL
0920: 23      	                inc     HL              ; go to next char
0921: E5      	                push    HL              ; store HL
0922: CD4036  	                call    CMP16           ; check if DE=HL (finish chars)
0925: E1      	                pop     HL
0926: 20F0    	                jr      NZ,SNDCHRTOBFR  ; no, repeat
0928: 3E0D    	                ld      A,CR            ; yes, so now send carriage return
092A: CD3301  	                call    CHARINTOBFR     ; send to buffer
092D: 2A6281  	                ld      HL,(ENDTXT)     ; recover address of last char of input text
0930: CD7A06  	                call    HL2XY           ; retrieve X,Y from address
0933: 7D      	                ld      A,L             ; move Y into A (we don't need X anymore)
0934: 325481  	                ld      (SCR_CURS_Y),A  ; store new Y
              	                ;---    final part: go at the beginning of a new line on the screen
0937: AF      	PRNTRETURN:     xor     A               ; move to col 0
0938: 325381  	                ld      (SCR_CURS_X),A  ; store new X
093B: 3A5481  	                ld      A,(SCR_CURS_Y)  ; load cursor Y into A
093E: 3C      	                inc     A               ; new row
093F: 214E81  	                ld      HL,SCR_SIZE_H   ; load address of cell that keeps screen height
0942: BE      	                cp      (HL)            ; is the cursor over the bottom of the screen?
0943: 3806    	                jr      C,ADDNEWLINE    ; no, jump over
0945: 3D      	                dec     A               ; yes, so come back 1 row, then...
0946: F5      	                push    AF              ; (store A)
0947: CD3208  	                call    SCROLLUP        ; ...scroll the screen before to...
094A: F1      	                pop     AF              ; (retrieve A)
094B: 325481  	ADDNEWLINE:     ld      (SCR_CURS_Y),A  ; ...store new Y
094E: 3A6481  	                ld      A,(TMPBFR4)     ; retrieve cursor state
0951: A7      	                and     A               ; was it off (A=0)?
0952: C41508  	                call    NZ,CURSOR_ON    ; no, set cursor on
0955: C32506  	                jp      POS_CURSOR      ; position cursor to new location & return to caller
              	
              	; ------------------------------------------------------------------------------
              	                ; this table contains the values of the offsets to be added to
              	                ; the starting address of the name table to find the correct
              	                ; value of the first cell of the corresponding row
              	                ; (by doing so, it's faster than doing a multipication)
              	                ; table for graphics 1 text mode: 32 cols
0958: 00002000	POS_TB_CRS_32   defw    $0000,$0020,$0040,$0060,$0080,$00A0,$00C0,$00E0
095C: 40006000	
0960: 8000A000	
0964: C000E000	
0968: 00012001	                defw    $0100,$0120,$0140,$0160,$0180,$01A0,$01C0,$01E0
096C: 40016001	
0970: 8001A001	
0974: C001E001	
0978: 00022002	                defw    $0200,$0220,$0240,$0260,$0280,$02A0,$02C0,$02E0
097C: 40026002	
0980: 8002A002	
0984: C002E002	
              	                ; table for pure text mode: 40 cols
0988: 00002800	POS_TB_CRS_40   defw    $0000,$0028,$0050,$0078,$00A0,$00C8,$00F0,$0118
098C: 50007800	
0990: A000C800	
0994: F0001801	
0998: 40016801	                defw    $0140,$0168,$0190,$01B8,$01E0,$0208,$0230,$0258
099C: 9001B801	
09A0: E0010802	
09A4: 30025802	
09A8: 8002A802	                defw    $0280,$02A8,$02D0,$02F8,$0320,$0348,$0370,$0398
09AC: D002F802	
09B0: 20034803	
09B4: 70039803	
              	
              	; ------------------------------------------------------------------------------
              	; reset VRAM
09B8: AF      	EMPTY_VRAM:     xor     A               ; reg.A cleared: we fill up VRAM with $00
09B9: 67      	                ld      H,A
09BA: 6F      	                ld      L,A             ; reset HL
09BB: CDC905  	                call    SETVDPADRS      ; set address of first VRAM cell to $0000
09BE: 0640    	                ld      B,$40           ; $40 pages of RAM...
09C0: 57      	                ld      D,A             ; ...each one with $100 cells (tot. $4000 bytes)
09C1: 0E30    	                ld      C,VDP_DAT       ; VDP data mode
09C3: ED79    	EMPTVRM:        out     (C),A           ; after first byte, the VDP autoincrements VRAM pointer
09C5: 14      	                inc     D               ; next cell
09C6: 00      	                nop
09C7: 20FA    	                jr      NZ,EMPTVRM      ; repeat until page is fully cleared
09C9: 10F8    	                djnz    EMPTVRM         ; repeat for $40 pages
09CB: C9      	                ret                     ; return to caller
              	
              	; empty video registers in SRAM
09CC: 214D81  	EMPTY_RAM:      ld      HL,SCR_SIZE_W   ; address of first register
09CF: AF      	                xor     A               ; $00 to clean the registers
09D0: 0645    	                ld      B,CHASNDDTN-SCR_SIZE_W; how many bytes to clean (this is calculated dinamically
              	                                        ; since we can add/remove some registers)
09D2: 77      	RSTVDPRAMREG:   ld      (HL),A          ; reset register
09D3: 23      	                inc     HL              ; next register
09D4: 10FC    	                djnz    RSTVDPRAMREG    ; repeat
09D6: C9      	                ret                     ; return to caller
              	
              	; ------------------------------------------------------------------------------
              	; set a specific graphics mode, passed into reg. E
09D7: 0608    	SET_GFX_MODE:   ld      B,$08           ; 8 registers means 8 bytes..
09D9: CB23    	                sla     E               ; multiply E by 8..
09DB: CB23    	                sla     E               ; so that reg. E can point..
09DD: CB23    	                sla     E               ; to the correct settings
09DF: 1600    	SET_GFX_MODE2:  ld      D,$00           ; reset D
09E1: 21140A  	                ld      HL,VDPMODESET   ; pointer to register settings | <= here points the SHOW_LOGO sub-routine
09E4: 19      	                add     HL,DE           ; add offset to get the correct set of values for the required mode
09E5: 3E80    	                ld      A,$80           ; start with REG0 ($80+register number)
09E7: 0E32    	                ld      C,VDP_SET       ; VDP set
09E9: 56      	LDREGVLS:       ld      D,(HL)          ; load register's value
09EA: ED51    	                out     (C),D           ; send data to VDP
09EC: ED79    	                out     (C),A           ; indicate the register to send data to
09EE: 3C      	                inc     A               ; next register
09EF: 23      	                inc     HL              ; next value
09F0: 10F7    	                djnz    LDREGVLS        ; repeat for 8 registers
09F2: C9      	                ret
              	
              	; ------------------------------------------------------------------------------
09F3:         	LOADCHARSET:    ; reg. A contains the video mode
              	                ; reg. HL contains address of pattern table into VRAM
09F3: 0600    	                ld      B,$00           ; 0=256 chars to load (complete charset)
09F5: CBF4    	                set     $06,H           ; add $4000 to address to indicate that we want to write into VRAM
09F7: 0E32    	                ld      C,VDP_SET       ; load VDP address into C
09F9: ED69    	                out     (C),L           ; send low byte of address
09FB: ED61    	                out     (C),H           ; send high byte
09FD: 218E36  	                ld      HL,CHRST68      ; starting address of 6x8 charset into ROM
0A00: A7      	                and     A               ; is it text mode (A=0)?
0A01: 2803    	                jr      Z,NXTCHAR       ; yes, so jump to load chars into VRAM
0A03: 218E3E  	                ld      HL,CHRST88      ; no, so we change and load the 8x8 charset
0A06: 1608    	NXTCHAR:        ld      D,$08           ; 8 bytes per pattern char
0A08: 0E30    	                ld      C,VDP_DAT       ; VDP data mode
0A0A: 7E      	SENDCHRPTRNS:   ld      A,(HL)          ; load byte to send to VDP
0A0B: ED79    	                out     (C),A           ; write byte into VRAM
0A0D: 23      	                inc     HL              ; inc byte pointer
0A0E: 15      	                dec     D               ; 8 bytes sents (0 char)?
0A0F: 20F9    	                jr      NZ,SENDCHRPTRNS ; no, continue
0A11: 10F3    	                djnz    NXTCHAR         ; yes, decrement chars counter and continue for all the chars
0A13: C9      	                ret                     ; return to caller
              	
              	;------------------------------------------------------------------------------
              	; NAME TABLE:       buffer video - contains the chars to be shown on video
              	; PATTERN TABLE:    charset - contains the chars/tiles to be loaded into the name table
              	; COLOR TABLE:      color settings for chars/tiles
              	
              	                ; VDP register settings for a text display
0A14: 00      	VDPMODESET      defb    %00000000       ; reg.0: external video off
0A15: D0      	                defb    %11010000       ; reg.1: 16K VRAM, video on, int. off, text mode (40x24)
0A16: 02      	                defb    $02             ; reg.2: name table set to $0800 ($02x$400)
0A17: 00      	                defb    $00             ; reg.3: not used in text mode
0A18: 00      	                defb    $00             ; reg.4: pattern table set to $0000
0A19: 00      	                defb    $00             ; reg.5: not used in text mode
0A1A: 00      	                defb    $00             ; reg.6: not used in text mode
0A1B: F5      	                defb    $f5             ; reg.7: white text on light blue background
              	
0A1C:         	VDPMODESET1     ; VDP register settings for a graphics 1 mode
0A1C: 00      	                defb    %00000000       ; reg.0: ext. video off
0A1D: C0      	                defb    %11000000       ; reg.1: 16K Vram; video on, int off, graphics mode 1, sprite size 8x8, sprite magn. 0
0A1E: 06      	                defb    $06             ; reg.2: name table address: $1800
0A1F: 80      	                defb    $80             ; reg.3: color table address: $2000
0A20: 00      	                defb    $00             ; reg.4: pattern table address: $0000
0A21: 36      	                defb    $36             ; reg.5: sprite attr. table address: $1B00
0A22: 07      	                defb    $07             ; reg.6: sprite pattern table addr.: $3800
0A23: 05      	                defb    $05             ; reg.7: backdrop color (light blue)
              	
0A24:         	VDPMODESET2     ; VDP register settings for a graphics 2 mode
0A24: 02      	                defb    %00000010       ; reg.0: graphics 2 mode, ext. video dis.
0A25: C0      	                defb    %11000000       ; reg.1: 16K VRAM, video on, INT off, sprite size 8x8, sprite magn. 0
0A26: 06      	                defb    $06             ; reg.2: name table addr.: $1800
0A27: FF      	                defb    $FF             ; reg.3: color table addr.: $2000
0A28: 03      	                defb    $03             ; reg.4: pattern table addr.: $0000
0A29: 36      	                defb    $36             ; reg.5: sprite attr. table addr.: $1B00
0A2A: 07      	                defb    $07             ; reg.6: sprite pattern table addr.: $3800
0A2B: 05      	                defb    $05             ; reg.7: backdrop color: light blue
              	
0A2C:         	VDPMODESETMC    ; VDP register settings for a multicolor mode
0A2C: 00      	                defb    %00000000       ; reg.0: ext. video dis.
0A2D: CB      	                defb    %11001011       ; reg.1: 16K VRAM, video on, INT off, multicolor mode, sprite size 8x8, sprite magn. 0
0A2E: 02      	                defb    $02             ; reg.2: name table addr.: $0800
0A2F: 00      	                defb    $00             ; reg.3: don't care
0A30: 00      	                defb    $00             ; reg.4: pattern table addr.: $0000
0A31: 36      	                defb    $36             ; reg.5: sprite attr. table addr.: $1B00
0A32: 07      	                defb    $07             ; reg.6: sprite pattern table addr.: $3800
0A33: 0F      	                defb    $0F             ; reg.7: backdrop color (white)
              	
0A34:         	VDPMODESETEX2   ; VDP register settings for an extended graphics 2 mode
0A34: 02      	                defb    %00000010       ; reg.0: graphics 2 mode, ext. video dis.
0A35: C0      	                defb    %11000000       ; reg.1: 16K VRAM, video on, INT off, sprite size 8x8, sprite magn. 0
0A36: 0E      	                defb    $0E             ; reg.2: name table addr.: $3800
0A37: 9F      	                defb    $9F             ; reg.3: color table addr.: $2000
0A38: 00      	                defb    $00             ; reg.4: pattern table addr.: $0000
0A39: 76      	                defb    $76             ; reg.5: sprite attr. table addr.: $3B00
0A3A: 03      	                defb    $03             ; reg.6: sprite pattern table addr.: $1800
0A3B: 05      	                defb    $05             ; reg.7: backdrop color: light blue
              	
0A3C:         	LM80CLOGO       ; patterns to compose the splash screen logo
0A3C: 00000000	                defb    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0A40: 00...   	
0A5C: 00000F0A	                defb    0,0,15,10,11,16,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0A60: 0B100000	
0A64: 00000000	
0A68: 00...   	
0A7C: 00000D17	                defb    0,0,13,23,0,12,0,0,0,1,0,0,0,20,0,0,6,5,6,21,22,7,6,21,22,7,6,1,1,7,0,0
0A80: 000C0000	
0A84: 00010000	
0A88: 00140000	
0A8C: 06050615	
0A90: 16070615	
0A94: 16070601	
0A98: 01070000	
0A9C: 00000D00	                defb    0,0,13,0,0,12,0,0,0,1,0,0,0,1,20,6,1,5,3,5,3,5,3,5,3,5,3,5,3,5,0,0
0AA0: 000C0000	
0AA4: 00010000	
0AA8: 00011406	
0AAC: 01050305	
0AB0: 03050305	
0AB4: 03050305	
0AB8: 03050000	
0ABC: 00000D00	                defb    0,0,13,0,0,12,0,0,0,1,0,0,0,1,1,1,1,5,9,20,19,8,3,5,19,5,3,5,0,0,0,0
0AC0: 000C0000	
0AC4: 00010000	
0AC8: 00010101	
0ACC: 01050914	
0AD0: 13080305	
0AD4: 13050305	
0AD8: 00000000	
0ADC: 00000D00	                defb    0,0,13,0,0,12,0,0,0,1,0,0,0,1,0,8,3,5,6,21,22,7,3,1,22,5,3,5,0,0,0,0
0AE0: 000C0000	
0AE4: 00010000	
0AE8: 00010008	
0AEC: 03050615	
0AF0: 16070301	
0AF4: 16050305	
0AF8: 00000000	
0AFC: 00000D00	                defb    0,0,13,0,0,12,0,0,0,1,0,0,0,1,0,0,3,5,3,5,3,5,3,5,3,5,3,5,3,5,0,0
0B00: 000C0000	
0B04: 00010000	
0B08: 00010000	
0B0C: 03050305	
0B10: 03050305	
0B14: 03050305	
0B18: 03050000	
0B1C: 00000D00	                defb    0,0,13,0,0,12,0,0,0,1,4,4,0,1,0,0,3,5,9,20,19,8,9,20,19,8,9,1,1,8,0,0
0B20: 000C0000	
0B24: 00010404	
0B28: 00010000	
0B2C: 03050914	
0B30: 13080914	
0B34: 13080901	
0B38: 01080000	
0B3C: 00000E12	                defb    0,0,14,18,18,17,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0B40: 12110000	
0B44: 00000000	
0B48: 00...   	
0B5C: 00000000	                defb    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0; ------------------------------------------------------------------------------
0B60: 00...   	
              	; LM80C - PSG ROUTINES - R3.6
              	; ------------------------------------------------------------------------------
              	; The following code is intended to be used with LM80C Z80-based computer
              	; designed by Leonardo Miliani. Code and computer schematics are released under
              	; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
              	; kind of warranty: you can use them at your own risk.
              	; You are free to use them for any non-commercial use: you are only asked to
              	; maintain the copyright notices, include this advice and the note to the 
              	; attribution of the original version to Leonardo Miliani, if you intend to
              	; redistribuite them.
              	; https://www.leonardomiliani.com
              	; 
              	; Please support me by visiting the following links:
              	; Main project page: https://www.leonardomiliani.com
              	; Schematics and code: https://github.com/leomil72/LM80C
              	; Videos about the computer: https://www.youtube.com/user/leomil72/videos
              	; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
              	; ------------------------------------------------------------------------------
              	; Code Revision:
              	; R2.1   - 20190818 - Added SOUND command to play simple tones and VOLUME command
              	; R2.1a  - 20190908 - Cursor management improvements
              	; R2.2   - 20190920 - Fixed cursor bug within SCREEN statement; new command PAUSE
              	; R2.3   - 20190930 - Fixed bugs in SOUND command
              	; R2.4   - 20191013 - Added new graphic chars and reorganized previous ones
              	; R2.4a  - 20191015 - More graphic chars
              	; R2.5   - 20191026 - Revision of init PSG code; revision of serial buffer exp. code;
              	;                     fixed a bug into the video buffer manager
              	; R2.6   - 20191102 - New function INKEY to read a key without a prompt;
              	;                     source code cleaning
              	; R2.7   - 20191116 - Fixed a bug into the INKEY code
              	; R2.8   - 20191207 - Minor bug fixes; added support for built-in keyboard;
              	;                     revision of some char codes;
              	; R2.8.1 - 20191208 - Introduced support for SHIFT key for uppercase letters & alternate chars
              	; R2.8.2 - 20191215 - Fixed a bug introduced with 2.8.1 that lead to wrong functioning of
              	;                     several BASIC statements (system tick counter, Locate, etc..)
              	; R2.9   - 20191222 - Code cleaning; improved SOUND statement; revision of PSG code;
              	;                     revision of release notes; add support for cursor keys & cursor movements
              	; R2.10  - 20191226 - SIO init code cleaning & improved support for serial RX; added extended
              	;                     char codes (128-255) for 6x8 fonts; removed double chars in 8x8 fonts
              	; R2.11  - 20200110 - Set graphics 2 VRAM in a better way; fixed TAB() function; new SCREEN 4 mode;
              	;                     new PLOT, DRAW, and CIRCLE commands
              	; R2.12  - 20200124 - Code optimizing; fixed a bug into the CIRCLE routine; new splash screen
              	;                     with a graphic logo
              	; R2.13  - 20200127 - Implemented ALT & CTRL keys to print graphic chars with keyboard;
              	;                     code improvements; faster cursor flashing
              	; R2.14  - 20200203 - Better CLS code (no more color flashes in graphics modes); added SYS command
              	; R2.15  - 20200225 - Now the computer starts as a stand-alone system, with serial disabled;
              	;                     new SERIAL command
              	; R3.0   - 20200228 - Major changes to kernel, now the computer has a full-screen inline editor:
              	;                     it now acts as an old home computer of the '80s, getting statements from
              	;                     anywhere the cursor is; removed MONITOR statement; code cleaning & optimization;
              	;                     adopted usual hexadecimal & binary prefixes
              	; R3.1   - 20200304 - Added XOR statement; fixed a bug for SERIAL (chars sent over serial were $01);
              	;                     removed NULL statement; added compilation date & time into ROM file
              	; R3.2   - 20200309 - Added sprite size and sprite magnification settings to SCREEN statement;
              	;                     fixed a bug in warm/cold reset input routine
              	; R3.3   - 20200315 - Code cleaning; improved LIST command
              	; R3.4   - 20200329 - Removed POINT and SET statements and their legacies; changed default colors for
              	;                     screens 1 & 4; enhanced serial communication on port 1, fixed freezing bug and
              	;                     added new function to SERIAL statement; fixed TAB function
              	; R3.5   - 20200408 - Fixed a bug into the new code of LIST statement; serial & BASIC buffers expanded
              	;                     to 88 chars; fixed a little bug into editor (pressing RETURN over a multi-line text
              	;                     did not reposition the cursor after the end of it)
              	; R3.6   - 20200419 - Minor improvement in LIST code; fixed a bug in sound management (automatic cutting down
              	;                     of a sound wrongly altered the sound mixer); added management of noise from PSG;
              	;                     fixed some timing issues in VDP access that lead to graphic glitches in graphic mode 2;
              	;                     code improvements
              	;
              	; ------------------------------------------------------------------------------
              	
              	;------------------------------------------------------------------------------
              	; configure the PSG
0B7C: 219281  	initPSG:        ld      HL,CHASNDDTN    ; starting address of sound & keyboard RAM registers
0B7F: 060A    	                ld      B,$0A           ; # of PSG sound & keyboard registers
0B81: AF      	                xor     A               ; reset A
0B82: 77      	EMPTSNDBFR:     ld      (HL),A          ; reset RAM register
0B83: 23      	                inc     HL              ; next register
0B84: 10FC    	                djnz    EMPTSNDBFR      ; repeat
0B86: 0610    	CLRPSGREGS:     ld      B,$10           ; 16 registers to set
0B88: 219A0B  	                ld      HL,SNDREGCFG    ; starting address of register settings
0B8B: 1600    	                ld      D,$00           ; first register
0B8D: 7A      	RSTPSG:         ld      A,D             ; register value
0B8E: CDD40B  	                call    SETSNDREG       ; select register
0B91: 7E      	                ld      A,(HL)          ; load value
0B92: CDD90B  	                call    WRTSNDREG       ; write to register
0B95: 14      	                inc     D               ; next register
0B96: 23      	                inc     HL              ; next value
0B97: 10F4    	                djnz    RSTPSG          ; repeat for each register
0B99: C9      	                ret                     ; return to caller
              	
0B9A: 00000000	SNDREGCFG:      defb $00,$00,$00,$00,$00,$00,$00,%01111111
0B9E: 0000007F	
0BA2: 00000000	                defb $00,$00,$00,$00,$00,$00,$ff,$ff
0BA6: 0000FFFF	
              	                ; reg. 7: set I/O ch.A to OUTPUT, I/O ch.B to INPUT; set noise to OFF; set audio to OFF
              	
              	
              	; routines to play a welcome beep on channel C (tone 4010) and to shut it off
0BAA: 21C40B  	WLCMBEEP:       ld      HL,WLCBPDAT     ; data address
0BAD: C3B30B  	                jp      SENDSND
0BB0: 21CC0B  	NOBEEP:         ld      HL,NOBPDAT      ; data address
0BB3: C5      	SENDSND:        push    BC
0BB4: 0604    	                ld      B,$04           ; 4 pairs
0BB6: 7E      	RPTWLCMBP:      ld      A,(HL)          ; read register #
0BB7: CDD40B  	                call    SETSNDREG
0BBA: 23      	                inc     HL              ; next cell
0BBB: 7E      	                ld      A,(HL)          ; read value
0BBC: CDD90B  	                call    WRTSNDREG
0BBF: 23      	                inc     HL
0BC0: 10F4    	                djnz    RPTWLCMBP       ; repeat
0BC2: C1      	                pop     BC
0BC3: C9      	                ret                     ; return to caller
              	
0BC4: 077B0456	WLCBPDAT:       defb    $07,%01111011,$04,$56,$05,$00,$0A,$0F
0BC8: 05000A0F	
0BCC: 04000500	NOBPDAT:        defb    $04,$00,$05,$00,$0A,$00,$07,%01111111
0BD0: 0A00077F	
              	
              	
              	; select register on PSG
0BD4: 0E40    	SETSNDREG:      ld      C,PSG_REG       ; PSG register port
0BD6: ED79    	                out     (C),A           ; set register
0BD8: C9      	                ret                     ; return to caller
              	
              	; send data to PSG
0BD9: 0E41    	WRTSNDREG:      ld      C,PSG_DAT       ; PSG data port
0BDB: ED79    	                out     (C),A           ; send data
0BDD: C9      	                ret                     ; return to caller
              	
              	; manage the sounds' duration: each time this subroutine is called, it
              	; decrements the single sound durations (measured in ms) and eventually
              	; shut off the audio channel whose counter has reached 0.
              	; (this sub-routine is called by CH3 timer ISR)
0BDE: DDE5    	MNGSNDS:        push    IX              ; store IX
0BE0: DD219281	                ld      IX,CHASNDDTN    ; starting address of tones duration
0BE4: 0603    	                ld      B,$03           ; 3 channels to check
0BE6: 2601    	                ld      H,$01           ; mixer channels: A=>bit 1, B=>bit 2, C=>bit 3
0BE8: DD5E00  	CHKSNDCH:       ld      E,(IX+0)        ; load LSB into E
0BEB: DD5601  	                ld      D,(IX+1)        ; load MSB into D
0BEE: 7B      	                ld      A,E             ; load E into A
0BEF: B2      	                or      D               ; check that DE=0
0BF0: 282D    	                jr      Z,CNTCHKSND     ; yes, jump over
0BF2: 1B      	                dec     DE              ; no, so decrement DE
0BF3: 7B      	                ld      A,E             ; reload E into A...
0BF4: DD7300  	                ld      (IX+0),E        ; store new...
0BF7: DD7201  	                ld      (IX+1),D        ; ...duration and...
0BFA: B2      	                or      D               ; ...do another check to see if DE=0
0BFB: 2022    	                jr      NZ,CNTCHKSND    ; no, so jump over
              	                                        ; if yes, let's shut down the corresponding channel
              	                                        ; to shut down a tone we set 0 into tone register
              	                                        ; and disable the channel into mixer
0BFD: 3E03    	                ld      A,$03           ; three channels
0BFF: 90      	                sub     B               ; find current channel (0->A, 1->B, 2->C)
0C00: 87      	                add     A,A             ; and find first register (A=>0, B=>2, C=>4)
0C01: 0E40    	                ld      C,PSG_REG       ; PSG register selector port
0C03: ED79    	                out     (C),A           ; select first tone register of channel
0C05: 2E00    	                ld      L,$00           ; value 0 into L
0C07: 0E41    	                ld      C,PSG_DAT       ; PSG data selector port
0C09: ED69    	                out     (C),L           ; write 0 into register
0C0B: 0E40    	                ld      C,PSG_REG       ; PSG register selector port
0C0D: 3C      	                inc     A               ; next tone register
0C0E: ED79    	                out     (C),A           ; select second tone register of channel
0C10: 0E41    	                ld      C,PSG_DAT       ; PSG data selector port
0C12: ED69    	                out     (C),L           ; write 0 into register
0C14: 3E07    	                ld      A,$07           ; mixer register
0C16: 0E40    	                ld      C,PSG_REG       ; PSG register selector port
0C18: ED79    	                out     (C),A           ; set mixer register
0C1A: ED78    	                in      A,(C)           ; load current value
0C1C: B4      	                or      H               ; set off the channel into the mixer (remember that 1=OFF)
0C1D: ED79    	                out     (C),A           ; send new value for the mixer
0C1F: DD23    	CNTCHKSND:      inc     IX              ; set for...
0C21: DD23    	                inc     IX              ; ...next channel...
0C23: CB24    	                sla     H               ; shift left H 1 bit
0C25: 10C1    	                djnz    CHKSNDCH        ; repeat for 3 channels
0C27: DDE1    	                pop     IX              ; restore IX
0C29: C9      	                ret                     ; return to caller
              	
              	; read a specific row of the keyboard matrix, set by A
              	; return read into A
0C2A: C5      	READKBLN:       push    BC
0C2B: 060E    	                ld      B,$0E           ; reg #14
0C2D: 0E40    	                ld      C,PSG_REG       ; PSG register port
0C2F: ED41    	                out     (C),B           ; select reg #14
0C31: 0E41    	                ld      C,PSG_DAT       ; PSG data port
0C33: ED79    	                out     (C),A           ; activate SHIFT row
0C35: 060F    	                ld      B,$0F           ; register #15 (port B)
0C37: 0E40    	                ld      C,PSG_REG       ; PSG register port
0C39: ED41    	                out     (C),B           ; select reg. 15 (port B)
0C3B: ED78    	                in      A,(C)           ; read register #15
0C3D: C1      	                pop     BC
0C3E: C9      	                ret
              	
              	; read the keyboard matrix to look for a key pressure
0C3F: 0E40    	KEYBOARD:       ld      C,PSG_REG       ; PSG register port
0C41: 0607    	                ld      B,$07           ; set register #7...
0C43: ED41    	                out     (C),B           ; ...to work with
0C45: ED78    	                in      A,(C)           ; read register #7
0C47: CBF7    	                set     6,A             ; port A set to output
0C49: CBBF    	                res     7,A             ; port B set to input
0C4B: ED41    	                out     (C),B           ; set register #7
0C4D: 0E41    	                ld      C,PSG_DAT       ; PSG data port
0C4F: ED79    	                out     (C),A           ; set I/O ports w/o altering the rest of the mixer
              	                ; check special keys (SHIFT/ALT/CTRL)
0C51: 3EFD    	                ld      A,%11111101     ; select SHIFT row
0C53: CD2A0C  	                call    READKBLN        ; read row
0C56: CB5F    	                bit     3,A             ; test if SHIFT key is pressed (4th bit is reset)
0C58: 2005    	                jr      NZ,CHECKALT     ; no, so go on
0C5A: 219C81  	                ld      HL,CONTROLKEYS  ; control key flags
0C5D: 3601    	                ld      (HL),%00000001  ; set SHIFT flag, reset CTRL & ALT flags (currently multiply control keys are NOT supported)
0C5F: 3EFE    	CHECKALT:       ld      A,%11111110     ; select ALT row
0C61: CD2A0C  	                call    READKBLN        ; read ALT row
0C64: CB6F    	                bit     5,A             ; test if ALT key is pressed (5th bit is reset)
0C66: 2005    	                jr      NZ,CHECKCTRL    ; no, so go on
0C68: 219C81  	                ld      HL,CONTROLKEYS  ; control key flags
0C6B: 3604    	                ld      (HL),%00000100  ; set ALT flag, reset SHIFT & CTRL flag (currently multiply control keys are NOT supported)
0C6D: 3EFE    	CHECKCTRL:      ld      A,%11111110     ; select CTRL row
0C6F: CD2A0C  	                call    READKBLN        ; read CTRL row
0C72: CB57    	                bit     2,A             ; test if CTRL key is pressed (3rd bit is reset)
0C74: 2005    	                jr      NZ,CHECKKBD     ; no, so make a normal reading
0C76: 219C81  	                ld      HL,CONTROLKEYS  ; control key flags
0C79: 3602    	                ld      (HL),%00000010  ; set CTRL flag, reset SHIFT & ALT flags (currently multiply control keys are NOT supported)
0C7B: 0608    	CHECKKBD:       ld      B,$08           ; 8 lines
0C7D: 3E7F    	                ld      A,%01111111     ; start from the last line of the matrix
0C7F: 160E    	RPTKBDRD:       ld      D,$0E           ; register #14 (port A)
0C81: 0E40    	                ld      C,PSG_REG       ; PSG register port
0C83: ED51    	                out     (C),D           ; select reg. #14
0C85: 0E41    	                ld      C,PSG_DAT       ; PSG data port
0C87: ED79    	                out     (C),A           ; activate 1 line (active line is grounded, i.e. with a LOW signal)
0C89: 5F      	                ld      E,A             ; save current line into E
0C8A: 160F    	                ld      D,$0F           ; register #15 (port B)
0C8C: 0E40    	                ld      C,PSG_REG       ; PSG register port
0C8E: ED51    	                out     (C),D           ; select reg. 15 (port B)
0C90: 00      	                nop
0C91: ED78    	                in      A,(C)           ; read register #15
0C93: FEFF    	                cp      $FF             ; is there any line set to 0?
0C95: 282E    	                jr      Z,NOKEYPRSD     ; no, go to the next row
              	                ; check control keys
0C97: 329981  	                ld      (KBTMP),A       ; yes, check if a control key was pressed. First, store current row
0C9A: 78      	                ld      A,B             ; copy current row (B) into A
0C9B: FE02    	                cp      $02             ; is it the row of the SHIFT?
0C9D: 200F    	                jr      NZ,TESTALT      ; no, continue checking the other control keys
0C9F: 3A9981  	                ld      A,(KBTMP)       ; yes, retrieve current row data
0CA2: CB5F    	                bit     3,A             ; check SHIFT bit line
0CA4: 202E    	                jr      NZ,FINDKEY      ; no SHIFT, continue checking
0CA6: CBDF    	                set     3,A             ; yes, it's the SHIFT. So remove SHIFT bit
0CA8: FEFF    	                cp      $FF             ; after deleting the SHIFT bit, is there any other bit selected?
0CAA: 2028    	                jr      NZ,FINDKEY      ; yes, go to check which one
0CAC: 1817    	                jr      NOKEYPRSD       ; no, go to next row        
0CAE: FE01    	TESTALT:        cp      $01             ; is it the line of ALT & CTRL?
0CB0: 3A9981  	                ld      A,(KBTMP)       ; retrieve current row data
0CB3: 201F    	                jr      NZ,FINDKEY      ; no, continue
0CB5: CB6F    	                bit     5,A             ; yes, check ALT bit line
0CB7: 2002    	                jr      NZ,TESTCTRL     ; no ALT, continue checking
0CB9: CBEF    	                set     5,A             ; yes, it's the ALT. So remove ALT bit
0CBB: CB57    	TESTCTRL:       bit     2,A             ; check CTRL bit line
0CBD: 2002    	                jr      NZ,ENDCTRLCK    ; no CTRL, continue checking
0CBF: CBD7    	                set     2,A             ; delete CTRL bit flag
0CC1: FEFF    	ENDCTRLCK:      cp      $FF             ; after deleting the ALT & CTRL bits, is there any other bit selected?
0CC3: 200F    	                jr      NZ,FINDKEY      ; yes, go to check which one
0CC5: 7B      	NOKEYPRSD:      ld      A,E             ; no key pressed, load current output port
0CC6: 0F      	                rrca                    ; rotate right by 1
0CC7: 10B6    	                djnz    RPTKBDRD        ; repeat for 8 lines
0CC9: AF      	                xor     A               ; if exit from here, no key has been pressed...
0CCA: 329B81  	                ld      (LASTKEYPRSD),A ; ...so reset the last key cell...
0CCD: 329C81  	                ld      (CONTROLKEYS),A ; ...reset contro key flags...
0CD0: 329881  	                ld      (KBDNPT),A      ; ...no input from keyboard...
0CD3: C9      	                ret                     ; ...and leave
0CD4: 1EFF    	FINDKEY:        ld      E,$FF           ; counter
0CD6: 1C      	CHKLN:          inc     E               ; E goes from 0 to 7
0CD7: CB3F    	                srl     A               ; is the first bit reset? (we're looking for a "0", meaning grounded line)
0CD9: 38FB    	                jr      C,CHKLN         ; no, check next bit
0CDB: 3A9C81  	                ld      A,(CONTROLKEYS) ; load control key flags
0CDE: 21470D  	                ld      HL,KBMAP        ; normal keymap
0CE1: FE01    	                cp      $01             ; SHIFT flag?
0CE3: 2005    	                jr      NZ,CHKCTRL      ; no, jump over
0CE5: 21870D  	                ld      HL,KBMAP_SFT    ; SHIFT keymap
0CE8: 1810    	                jr      LOADMAP         ; and load it
0CEA: FE02    	CHKCTRL:        cp      $02             ; CTRL flag?
0CEC: 2005    	                jr      NZ,CHKALT       ; no, jump over
0CEE: 21070E  	                ld      HL,KBMAP_CTRL   ; CTRL map
0CF1: 1807    	                jr      LOADMAP         ; and load it
0CF3: FE04    	CHKALT:         cp      $04             ; ALT flag?
0CF5: 2003    	                jr      NZ,LOADMAP      ; no, check over
0CF7: 21C70D  	                ld      HL,KBMAP_ALT    ; ALT map
0CFA: 05      	LOADMAP:        dec     B               ; decrement row # (rows go from 0 to 7)
0CFB: 48      	                ld      C,B             ; move B into C and...
0CFC: CB21    	                sla     C               ; ...multiply it...
0CFE: CB21    	                sla     C               ; ...by 8 to find...
0D00: CB21    	                sla     C               ; ...the current row into the matrix
0D02: 0600    	                ld      B,$00           ; reset B
0D04: 09      	                add     HL,BC           ; find the address of the current row
0D05: 50      	                ld      D,B             ; reset D
0D06: 19      	                add     HL,DE           ; find the current column
0D07: 3A9B81  	                ld      A,(LASTKEYPRSD) ; load the last key pressed
0D0A: BE      	                cp      (HL)            ; is it the same key?
0D0B: 2839    	                jr      Z,LVKBRDCHK     ; yes, so do nothing
0D0D: 7E      	                ld      A,(HL)          ; no, load it...
0D0E: 329B81  	                ld      (LASTKEYPRSD),A ; ...store it...
0D11: 329A81  	                ld      (TMPKEYBFR),A   ; ...insert it into the INKEY buffer...
0D14: 325B81  	                ld      (CHR4VID),A     ; ...store char for video and...
0D17: FE03    	                cp      CTRLC           ; is it RUN/STOP?
0D19: 2005    	                jr      NZ,CNTKBCK      ; no, jump over
0D1B: CD3301  	                call    CHARINTOBFR     ; yes, send directly to buffer and...
0D1E: 1822    	                jr      LVKBRDCHK2      ; ...leave
0D20: 3E01    	CNTKBCK:        ld      A,$01           ; set input flag
0D22: 329881  	                ld      (KBDNPT),A      ; to keyboard
0D25: 3A5A81  	                ld      A,(PRNTVIDEO)   ; load status of print-on-video
0D28: B7      	                or      A               ; is the print-on-video disabled?
0D29: CA320D  	                jp      Z,PUTCHRBUF     ; yes, so send char to input buffer
0D2C: 3A5881  	                ld      A,(CRSR_STATE)  ; check cursor state
0D2F: B7      	                or      A               ; is it 0 (cursor OFF)?
0D30: 200D    	                jr      NZ,PNT2VD       ; no, print on screen
0D32: AF      	PUTCHRBUF:      xor     A
0D33: 329881  	                ld      (KBDNPT),A      ; if send to input buffer, set RETURN as from BASIC
0D36: 3A9A81  	                ld      A,(TMPKEYBFR)   ; retrieve char
0D39: CD3301  	                call    CHARINTOBFR     ; cursor off, so send char to buffer...
0D3C: C3420D  	                jp      LVKBRDCHK2      ; ...and leave
0D3F: CD8B06  	PNT2VD:         call    CHAR2VID        ; send char to video
0D42: AF      	LVKBRDCHK2:     xor     A
0D43: 329C81  	                ld      (CONTROLKEYS),A ; reset control key flags
0D46: C9      	LVKBRDCHK:      ret                     ; return to caller: the current key code is into TMPKEYBFR              
              	
              	;-----------------------------------------------------------------------
              	; key codes
0D47: 31190E03	KBMAP:          defb '1',25,14,3,' ',16,'q','2'         ; 25=HOME  14=CTRL  3=RUN/STOP 16=C=
0D4B: 20107132	
0D4F: 33776114	                defb '3','w','a',20,'z','s','e','4'     ; 20=SHIFT
0D53: 7A736534	
0D57: 35726478	                defb '5','r','d','x','c','f','t','6'
0D5B: 63667436	
0D5F: 37796776	                defb '7','y','g','v','b','h','u','8'
0D63: 62687538	
0D67: 39696A6E	                defb '9','i','j','n','m','k','o','0'
0D6B: 6D6B6F30	
0D6F: 1F706C2C	                defb 31,'p','l',',','.',':','-',30      ; 31=CURSOR DOWN  30=CURSOR UP
0D73: 2E3A2D1E	
0D77: 1C2A3B2F	                defb 28,'*',';','/',27,'=','+',29       ; 28=CURSOR LEFT  27=ESCAPE  29=CURSOR RIGHT
0D7B: 1B3D2B1D	
0D7F: 080DFC40	                defb 8,13,252,'@',1,2,4,24              ; 8=DEL(backspace)  13=RETURN  252=  1=F1  2=F2  4=F3  24=HELP
0D83: 01020418	
              	
              	; shifted codes - not all the keys have the shifted version
0D87: 210C0E03	KBMAP_SFT:      defb '!',12,14,3,' ',16,'Q',34          ; 12=CLEAR  14=CTRL  3=RUN/STOP 16=C=   34="
0D8B: 20105122	
0D8F: 23574114	                defb '#','W','A',20,'Z','S','E','$'     ; 20=SHIFT
0D93: 5A534524	
0D97: 25524458	                defb '%','R','D','X','C','F','T','&'
0D9B: 43465426	
0D9F: 27594756	                defb 39,'Y','G','V','B','H','U','('     ; 39='
0DA3: 42485528	
0DA7: 29494A4E	                defb ')','I','J','N','M','K','O',94     ; 94=^
0DAB: 4D4B4F5E	
0DAF: 1F504C3C	                defb 31,'P','L','<','>','[','_',30      ; 31=CURSOR DOWN  30=CURSOR UP
0DB3: 3E5B5F1E	
0DB7: 1C2A5D3F	                defb 28,'*',']','?',27,198,'+',29       ; 28=CURSOR LEFT  27=ESCAPE  29=CURSOR RIGHT
0DBB: 1BC62B1D	
0DBF: 080DD340	                defb 8,13,211,'@',5,6,22,23             ; 211=  5=F4  6=F5  22=F6  23=F7
0DC3: 05061617	
              	
              	; ALT (C=) codes - not all the keys have the alt-ed version
0DC7: 310C0E03	KBMAP_ALT:      defb '1',12,14,3,' ',16,222,196         ; 12=CLEAR  14=CTRL  3=RUN/STOP  16=C=  34="
0DCB: 2010DEC4	
0DCF: 33DD8514	                defb '3',221,133,20,131,130,165,'4'     ; 20=SHIFT
0DD3: 8382A534	
0DD7: 35A2A684	                defb '5',162,166,132,157,163,168,'6'
0DDB: 9DA3A836	
0DDF: 37ABA9A1	                defb '7',171,169,161,158,172,213,'8'    ;
0DE3: 9EACD538	
0DE7: 39D6D89F	                defb '9',214,216,159,160,215,135,195    ;
0DEB: A0D787C3	
0DEF: 1F888AC1	                defb 31,136,138,193,192,123,144,30      ; 31=CURSOR DOWN  123={  30=CURSOR UP
0DF3: C07B901E	
0DF7: 1C8F7DFE	                defb 28,143,125,254,27,209,148,29       ; 28=CURSOR LEFT  125=}  27=ESCAPE  29=CURSOR RIGHT
0DFB: 1BD1941D	
0DFF: 080DE089	                defb 8,13,224,137,5,6,22,23             ; 8=DEL(backspace)  13=RETURN  252=  5=F4  6=F5  22=F6  23=F7
0E03: 05061617	
              	
              	; CTRL codes - not all the keys have the control-ed version
0E07: 31190E03	KBMAP_CTRL:     defb '1',25,14,3,' ',16,154,'2'         ; 25=HOME  14=CTRL  3=RUN/STOP  16=C=
0E0B: 20109A32	
0E0F: 339C9514	                defb '3',156,149,20,152,150,153,'4'     ; 20=SHIFT
0E13: 98969934	
0E17: 359BB097	                defb '5',155,176,151,177,175,165,'6'
0E1B: B1AFA536	
0E1F: 37A6A8B2	                defb '7',166,168,178,179,169,167,'8'
0E23: B3A9A738	
0E27: 39B8AAAC	                defb '9',184,170,172,171,181,164,'0'
0E2B: ABB5A430	
0E2F: 1FA3AD2C	                defb 31,163,173,',','.',':',186,30      ; 31=CURSOR DOWN  30=CURSOR UP
0E33: 2E3ABA1E	
0E37: 1CE13B2F	                defb 28,225,';','/',27,212,185,29       ; 28=CURSOR LEFT  27=ESCAPE  212=  29=CURSOR RIGHT
0E3B: 1BD4B91D	
0E3F: 080DBDA2	                defb 8,13,189,162,1,2,4,24              ; 8=DEL(backspace)  13=RETURN  252=  1=F1  2=F2  4=F3  24=HELP; ------------------------------------------------------------------------------
0E43: 01020418	
              	; LM80C - BASIC32K - R3.6
              	; ------------------------------------------------------------------------------
              	; The following code is intended to be used with LM80C Z80-based computer
              	; designed by Leonardo Miliani. Code and computer schematics are released under
              	; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
              	; kind of warranty: you can use them at your own risk.
              	; You are free to use them for any non-commercial use: you are only asked to
              	; maintain the copyright notices, include this advice and the note to the 
              	; attribution of the original version to Leonardo Miliani, if you intend to
              	; redistribuite them.
              	; https://www.leonardomiliani.com
              	; 
              	; Please support me by visiting the following links:
              	; Main project page: https://www.leonardomiliani.com
              	; Schematics and code: https://github.com/leomil72/LM80C
              	; Videos about the computer: https://www.youtube.com/user/leomil72/videos
              	; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
              	; ------------------------------------------------------------------------------
              	; Code Revision:
              	; R1.4   - 20190514
              	; R1.5   - 20190521 - Video cursor management - preliminary
              	; R1.6   - 20190524 - Video management
              	; R1.7   - 20190606 - Added SCREEN command to change video mode
              	; R1.8   - 20190615 - Better cursor integration; added VPOKE & VPEEK statements; 6x8 & 8x8 fonts
              	; R1.9   - 20190620 - Default string space set to 100 bytes; added VREG, VSTAT, & LOCATE statements; 8x8 fonts completed
              	; R2.0   - 20190714 - Added SREG & SSTAT to write to/read from PSG
              	; R2.1   - 20190818 - Added SOUND command to play simple tones and VOLUME command
              	; R2.1a  - 20190908 - Cursor management improvements
              	; R2.2   - 20190920 - Fixed cursor bug within SCREEN statement; new command PAUSE
              	; R2.3   - 20190930 - Fixed bugs in SOUND command
              	; R2.4   - 20191013 - Added new graphic chars and reorganized previous ones
              	; R2.4a  - 20191015 - More graphic chars
              	; R2.5   - 20191026 - Revision of init PSG code; revision of serial buffer exp. code;
              	;                     fixed a bug into the video buffer manager
              	; R2.6   - 20191102 - New function INKEY to read a key without a prompt;
              	;                     source code cleaning
              	; R2.7   - 20191116 - Fixed a bug into the INKEY code
              	; R2.8   - 20191207 - Minor bug fixes; added support for built-in keyboard;
              	;                     revision of some char codes;
              	; R2.8.1 - 20191208 - Introduced support for SHIFT key for uppercase letters & alternate chars
              	; R2.8.2 - 20191215 - Fixed a bug introduced with 2.8.1 that lead to wrong functioning of
              	;                     several BASIC statements (system tick counter, Locate, etc..)
              	; R2.9   - 20191222 - Code cleaning; improved SOUND statement; revision of PSG code;
              	;                     revision of release notes; add support for cursor keys & cursor movements
              	; R2.10  - 20191226 - SIO init code cleaning & improved support for serial RX; added extended
              	;                     char codes (128-255) for 6x8 fonts; removed double chars in 8x8 fonts
              	; R2.11  - 20200110 - Set graphics 2 VRAM in a better way; fixed TAB() function; new SCREEN 4 mode;
              	;                     new PLOT, DRAW, and CIRCLE commands
              	; R2.12  - 20200124 - Code optimizing; fixed a bug into the CIRCLE routine; new splash screen
              	;                     with a graphic logo
              	; R2.13  - 20200127 - Implemented ALT & CTRL keys to print graphic chars with keyboard;
              	;                     code improvements; faster cursor flashing
              	; R2.14  - 20200203 - Better CLS code (no more color flashes in graphics modes); added SYS command
              	; R2.15  - 20200225 - Now the computer starts as a stand-alone system, with serial disabled;
              	;                     new SERIAL command
              	; R3.0   - 20200228 - Major changes to kernel, now the computer has a full-screen inline editor,
              	;                     it now acts as an old home computer of the '80s, getting statements from
              	;                     anywhere the cursor is; removed MONITOR statement; code cleaning & optimization;
              	;                     adopted usual hexadecimal & binary prefixes
              	; R3.1   - 20200304 - Added XOR statement; fixed a bug for SERIAL (chars sent over serial were $01);
              	;                     removed NULL statement; added compilation date & time into ROM file
              	; R3.2   - 20200309 - Added sprite size and sprite magnification settings to SCREEN statement;
              	;                     fixed a bug in warm/cold reset input routine
              	; R3.3   - 20200315 - Code cleaning; improved LIST command
              	; R3.4   - 20200329 - Removed POINT and SET statements and their legacies; changed default colors for
              	;                     screens 1 & 4; enhanced serial communication on port 1, fixed freezing bug and
              	;                     added new function to SERIAL statement; fixed TAB function
              	; R3.5   - 20200408 - Fixed a bug into the new code of LIST statement; serial & BASIC buffers expanded
              	;                     to 88 chars; fixed a little bug into editor (pressing RETURN over a multi-line text
              	;                     did not reposition the cursor after the end of it)
              	; R3.6   - 20200419 - Minor improvement in LIST code; fixed a bug in sound management (automatic cutting down
              	;                     of a sound wrongly altered the sound mixer); added management of noise from PSG;
              	;                     fixed some timing issues in VDP access that lead to graphic glitches in graphic mode 2;
              	;                     code improvements
              	;
              	; ------------------------------------------------------------------------------
              	; NASCOM BASIC versions:
              	; 4.7  - original version by NASCOM
              	; 4.7b - modified version by Grant Searle (additional commands & functions)
              	; 4.8  - modified by Leonardo Miliani (new commands/functions)
              	;
              	;------------------------------------------------------------------------------
              	;  B A S I C
              	;------------------------------------------------------------------------------
              	; GENERAL EQUATES
              	
0000:         	NLLCR           equ     $00             ; null char (used as space/empty char in video prints)
0003:         	CTRLC           equ     $03             ; Control "C"
0007:         	CTRLG           equ     $07             ; Control "G"
0008:         	BKSP            equ     $08             ; Back space
000A:         	LF              equ     $0A             ; Line feed
000C:         	CS              equ     $0C             ; Clear screen
000D:         	CR              equ     $0D             ; Carriage return
000F:         	CTRLO           equ     $0F             ; Control "O"
0011:         	CTRLQ           equ     $11             ; Control "Q"
0012:         	CTRLR           equ     $12             ; Control "R"
0013:         	CTRLS           equ     $13             ; Control "S"
0015:         	CTRLU           equ     $15             ; Control "U"
0019:         	HOME            equ     $19             ; Home (cursor at 0,0)
001B:         	ESC             equ     $1B             ; Escape
0020:         	SPC             equ     $20             ; Space
007F:         	DEL             equ     $7F             ; Delete
              	; cursor ASCII codes
001C:         	CRSLFT          equ     $1C             ; cursor left
001D:         	CRSRGT          equ     $1D             ; cursor right
001E:         	CRSUP           equ     $1E             ; cursor up
001F:         	CRSDN           equ     $1F             ; cursor down
              	
              	
              	; BASIC WORK SPACE LOCATIONS
              	; BY STARTING FROM $8045 THE INTERPRETER ALLOCATES THE FOLLOWING RAM CELLS
              	; TO STORE IMPORTANT VALUES USED FOR SOME SPECIFIC FUNCTIONS:
              	; THEY CAN BE VECTOR (ADDRESSES) FUNCTIONS, SYSTEM DATAS (I.E. VARIABLES)
              	; AND SO ON. THE FIRST CELLS ARE FILLED WITH VALUES STORED INTO ROM AT $(INITAB) ADDRESS
805E:         	WRKSPC          equ     basicStarted+$01; (3) BASIC Work space
8061:         	USR             equ     WRKSPC+$03      ; (3) "USR (x)" jump  <-- in $8049/804A the user can store the address of a specific machine language routine
8064:         	OUTSUB          equ     USR+$03         ; (1) "out p,n"
8065:         	OTPORT          equ     OUTSUB+$01      ; (2) Port (p)
8067:         	DIVSUP          equ     OTPORT+$02      ; (1) Division support routine
8068:         	DIV1            equ     DIVSUP+$01      ; (4) <- Values
806C:         	DIV2            equ     DIV1+$04        ; (4) <-   to
8070:         	DIV3            equ     DIV2+$04        ; (3) <-   be
8073:         	DIV4            equ     DIV3+$03        ; (2) <-inserted
8075:         	SEED            equ     DIV4+$02        ; (35) Random number seed  <-- starting address of a seed table
8098:         	LSTRND          equ     SEED+$23        ; (4) Last random number
809C:         	INPSUB          equ     LSTRND+$04      ; (1) #INP (x)" Routine
809D:         	INPORT          equ     INPSUB+$01      ; (2) PORT (x)
809F:         	LWIDTH          equ     INPORT+$02      ; (1) Terminal width
80A0:         	COMMAN          equ     LWIDTH+$01      ; (1) Width for commas
80A1:         	NULFLG          equ     COMMAN+$01      ; (1) Null after input byte flag
80A2:         	CTLOFG          equ     NULFLG+$01      ; (1) Control "O" flag
80A3:         	CHKSUM          equ     CTLOFG+$01      ; (2) Array load/save check sum
80A5:         	NMIFLG          equ     CHKSUM+$02      ; (1) Flag for NMI break routine
80A6:         	BRKFLG          equ     NMIFLG+$01      ; (1) Break flag
80A7:         	RINPUT          equ     BRKFLG+$01      ; (3) Input reflection
80AA:         	STRSPC          equ     RINPUT+$03      ; (2) Bottom of string space
80AC:         	LINEAT          equ     STRSPC+$02      ; (2) Current line number
80AE:         	BASTXT          equ     LINEAT+$02      ; (3) Pointer to start of program   <-- actually this is the last value pre-filled by the firmware at startup
80B1:         	BUFFER          equ     BASTXT+$03      ; (5) Input buffer
80B6:         	STACK           equ     BUFFER+$05      ; (85) Initial stack
810B:         	CURPOS          equ     STACK+$55       ; (1) Character position on line
810C:         	LCRFLG          equ     CURPOS+$01      ; (1) Locate/Create flag
810D:         	TYPE            equ     LCRFLG+$01      ; (1) Data type flag
810E:         	DATFLG          equ     TYPE+$01        ; (1) Literal statement flag
810F:         	LSTRAM          equ     DATFLG+$01      ; (2) Last available RAM
8111:         	TMSTPT          equ     LSTRAM+$02      ; (2) Temporary string pointer
8113:         	TMSTPL          equ     TMSTPT+$02      ; (12) Temporary string pool
811F:         	TMPSTR          equ     TMSTPL+$0C      ; (4) Temporary string
8123:         	STRBOT          equ     TMPSTR+$04      ; (2) Bottom of string space
8125:         	CUROPR          equ     STRBOT+$02      ; (2) Current operator in EVAL
8127:         	LOOPST          equ     CUROPR+$02      ; (2) First statement of loop
8129:         	DATLIN          equ     LOOPST+$02      ; (2) Line of current DATA item
812B:         	FORFLG          equ     DATLIN+$02      ; (1) "FOR" loop flag
812C:         	LSTBIN          equ     FORFLG+$01      ; (1) Last byte entered
812D:         	READFG          equ     LSTBIN+$01      ; (1) Read/Input flag
812E:         	BRKLIN          equ     READFG+$01      ; (2) Line of break
8130:         	NXTOPR          equ     BRKLIN+$02      ; (2) Next operator in EVAL
8132:         	ERRLIN          equ     NXTOPR+$02      ; (2) Line of error
8134:         	CONTAD          equ     ERRLIN+$02      ; (2) Where to CONTinue
8136:         	PROGND          equ     CONTAD+$02      ; (2) End of program
8138:         	VAREND          equ     PROGND+$02      ; (2) End of variables
813A:         	ARREND          equ     VAREND+$02      ; (2) End of arrays
813C:         	NXTDAT          equ     ARREND+$02      ; (2) Next data item
813E:         	FNRGNM          equ     NXTDAT+$02      ; (2) Name of FN argument
8140:         	FNARG           equ     FNRGNM+$02      ; (4) FN argument value
8144:         	FPREG           equ     FNARG+$04       ; (3) Floating point register
8147:         	FPEXP           equ     FPREG+$03       ; (1) Floating point exponent
8148:         	SGNRES          equ     FPEXP+$01       ; (1) Sign of result
8149:         	TMRCNT          equ     SGNRES+$01      ; (4) TMR counter for 1/100 seconds
              	; - - - - - - - - - - - - - - - - - - -   VIDEO REGISTERS - FROM HERE...
814D:         	SCR_SIZE_W      equ     TMRCNT+$04      ; (1) screen width (it can be either 40 chars or 32 chars/bytes)
814E:         	SCR_SIZE_H      equ     SCR_SIZE_W+$01  ; (1) screen height (it can be 24/48/192: 24 for text, 48 for MC, 192 for graphics)
814F:         	SCR_MODE        equ     SCR_SIZE_H+$01  ; (1) screen mode (0=text, 1=G1, 2=G2, 3=MC, 4=ExG2)
8151:         	SCR_NAM_TB      equ     SCR_MODE+$02    ; (2) video name table address
8153:         	SCR_CURS_X      equ     SCR_NAM_TB+$02  ; (1) cursor X
8154:         	SCR_CURS_Y      equ     SCR_CURS_X+$01  ; (1) cursor Y
8155:         	SCR_CUR_NX      equ     SCR_CURS_Y+$01  ; (1) new cursor X position
8156:         	SCR_CUR_NY      equ     SCR_CUR_NX+$01  ; (1) new cursor Y position
8157:         	SCR_ORG_CHR     equ     SCR_CUR_NY+$01  ; (1) original char positioned under the cursor
8158:         	CRSR_STATE      equ     SCR_ORG_CHR+$01 ; (1) state of cursor (1=on, 0=off)
8159:         	LSTCSRSTA       equ     CRSR_STATE+$01  ; (1) last cursor state
815A:         	PRNTVIDEO       equ     LSTCSRSTA+$01   ; (1) print on video buffer (1=on / 0=off) set to off on graphic only modes
815B:         	CHR4VID         equ     PRNTVIDEO+$01   ; (1) char for video buffer
815C:         	FRGNDCLR        equ     CHR4VID+$01     ; (1) foreground color as set by SCREEN or COLOR commands
815D:         	BKGNDCLR        equ     FRGNDCLR+$01    ; (1) background color as set by SCREEN or COLOR commands
815E:         	TMPBFR1         equ     BKGNDCLR+$01    ; (2) word for general purposes use (temp. buffer for 1 or 2 bytes)
8160:         	TMPBFR2         equ     TMPBFR1+$02     ; (2) word for general purposes use (temp. buffer for 1 or 2 bytes)
8162:         	TMPBFR3         equ     TMPBFR2+$02     ; (2) word for general purposes use (temp. buffer for 1 or 2 bytes)
8164:         	TMPBFR4         equ     TMPBFR3+$02     ; (2) word for general purposes use (temp. buffer for 1 or 2 bytes)
8166:         	VIDEOBUFF       equ     TMPBFR4+$02     ; (40) buffer used for video scrolling and other purposes
818E:         	VIDTMP1         equ     VIDEOBUFF+$28   ; (2) temporary video word
8190:         	VIDTMP2         equ     VIDTMP1+$02     ; (2) temporary video word
              	; - - - - - - - - - - - - - - - - - - -   ...TO HERE. DO NOT ADD ANYTHING RELATED TO VPD OUT OF THIS RANGE,
              	                                        ; OTHERWISE YOU WILL HAVE TO CHECK THE POINTER IN "EMPTY_RAM" FUNCTION
              	; - - - - - - - - - - - - - - - - - - -   SOUND & KEYBOARD REGISTERS - FROM HERE...
8192:         	CHASNDDTN       equ     VIDTMP2+$02     ; (2) sound Ch.A duration (1/100s)
8194:         	CHBSNDDTN       equ     CHASNDDTN+$02   ; (2) sound Ch.B duration (1/100s)
8196:         	CHCSNDDTN       equ     CHBSNDDTN+$02   ; (2) sound Ch.C duration (1/100s)
8198:         	KBDNPT          equ     CHCSNDDTN+$02   ; (1) temp cell used to flag if input comes from keyboard
8199:         	KBTMP           equ     KBDNPT+$01      ; (1) temp cell used by keyboard scanner
819A:         	TMPKEYBFR       equ     KBTMP+$01       ; (1) temp buffer for last key pressed
819B:         	LASTKEYPRSD     equ     TMPKEYBFR+$01   ; (1) last key code pressed
819C:         	CONTROLKEYS     equ     LASTKEYPRSD+$01  ; (1) flags for control keys (bit#0=SHIFT; bit#1=CTRL; bit#2=C=)
              	; - - - - - - - - - - - - - - - - - - -   ...TO HERE. DO NOT ADD ANYTHING RELATED TO PSG OUT OF THIS RANGE,
              	                                        ; OTHERWISE YOU WILL HAVE TO CHANGE THE POINTER IN "INIT_PSG" FUNCTION
819D:         	SERIALS_EN      equ     CONTROLKEYS+$01 ; (1) serial ports status: bit 0 for Port1(A), bit 1 for Port2(B): 0=OFF, 1=ON
819E:         	SERABITS        equ     SERIALS_EN+$01  ; (1) serial port A data bits
819F:         	PBUFF           equ     SERABITS+$01    ; (13) Number print buffer
81AC:         	MULVAL          equ     PBUFF+$0D       ; (3) Multiplier
81AF:         	PROGST          equ     MULVAL+$03      ; (100) Start of program text area
8213:         	STLOOK          equ     PROGST+$64      ; Start of memory test
              	
              	; BASIC ERROR CODE VALUES
              	; These values act as an offset to point to the error message into the error table
              	; must be incremented by 2 because they point to a word address jump
0000:         	NF              equ     $00             ; NEXT without FOR
0002:         	SN              equ     $02             ; Syntax error
0004:         	RG              equ     $04             ; RETURN without GOSUB
0006:         	OD              equ     $06             ; Out of DATA
0008:         	FC              equ     $08             ; Function call error
000A:         	OV              equ     $0A             ; Overflow
000C:         	OM              equ     $0C             ; Out of memory
000E:         	UL              equ     $0E             ; Undefined line number
0010:         	BS              equ     $10             ; Bad subscript
0012:         	DD              equ     $12             ; Re-DIMensioned array
0014:         	DZ              equ     $14             ; Division by zero (/0)
0016:         	ID              equ     $16             ; Illegal direct
0018:         	TM              equ     $18             ; Type mis-match
001A:         	OS              equ     $1A             ; Out of string space
001C:         	LS              equ     $1C             ; String too long
001E:         	ST              equ     $1E             ; String formula too complex
0020:         	CN              equ     $20             ; Can't CONTinue
0022:         	UF              equ     $22             ; UnDEFined FN function
0024:         	MO              equ     $24             ; Missing operand
0026:         	HX              equ     $26             ; HEX error
0028:         	BN              equ     $28             ; BIN error
002A:         	GM              equ     $2A             ; No Graphics Mode
002C:         	SC              equ     $2C             ; Serial Configuration
002E:         	SA              equ     $2E             ; Serial Port Already Open
              	
0E47: C34D0E  	COLD:   jp      STARTB          ; Jump for cold start
0E4A: C3E50E  	WARM:   jp      WARMST          ; Jump for warm start
              	
0E4D: C3540E  	STARTB: jp      CSTART          ; Jump to initialise
0E50: 7319    	        defw    DEINT           ; Get integer -32768 to 32767
0E52: 0B21    	        defw    ABPASS          ; Return integer in AB
0E54: 215E80  	CSTART: ld      HL,WRKSPC       ; Start of workspace RAM
0E57: F9      	        ld      SP,HL           ; Set up a temporary stack
0E58: C32B36  	        jp      INITST          ; Go to initialise
              	
0E5B: 211B13  	INIT:   ld      HL,INITAB       ; Initialise workspace
0E5E: 015500  	        ld      BC,INITBE-INITAB+3; Bytes to copy
0E61: 115E80  	        ld      DE,WRKSPC       ; Into workspace RAM
0E64: EDB0    	        ldir                    ; Copy data
0E66: EB      	        ex      DE,HL           ; Copy DE into HL
0E67: F9      	        ld      SP,HL           ; Temporary stack
0E68: CD1415  	        call    CLREG           ; Clear registers and stack
0E6B: CD6E1B  	        call    PRNTCRLF        ; Output CRLF
0E6E: 320A81  	        ld      (BUFFER+88+1),A ; Mark end of buffer
0E71: 32AF81  	        ld      (PROGST),A      ; Initialise program area
0E74: 1810    	        jr      MNOASK          ; usually, don't ask for memory top (only when there are errors)
0E76: 212F0F  	MSIZE:  ld      HL,MEMMSG       ; Point to message
0E79: CD2922  	        call    PRS             ; Output "Memory size"
0E7C: CD3115  	        call    PROMPT          ; Get input with '?'
0E7F: CDC918  	        call    GETCHR          ; Get next character
0E82: B7      	        or      A               ; Set flags
0E83: C29B0E  	        jp      NZ,TSTMEM       ; If number - Test if RAM there
0E86: 211382  	MNOASK: ld      HL,STLOOK       ; Point to start of RAM
0E89: 23      	MLOOP:  inc     HL              ; Next byte
0E8A: 7C      	        ld      A,H             ; Above address FFFF ?
0E8B: B5      	        or      L
0E8C: CAAD0E  	        jp      Z,SETTOP        ; Yes - 64K RAM
0E8F: 7E      	        ld      A,(HL)          ; Get contents
0E90: 47      	        ld      B,A             ; Save it
0E91: 2F      	        cpl                     ; Flip all bits
0E92: 77      	        ld      (HL),A          ; Put it back
0E93: BE      	        cp      (HL)            ; RAM there if same
0E94: 70      	        ld      (HL),B          ; Restore old contents
0E95: CA890E  	        jp      Z,MLOOP         ; If RAM - test next byte
0E98: C3AD0E  	        jp      SETTOP          ; Top of RAM found
              	
0E9B: CD8D19  	TSTMEM: call    ATOH            ; Get high memory into DE
0E9E: B7      	        or      A               ; Set flags on last byte
0E9F: C2DB13  	        jp      NZ,SNERR        ; ?SN Error if bad character
0EA2: EB      	        ex      DE,HL           ; Address into HL
0EA3: 2B      	        dec     HL              ; Back one byte
0EA4: 3ED9    	        ld      A,%11011001     ; Test byte
0EA6: 46      	        ld      B,(HL)          ; Get old contents
0EA7: 77      	        ld      (HL),A          ; Load test byte
0EA8: BE      	        cp      (HL)            ; RAM there if same
0EA9: 70      	        ld      (HL),B          ; Restore old contents
0EAA: C2760E  	        jp      NZ,MSIZE        ; Ask again if no RAM
              	
0EAD: 2B      	SETTOP: dec     HL              ; Back one byte
0EAE: 111282  	        ld      DE,STLOOK-1     ; See if enough RAM
0EB1: CDA016  	        call    CPDEHL          ; Compare DE with HL
0EB4: DA760E  	        jp      C,MSIZE         ; Ask again if not enough RAM
0EB7: 119CFF  	        ld      DE,0-100        ; 100 Bytes string space
0EBA: 220F81  	        ld      (LSTRAM),HL     ; Save last available RAM
0EBD: 19      	        add     HL,DE           ; Allocate string space
0EBE: 22AA80  	        ld      (STRSPC),HL     ; Save string space
0EC1: CDEF14  	        call    CLRPTR          ; Clear program area
0EC4: 2AAA80  	        ld      HL,(STRSPC)     ; Get end of memory
0EC7: 11EFFF  	        ld      DE,0-17         ; Offset for free bytes
0ECA: 19      	        add     HL,DE           ; Adjust HL
0ECB: 11AF81  	        ld      DE,PROGST       ; Start of program text
0ECE: 7D      	        ld      A,L             ; Get LSB
0ECF: 93      	        sub     E               ; Adjust it
0ED0: 6F      	        ld      L,A             ; Re-save
0ED1: 7C      	        ld      A,H             ; Get MSB
0ED2: 9A      	        sbc     A,D             ; Adjust it
0ED3: 67      	        ld      H,A             ; Re-save
0ED4: E5      	        push    HL              ; Save bytes free
0ED5: 21FE0E  	        ld      HL,SIGNON       ; Sign-on message
0ED8: CD2922  	        call    PRS             ; Output string
0EDB: E1      	        pop     HL              ; Get bytes free back
0EDC: CDFF2A  	        call    PRNTHL          ; Output amount of free memory
0EDF: 21F10E  	        ld      HL,BFREE        ; " Bytes free" message
0EE2: CD2922  	        call    PRS             ; Output string
              	
0EE5: 31B680  	WARMST: ld      SP,STACK        ; Temporary stack
0EE8: CD1415  	BRKRET: call    CLREG           ; Clear registers and stack
0EEB: CD1508  	        call    CURSOR_ON       ; enable cursor
0EEE: C32714  	        jp      PRNTOK          ; Go to get command line
              	
0EF1: 20427974	BFREE:  defb    " Bytes free",CR,0
0EF5: 65732066	
0EF9: 7265650D	
0EFD: 00      	
              	
0EFE: 5A383020	SIGNON: defb    "Z80 BASIC Ver 4.8",CR
0F02: 42415349	
0F06: 43205665	
0F0A: 7220342E	
0F0E: 380D    	
0F10: 436F7079	        defb    "Copyright ",251," 1978"
0F14: 72696768	
0F18: 7420FB20	
0F1C: 31393738	
0F20: 20627920	        defb    " by Microsoft",CR,0
0F24: 4D696372	
0F28: 6F736F66	
0F2C: 740D00  	
              	
0F2F: 4D656D6F	MEMMSG: defb    "Memory top",0
0F33: 72792074	
0F37: 6F7000  	
              	
              	; The following list reports all the functions supported by the interpreter.
              	; To add a custom function, the user must first insert the reserved word here,
              	; then into the list of the reserved words below, and finally must increment the
              	; ZSGN token value and all the following ones after ZSGN by 1 for every added
              	; function.
              	
              	; FUNCTION ADDRESS TABLE (this is a sort of offset table)
              	; this list must be coherent with the tokens' functions list. This means that every
              	; entry here must have the corresponding entry in the tokens list.
0F3A: 7429    	FNCTAB: defw    SGN
0F3C: D220    	        defw    TMR      ; added by Leonardo Miliani
0F3E: 382A    	        defw    INT
0F40: 8A29    	        defw    ABS
0F42: 6180    	        defw    USR
0F44: E920    	        defw    FRE
0F46: 6E24    	        defw    INP
0F48: 1721    	        defw    POS
0F4A: FE2B    	        defw    SQR
0F4C: DD2C    	        defw    RND
0F4E: 1928    	        defw    LOG
0F50: 4C2C    	        defw    EXP
0F52: 522D    	        defw    COS
0F54: 582D    	        defw    SIN
0F56: B92D    	        defw    TAN
0F58: CE2D    	        defw    ATN
0F5A: EA24    	        defw    PEEK
0F5C: 392E    	        defw    DEEK
0F5E: F124    	        defw    VPEEK     ; added by Leonardo Miliani
0F60: AE26    	        defw    VSTAT     ; added by Leonardo Miliani
0F62: B926    	        defw    SSTAT     ; added by Leonardo Miliani
0F64: CB26    	        defw    INKEY     ; added by Leonardo Miliani
0F66: 9B23    	        defw    LEN
0F68: B321    	        defw    STR
0F6A: 3524    	        defw    VAL
0F6C: AA23    	        defw    ASC
0F6E: BB23    	        defw    CHR
0F70: 2A35    	        defw    HEX      ; added by Grant Searle
0F72: BB35    	        defw    BIN      ; added by Grant Searle
0F74: CB23    	        defw    LEFT
0F76: FB23    	        defw    RIGHT
0F78: 0524    	        defw    MID
              	
              	; RESERVED WORD LIST
              	; Here are all the reserved words used by the interpreter
              	; To add custom functions/commands, the user must insert the keyword
              	; in this list, following the schematic
0F7A: C54E44  	WORDS:  defb    'E'+$80,"ND"            ; from here the list contains the COMMANDS
0F7D: C64F52  	        defb    'F'+$80,"OR"
0F80: CE455854	        defb    'N'+$80,"EXT"
0F84: C4415441	        defb    'D'+$80,"ATA"
0F88: C94E5055	        defb    'I'+$80,"NPUT"
0F8C: 54      	
0F8D: C4494D  	        defb    'D'+$80,"IM"
0F90: D2454144	        defb    'R'+$80,"EAD"
0F94: CC4554  	        defb    'L'+$80,"ET"
0F97: C74F544F	        defb    'G'+$80,"OTO"
0F9B: D2554E  	        defb    'R'+$80,"UN"
0F9E: C946    	        defb    'I'+$80,"F"
0FA0: D2455354	        defb    'R'+$80,"ESTORE"
0FA4: 4F5245  	
0FA7: C74F5355	        defb    'G'+$80,"OSUB"
0FAB: 42      	
0FAC: D2455455	        defb    'R'+$80,"ETURN"
0FB0: 524E    	
0FB2: D2454D  	        defb    'R'+$80,"EM"
0FB5: D3544F50	        defb    'S'+$80,"TOP"
0FB9: CF5554  	        defb    'O'+$80,"UT"
0FBC: CF4E    	        defb    'O'+$80,"N"
0FBE: CE554C4C	        defb    'N'+$80,"ULL"
0FC2: D7414954	        defb    'W'+$80,"AIT"
0FC6: C44546  	        defb    'D'+$80,"EF"
0FC9: D04F4B45	        defb    'P'+$80,"OKE"
0FCD: C44F4B45	        defb    'D'+$80,"OKE"
0FD1: D6504F4B	        defb    'V'+$80,"POKE"          ; added by Leonardo Miliani
0FD5: 45      	
0FD6: D3524547	        defb    'S'+$80,"REG"           ; added by Leonardo Miliani
0FDA: D6524547	        defb    'V'+$80,"REG"           ; added by Leonardo Miliani
0FDE: D3435245	        defb    'S'+$80,"CREEN"         ; changed by Leonardo Miliani
0FE2: 454E    	
0FE4: CC4F4341	        defb    'L'+$80,"OCATE"         ; added by Leonardo Miliani
0FE8: 5445    	
0FEA: D34F554E	        defb    'S'+$80,"OUND"          ; added by Leonardo Miliani
0FEE: 44      	
0FEF: D64F4C55	        defb    'V'+$80,"OLUME"         ; added by Leonardo Miliani
0FF3: 4D45    	
0FF5: D0415553	        defb    'P'+$80,"AUSE"          ; added by Leonardo Miliani
0FF9: 45      	
0FFA: C34F4C4F	        defb    'C'+$80,"OLOR"          ; added by Leonardo Miliani
0FFE: 52      	
0FFF: D04C4F54	        defb    'P'+$80,"LOT"           ; added by Leonardo Miliani
1003: C4524157	        defb    'D'+$80,"RAW"           ; added by Leonardo Miliani
1007: C3495243	        defb    'C'+$80,"IRCLE"         ; added by Leonardo Miliani
100B: 4C45    	
100D: D3455249	        defb    'S'+$80,"ERIAL"         ; added by Leonardo Miliani
1011: 414C    	
1013: CC494E45	        defb    'L'+$80,"INES"
1017: 53      	
1018: C34C53  	        defb    'C'+$80,"LS"            ; restored command
101B: D7494454	        defb    'W'+$80,"IDTH"
101F: 48      	
1020: D35953  	        defb    'S'+$80,"YS"            ; added by Leonardo Miliani
1023: D2455345	        defb    'R'+$80,"ESET"          ; changed by Leonardo Miliani
1027: 54      	
1028: D052494E	        defb    'P'+$80,"RINT"
102C: 54      	
102D: C34F4E54	        defb    'C'+$80,"ONT"
1031: CC495354	        defb    'L'+$80,"IST"
1035: C34C4541	        defb    'C'+$80,"LEAR"
1039: 52      	
103A: C34C4F41	        defb    'C'+$80,"LOAD"
103E: 44      	
103F: C3534156	        defb    'C'+$80,"SAVE"
1043: 45      	
1044: CE4557  	        defb    'N'+$80,"EW"
1047: D4414228	        defb    'T'+$80,"AB("
104B: D44F    	        defb    'T'+$80,"O"
104D: C64E    	        defb    'F'+$80,"N"
104F: D3504328	        defb    'S'+$80,"PC("
1053: D448454E	        defb    'T'+$80,"HEN"
1057: CE4F54  	        defb    'N'+$80,"OT"
105A: D3544550	        defb    'S'+$80,"TEP"
              	        ; from here: operators
105E: AB      	        defb    '+'+$80
105F: AD      	        defb    '-'+$80
1060: AA      	        defb    '*'+$80
1061: AF      	        defb    '/'+$80
1062: DE      	        defb    '^'+$80
1063: C14E44  	        defb    'A'+$80,"ND"
1066: D84F52  	        defb    'X'+$80,"OR"
1069: CF52    	        defb    'O'+$80,"R"
106B: BE      	        defb    '>'+$80
106C: BD      	        defb    '='+$80
106D: BC      	        defb    '<'+$80
              	
              	        ; from here there are the tokens' FUNCTIONS list
              	        ; this list must be coherent with the functions list above
106E: D3474E  	        defb    'S'+$80,"GN"
1071: D44D52  	        defb    'T'+$80,"MR"            ; <-- added by Leonardo Miliani
1074: C94E54  	        defb    'I'+$80,"NT"
1077: C14253  	        defb    'A'+$80,"BS"
107A: D55352  	        defb    'U'+$80,"SR"
107D: C65245  	        defb    'F'+$80,"RE"
1080: C94E50  	        defb    'I'+$80,"NP"
1083: D04F53  	        defb    'P'+$80,"OS"
1086: D35152  	        defb    'S'+$80,"QR"
1089: D24E44  	        defb    'R'+$80,"ND"
108C: CC4F47  	        defb    'L'+$80,"OG"
108F: C55850  	        defb    'E'+$80,"XP"
1092: C34F53  	        defb    'C'+$80,"OS"
1095: D3494E  	        defb    'S'+$80,"IN"
1098: D4414E  	        defb    'T'+$80,"AN"
109B: C1544E  	        defb    'A'+$80,"TN"
109E: D045454B	        defb    'P'+$80,"EEK"
10A2: C445454B	        defb    'D'+$80,"EEK"
10A6: D6504545	        defb    'V'+$80,"PEEK"          ; <-- added by Leonardo Miliani
10AA: 4B      	
10AB: D6535441	        defb    'V'+$80,"STAT"          ; <-- added by Leonardo Miliani
10AF: 54      	
10B0: D3535441	        defb    'S'+$80,"STAT"          ; <-- added by Leonardo Miliani
10B4: 54      	
10B5: C94E4B45	        defb    'I'+$80,"NKEY"          ; <-- added by Leonardo Miliani
10B9: 59      	
10BA: CC454E  	        defb    'L'+$80,"EN"
10BD: D3545224	        defb    'S'+$80,"TR$"
10C1: D6414C  	        defb    'V'+$80,"AL"
10C4: C15343  	        defb    'A'+$80,"SC"
10C7: C3485224	        defb    'C'+$80,"HR$"
10CB: C8455824	        defb    'H'+$80,"EX$"           ; added by Grant Searle
10CF: C2494E24	        defb    'B'+$80,"IN$"           ; added by Grant Searle
10D3: CC454654	        defb    'L'+$80,"EFT$"
10D7: 24      	
10D8: D2494748	        defb    'R'+$80,"IGHT$"
10DC: 5424    	
10DE: CD494424	        defb    'M'+$80,"ID$"
10E2: 80      	        defb    $80                     ; End-of-list marker
              	
              	; KEYWORD ADDRESS TABLE
              	; this list must be coherent with the commands'
              	; tokens list above
10E3: 1319    	WORDTB: defw    PEND
10E5: 1018    	        defw    FOR
10E7: DF1C    	        defw    NEXT
10E9: 581A    	        defw    DATA
10EB: E41B    	        defw    INPUT
10ED: 2A1F    	        defw    DIM
10EF: 161C    	        defw    READ
10F1: 6F1A    	        defw    LET
10F3: 151A    	        defw    GOTO
10F5: F819    	        defw    RUN
10F7: E71A    	        defw    IF
10F9: D918    	        defw    RESTOR
10FB: 041A    	        defw    GOSUB
10FD: 331A    	        defw    RETURN
10FF: 5A1A    	        defw    REM
1101: 1119    	        defw    STOP
1103: 7A24    	        defw    POUT
1105: C91A    	        defw    ON
1107: 5A1A    	        defw    REM         ; removed - was NULL
1109: 8024    	        defw    WAIT
110B: 1F21    	        defw    DEF
110D: 1425    	        defw    POKE
110F: 442E    	        defw    DOKE
1111: 1925    	        defw    VPOKE       ; added by Leonardo Miliani
1113: 5625    	        defw    SREG        ; added by Leonardo Miliani
1115: 9226    	        defw    VREG        ; added by Leonardo Miliani
1117: 772E    	        defw    SCREEN      ; mod function: now it sets up a graphics mode (Leonardo Miliani)
1119: 2425    	        defw    LOCATE      ; added by Leonardo Miliani
111B: AE25    	        defw    SOUND       ; added by Leonardo Miliani
111D: 7525    	        defw    VOLUME      ; added by Leonardo Miliani
111F: 5B2E    	        defw    PAUSE       ; added by Leonardo Miliani
1121: F22E    	        defw    COLOR       ; added by Leonardo Miliani
1123: AC2F    	        defw    PLOT        ; added by Leonardo Miliani
1125: 2530    	        defw    DRAW        ; added by Leonardo Miliani
1127: 4C31    	        defw    CIRCLE      ; added by Leonardo Miliani
1129: 5133    	        defw    SERIAL      ; added by Leonardo Miliani
112B: 5A1A    	        defw    REM         ; removed - was LINES
112D: 1D2E    	        defw    CLS
112F: 312E    	        defw    WIDTH
1131: C224    	        defw    SYS
1133: 2036    	        defw    RESET        ; new behaviour: now it resets the system
1135: 0B1B    	        defw    PRINT
1137: 3F19    	        defw    CONT
1139: 0517    	        defw    LIST
113B: B219    	        defw    CLEAR
113D: 5A1A    	        defw    REM          ; not implemented (was CLOAD)
113F: 5A1A    	        defw    REM          ; not implemented (was CSAVE)
1141: EE14    	        defw    NEW
              	
              	; RESERVED WORD TOKEN VALUES
              	; if you add a function or command you must increment by 1
              	; the values below. Pay attention that you must increment only the
              	; values AFTER the position where you entered the function/command word
              	; in the "Reserver word list" above. I.E.: VPOKE has been added between
              	; DOKE and SCREEN, and since REM is the reserved work listed below
              	; that is before the point where VPOKE has been entered, every entry
              	; after REM has been incremented.
              	; Another example: when TMR has been added, since it's a function, every
              	; entry after & included ZSGN must be checked (read below)
              	
0080:         	ZEND    equ     $80             ; END        <-- from here, there are the commands
0081:         	ZFOR    equ     $81             ; FOR
0083:         	ZDATA   equ     $83             ; DATA
0088:         	ZGOTO   equ     $88             ; GOTO
008C:         	ZGOSUB  equ     $8C             ; GOSUB
008E:         	ZREM    equ     $8E             ; REM
00A9:         	ZPRINT  equ     $A9             ; PRINT
00AF:         	ZNEW    equ     $AF             ; NEW
              	
00B0:         	ZTAB    equ     $B0             ; TAB
00B1:         	ZTO     equ     $B1             ; TO
00B2:         	ZFN     equ     $B2             ; FN
00B3:         	ZSPC    equ     $B3             ; SPC
00B4:         	ZTHEN   equ     $B4             ; THEN
00B5:         	ZNOT    equ     $B5             ; NOT
00B6:         	ZSTEP   equ     $B6             ; STEP
              	
00B7:         	ZPLUS   equ     $B7             ; +         <-- from here, there are the math operators
00B8:         	ZMINUS  equ     $B8             ; -
00B9:         	ZTIMES  equ     $B9             ; *
00BA:         	ZDIV    equ     $BA             ; /
00BE:         	ZOR     equ     $BE             ; OR
00BF:         	ZGTR    equ     $BF             ; >
00C0:         	ZEQUAL  equ     $C0             ; M
00C1:         	ZLTH    equ     $C1             ; <
              	
00C2:         	ZSGN    equ     $C2             ; SGN       <-- from here, there are the functions
00DF:         	ZLEFT   equ     $DF             ; LEFT$     ; <- if the user enters a custom function,
              	                                            ; he/she must increment this pointer by 1
              	
              	; ARITHMETIC PRECEDENCE TABLE
              	
1143: 79      	PRITAB: defb    $79             ; Precedence value
1144: E62A    	        defw    PADD            ; FPREG = <last> + FPREG
              	
1146: 79      	        defb    $79             ; Precedence value
1147: 1A27    	        defw    PSUB            ; FPREG = <last> - FPREG
              	
1149: 7C      	        defb    $7C             ; Precedence value
114A: 5828    	        defw    MULT            ; PPREG = <last> * FPREG
              	
114C: 7C      	        defb    $7C             ; Precedence value
114D: B928    	        defw    DIV             ; FPREG = <last> / FPREG
              	
114F: 7F      	        defb    $7F             ; Precedence value
1150: 072C    	        defw    POWER           ; FPREG = <last> ^ FPREG
              	
1152: 50      	        defb    $50             ; Precedence value
1153: 731E    	        defw    PAND            ; FPREG = <last> AND FPREG
              	
1155: 4A      	        defb    $4A             ; Precedence value
1156: 7B1E    	        defw    PXOR            ; FPREG = <last> XOR FPREG
              	
1158: 46      	        defb    $46             ; Precedence value
1159: 761E    	        defw    POR             ; FPREG = <last> OR FPREG
              	
              	; BASIC ERROR CODE LIST
              	
115B:         	ERRORS  equ $
115B: 4E455854	NFMSG:  defb    "NEXT Without FOR",0
115F: 20576974	
1163: 686F7574	
1167: 20464F52	
116B: 00      	
116C: 53796E74	SNMSG:  defb    "Syntax",0
1170: 617800  	
1173: 52455455	RGMSG:  defb    "RETURN without GOSUB",0
1177: 524E2077	
117B: 6974686F	
117F: 75742047	
1183: 4F535542	
1187: 00      	
1188: 4F757420	ODMSG:  defb    "Out of DATA",0
118C: 6F662044	
1190: 41544100	
1194: 496C6C65	FCMSG:  defb    "Illegal Function Call",0
1198: 67616C20	
119C: 46756E63	
11A0: 74696F6E	
11A4: 2043616C	
11A8: 6C00    	
11AA: 4F766572	OVMSG:  defb    "Overflow",0
11AE: 666C6F77	
11B2: 00      	
11B3: 4F757420	OMMSG:  defb    "Out of Memory",0
11B7: 6F66204D	
11BB: 656D6F72	
11BF: 7900    	
11C1: 556E6465	ULMSG:  defb    "Undefined Line",0
11C5: 66696E65	
11C9: 64204C69	
11CD: 6E6500  	
11D0: 42616420	BSMSG:  defb    "Bad Subscript",0
11D4: 53756273	
11D8: 63726970	
11DC: 7400    	
11DE: 52652D44	DDMSG:  defb    "Re-Dimensioned Array",0
11E2: 696D656E	
11E6: 73696F6E	
11EA: 65642041	
11EE: 72726179	
11F2: 00      	
11F3: 44697669	DZMSG:  defb    "Division by Zero",0
11F7: 73696F6E	
11FB: 20627920	
11FF: 5A65726F	
1203: 00      	
1204: 496C6C65	IDMSG:  defb    "Illegal Direct",0
1208: 67616C20	
120C: 44697265	
1210: 637400  	
1213: 54797065	TMMSG:  defb    "Type Mis-match",0
1217: 204D6973	
121B: 2D6D6174	
121F: 636800  	
1222: 4F757420	OSMSG:  defb    "Out of String Space",0
1226: 6F662053	
122A: 7472696E	
122E: 67205370	
1232: 61636500	
1236: 53747269	LSMSG:  defb    "String Too Long",0
123A: 6E672054	
123E: 6F6F204C	
1242: 6F6E6700	
1246: 53747269	STMSG:  defb    "String Formula Too Complex",0
124A: 6E672046	
124E: 6F726D75	
1252: 6C612054	
1256: 6F6F2043	
125A: 6F6D706C	
125E: 657800  	
1261: 43616E27	CNMSG:  defb    "Can't Continue",0
1265: 7420436F	
1269: 6E74696E	
126D: 756500  	
1270: 556E6465	UFMSG:  defb    "Undefined FN Function",0
1274: 66696E65	
1278: 6420464E	
127C: 2046756E	
1280: 6374696F	
1284: 6E00    	
1286: 4D697373	MOMSG:  defb    "Missing Operand",0
128A: 696E6720	
128E: 4F706572	
1292: 616E6400	
1296: 48455820	HXMSG:  defb    "HEX Format",0
129A: 466F726D	
129E: 617400  	
12A1: 42494E20	BNMSG:  defb    "BIN Format",0
12A5: 466F726D	
12A9: 617400  	
12AC: 4E6F2047	GMMSG:  defb    "No Graphics Mode",0
12B0: 72617068	
12B4: 69637320	
12B8: 4D6F6465	
12BC: 00      	
12BD: 53657269	SCMSG:  defb    "Serial Configuration",0
12C1: 616C2043	
12C5: 6F6E6669	
12C9: 67757261	
12CD: 74696F6E	
12D1: 00      	
12D2: 53657269	SAMSG:  defb    "Serial Port Already Open",0
12D6: 616C2050	
12DA: 6F727420	
12DE: 416C7265	
12E2: 61647920	
12E6: 4F70656E	
12EA: 00      	
              	
12EB:         	ERRTBL  equ $
12EB: 5B11    	NFPTR   defw    NFMSG
12ED: 6C11    	SNPTR   defw    SNMSG
12EF: 7311    	RGPTR   defw    RGMSG
12F1: 8811    	ODPTR   defw    ODMSG
12F3: 9411    	FCPTR   defw    FCMSG
12F5: AA11    	OVPTR   defw    OVMSG
12F7: B311    	OMPTR   defw    OMMSG
12F9: C111    	ULPTR   defw    ULMSG
12FB: D011    	BSPTR   defw    BSMSG
12FD: DE11    	DDPTR   defw    DDMSG
12FF: F311    	DZPTR   defw    DZMSG
1301: 0412    	IDPTR   defw    IDMSG
1303: 1312    	TMPTR   defw    TMMSG
1305: 2212    	OSPTR   defw    OSMSG
1307: 3612    	LSPTR   defw    LSMSG
1309: 4612    	STPTR   defw    STMSG
130B: 6112    	CNPTR   defw    CNMSG
130D: 7012    	UFPTR   defw    UFMSG
130F: 8612    	MOPTR   defw    MOMSG
1311: 9612    	HXPTR   defw    HXMSG
1313: A112    	BNPTR   defw    BNMSG
1315: AC12    	GMPRT   defw    GMMSG
1317: BD12    	SCPTR   defw    SCMSG
1319: D212    	SAPTR   defw    SAMSG
              	
              	; INITIALISATION TABLE -------------------------------------------------------
              	; these values are copied into RAM at startup
131B: C3E50E  	INITAB: jp      WARMST          ; Warm start jump
131E: C38819  	        jp      FCERR           ; "USR (X)" jump (Set to Error)
1321: D300    	        out     (0),A           ; "out p,n" skeleton
1323: C9      	        ret
1324: D600    	        sub     $00             ; Division support routine
1326: 6F      	        ld      L,A
1327: 7C      	        ld      A,H
1328: DE00    	        sbc     A,$00
132A: 67      	        ld      H,A
132B: 78      	        ld      A,B
132C: DE00    	        sbc     A,$00
132E: 47      	        ld      B,A
132F: 3E00    	        ld      A,$00
1331: C9      	        ret
1332: 000000  	        defb    $00,$00,$00         ; Random number seed table used by RND
1335: 354ACA99	        defb    $35,$4A,$CA,$99     ;-2.65145E+07
1339: 391C7698	        defb    $39,$1C,$76,$98     ; 1.61291E+07
133D: 2295B398	        defb    $22,$95,$B3,$98     ;-1.17691E+07
1341: 0ADD4798	        defb    $0A,$DD,$47,$98     ; 1.30983E+07
1345: 53D19999	        defb    $53,$D1,$99,$99     ;-2-01612E+07
1349: 0A1A9F98	        defb    $0A,$1A,$9F,$98     ;-1.04269E+07
134D: 65BCCD98	        defb    $65,$BC,$CD,$98     ;-1.34831E+07
1351: D6773E98	        defb    $D6,$77,$3E,$98     ; 1.24825E+07
1355: 52C74F80	        defb    $52,$C7,$4F,$80     ; Last random number
1359: DB00    	        in      A,($00)         ; INP (x) skeleton
135B: C9      	        ret
135C: FF      	        defb    $FF             ; Terminal width (255 = no auto CRLF)
135D: 1C      	        defb    $1C             ; Width for commas (3 columns)
135E: 00      	        defb    $00             ; No nulls after input bytes
135F: 00      	        defb    $00             ; Output enabled (^O off)
1360: 0000    	        defw    $00             ; Array load/save check sum
1362: 00      	        defb    $00             ; Break not by NMI
1363: 00      	        defb    $00             ; Break flag
1364: C32A16  	        jp      TTYLIN          ; Input reflection (set to TTY)
1367: 1382    	        defw    STLOOK          ; Temp string space
1369: FEFF    	        defw    -2              ; Current line number (cold)
136B: B081    	        defw    PROGST+1        ; Start of program text
136D:         	INITBE:
              	
              	; END OF INITIALISATION TABLE ---------------------------------------------------
              	
136D: 20457272	ERRMSG: defb    " Error",0
1371: 6F7200  	
1374: 20696E20	INMSG:  defb    " in ",0
1378: 00      	
1378:         	ZERBYT  equ     $-1             ; A zero byte
1379: 4F6B0D00	OKMSG:  defb    "Ok",CR,0,0
137D: 00      	
137E: 42726561	BRKMSG: defb    "Break",0
1382: 6B00    	
              	
1384: 210400  	BAKSTK: ld      HL,$04          ; Look for "FOR" block with
1387: 39      	        add     HL,SP           ; same index as specified
1388: 7E      	LOKFOR: ld      A,(HL)          ; Get block ID
1389: 23      	        inc     HL              ; Point to index address
138A: FE81    	        cp      ZFOR            ; Is it a "FOR" token
138C: C0      	        ret     NZ              ; No - exit
138D: 4E      	        ld      C,(HL)          ; BC = Address of "FOR" index
138E: 23      	        inc     HL
138F: 46      	        ld      B,(HL)
1390: 23      	        inc     HL              ; Point to sign of STEP
1391: E5      	        push    HL              ; Save pointer to sign
1392: 69      	        ld      L,C             ; HL = address of "FOR" index
1393: 60      	        ld      H,B
1394: 7A      	        ld      A,D             ; See if an index was specified
1395: B3      	        or      E               ; DE = 0 if no index specified
1396: EB      	        ex      DE,HL           ; Specified index into HL
1397: CA9E13  	        jp      Z,INDFND        ; Skip if no index given
139A: EB      	        ex      DE,HL           ; Index back into DE
139B: CDA016  	        call    CPDEHL          ; Compare index with one given
139E: 010D00  	INDFND: ld      BC,16-3         ; Offset to next block
13A1: E1      	        pop     HL              ; Restore pointer to sign
13A2: C8      	        ret     Z               ; Return if block found
13A3: 09      	        add     HL,BC           ; Point to next block
13A4: C38813  	        jp      LOKFOR          ; Keep on looking
              	
13A7: CDC113  	MOVUP:  call    ENFMEM          ; See if enough memory
13AA: C5      	MOVSTR: push    BC              ; Save end of source
13AB: E3      	        ex      (SP),HL         ; Swap source and dest" end
13AC: C1      	        pop     BC              ; Get end of destination
13AD: CDA016  	MOVLP:  call    CPDEHL          ; See if list moved
13B0: 7E      	        ld      A,(HL)          ; Get byte
13B1: 02      	        ld      (BC),A          ; Move it
13B2: C8      	        ret     Z               ; Exit if all done
13B3: 0B      	        dec     BC              ; Next byte to move to
13B4: 2B      	        dec     HL              ; Next byte to move
13B5: C3AD13  	        jp      MOVLP           ; Loop until all bytes moved
              	
13B8: E5      	CHKSTK: push    HL              ; Save code string address
13B9: 2A3A81  	        ld      HL,(ARREND)     ; Lowest free memory
13BC: 0600    	        ld      B,$00           ; BC = Number of levels to test
13BE: 09      	        add     HL,BC           ; 2 Bytes for each level
13BF: 09      	        add     HL,BC
13C0: 3E      	        defb    $3E             ; Skip "push HL"
13C1: E5      	ENFMEM: push    HL              ; Save code string address
13C2: 3ED0    	        ld      A,$D0           ; LOW -48 ; 48 Bytes minimum RAM
13C4: 95      	        sub     L
13C5: 6F      	        ld      L,A
13C6: 3EFF    	        ld      A,$FF           ; HIGH (-48) ; 48 Bytes minimum RAM
13C8: 9C      	        sbc     A,H
13C9: DAD013  	        jp      C,OMERR         ; Not enough - ?OM Error
13CC: 67      	        ld      H,A
13CD: 39      	        add     HL,SP           ; Test if stack is overflowed
13CE: E1      	        pop     HL              ; Restore code string address
13CF: D8      	        ret     C               ; Return if enough mmory
13D0: 1E0C    	OMERR:  ld      E,OM            ; ?OM Error
13D2: C3EF13  	        jp      ERROR
              	
13D5: 2A2981  	DATSNR: ld      HL,(DATLIN)     ; Get line of current DATA item
13D8: 22AC80  	        ld      (LINEAT),HL     ; Save as current line
13DB: 1E02    	SNERR:  ld      E,SN            ; ?SN Error
13DD: 01      	        defb    $01             ; Skip "ld E,DZ"
13DE: 1E14    	DZERR:  ld      E,DZ            ; ?/0 Error
13E0: 01      	        defb    $01             ; Skip "ld E,NF"
13E1: 1E00    	NFERR:  ld      E,NF            ; ?NF Error
13E3: 01      	        defb    $01             ; Skip "ld E,DD"
13E4: 1E12    	DDERR:  ld      E,DD            ; ?DD Error
13E6: 01      	        defb    $01             ; Skip "ld E,UF"
13E7: 1E22    	UFERR:  ld      E,UF            ; ?UF Error
13E9: 01      	        defb    $01             ; Skip "ld E,OV
13EA: 1E0A    	OVERR:  ld      E,OV            ; ?OV Error
13EC: 01      	        defb    $01             ; Skip "ld E,TM"
13ED: 1E18    	TMERR:  ld      E,TM            ; ?TM Error
              	
13EF: CD1415  	ERROR:  call    CLREG           ; Clear registers and stack
13F2: 32A280  	        ld      (CTLOFG),A      ; Enable output (A is 0)
13F5: CD1508  	        call    CURSOR_ON       ; enable cursor
13F8: CD5C1B  	        call    STTLIN          ; Start new line
13FB: 21EB12  	        ld      HL,ERRTBL       ; Point to error codes
13FE: 57      	        ld      D,A             ; D = 0 (A is 0)
13FF: 3E3F    	        ld      A,'?'
1401: CDB116  	        call    OUTC            ; Output '?'
1404: 19      	        add     HL,DE           ; Offset to correct error code
1405: 5E      	        ld      E,(HL)          ; load pointer to error message
1406: 23      	        inc     HL              ; by loading LSB,
1407: 56      	        ld      D,(HL)          ; then MSB
1408: 626B    	        ld      HL,DE           ; load pointer to HL
140A: CD2922  	        call    PRS             ; Output error message
140D: 216D13  	        ld      HL,ERRMSG       ; "Error" message
1410: CD2922  	ERRIN:  call    PRS             ; Output message
1413: 2AAC80  	        ld      HL,(LINEAT)     ; Get line of error
1416: 11FEFF  	        ld      DE,-2           ; Cold start error if -2
1419: CDA016  	        call    CPDEHL          ; See if cold start error
141C: CA540E  	        jp      Z,CSTART        ; Cold start error - Restart
141F: 7C      	        ld      A,H             ; Was it a direct error?
1420: A5      	        and     L               ; Line = -1 if direct error
1421: 3C      	        inc     A
1422: C4F72A  	        call    NZ,LINEIN       ; No - output line of error
1425: 3E      	        defb    $3E             ; Skip "pop BC"
1426: C1      	POPNOK: pop     BC              ; Drop address in input buffer
              	
              	; run into direct mode: print OK and get command
1427: AF      	PRNTOK: xor     A               ; Output "Ok" and get command
1428: 32A280  	        ld      (CTLOFG),A      ; Enable output
142B: CD5C1B  	        call    STTLIN          ; Start new line
142E: 217913  	        ld      HL,OKMSG        ; "Ok" message
1431: CD2922  	        call    PRS             ; Output "Ok"
1434: CD1508  	GETCMD: call    CURSOR_ON       ; enable cursor
1437: 21FFFF  	        ld      HL,-1           ; Flag direct mode
143A: 22AC80  	        ld      (LINEAT),HL     ; Save as current line
143D: CD2A16  	        call    GETLIN          ; Get an input line
1440: DA3414  	        jp      C,GETCMD        ; Get line again if break
1443: CDC918  	        call    GETCHR          ; Get first character
1446: 3C      	        inc     A               ; Test if end of line
1447: 3D      	        dec     A               ; Without affecting Carry
1448: CA3414  	        jp      Z,GETCMD        ; Nothing entered - Get another
144B: F5      	        push    AF              ; Save Carry status
144C: CD2B08  	        call    CURSOR_OFF      ; cursor disabled
144F: CD8D19  	        call    ATOH            ; Get line number into DE
1452: D5      	        push    DE              ; Save line number
1453: CD4115  	        call    CRUNCH          ; Tokenise rest of line
1456: 47      	        ld      B,A             ; Length of tokenised line
1457: D1      	        pop     DE              ; Restore line number
1458: F1      	        pop     AF              ; Restore Carry
1459: D2A918  	        jp      NC,EXCUTE       ; No line number - Direct mode
145C: D5      	        push    DE              ; Save line number
145D: C5      	        push    BC              ; Save length of tokenised line
145E: AF      	        xor     A
145F: 322C81  	        ld      (LSTBIN),A      ; Clear last byte input
1462: CDC918  	        call    GETCHR          ; Get next character
1465: B7      	        or      A               ; Set flags
1466: F5      	        push    AF              ; And save them
1467: CDCE14  	        call    SRCHLN          ; Search for line number in DE
146A: DA7314  	        jp      C,LINFND        ; Jump if line found
146D: F1      	        pop     AF              ; Get status
146E: F5      	        push    AF              ; And re-save
146F: CA2E1A  	        jp      Z,ULERR         ; Nothing after number - Error
1472: B7      	        or      A               ; Clear Carry
1473: C5      	LINFND: push    BC              ; Save address of line in prog
1474: D28A14  	        jp      NC,INEWLN       ; Line not found - Insert new
1477: EB      	        ex      DE,HL           ; Next line address in DE
1478: 2A3681  	        ld      HL,(PROGND)     ; End of program
147B: 1A      	SFTPRG: ld      A,(DE)          ; Shift rest of program down
147C: 02      	        ld      (BC),A
147D: 03      	        inc     BC              ; Next destination
147E: 13      	        inc     DE              ; Next source
147F: CDA016  	        call    CPDEHL          ; All done?
1482: C27B14  	        jp      NZ,SFTPRG       ; More to do
1485: 60      	        ld      H,B             ; HL - New end of program
1486: 69      	        ld      L,C
1487: 223681  	        ld      (PROGND),HL     ; Update end of program
              	
148A: D1      	INEWLN: pop     DE              ; Get address of line,
148B: F1      	        pop     AF              ; Get status
148C: CAB114  	        jp      Z,SETPTR        ; No text - Set up pointers
148F: 2A3681  	        ld      HL,(PROGND)     ; Get end of program
1492: E3      	        ex      (SP),HL         ; Get length of input line
1493: C1      	        pop     BC              ; End of program to BC
1494: 09      	        add     HL,BC           ; Find new end
1495: E5      	        push    HL              ; Save new end
1496: CDA713  	        call    MOVUP           ; Make space for line
1499: E1      	        pop     HL              ; Restore new end
149A: 223681  	        ld      (PROGND),HL     ; Update end of program pointer
149D: EB      	        ex      DE,HL           ; Get line to move up in HL
149E: 74      	        ld      (HL),H          ; Save MSB
149F: D1      	        pop     DE              ; Get new line number
14A0: 23      	        inc     HL              ; Skip pointer
14A1: 23      	        inc     HL
14A2: 73      	        ld      (HL),E          ; Save LSB of line number
14A3: 23      	        inc     HL
14A4: 72      	        ld      (HL),D          ; Save MSB of line number
14A5: 23      	        inc     HL              ; To first byte in line
14A6: 11B180  	        ld      DE,BUFFER       ; Copy buffer to program
14A9: 1A      	MOVBUF: ld      A,(DE)          ; Get source
14AA: 77      	        ld      (HL),A          ; Save destinations
14AB: 23      	        inc     HL              ; Next source
14AC: 13      	        inc     DE              ; Next destination
14AD: B7      	        or      A               ; Done?
14AE: C2A914  	        jp      NZ,MOVBUF       ; No - Repeat
14B1: CDFA14  	SETPTR: call    RUNFST          ; Set line pointers
14B4: 23      	        inc     HL              ; To LSB of pointer
14B5: EB      	        ex      DE,HL           ; Address to DE
14B6: 62      	PTRLP:  ld      H,D             ; Address to HL
14B7: 6B      	        ld      L,E
14B8: 7E      	        ld      A,(HL)          ; Get LSB of pointer
14B9: 23      	        inc     HL              ; To MSB of pointer
14BA: B6      	        or      (HL)            ; Compare with MSB pointer
14BB: CA3414  	        jp      Z,GETCMD        ; Get command line if end
14BE: 23      	        inc     HL              ; To LSB of line number
14BF: 23      	        inc     HL              ; Skip line number
14C0: 23      	        inc     HL              ; Point to first byte in line
14C1: AF      	        xor     A               ; Looking for 00 byte
14C2: BE      	FNDEND: cp      (HL)            ; Found end of line?
14C3: 23      	        inc     HL              ; Move to next byte
14C4: C2C214  	        jp      NZ,FNDEND       ; No - Keep looking
14C7: EB      	        ex      DE,HL           ; Next line address to HL
14C8: 73      	        ld      (HL),E          ; Save LSB of pointer
14C9: 23      	        inc     HL
14CA: 72      	        ld      (HL),D          ; Save MSB of pointer
14CB: C3B614  	        jp      PTRLP           ; Do next line
              	
14CE: 2AAE80  	SRCHLN: ld      HL,(BASTXT)     ; Start of program text
14D1: 44      	SRCHLP: ld      B,H             ; BC = Address to look at
14D2: 4D      	        ld      C,L
14D3: 7E      	        ld      A,(HL)          ; Get address of next line
14D4: 23      	        inc     HL
14D5: B6      	        or      (HL)            ; End of program found?
14D6: 2B      	        dec     HL
14D7: C8      	        ret     Z               ; Yes - Line not found
14D8: 23      	        inc     HL
14D9: 23      	        inc     HL
14DA: 7E      	        ld      A,(HL)          ; Get LSB of line number
14DB: 23      	        inc     HL
14DC: 66      	        ld      H,(HL)          ; Get MSB of line number
14DD: 6F      	        ld      L,A
14DE: CDA016  	        call    CPDEHL          ; Compare with line in DE
14E1: 60      	        ld      H,B             ; HL = Start of this line
14E2: 69      	        ld      L,C
14E3: 7E      	        ld      A,(HL)          ; Get LSB of next line address
14E4: 23      	        inc     HL
14E5: 66      	        ld      H,(HL)          ; Get MSB of next line address
14E6: 6F      	        ld      L,A             ; Next line to HL
14E7: 3F      	        ccf
14E8: C8      	        ret     Z               ; Lines found - Exit
14E9: 3F      	        ccf
14EA: D0      	        ret     NC              ; Line not found,at line after
14EB: C3D114  	        jp      SRCHLP          ; Keep looking
              	
14EE: C0      	NEW:    ret     NZ              ; Return if any more on line
14EF: 2AAE80  	CLRPTR: ld      HL,(BASTXT)     ; Point to start of program
14F2: AF      	        xor     A               ; Set program area to empty
14F3: 77      	        ld      (HL),A          ; Save LSB = 00
14F4: 23      	        inc     HL
14F5: 77      	        ld      (HL),A          ; Save MSB = 00
14F6: 23      	        inc     HL
14F7: 223681  	        ld      (PROGND),HL     ; Set program end
              	
14FA: 2AAE80  	RUNFST: ld      HL,(BASTXT)     ; Clear all variables
14FD: 2B      	        dec     HL
              	
14FE: 222E81  	INTVAR: ld      (BRKLIN),HL     ; Initialise RUN variables
1501: 2A0F81  	        ld      HL,(LSTRAM)     ; Get end of RAM
1504: 222381  	        ld      (STRBOT),HL     ; Clear string space
1507: AF      	        xor     A
1508: CDD918  	        call    RESTOR          ; Reset DATA pointers
150B: 2A3681  	        ld      HL,(PROGND)     ; Get end of program
150E: 223881  	        ld      (VAREND),HL     ; Clear variables
1511: 223A81  	        ld      (ARREND),HL     ; Clear arrays
              	
1514: C1      	CLREG:  pop     BC              ; Save return address
1515: 2AAA80  	        ld      HL,(STRSPC)     ; Get end of working RAM
1518: F9      	        ld      SP,HL           ; Set stack
1519: 211381  	        ld      HL,TMSTPL       ; Temporary string pool
151C: 221181  	        ld      (TMSTPT),HL     ; Reset temporary string ptr
151F: AF      	        xor     A               ; A = 00
1520: 6F      	        ld      L,A             ; HL = 0000
1521: 67      	        ld      H,A
1522: 223481  	        ld      (CONTAD),HL     ; No CONTinue
1525: 322B81  	        ld      (FORFLG),A      ; Clear FOR flag
1528: 223E81  	        ld      (FNRGNM),HL     ; Clear FN argument
152B: E5      	        push    HL              ; HL = 0000
152C: C5      	        push    BC              ; Put back return
152D: 2A2E81  	DOAGN:  ld      HL,(BRKLIN)     ; Get address of code to RUN
1530: C9      	        ret                     ; Return to execution driver
              	
1531: 3E3F    	PROMPT: ld      A,'?'           ; '?'
1533: CDB116  	        call    OUTC            ; Output character
1536: 3E00    	        ld      A,NLLCR         ; null char
1538: CDB116  	        call    OUTC            ; Output character
153B: CD1508  	        call    CURSOR_ON       ; enable cursor
153E: C3A780  	        jp      RINPUT          ; Get input line
              	
1541: AF      	CRUNCH: xor     A               ; Tokenise line @ HL to BUFFER
1542: 320E81  	        ld      (DATFLG),A      ; Reset literal flag
1545: 0E05    	        ld      C,2+3           ; 2 byte number and 3 nulls
1547: 11B180  	        ld      DE,BUFFER       ; Start of input buffer
154A: 7E      	CRNCLP: ld      A,(HL)          ; Get byte
154B: FE20    	        cp      SPC             ; Is it a space?
154D: CAC915  	        jp      Z,MOVDIR        ; Yes - Copy direct
1550: 47      	        ld      B,A             ; Save character
1551: FE22    	        cp      22H             ; '"'             ; Is it a quote?
1553: CAE915  	        jp      Z,CPYLIT        ; Yes - Copy literal string
1556: B7      	        or      A               ; Is it end of buffer?
1557: CAF015  	        jp      Z,ENDBUF        ; Yes - End buffer
155A: 3A0E81  	        ld      A,(DATFLG)      ; Get data type
155D: B7      	        or      A               ; Literal?
155E: 7E      	        ld      A,(HL)          ; Get byte to copy
155F: C2C915  	        jp      NZ,MOVDIR       ; Literal - Copy direct
1562: FE3F    	        cp      '?'             ; Is it '?' short for PRINT
1564: 3EA9    	        ld      A,ZPRINT        ; "PRINT" token
1566: CAC915  	        jp      Z,MOVDIR        ; Yes - replace it
1569: 7E      	        ld      A,(HL)          ; Get byte again
156A: FE30    	        cp      '0'             ; Is it less than '0'
156C: DA7415  	        jp      C,FNDWRD        ; Yes - Look for reserved words
156F: FE3C    	        cp      $3C  ;60; ";"+1       ; Is it "0123456789:;" ?
1571: DAC915  	        jp      C,MOVDIR        ; Yes - copy it direct
1574: D5      	FNDWRD: push    DE              ; Look for reserved words
1575: 11790F  	        ld      DE,WORDS-1      ; Point to table
1578: C5      	        push    BC              ; Save count
1579: 01C515  	        ld      BC,RETNAD       ; Where to return to
157C: C5      	        push    BC              ; Save return address
157D: 067F    	        ld      B,ZEND-1        ; First token value -1
157F: 7E      	        ld      A,(HL)          ; Get byte
1580: FE61    	        cp      'a'             ; Less than 'a' ?
1582: DA8D15  	        jp      C,SEARCH        ; Yes - search for words
1585: FE7B    	        cp      'z'+1           ; Greater than 'z' ?
1587: D28D15  	        jp      NC,SEARCH       ; Yes - search for words
158A: E65F    	        and     %01011111       ; Force upper case
158C: 77      	        ld      (HL),A          ; Replace byte
158D: 4E      	SEARCH: ld      C,(HL)          ; Search for a word
158E: EB      	        ex      DE,HL
158F: 23      	GETNXT: inc     HL              ; Get next reserved word
1590: B6      	        or      (HL)            ; Start of word?
1591: F28F15  	        jp      P,GETNXT        ; No - move on
1594: 04      	        inc     B               ; Increment token value
1595: 7E      	        ld      A,(HL)          ; Get byte from table
1596: E67F    	        and     %01111111       ; Strip bit 7
1598: C8      	        ret     Z               ; Return if end of list
1599: B9      	        cp      C               ; Same character as in buffer?
159A: C28F15  	        jp      NZ,GETNXT       ; No - get next word
159D: EB      	        ex      DE,HL
159E: E5      	        push    HL              ; Save start of word
              	
159F: 13      	NXTBYT: inc     DE              ; Look through rest of word
15A0: 1A      	        ld      A,(DE)          ; Get byte from table
15A1: B7      	        or      A               ; End of word ?
15A2: FAC115  	        jp      M,MATCH         ; Yes - Match found
15A5: 4F      	        ld      C,A             ; Save it
15A6: 78      	        ld      A,B             ; Get token value
15A7: FE88    	        cp      ZGOTO           ; Is it "GOTO" token ?
15A9: C2B015  	        jp      NZ,NOSPC        ; No - Don't allow spaces
15AC: CDC918  	        call    GETCHR          ; Get next character
15AF: 2B      	        dec     HL              ; Cancel increment from GETCHR
15B0: 23      	NOSPC:  inc     HL              ; Next byte
15B1: 7E      	        ld      A,(HL)          ; Get byte
15B2: FE61    	        cp      'a'             ; Less than 'a' ?
15B4: DAB915  	        jp      C,NOCHNG        ; Yes - don't change
15B7: E65F    	        and     %01011111       ; Make upper case
15B9: B9      	NOCHNG: cp      C               ; Same as in buffer ?
15BA: CA9F15  	        jp      Z,NXTBYT        ; Yes - keep testing
15BD: E1      	        pop     HL              ; Get back start of word
15BE: C38D15  	        jp      SEARCH          ; Look at next word
              	
15C1: 48      	MATCH:  ld      C,B             ; Word found - Save token value
15C2: F1      	        pop     AF              ; Throw away return
15C3: EB      	        ex      DE,HL
15C4: C9      	        ret                     ; Return to "RETNAD"
15C5: EB      	RETNAD: ex      DE,HL           ; Get address in string
15C6: 79      	        ld      A,C             ; Get token value
15C7: C1      	        pop     BC              ; Restore buffer length
15C8: D1      	        pop     DE              ; Get destination address
15C9: 23      	MOVDIR: inc     HL              ; Next source in buffer
15CA: 12      	        ld      (DE),A          ; Put byte in buffer
15CB: 13      	        inc     DE              ; Move up buffer
15CC: 0C      	        inc     C               ; Increment length of buffer
15CD: D63A    	        sub     ':'             ; End of statement?
15CF: CAD715  	        jp      Z,SETLIT        ; Jump if multi-statement line
15D2: FE49    	        cp      ZDATA-$3A       ; Is it DATA statement ?
15D4: C2DA15  	        jp      NZ,TSTREM       ; No - see if REM
15D7: 320E81  	SETLIT: ld      (DATFLG),A      ; Set literal flag
15DA: D654    	TSTREM: sub     ZREM-$3A        ; Is it REM?
15DC: C24A15  	        jp      NZ,CRNCLP       ; No - Leave flag
15DF: 47      	        ld      B,A             ; Copy rest of buffer
15E0: 7E      	NXTCHR: ld      A,(HL)          ; Get byte
15E1: B7      	        or      A               ; End of line ?
15E2: CAF015  	        jp      Z,ENDBUF        ; Yes - Terminate buffer
15E5: B8      	        cp      B               ; End of statement ?
15E6: CAC915  	        jp      Z,MOVDIR        ; Yes - Get next one
15E9: 23      	CPYLIT: inc     HL              ; Move up source string
15EA: 12      	        ld      (DE),A          ; Save in destination
15EB: 0C      	        inc     C               ; Increment length
15EC: 13      	        inc     DE              ; Move up destination
15ED: C3E015  	        jp      NXTCHR          ; Repeat
              	
15F0: 21B080  	ENDBUF: ld      HL,BUFFER-1     ; Point to start of buffer
15F3: 12      	        ld      (DE),A          ; Mark end of buffer (A = 00)
15F4: 13      	        inc     DE
15F5: 12      	        ld      (DE),A          ; A = 00
15F6: 13      	        inc     DE
15F7: 12      	        ld      (DE),A          ; A = 00
15F8: C9      	        ret
              	
15F9: 3AA180  	DODEL:  ld      A,(NULFLG)      ; Get null flag status
15FC: B7      	        or      A               ; Is it zero?
15FD: 3E00    	        ld      A,$00           ; Zero A - Leave flags
15FF: 32A180  	        ld      (NULFLG),A      ; Zero null flag
1602: C20D16  	        jp      NZ,ECHDEL       ; Set - Echo it
1605: 05      	        dec     B               ; Decrement length
1606: CA2A16  	        jp      Z,GETLIN        ; Get line again if empty
1609: CDB116  	        call    OUTC            ; Output null character
160C: 3E      	        defb    $3E             ; Skip "dec B"
160D: 05      	ECHDEL: dec     B               ; Count bytes in buffer
160E: 2B      	        dec     HL              ; Back space buffer
160F: CA2116  	        jp      Z,OTKLN         ; No buffer - Try again
1612: 7E      	        ld      A,(HL)          ; Get deleted byte
1613: CDB116  	        call    OUTC            ; Echo it
1616: C33316  	        jp      MORINP          ; Get more input
              	
1619: 05      	DELCHR: dec     B               ; Count bytes in buffer
161A: 2B      	        dec     HL              ; Back space buffer
161B: CDB116  	        call    OUTC            ; Output character in A
161E: C23316  	        jp      NZ,MORINP       ; Not end - Get more
1621: CDB116  	OTKLN:  call    OUTC            ; Output character in A
1624: CD6E1B  	KILIN:  call    PRNTCRLF        ; Output CRLF
1627: C32A16  	        jp      TTYLIN          ; Get line again
              	
162A:         	GETLIN:
162A: 21B180  	TTYLIN: ld      HL,BUFFER       ; Get a line by character
162D: 0601    	        ld      B,$01           ; Set buffer as empty
162F: AF      	        xor     A
1630: 32A180  	        ld      (NULFLG),A      ; Clear null flag
1633: CDF216  	MORINP: call    CLOTST          ; Get character and test ^O
1636: 4F      	        ld      C,A             ; Save character in C
1637: FE7F    	        cp      DEL             ; Delete character?
1639: CAF915  	        jp      Z,DODEL         ; Yes - Process it
163C: 3AA180  	        ld      A,(NULFLG)      ; Get null flag
163F: B7      	        or      A               ; Test null flag status
1640: CA4C16  	        jp      Z,PROCES        ; Reset - Process character
1643: 3E00    	        ld      A,$00           ; Set a null
1645: CDB116  	        call    OUTC            ; Output null
1648: AF      	        xor     A               ; Clear A
1649: 32A180  	        ld      (NULFLG),A      ; Reset null flag
164C: 79      	PROCES: ld      A,C             ; Get character
164D: FE07    	        cp      CTRLG           ; Bell?
164F: CA8616  	        jp      Z,PUTCTL        ; Yes - Save it
1652: FE03    	        cp      CTRLC           ; Is it control "C"?
1654: CC6E1B  	        call    Z,PRNTCRLF      ; Yes - Output CRLF
1657: 37      	        scf                     ; Flag break
1658: C8      	        ret     Z               ; Return if control "C"
1659: FE0D    	        cp      CR              ; Is it enter?
165B: CA641B  	        jp      Z,ENDINP        ; Yes - Terminate input
165E: FE15    	        cp      CTRLU           ; Is it control "U"?
1660: CA2416  	        jp      Z,KILIN         ; Yes - Get another line
1663: FE08    	        cp      BKSP            ; Is it backspace?
1665: CA1916  	        jp      Z,DELCHR        ; Yes - Delete character
1668: FE12    	        cp      CTRLR           ; Is it control "R"?
166A: C28116  	        jp      NZ,PUTBUF       ; No - Put in buffer
166D: C5      	        push    BC              ; Save buffer length
166E: D5      	        push    DE              ; Save DE
166F: E5      	        push    HL              ; Save buffer address
1670: 3600    	        ld      (HL),$00        ; Mark end of buffer
1672: CD3A36  	        call    OUTNCR          ; Output and do CRLF
1675: 21B180  	        ld      HL,BUFFER       ; Point to buffer start
1678: CD2922  	        call    PRS             ; Output buffer
167B: E1      	        pop     HL              ; Restore buffer address
167C: D1      	        pop     DE              ; Restore DE
167D: C1      	        pop     BC              ; Restore buffer length
167E: C33316  	        jp      MORINP          ; Get another character
              	
              	
1681: FE20    	PUTBUF: cp      SPC             ; Is it a control code?
1683: DA3316  	        jp      C,MORINP        ; Yes - Ignore
1686: 78      	PUTCTL: ld      A,B             ; Get number of bytes in buffer
1687: FE59    	        cp      $58+$01         ; Test for line overflow
1689: 3E07    	        ld      A,CTRLG         ; Set a bell
168B: D29816  	        jp      NC,OUTNBS       ; Ring bell if buffer full
168E: 79      	        ld      A,C             ; Get character
168F: 71      	        ld      (HL),C          ; Save in buffer
1690: 322C81  	        ld      (LSTBIN),A      ; Save last input byte
1693: 23      	        inc     HL              ; Move up buffer
1694: 04      	        inc     B               ; Increment length
1695:         	OUTIT:  ;call    MONOUT          ; Output the character entered (to be check if from keyboard or serial)
1695: C33316  	        jp      MORINP          ; Get another character
              	
1698: CDB116  	OUTNBS: call    OUTC            ; Output bell and back over it
169B: 3E08    	        ld      A,BKSP          ; Set back space
169D: C39516  	        jp      OUTIT           ; Output it and get more
              	
16A0: 7C      	CPDEHL: ld      A,H             ; Get H
16A1: 92      	        sub     D               ; Compare with D
16A2: C0      	        ret     NZ              ; Different - Exit
16A3: 7D      	        ld      A,L             ; Get L
16A4: 93      	        sub     E               ; Compare with E
16A5: C9      	        ret                     ; Return status
              	
16A6: 7E      	CHKSYN: ld      A,(HL)          ; Check syntax of character
16A7: E3      	        ex      (SP),HL         ; Address of test byte
16A8: BE      	        cp      (HL)            ; Same as in code string?
16A9: 23      	        inc     HL              ; Return address
16AA: E3      	        ex      (SP),HL         ; Put it back
16AB: CAC918  	        jp      Z,GETCHR        ; Yes - Get next character
16AE: C3DB13  	        jp      SNERR           ; Different - ?SN Error
              	
16B1: F5      	OUTC:   push    AF              ; Save character
16B2: 3AA280  	        ld      A,(CTLOFG)      ; Get control "O" flag
16B5: B7      	        or      A               ; Is it set?
16B6: C25E22  	        jp      NZ,POPAF        ; Yes - don't output
16B9: F1      	        pop     AF              ; Restore character
16BA: C5      	        push    BC              ; Save buffer length
16BB: F5      	        push    AF              ; Save character
16BC: FE20    	        cp      SPC             ; Is it a control code?
16BE: DAD516  	        jp      C,DINPOS        ; Yes - Don't inc POS(X)
16C1: 3A9F80  	        ld      A,(LWIDTH)      ; Get line width
16C4: 47      	        ld      B,A             ; To B
16C5: 3A0B81  	        ld      A,(CURPOS)      ; Get cursor position
16C8: 04      	        inc     B               ; Width 255?
16C9: CAD116  	        jp      Z,INCLEN        ; Yes - No width limit
16CC: 05      	        dec     B               ; Restore width
16CD: B8      	        cp      B               ; At end of line?
16CE: CC6E1B  	        call    Z,PRNTCRLF      ; Yes - output CRLF
16D1: 3C      	INCLEN: inc     A               ; Move on one character
16D2: 320B81  	        ld      (CURPOS),A      ; Save new position
16D5: AF      	DINPOS: xor     A
16D6: 329881  	        ld      (KBDNPT),A      ; set flag for no char from keyboard
16D9: F1      	        pop     AF              ; Restore character
16DA: C1      	        pop     BC              ; Restore buffer length
16DB: F5      	        push    AF
16DC: CDE416  	        call    SND2VID         ; send char to video
16DF: F1      	        pop     AF
16E0: CD1D36  	        call    MONOUT          ; send char to serial if enabled
16E3: C9      	        ret
              	
              	; print char to video if cursor is on
16E4: 325B81  	SND2VID:ld      (CHR4VID),A     ; store A
16E7: 3A5A81  	        ld      A,(PRNTVIDEO)   ; check print-on-video
16EA: B7      	        or      A               ; is it off?
16EB: C8      	        ret     Z               ; yes, so return
16EC: F3      	        di                      ; disable INTs
16ED: CD8B06  	        call    CHAR2VID        ; cursor is on, so print char on screen
16F0: FB      	        ei                      ; re-enable INTs
16F1: C9      	        ret                     ; return to caller
              	
16F2: CD1B2E  	CLOTST: call    GETINP          ; Get input character
16F5: FE0F    	        cp      CTRLO           ; Is it control "O"?
16F7: C0      	        ret     NZ              ; No don't flip flag
16F8: 3AA280  	        ld      A,(CTLOFG)      ; Get flag
16FB: 2F      	        cpl                     ; Flip it
16FC: 32A280  	        ld      (CTLOFG),A      ; Put it back
16FF: A7      	        and     A               ; is output enabled?
1700: CC1508  	        call    Z,CURSOR_ON     ; yes, so cursor on
1703: AF      	        xor     A               ; Null character
1704: C9      	        ret
              	
              	; LIST: list the program stored into memory
1705: C1      	LIST:   pop     BC              ; rubbish - not needed (legacy from original call of LIST)
1706: 2B      	        dec     HL              ; dec 'cos GETCHR INCs
1707: CDC918  	        call    GETCHR          ; Get next character
170A: CA5617  	        jp      Z,LSTALL        ; list all if nothing follows
170D: FEB8    	        cp      ZMINUS          ; is it '-'?
170F: 2020    	        jr      NZ,LST01        ; no, look for a line number
1711: 110000  	        ld      DE,$0000        ; yes, set search from 0
1714: CDF117  	        call    SRCHLIN         ; find address of line number
1717: ED435E81	        ld      (TMPBFR1),BC    ; store address of starting line
171B: CDA616  	        call    CHKSYN          ; skip '-'
171E: B8      	        defb    ZMINUS
171F: CD8D19  	        call    ATOH            ; now, look for another number (ASCII number to DE)
1722: CDF117  	        call    SRCHLIN         ; find address of line number
1725: ED436081	        ld      (TMPBFR2),BC    ; store address of ending line
1729: ED4B5E81	        ld      BC,(TMPBFR1)    ; retrieve address of starting line
172D: C5      	        push    BC              ; store address of line for later use
172E: C38817  	        jp      LISTLP          ; go listing
1731: CD8D19  	LST01:  call    ATOH            ; get a line number (ASCII number to DE)
1734: CDF117  	        call    SRCHLIN         ; find address of line number
1737: ED435E81	        ld      (TMPBFR1),BC    ; store address of starting line
173B: ED436081	        ld      (TMPBFR2),BC    ; same address for ending line (we'll change later if needed)
173F: 2B      	        dec     HL              ; dec 'cos GETCHR INCs
1740: CDC918  	        call    GETCHR          ; Get next character
1743: CA5217  	        jp      Z,LST06         ; nothing follows, so ending & starting lines are the same
1746: FEB8    	        cp      ZMINUS          ; is it '-'?
1748: CA6E17  	        jp      Z,LST03         ; yes, read ending line
174B: CDF117  	LST04:  call    SRCHLIN         ; find address of line number
174E: ED436081	        ld      (TMPBFR2),BC    ; set address of ending line
1752: C5      	LST06:  push    BC              ; store address for later use
1753: C38817  	        jp      LISTLP          ; jump to list
1756: 11F9FF  	LSTALL  ld      DE,65529        ; set ending line to max. allowed line number
1759: CDF117  	        call    SRCHLIN         ; get address of last line
175C: ED436081	        ld      (TMPBFR2),BC    ; store it
1760: 110000  	        ld      DE,$0000        ; set start to first line in memory
1763: CDF117  	        call    SRCHLIN         ; get address of first line
1766: ED435E81	        ld      (TMPBFR1),BC    ; store it
176A: C5      	        push    BC              ; store address of starting line for later use
176B: C38817  	        jp      LISTLP          ; start printing
176E: CDA616  	LST03:  call    CHKSYN          ; skip '-'
1771: B8      	        defb    ZMINUS
1772: CD8D19  	        call    ATOH            ; look for another number (return into DE)
1775: 7A      	        ld      A,D
1776: B3      	        or      E               ; is line=0?
1777: 2003    	        jr      NZ,LST05        ; no, jump over
1779: 11F9FF  	        ld      DE,65529        ; yes set last valid line number
177C: CDF117  	LST05:  call    SRCHLIN         ; find address of line number
177F: ED436081	        ld      (TMPBFR2),BC    ; store address of ending line
1783: ED4B5E81	        ld      BC,(TMPBFR1)    ; retrieve address of starting line
1787: C5      	        push    BC              ; store it for later use
1788: E1      	LISTLP: pop     HL              ; Restore address of line
1789: 4E      	        ld      C,(HL)          ; Get LSB of next line
178A: 23      	        inc     HL
178B: 46      	        ld      B,(HL)          ; Get MSB of next line
178C: 23      	        inc     HL
178D: 78      	        ld      A,B             ; BC = 0 (End of program)?
178E: B1      	        or      C
178F: CA2714  	        jp      Z,PRNTOK        ; Yes - Go to command mode
1792: CDF418  	        call    TSTBRK          ; Test for break key
1795: CDF717  	        call    TSTSPC          ; test for space
1798: C5      	        push    BC              ; Save address of next line
1799: 3A5381  	        ld      A,(SCR_CURS_X)  ; load current X pos of cursor
179C: A7      	        and     A               ; is it at the beginning of a new line?
179D: 200B    	        jr      NZ,LST08        ; No, jump over
179F: 3E0D    	        ld      A,CR            ; yes, so just send a CR
17A1: CD1D36  	        call    MONOUT          ; to serial if it's open
17A4: AF      	        xor     A               ; then, set cursor
17A5: 320B81  	        ld      (CURPOS),A      ; to position 0
17A8: 1803    	        jr      LST07           ; and continue
17AA: CD6E1B  	LST08:  call    PRNTCRLF        ; output CRLF
17AD: 5E      	LST07:  ld      E,(HL)          ; Get LSB of line number
17AE: 23      	        inc     HL
17AF: 56      	        ld      D,(HL)          ; Get MSB of line number
17B0: 23      	        inc     HL
17B1: E5      	        push    HL              ; Save address of line start
17B2: EB      	        ex      DE,HL           ; Line number to HL
17B3: CDFF2A  	        call    PRNTHL          ; Output line number in decimal
17B6: 3E20    	        ld      A,SPC           ; Space after line number
17B8: E1      	        pop     HL              ; Restore start of line address
17B9: CDB116  	LSTLP2: call    OUTC            ; Output character in A
17BC: 7E      	LSTLP3: ld      A,(HL)          ; Get next byte in line
17BD: B7      	        or      A               ; End of line?
17BE: 23      	        inc     HL              ; To next byte in line
17BF: CAE317  	        jp      Z,NXTLN         ; Yes - check next line
17C2: F2B917  	        jp      P,LSTLP2        ; No token - output it
17C5: D67F    	        sub     ZEND-1          ; Find and output word
17C7: 4F      	        ld      C,A             ; Token offset+1 to C
17C8: 117A0F  	        ld      DE,WORDS        ; Reserved word list
17CB: 1A      	FNDTOK: ld      A,(DE)          ; Get character in list
17CC: 13      	        inc     DE              ; Move on to next
17CD: B7      	        or      A               ; Is it start of word?
17CE: F2CB17  	        jp      P,FNDTOK        ; No - Keep looking for word
17D1: 0D      	        dec     C               ; Count words
17D2: C2CB17  	        jp      NZ,FNDTOK       ; Not there - keep looking
17D5: E67F    	OUTWRD: and     %01111111       ; Strip bit 7
17D7: CDB116  	        call    OUTC            ; Output character
17DA: 1A      	        ld      A,(DE)          ; Get next character
17DB: 13      	        inc     DE              ; Move on to next
17DC: B7      	        or      A               ; Is it end of word?
17DD: F2D517  	        jp      P,OUTWRD        ; No - output the rest
17E0: C3BC17  	        jp      LSTLP3          ; Next byte in line
17E3: D1      	NXTLN:  pop     DE              ; recover address of current line
17E4: 2A6081  	        ld      HL,(TMPBFR2)    ; address of last line to print
17E7: CD4036  	        call    CMP16           ; check if current line is over last printable line
17EA: DA2714  	        jp      C,PRNTOK        ; finish - leave & print OK
17ED: D5      	        push    DE              ; store address of current line
17EE: C38817  	        jp      LISTLP          ; continue listing
17F1: E5      	SRCHLIN:push    HL              ; store HL (this is needed because HL store the pointer to the input buffer)
17F2: CDCE14  	        call    SRCHLN          ; search for line number in DE
17F5: E1      	        pop     HL              ; retrieve HL
17F6: C9      	        ret                     ; return to caller
              	
              	; during LISTing, check if PAUSE is pressed, then pause listing and
              	; wait for another pressing of PAUSE to continue or CTRL-C/BREAK to exit
17F7: 3A9A81  	TSTSPC: ld      A,(TMPKEYBFR)   ; Get input character
17FA: FE20    	        cp      SPC             ; Is it SPACE?
17FC: C0      	        ret     NZ              ; No, return
17FD: CD1B2E  	WTSPC   call    GETINP          ; Yes, stop listing and wait for another space or BREAK
1800: FE20    	        cp      SPC             ; is it SPACE?
1802: 2005    	        jr      NZ,CNTWTSP      ; no, continue
1804: AF      	        xor     A
1805: 329A81  	        ld      (TMPKEYBFR),A   ; reset key
1808: C9      	        ret                     ; return to caller
1809: FE03    	CNTWTSP:cp      CTRLC           ; is it CTRL-C/BREAK?
180B: 20F0    	        jr      NZ,WTSPC        ; no, loop
180D: C3E80E  	        jp      BRKRET          ; exit and output "Ok"
              	
              	
1810: 3E64    	FOR:    ld      A,$64           ; Flag "FOR" assignment
1812: 322B81  	        ld      (FORFLG),A      ; Save "FOR" flag
1815: CD6F1A  	        call    LET             ; Set up initial index
1818: C1      	        pop     BC              ; Drop RETurn address
1819: E5      	        push    HL              ; Save code string address
181A: CD581A  	        call    DATA            ; Get next statement address
181D: 222781  	        ld      (LOOPST),HL     ; Save it for start of loop
1820: 210200  	        ld      HL,$0002        ; Offset for "FOR" block
1823: 39      	        add     HL,SP           ; Point to it
1824: CD8813  	FORSLP: call    LOKFOR          ; Look for existing "FOR" block
1827: D1      	        pop     DE              ; Get code string address
1828: C24018  	        jp      NZ,FORFND       ; No nesting found
182B: 09      	        add     HL,BC           ; Move into "FOR" block
182C: D5      	        push    DE              ; Save code string address
182D: 2B      	        dec     HL
182E: 56      	        ld      D,(HL)          ; Get MSB of loop statement
182F: 2B      	        dec     HL
1830: 5E      	        ld      E,(HL)          ; Get LSB of loop statement
1831: 23      	        inc     HL
1832: 23      	        inc     HL
1833: E5      	        push    HL              ; Save block address
1834: 2A2781  	        ld      HL,(LOOPST)     ; Get address of loop statement
1837: CDA016  	        call    CPDEHL          ; Compare the FOR loops
183A: E1      	        pop     HL              ; Restore block address
183B: C22418  	        jp      NZ,FORSLP       ; Different FORs - Find another
183E: D1      	        pop     DE              ; Restore code string address
183F: F9      	        ld      SP,HL           ; Remove all nested loops
              	
1840: EB      	FORFND: ex      DE,HL           ; Code string address to HL
1841: 0E08    	        ld      C,$08
1843: CDB813  	        call    CHKSTK          ; Check for 8 levels of stack
1846: E5      	        push    HL              ; Save code string address
1847: 2A2781  	        ld      HL,(LOOPST)     ; Get first statement of loop
184A: E3      	        ex      (SP),HL         ; Save and restore code string
184B: E5      	        push    HL              ; Re-save code string address
184C: 2AAC80  	        ld      HL,(LINEAT)     ; Get current line number
184F: E3      	        ex      (SP),HL         ; Save and restore code string
1850: CD2D1D  	        call    TSTNUM          ; Make sure it's a number
1853: CDA616  	        call    CHKSYN          ; Make sure "TO" is next
1856: B1      	        defb    ZTO             ; "TO" token
1857: CD2A1D  	        call    GETNUM          ; Get "TO" expression value
185A: E5      	        push    HL              ; Save code string address
185B: CDB129  	        call    BCDEFP          ; Move "TO" value to BCDE
185E: E1      	        pop     HL              ; Restore code string address
185F: C5      	        push    BC              ; Save "TO" value in block
1860: D5      	        push    DE
1861: 010081  	        ld      BC,$8100        ; BCDE - 1 (default STEP)
1864: 51      	        ld      D,C             ; C=0
1865: 5A      	        ld      E,D             ; D=0
1866: 7E      	        ld      A,(HL)          ; Get next byte in code string
1867: FEB6    	        cp      ZSTEP           ; See if "STEP" is stated
1869: 3E01    	        ld      A,$01           ; Sign of step = 1
186B: C27C18  	        jp      NZ,SAVSTP       ; No STEP given - Default to 1
186E: CDC918  	        call    GETCHR          ; Jump over "STEP" token
1871: CD2A1D  	        call    GETNUM          ; Get step value
1874: E5      	        push    HL              ; Save code string address
1875: CDB129  	        call    BCDEFP          ; Move STEP to BCDE
1878: CD6529  	        call    TSTSGN          ; Test sign of FPREG
187B: E1      	        pop     HL              ; Restore code string address
187C: C5      	SAVSTP: push    BC              ; Save the STEP value in block
187D: D5      	        push    DE
187E: F5      	        push    AF              ; Save sign of STEP
187F: 33      	        inc     SP              ; Don't save flags
1880: E5      	        push    HL              ; Save code string address
1881: 2A2E81  	        ld      HL,(BRKLIN)     ; Get address of index variable
1884: E3      	        ex      (SP),HL         ; Save and restore code string
1885: 0681    	PUTFID: ld      B,ZFOR          ; "FOR" block marker
1887: C5      	        push    BC              ; Save it
1888: 33      	        inc     SP              ; Don't save C
              	
1889: CDF418  	RUNCNT: call    TSTBRK          ; Execution driver - Test break
188C: 222E81  	        ld      (BRKLIN),HL     ; Save code address for break
188F: 7E      	        ld      A,(HL)          ; Get next byte in code string
1890: FE3A    	        cp      ':'             ; Multi statement line?
1892: CAA918  	        jp      Z,EXCUTE        ; Yes - Execute it
1895: B7      	        or      A               ; End of line?
1896: C2DB13  	        jp      NZ,SNERR        ; No - Syntax error
1899: 23      	        inc     HL              ; Point to address of next line
189A: 7E      	        ld      A,(HL)          ; Get LSB of line pointer
189B: 23      	        inc     HL
189C: B6      	        or      (HL)            ; Is it zero (End of prog)?
189D: CA1B19  	        jp      Z,ENDPRG        ; Yes - Terminate execution
18A0: 23      	        inc     HL              ; Point to line number
18A1: 5E      	        ld      E,(HL)          ; Get LSB of line number
18A2: 23      	        inc     HL
18A3: 56      	        ld      D,(HL)          ; Get MSB of line number
18A4: EB      	        ex      DE,HL           ; Line number to HL
18A5: 22AC80  	        ld      (LINEAT),HL     ; Save as current line number
18A8: EB      	        ex      DE,HL           ; Line number back to DE
18A9: CDC918  	EXCUTE: call    GETCHR          ; Get key word
18AC: 118918  	        ld      DE,RUNCNT       ; Where to RETurn to
18AF: D5      	        push    DE              ; Save for RETurn
18B0: C8      	IFJMP:  ret     Z               ; Go to RUNCNT if end of STMT
              	
18B1: D680    	ONJMP:  sub     ZEND            ; Is it a token?
18B3: DA6F1A  	        jp      C,LET           ; No - try to assign it
18B6: FE30    	        cp      ZNEW+1-ZEND     ; END to NEW ?
18B8: D2DB13  	        jp      NC,SNERR        ; Not a key word - ?SN Error
18BB: 07      	        rlca                    ; Double it
18BC: 4F      	        ld      C,A             ; BC = Offset into table
18BD: 0600    	        ld      B,0
18BF: EB      	        ex      DE,HL           ; Save code string address
18C0: 21E310  	        ld      HL,WORDTB       ; Keyword address table
18C3: 09      	        add     HL,BC           ; Point to routine address
18C4: 4E      	        ld      C,(HL)          ; Get LSB of routine address
18C5: 23      	        inc     HL
18C6: 46      	        ld      B,(HL)          ; Get MSB of routine address
18C7: C5      	        push    BC              ; Save routine address
18C8: EB      	        ex      DE,HL           ; Restore code string address
              	
              	; get a char from input buffer: exit with NC if character found is
              	; not a number; exit with Z if nothing found; char is into A
18C9: 23      	GETCHR: inc     HL              ; Point to next character
18CA: 7E      	        ld      A,(HL)          ; Get next code string byte
18CB: FE3A    	        cp      ':'             ; Z if ':'
18CD: D0      	        ret     NC              ; NC if > "9"
18CE: FE20    	        cp      SPC
18D0: CAC918  	        jp      Z,GETCHR        ; Skip over spaces
18D3: FE30    	        cp      '0'
18D5: 3F      	        ccf                     ; NC if < '0'
18D6: 3C      	        inc     A               ; Test for zero - Leave carry
18D7: 3D      	        dec     A               ; Z if Null
18D8: C9      	        ret
              	
18D9: EB      	RESTOR: ex      DE,HL           ; Save code string address
18DA: 2AAE80  	        ld      HL,(BASTXT)     ; Point to start of program
18DD: CAEE18  	        jp      Z,RESTNL        ; Just RESTORE - reset pointer
18E0: EB      	        ex      DE,HL           ; Restore code string address
18E1: CD8D19  	        call    ATOH            ; Get line number to DE
18E4: E5      	        push    HL              ; Save code string address
18E5: CDCE14  	        call    SRCHLN          ; Search for line number in DE
18E8: 60      	        ld      H,B             ; HL = Address of line
18E9: 69      	        ld      L,C
18EA: D1      	        pop     DE              ; Restore code string address
18EB: D22E1A  	        jp      NC,ULERR        ; ?UL Error if not found
18EE: 2B      	RESTNL: dec     HL              ; Byte before DATA statement
18EF: 223C81  	UPDATA: ld      (NXTDAT),HL     ; Update DATA pointer
18F2: EB      	        ex      DE,HL           ; Restore code string address
18F3: C9      	        ret
              	
              	
18F4: DF      	TSTBRK: rst     $18             ; Check input status
18F5: C8      	        ret     Z               ; No key, go back
18F6: D7      	        rst     $10             ; Get the key into A
18F7: FE1B    	        cp      ESC             ; Escape key?
18F9: 2811    	        jr      Z,BRK           ; Yes, break
18FB: FE03    	        cp      CTRLC           ; <Ctrl-C>
18FD: 280D    	        jr      Z,BRK           ; Yes, break
18FF: FE13    	        cp      CTRLS           ; Stop scrolling?
1901: C0      	        ret     NZ              ; Other key, ignore
              	
              	
1902: D7      	STALL:  rst     $10             ; Wait for key
1903: FE11    	        cp      CTRLQ           ; Resume scrolling?
1905: C8      	        ret     Z               ; Release the chokehold
1906: FE03    	        cp      CTRLC           ; Second break?
1908: 2807    	        jr      Z,STOP          ; Break during hold exits prog
190A: 18F6    	        jr      STALL           ; Loop until <Ctrl-Q> or <brk>
              	
190C: 3EFF    	BRK:    ld      A,$FF           ; Set BRKFLG
190E: 32A680  	        ld      (BRKFLG),A      ; Store it
              	
1911: C0      	STOP:   ret     NZ              ; Exit if anything else
1912: F6      	        defb    $F6             ; Flag "STOP"
1913: C0      	PEND:   ret     NZ              ; Exit if anything else
1914: 222E81  	        ld      (BRKLIN),HL     ; Save point of break
1917: 21      	        defb    $21             ; Skip "OR 11111111B"
1918: F6FF    	INPBRK: or      %11111111       ; Flag "Break" wanted
191A: C1      	        pop     BC              ; Return not needed and more
191B: 2AAC80  	ENDPRG: ld      HL,(LINEAT)     ; Get current line number
191E: F5      	        push    AF              ; Save STOP / END status
191F: 7D      	        ld      A,L             ; Is it direct break?
1920: A4      	        and     H
1921: 3C      	        inc     A               ; Line is -1 if direct break
1922: CA2E19  	        jp      Z,NOLIN         ; Yes - No line number
1925: 223281  	        ld      (ERRLIN),HL     ; Save line of break
1928: 2A2E81  	        ld      HL,(BRKLIN)     ; Get point of break
192B: 223481  	        ld      (CONTAD),HL     ; Save point to CONTinue
192E: AF      	NOLIN:  xor     A
192F: 32A280  	        ld      (CTLOFG),A      ; Enable output
1932: CD5C1B  	        call    STTLIN          ; Start a new line
1935: F1      	        pop     AF              ; Restore STOP / END status
1936: 217E13  	        ld      HL,BRKMSG       ; "Break" message
1939: C21014  	        jp      NZ,ERRIN        ; "in line" wanted?
193C: C32714  	        jp      PRNTOK          ; Go to command mode
              	
193F: 2A3481  	CONT:   ld      HL,(CONTAD)     ; Get CONTinue address
1942: 7C      	        ld      A,H             ; Is it zero?
1943: B5      	        or      L
1944: 1E20    	        ld      E,CN            ; ?CN Error
1946: CAEF13  	        jp      Z,ERROR         ; Yes - output "?CN Error"
1949: EB      	        ex      DE,HL           ; Save code string address
194A: 2A3281  	        ld      HL,(ERRLIN)     ; Get line of last break
194D: 22AC80  	        ld      (LINEAT),HL     ; Set up current line number
1950: EB      	        ex      DE,HL           ; Restore code string address
1951: C9      	        ret                     ; CONTinue where left off
              	
1952: E5      	ACCSUM: push    HL              ; Save address in array
1953: 2AA380  	        ld      HL,(CHKSUM)     ; Get check sum
1956: 0600    	        ld      B,$00           ; BC - Value of byte
1958: 4F      	        ld      C,A
1959: 09      	        add     HL,BC           ; Add byte to check sum
195A: 22A380  	        ld      (CHKSUM),HL     ; Re-save check sum
195D: E1      	        pop     HL              ; Restore address in array
195E: C9      	        ret
              	
195F: 7E      	CHKLTR: ld      A,(HL)          ; Get byte
1960: FE41    	        cp      'A'             ; < 'a' ?
1962: D8      	        ret     C               ; Carry set if not letter
1963: FE5B    	        cp      'Z'+1           ; > 'z' ?
1965: 3F      	        ccf
1966: C9      	        ret                     ; Carry set if not letter
              	
1967: CDC918  	FPSINT: call    GETCHR          ; Get next character
196A: CD2A1D  	POSINT: call    GETNUM          ; Get integer 0 to 32767
196D: CD6529  	DEPINT: call    TSTSGN          ; Test sign of FPREG
1970: FA8819  	        jp      M,FCERR         ; Negative - ?FC Error
1973: 3A4781  	DEINT:  ld      A,(FPEXP)       ; Get integer value to DE
1976: FE90    	        cp      $80+$10         ; Exponent in range (16 bits)?
1978: DA0D2A  	        jp      C,FPINT         ; Yes - convert it
197B: 018090  	        ld      BC,$9080        ; BCDE = -32768
197E: 110000  	        ld      DE,$0000
1981: E5      	        push    HL              ; Save code string address
1982: CDE029  	        call    CMPNUM          ; Compare FPREG with BCDE
1985: E1      	        pop     HL              ; Restore code string address
1986: 51      	        ld      D,C             ; MSB to D
1987: C8      	        ret     Z               ; Return if in range
1988: 1E08    	FCERR:  ld      E,FC            ; ?FC Error
198A: C3EF13  	        jp      ERROR           ; Output error-
              	
198D: 2B      	ATOH:   dec     HL              ; ASCII number to DE binary
198E: 110000  	GETLN:  ld      DE,$0000        ; Get number to DE
1991: CDC918  	GTLNLP: call    GETCHR          ; Get next character
1994: D0      	        ret     NC              ; Exit if not a digit
1995: E5      	        push    HL              ; Save code string address
1996: F5      	        push    AF              ; Save digit
1997: 219819  	        ld      HL,65529/10     ; Largest number 65529
199A: CDA016  	        call    CPDEHL          ; Number in range?
199D: DADB13  	        jp      C,SNERR         ; No - ?SN Error
19A0: 62      	        ld      H,D             ; HL = Number
19A1: 6B      	        ld      L,E
19A2: 19      	        add     HL,DE           ; Times 2
19A3: 29      	        add     HL,HL           ; Times 4
19A4: 19      	        add     HL,DE           ; Times 5
19A5: 29      	        add     HL,HL           ; Times 10
19A6: F1      	        pop     AF              ; Restore digit
19A7: D630    	        sub     '0'             ; Make it 0 to 9
19A9: 5F      	        ld      E,A             ; DE = Value of digit
19AA: 1600    	        ld      D,0
19AC: 19      	        add     HL,DE           ; Add to number
19AD: EB      	        ex      DE,HL           ; Number to DE
19AE: E1      	        pop     HL              ; Restore code string address
19AF: C39119  	        jp      GTLNLP          ; Go to next character
              	
19B2: CAFE14  	CLEAR:  jp      Z,INTVAR        ; Just "CLEAR" Keep parameters
19B5: CD6A19  	        call    POSINT          ; Get integer 0 to 32767 to DE
19B8: 2B      	        dec     HL              ; Cancel increment
19B9: CDC918  	        call    GETCHR          ; Get next character
19BC: E5      	        push    HL              ; Save code string address
19BD: 2A0F81  	        ld      HL,(LSTRAM)     ; Get end of RAM
19C0: CAD519  	        jp      Z,STORED        ; No value given - Use stored
19C3: E1      	        pop     HL              ; Restore code string address
19C4: CDA616  	        call    CHKSYN          ; Check for comma
19C7: 2C      	        defb    ','
19C8: D5      	        push    DE              ; Save number
19C9: CD6A19  	        call    POSINT          ; Get integer 0 to 32767
19CC: 2B      	        dec     HL              ; Cancel increment
19CD: CDC918  	        call    GETCHR          ; Get next character
19D0: C2DB13  	        jp      NZ,SNERR        ; ?SN Error if more on line
19D3: E3      	        ex      (SP),HL         ; Save code string address
19D4: EB      	        ex      DE,HL           ; Number to DE
19D5: 7D      	STORED: ld      A,L             ; Get LSB of new RAM top
19D6: 93      	        sub     E               ; Subtract LSB of string space
19D7: 5F      	        ld      E,A             ; Save LSB
19D8: 7C      	        ld      A,H             ; Get MSB of new RAM top
19D9: 9A      	        sbc     A,D             ; Subtract MSB of string space
19DA: 57      	        ld      D,A             ; Save MSB
19DB: DAD013  	        jp      C,OMERR         ; ?OM Error if not enough mem
19DE: E5      	        push    HL              ; Save RAM top
19DF: 2A3681  	        ld      HL,(PROGND)     ; Get program end
19E2: 012800  	        ld      BC,$28          ; 40 Bytes minimum working RAM
19E5: 09      	        add     HL,BC           ; Get lowest address
19E6: CDA016  	        call    CPDEHL          ; Enough memory?
19E9: D2D013  	        jp      NC,OMERR        ; No - ?OM Error
19EC: EB      	        ex      DE,HL           ; RAM top to HL
19ED: 22AA80  	        ld      (STRSPC),HL     ; Set new string space
19F0: E1      	        pop     HL              ; End of memory to use
19F1: 220F81  	        ld      (LSTRAM),HL     ; Set new top of RAM
19F4: E1      	        pop     HL              ; Restore code string address
19F5: C3FE14  	        jp      INTVAR          ; Initialise variables
              	
19F8: CAFA14  	RUN:    jp      Z,RUNFST        ; RUN from start if just RUN
19FB: CDFE14  	        call    INTVAR          ; Initialise variables
19FE: 018918  	        ld      BC,RUNCNT       ; Execution driver loop
1A01: C3141A  	        jp      RUNLIN          ; RUN from line number
              	
1A04: 0E03    	GOSUB:  ld      C,$03           ; 3 Levels of stack needed
1A06: CDB813  	        call    CHKSTK          ; Check for 3 levels of stack
1A09: C1      	        pop     BC              ; Get return address
1A0A: E5      	        push    HL              ; Save code string for RETURN
1A0B: E5      	        push    HL              ; And for GOSUB routine
1A0C: 2AAC80  	        ld      HL,(LINEAT)     ; Get current line
1A0F: E3      	        ex      (SP),HL         ; Into stack - Code string out
1A10: 3E8C    	        ld      A,ZGOSUB        ; "GOSUB" token
1A12: F5      	        push    AF              ; Save token
1A13: 33      	        inc     SP              ; Don't save flags
              	
1A14: C5      	RUNLIN: push    BC              ; Save return address
1A15: CD8D19  	GOTO:   call    ATOH            ; ASCII number to DE binary
1A18: CD5A1A  	        call    REM             ; Get end of line
1A1B: E5      	        push    HL              ; Save end of line
1A1C: 2AAC80  	        ld      HL,(LINEAT)     ; Get current line
1A1F: CDA016  	        call    CPDEHL          ; Line after current?
1A22: E1      	        pop     HL              ; Restore end of line
1A23: 23      	        inc     HL              ; Start of next line
1A24: DCD114  	        call    C,SRCHLP        ; Line is after current line
1A27: D4CE14  	        call    NC,SRCHLN       ; Line is before current line
1A2A: 60      	        ld      H,B             ; Set up code string address
1A2B: 69      	        ld      L,C
1A2C: 2B      	        dec     HL              ; Incremented after
1A2D: D8      	        ret     C               ; Line found
1A2E: 1E0E    	ULERR:  ld      E,UL            ; ?UL Error
1A30: C3EF13  	        jp      ERROR           ; Output error message
              	
1A33: C0      	RETURN: ret     NZ              ; Return if not just RETURN
1A34: 16FF    	        ld      D,-1            ; Flag "GOSUB" search
1A36: CD8413  	        call    BAKSTK          ; Look "GOSUB" block
1A39: F9      	        ld      SP,HL           ; Kill all FORs in subroutine
1A3A: FE8C    	        cp      ZGOSUB          ; Test for "GOSUB" token
1A3C: 1E04    	        ld      E,RG            ; ?RG Error
1A3E: C2EF13  	        jp      NZ,ERROR        ; Error if no "GOSUB" found
1A41: E1      	        pop     HL              ; Get RETURN line number
1A42: 22AC80  	        ld      (LINEAT),HL     ; Save as current
1A45: 23      	        inc     HL              ; Was it from direct statement?
1A46: 7C      	        ld      A,H
1A47: B5      	        or      L               ; Return to line
1A48: C2521A  	        jp      NZ,RETLIN       ; No - Return to line
1A4B: 3A2C81  	        ld      A,(LSTBIN)      ; Any INPUT in subroutine?
1A4E: B7      	        or      A               ; If so buffer is corrupted
1A4F: C22614  	        jp      NZ,POPNOK       ; Yes - Go to command mode
1A52: 218918  	RETLIN: ld      HL,RUNCNT       ; Execution driver loop
1A55: E3      	        ex      (SP),HL         ; Into stack - Code string out
1A56: 3E      	        defb    $3E             ; Skip "pop HL"
1A57: E1      	NXTDTA: pop     HL              ; Restore code string address
              	
1A58: 013A    	DATA:   defb    $01,$3A         ; ':' End of statement
1A5A: 0E00    	REM:    ld      C,$00           ; 00  End of statement
1A5C: 0600    	        ld      B,$00
1A5E: 79      	NXTSTL: ld      A,C             ; Statement and byte
1A5F: 48      	        ld      C,B
1A60: 47      	        ld      B,A             ; Statement end byte
1A61: 7E      	NXTSTT: ld      A,(HL)          ; Get byte
1A62: B7      	        or      A               ; End of line?
1A63: C8      	        ret     Z               ; Yes - Exit
1A64: B8      	        cp      B               ; End of statement?
1A65: C8      	        ret     Z               ; Yes - Exit
1A66: 23      	        inc     HL              ; Next byte
1A67: FE22    	        cp      $22             ; '"'             ; Literal string?
1A69: CA5E1A  	        jp      Z,NXTSTL        ; Yes - Look for another '"'
1A6C: C3611A  	        jp      NXTSTT          ; Keep looking
              	
1A6F: CD2F1F  	LET:    call    GETVAR          ; Get variable name
1A72: CDA616  	        call    CHKSYN          ; Make sure "=" follows
1A75: C0      	        defb    ZEQUAL          ; "=" token
1A76: D5      	        push    DE              ; Save address of variable
1A77: 3A0D81  	        ld      A,(TYPE)        ; Get data type
1A7A: F5      	        push    AF              ; Save type
1A7B: CD3C1D  	        call    EVAL            ; Evaluate expression
1A7E: F1      	        pop     AF              ; Restore type
1A7F: E3      	        ex      (SP),HL         ; Save code - Get var addr
1A80: 222E81  	        ld      (BRKLIN),HL     ; Save address of variable
1A83: 1F      	        rra                     ; Adjust type
1A84: CD2F1D  	        call    CHKTYP          ; Check types are the same
1A87: CAC21A  	        jp      Z,LETNUM        ; Numeric - Move value
1A8A: E5      	LETSTR: push    HL              ; Save address of string var
1A8B: 2A4481  	        ld      HL,(FPREG)      ; Pointer to string entry
1A8E: E5      	        push    HL              ; Save it on stack
1A8F: 23      	        inc     HL              ; Skip over length
1A90: 23      	        inc     HL
1A91: 5E      	        ld      E,(HL)          ; LSB of string address
1A92: 23      	        inc     HL
1A93: 56      	        ld      D,(HL)          ; MSB of string address
1A94: 2AAE80  	        ld      HL,(BASTXT)     ; Point to start of program
1A97: CDA016  	        call    CPDEHL          ; Is string before program?
1A9A: D2B11A  	        jp      NC,CRESTR       ; Yes - Create string entry
1A9D: 2AAA80  	        ld      HL,(STRSPC)     ; Point to string space
1AA0: CDA016  	        call    CPDEHL          ; Is string literal in program?
1AA3: D1      	        pop     DE              ; Restore address of string
1AA4: D2B91A  	        jp      NC,MVSTPT       ; Yes - Set up pointer
1AA7: 211F81  	        ld      HL,TMPSTR       ; Temporary string pool
1AAA: CDA016  	        call    CPDEHL          ; Is string in temporary pool?
1AAD: D2B91A  	        jp      NC,MVSTPT       ; No - Set up pointer
1AB0: 3E      	        defb    $3E             ; Skip "pop DE"
1AB1: D1      	CRESTR: pop     DE              ; Restore address of string
1AB2: CD8A23  	        call    BAKTMP          ; Back to last tmp-str entry
1AB5: EB      	        ex      DE,HL           ; Address of string entry
1AB6: CDC321  	        call    SAVSTR          ; Save string in string area
1AB9: CD8A23  	MVSTPT: call    BAKTMP          ; Back to last tmp-str entry
1ABC: E1      	        pop     HL              ; Get string pointer
1ABD: CDC029  	        call    DETHL4          ; Move string pointer to var
1AC0: E1      	        pop     HL              ; Restore code string address
1AC1: C9      	        ret
              	
1AC2: E5      	LETNUM: push    HL              ; Save address of variable
1AC3: CDBD29  	        call    FPTHL           ; Move value to variable
1AC6: D1      	        pop     DE              ; Restore address of variable
1AC7: E1      	        pop     HL              ; Restore code string address
1AC8: C9      	        ret
              	
1AC9: CDB124  	ON:     call    GETINT          ; Get integer 0-255
1ACC: 7E      	        ld      A,(HL)          ; Get "GOTO" or "GOSUB" token
1ACD: 47      	        ld      B,A             ; Save in B
1ACE: FE8C    	        cp      ZGOSUB          ; "GOSUB" token?
1AD0: CAD81A  	        jp      Z,ONGO          ; Yes - Find line number
1AD3: CDA616  	        call    CHKSYN          ; Make sure it's "GOTO"
1AD6: 88      	        defb    ZGOTO           ; "GOTO" token
1AD7: 2B      	        dec     HL              ; Cancel increment
1AD8: 4B      	ONGO:   ld      C,E             ; Integer of branch value
1AD9: 0D      	ONGOLP: dec     C               ; Count branches
1ADA: 78      	        ld      A,B             ; Get "GOTO" or "GOSUB" token
1ADB: CAB118  	        jp      Z,ONJMP         ; Go to that line if right one
1ADE: CD8E19  	        call    GETLN           ; Get line number to DE
1AE1: FE2C    	        cp      ','             ; Another line number?
1AE3: C0      	        ret     NZ              ; No - Drop through
1AE4: C3D91A  	        jp      ONGOLP          ; Yes - loop
              	
1AE7: CD3C1D  	IF:     call    EVAL            ; Evaluate expression
1AEA: 7E      	        ld      A,(HL)          ; Get token
1AEB: FE88    	        cp      ZGOTO           ; "GOTO" token?
1AED: CAF51A  	        jp      Z,IFGO          ; Yes - Get line
1AF0: CDA616  	        call    CHKSYN          ; Make sure it's "THEN"
1AF3: B4      	        defb    ZTHEN           ; "THEN" token
1AF4: 2B      	        dec     HL              ; Cancel increment
1AF5: CD2D1D  	IFGO:   call    TSTNUM          ; Make sure it's numeric
1AF8: CD6529  	        call    TSTSGN          ; Test state of expression
1AFB: CA5A1A  	        jp      Z,REM           ; False - Drop through
1AFE: CDC918  	        call    GETCHR          ; Get next character
1B01: DA151A  	        jp      C,GOTO          ; Number - GOTO that line
1B04: C3B018  	        jp      IFJMP           ; Otherwise do statement
              	
1B07: 2B      	MRPRNT: dec     HL              ; dec 'cos GETCHR INCs
1B08: CDC918  	        call    GETCHR          ; Get next character
1B0B: CA6E1B  	PRINT:  jp      Z,PRNTCRLF      ; CRLF if just PRINT
1B0E: C8      	PRNTLP: ret     Z               ; End of list - Exit
1B0F: FEB0    	        cp      ZTAB            ; "TAB(" token?
1B11: CA961B  	        jp      Z,DOTAB         ; Yes - Do TAB routine
1B14: FEB3    	        cp      ZSPC            ; "SPC(" token?
1B16: CA961B  	        jp      Z,DOTAB         ; Yes - Do SPC routine
1B19: E5      	        push    HL              ; Save code string address
1B1A: FE2C    	        cp      ','             ; Comma?
1B1C: CA7D1B  	        jp      Z,DOCOM         ; Yes - Move to next zone
1B1F: FE3B    	        cp      ';'             ; Semi-colon?
1B21: CABA1B  	        jp      Z,NEXITM        ; Do semi-colon routine
1B24: C1      	        pop     BC              ; Code string address to BC
1B25: CD3C1D  	        call    EVAL            ; Evaluate expression
1B28: E5      	        push    HL              ; Save code string address
1B29: 3A0D81  	        ld      A,(TYPE)        ; Get variable type
1B2C: B7      	        or      A               ; Is it a string variable?
1B2D: C2551B  	        jp      NZ,PRNTST       ; Yes - Output string contents
1B30: CD0A2B  	        call    NUMASC          ; Convert number to text
1B33: CDE721  	        call    CRTST           ; Create temporary string
1B36: 3600    	        ld      (HL),NLLCR      ; Followed by a NULL char (was SPC, space)
1B38: 2A4481  	        ld      HL,(FPREG)      ; Get length of output
1B3B: 34      	        inc     (HL)            ; Plus 1 for the space
1B3C: 2A4481  	        ld      HL,(FPREG)      ; < Not needed >
1B3F: 3A9F80  	        ld      A,(LWIDTH)      ; Get width of line
1B42: 47      	        ld      B,A             ; To B
1B43: 04      	        inc     B               ; Width 255 (No limit)?
1B44: CA511B  	        jp      Z,PRNTNB        ; Yes - Output number string
1B47: 04      	        inc     B               ; Adjust it
1B48: 3A0B81  	        ld      A,(CURPOS)      ; Get cursor position
1B4B: 86      	        add     A,(HL)          ; Add length of string
1B4C: 3D      	        dec     A               ; Adjust it
1B4D: B8      	        cp      B               ; Will output fit on this line?
1B4E: D46E1B  	        call    NC,PRNTCRLF     ; No - CRLF first
1B51: CD2C22  	PRNTNB: call    PRS1            ; Output string at (HL)
1B54: AF      	        xor     A               ; Skip call by setting 'z' flag
1B55: C42C22  	PRNTST: call    NZ,PRS1         ; Output string at (HL)
1B58: E1      	        pop     HL              ; Restore code string address
1B59: C3071B  	        jp      MRPRNT          ; See if more to PRINT
              	
1B5C: 3A0B81  	STTLIN: ld      A,(CURPOS)      ; Make sure on new line
1B5F: B7      	        or      A               ; Already at start?
1B60: C8      	        ret     Z               ; Yes - Do nothing
1B61: C36E1B  	        jp      PRNTCRLF        ; Start a new line
              	
1B64: AF      	ENDINP: xor     A
1B65: 329881  	        ld      (KBDNPT),A      ; char is not from keyboard
1B68: 77      	        ld      (HL),A          ; Mark end of buffer
1B69: 21B080  	        ld      HL,BUFFER-1     ; Point to buffer
1B6C: 180A    	        jr      CNTEND
1B6E: 3E0D    	PRNTCRLF:ld     A,CR            ; Load a CR
1B70: CDB116  	        call    OUTC            ; Output character
1B73: 3E0A    	        ld      A,LF            ; Load a LF
1B75: CDB116  	        call    OUTC            ; Output character
1B78: AF      	CNTEND: xor     A               ; Set to position 0
1B79: 320B81  	        ld      (CURPOS),A      ; Store it
1B7C: C9      	        ret                     ; return to caller
              	
1B7D: 3AA080  	DOCOM:  ld      A,(COMMAN)      ; Get comma width
1B80: 47      	        ld      B,A             ; Save in B
1B81: 3A0B81  	        ld      A,(CURPOS)      ; Get current position
1B84: B8      	        cp      B               ; Within the limit?
1B85: D46E1B  	        call    NC,PRNTCRLF     ; No - output CRLF
1B88: D2BA1B  	        jp      NC,NEXITM       ; Get next item
1B8B: D60E    	ZONELP: sub     $0E             ; Next zone of 14 characters
1B8D: D28B1B  	        jp      NC,ZONELP       ; Repeat if more zones
1B90: 2F      	        cpl                     ; Number of null chars to output
1B91: 0E00    	        ld      C,NLLCR         ; null char
1B93: C3B01B  	        jp      ASPCS           ; Output them
              	
1B96: F5      	DOTAB:  push    AF              ; Save token
1B97: CDAE24  	        call    FNDNUM          ; Evaluate expression
1B9A: CDA616  	        call    CHKSYN          ; Make sure ")" follows
1B9D: 29      	        defb    ')'
1B9E: 2B      	        dec     HL              ; Back space on to ")"
1B9F: F1      	        pop     AF              ; Restore token
1BA0: 0E00    	        ld      C,NLLCR         ; for SPC we use NULL char (was SPACE)
1BA2: D6B3    	        sub     ZSPC            ; Was it "SPC(" ?
1BA4: E5      	        push    HL              ; Save code string address
1BA5: CAAB1B  	        jp      Z,DOSPC         ; Yes - Do 'E' spaces
1BA8: 3A5381  	        ld      A,(SCR_CURS_X)  ; Get current X position
1BAB: 2F      	DOSPC:  cpl                     ; Number of spaces to print to
1BAC: 83      	        add     A,E             ; Total number to print
1BAD: D2BA1B  	        jp      NC,NEXITM       ; TAB < Current POS(X)
1BB0: 3C      	ASPCS:  inc     A               ; Output A spaces
1BB1: 47      	        ld      B,A             ; Save number to print
1BB2: 79      	SPCLP:  ld      A,C             ; char to print
1BB3: CDB116  	        call    OUTC            ; Output character in A
1BB6: 05      	        dec     B               ; Count them
1BB7: C2B21B  	        jp      NZ,SPCLP        ; Repeat if more
1BBA: E1      	NEXITM: pop     HL              ; Restore code string address
1BBB: CDC918  	        call    GETCHR          ; Get next character
1BBE: C30E1B  	        jp      PRNTLP          ; More to print
              	
1BC1: 3F526564	REDO:   defb    "?Redo from start",CR,0
1BC5: 6F206672	
1BC9: 6F6D2073	
1BCD: 74617274	
1BD1: 0D00    	
              	
1BD3: 3A2D81  	BADINP: ld      A,(READFG)      ; READ or INPUT?
1BD6: B7      	        or      A
1BD7: C2D513  	        jp      NZ,DATSNR       ; READ - ?SN Error
1BDA: C1      	        pop     BC              ; Throw away code string addr
1BDB: 21C11B  	        ld      HL,REDO         ; "Redo from start" message
1BDE: CD2922  	        call    PRS             ; Output string
1BE1: C32D15  	        jp      DOAGN           ; Do last INPUT again
              	
1BE4: CD9421  	INPUT:  call    IDTEST          ; Test for illegal direct
1BE7: 7E      	        ld      A,(HL)          ; Get character after "INPUT"
1BE8: FE22    	        cp      $22             ; '"' ; Is there a prompt string?
1BEA: 3E00    	        ld      A,$00           ; Clear A and leave flags
1BEC: 32A280  	        ld      (CTLOFG),A      ; Enable output
1BEF: C2FE1B  	        jp      NZ,NOPMPT       ; No prompt - get input
1BF2: CDE821  	        call    QTSTR           ; Get string terminated by '"'
1BF5: CDA616  	        call    CHKSYN          ; Check for ';' after prompt
1BF8: 3B      	        defb    ";"
1BF9: E5      	        push    HL              ; Save code string address
1BFA: CD2C22  	        call    PRS1            ; Output prompt string
1BFD: 3E      	        defb    $3E             ; Skip "push HL"
1BFE: E5      	NOPMPT: push    HL              ; Save code string address
1BFF: CD3115  	        call    PROMPT          ; Get input with "? " prompt
1C02: C1      	        pop     BC              ; Restore code string address
1C03: DA1819  	        jp      C,INPBRK        ; Break pressed - Exit
1C06: 23      	        inc     HL              ; Next byte
1C07: 7E      	        ld      A,(HL)          ; Get it
1C08: B7      	        or      A               ; End of line?
1C09: 2B      	        dec     HL              ; Back again
1C0A: C5      	        push    BC              ; Re-save code string address
1C0B: CD2B08  	        call    CURSOR_OFF      ; disable cursor
1C0E: CA571A  	        jp      Z,NXTDTA        ; Yes - Find next DATA stmt
1C11: 362C    	        ld      (HL),','        ; Store comma as separator
1C13: C31B1C  	        jp      NXTITM          ; Get next item
              	
1C16: E5      	READ:   push    HL              ; Save code string address
1C17: 2A3C81  	        ld      HL,(NXTDAT)     ; Next DATA statement
1C1A: F6      	        defb    $F6             ; Flag "READ"
1C1B: AF      	NXTITM: xor     A               ; Flag "INPUT"
1C1C: 322D81  	        ld      (READFG),A      ; Save "READ"/"INPUT" flag
1C1F: E3      	        ex      (SP),HL         ; Get code str' , Save pointer
1C20: C3271C  	        jp      GTVLUS          ; Get values
              	
1C23: CDA616  	NEDMOR: call    CHKSYN          ; Check for comma between items
1C26: 2C      	        defb    ','
1C27: CD2F1F  	GTVLUS: call    GETVAR          ; Get variable name
1C2A: E3      	        ex      (SP),HL         ; Save code str" , Get pointer
1C2B: D5      	        push    DE              ; Save variable address
1C2C: 7E      	        ld      A,(HL)          ; Get next "INPUT"/"DATA" byte
1C2D: FE2C    	        cp      ','             ; Comma?
1C2F: CA4F1C  	        jp      Z,ANTVLU        ; Yes - Get another value
1C32: 3A2D81  	        ld      A,(READFG)      ; Is it READ?
1C35: B7      	        or      A
1C36: C2BB1C  	        jp      NZ,FDTLP        ; Yes - Find next DATA stmt
1C39: 3E3F    	        ld      A,'?'           ; More INPUT needed
1C3B: CDB116  	        call    OUTC            ; Output character
1C3E: CD3115  	        call    PROMPT          ; Get INPUT with prompt
1C41: D1      	        pop     DE              ; Variable address
1C42: C1      	        pop     BC              ; Code string address
1C43: DA1819  	        jp      C,INPBRK        ; Break pressed
1C46: 23      	        inc     HL              ; Point to next DATA byte
1C47: 7E      	        ld      A,(HL)          ; Get byte
1C48: B7      	        or      A               ; Is it zero (No input) ?
1C49: 2B      	        dec     HL              ; Back space INPUT pointer
1C4A: C5      	        push    BC              ; Save code string address
1C4B: CA571A  	        jp      Z,NXTDTA        ; Find end of buffer
1C4E: D5      	        push    DE              ; Save variable address
1C4F: 3A0D81  	ANTVLU: ld      A,(TYPE)        ; Check data type
1C52: B7      	        or      A               ; Is it numeric?
1C53: CA791C  	        jp      Z,INPBIN        ; Yes - Convert to binary
1C56: CDC918  	        call    GETCHR          ; Get next character
1C59: 57      	        ld      D,A             ; Save input character
1C5A: 47      	        ld      B,A             ; Again
1C5B: FE22    	        cp      $22             ; '"'     ; Start of literal sting?
1C5D: CA6D1C  	        jp      Z,STRENT        ; Yes - Create string entry
1C60: 3A2D81  	        ld      A,(READFG)      ; "READ" or "INPUT" ?
1C63: B7      	        or      A
1C64: 57      	        ld      D,A             ; Save 00 if "INPUT"
1C65: CA6A1C  	        jp      Z,ITMSEP        ; "INPUT" - End with 00
1C68: 163A    	        ld      D,':'           ; "DATA" - End with 00 or ':'
1C6A: 062C    	ITMSEP: ld      B,','           ; Item separator
1C6C: 2B      	        dec     HL              ; Back space for DTSTR
1C6D: CDEB21  	STRENT: call    DTSTR           ; Get string terminated by D
1C70: EB      	        ex      DE,HL           ; String address to DE
1C71: 21841C  	        ld      HL,LTSTND       ; Where to go after LETSTR
1C74: E3      	        ex      (SP),HL         ; Save HL , get input pointer
1C75: D5      	        push    DE              ; Save address of string
1C76: C38A1A  	        jp      LETSTR          ; Assign string to variable
              	
1C79: CDC918  	INPBIN: call    GETCHR          ; Get next character
1C7C: CD6C2A  	        call    ASCTFP          ; Convert ASCII to FP number
1C7F: E3      	        ex      (SP),HL         ; Save input ptr, Get var addr
1C80: CDBD29  	        call    FPTHL           ; Move FPREG to variable
1C83: E1      	        pop     HL              ; Restore input pointer
1C84: 2B      	LTSTND: dec     HL              ; dec 'cos GETCHR INCs
1C85: CDC918  	        call    GETCHR          ; Get next character
1C88: CA901C  	        jp      Z,MORDT         ; End of line - More needed?
1C8B: FE2C    	        cp      ','             ; Another value?
1C8D: C2D31B  	        jp      NZ,BADINP       ; No - Bad input
1C90: E3      	MORDT:  ex      (SP),HL         ; Get code string address
1C91: 2B      	        dec     HL              ; dec 'cos GETCHR INCs
1C92: CDC918  	        call    GETCHR          ; Get next character
1C95: C2231C  	        jp      NZ,NEDMOR       ; More needed - Get it
1C98: D1      	        pop     DE              ; Restore DATA pointer
1C99: 3A2D81  	        ld      A,(READFG)      ; "READ" or "INPUT" ?
1C9C: B7      	        or      A
1C9D: EB      	        ex      DE,HL           ; DATA pointer to HL
1C9E: C2EF18  	        jp      NZ,UPDATA       ; Update DATA pointer if "READ"
1CA1: D5      	        push    DE              ; Save code string address
1CA2: B6      	        or      (HL)            ; More input given?
1CA3: 21AB1C  	        ld      HL,EXTIG        ; "?Extra ignored" message
1CA6: C42922  	        call    NZ,PRS          ; Output string if extra given
1CA9: E1      	        pop     HL              ; Restore code string address
1CAA: C9      	        ret
              	
1CAB: 3F457874	EXTIG:  defb    "?Extra ignored",CR,0
1CAF: 72612069	
1CB3: 676E6F72	
1CB7: 65640D00	
              	
1CBB: CD581A  	FDTLP:  call    DATA            ; Get next statement
1CBE: B7      	        or      A               ; End of line?
1CBF: C2D41C  	        jp      NZ,FANDT        ; No - See if DATA statement
1CC2: 23      	        inc     HL
1CC3: 7E      	        ld      A,(HL)          ; End of program?
1CC4: 23      	        inc     HL
1CC5: B6      	        or      (HL)            ; 00 00 Ends program
1CC6: 1E06    	        ld      E,OD            ; ?OD Error
1CC8: CAEF13  	        jp      Z,ERROR         ; Yes - Out of DATA
1CCB: 23      	        inc     HL
1CCC: 5E      	        ld      E,(HL)          ; LSB of line number
1CCD: 23      	        inc     HL
1CCE: 56      	        ld      D,(HL)          ; MSB of line number
1CCF: EB      	        ex      DE,HL
1CD0: 222981  	        ld      (DATLIN),HL     ; Set line of current DATA item
1CD3: EB      	        ex      DE,HL
1CD4: CDC918  	FANDT:  call    GETCHR          ; Get next character
1CD7: FE83    	        cp      ZDATA           ; "DATA" token
1CD9: C2BB1C  	        jp      NZ,FDTLP        ; No "DATA" - Keep looking
1CDC: C34F1C  	        jp      ANTVLU          ; Found - Convert input
              	
1CDF: 110000  	NEXT:   ld      DE,$0000        ; In case no index given
1CE2: C42F1F  	NEXT1:  call    NZ,GETVAR       ; Get index address
1CE5: 222E81  	        ld      (BRKLIN),HL     ; Save code string address
1CE8: CD8413  	        call    BAKSTK          ; Look for "FOR" block
1CEB: C2E113  	        jp      NZ,NFERR        ; No "FOR" - ?NF Error
1CEE: F9      	        ld      SP,HL           ; Clear nested loops
1CEF: D5      	        push    DE              ; Save index address
1CF0: 7E      	        ld      A,(HL)          ; Get sign of STEP
1CF1: 23      	        inc     HL
1CF2: F5      	        push    AF              ; Save sign of STEP
1CF3: D5      	        push    DE              ; Save index address
1CF4: CDA329  	        call    PHLTFP          ; Move index value to FPREG
1CF7: E3      	        ex      (SP),HL         ; Save address of TO value
1CF8: E5      	        push    HL              ; Save address of index
1CF9: CD1027  	        call    ADDPHL          ; Add STEP to index value
1CFC: E1      	        pop     HL              ; Restore address of index
1CFD: CDBD29  	        call    FPTHL           ; Move value to index variable
1D00: E1      	        pop     HL              ; Restore address of TO value
1D01: CDB429  	        call    LOADFP          ; Move TO value to BCDE
1D04: E5      	        push    HL              ; Save address of line of FOR
1D05: CDE029  	        call    CMPNUM          ; Compare index with TO value
1D08: E1      	        pop     HL              ; Restore address of line num
1D09: C1      	        pop     BC              ; Address of sign of STEP
1D0A: 90      	        sub     B               ; Compare with expected sign
1D0B: CDB429  	        call    LOADFP          ; BC = Loop stmt,DE = Line num
1D0E: CA1A1D  	        jp      Z,KILFOR        ; Loop finished - Terminate it
1D11: EB      	        ex      DE,HL           ; Loop statement line number
1D12: 22AC80  	        ld      (LINEAT),HL     ; Set loop line number
1D15: 69      	        ld      L,C             ; Set code string to loop
1D16: 60      	        ld      H,B
1D17: C38518  	        jp      PUTFID          ; Put back "FOR" and continue
              	
1D1A: F9      	KILFOR: ld      SP,HL           ; Remove "FOR" block
1D1B: 2A2E81  	        ld      HL,(BRKLIN)     ; Code string after "NEXT"
1D1E: 7E      	        ld      A,(HL)          ; Get next byte in code string
1D1F: FE2C    	        cp      ','             ; More NEXTs ?
1D21: C28918  	        jp      NZ,RUNCNT       ; No - Do next statement
1D24: CDC918  	        call    GETCHR          ; Position to index name
1D27: CDE21C  	        call    NEXT1           ; Re-enter NEXT routine
              	; < will not RETurn to here , Exit to RUNCNT or Loop >
              	
1D2A: CD3C1D  	GETNUM: call    EVAL            ; Get a numeric expression
1D2D: F6      	TSTNUM: defb    $F6             ; Clear carry (numeric)
1D2E: 37      	TSTSTR: scf                     ; Set carry (string)
1D2F: 3A0D81  	CHKTYP: ld      A,(TYPE)        ; Check types match
1D32: 8F      	        adc     A,A             ; Expected + actual
1D33: B7      	        or      A               ; Clear carry , set parity
1D34: E8      	        ret     PE              ; Even parity - Types match
1D35: C3ED13  	        jp      TMERR           ; Different types - Error
              	
1D38: CDA616  	OPNPAR: call    CHKSYN          ; Make sure "(" follows
1D3B: 28      	        defb    '('
1D3C: 2B      	EVAL:   dec     HL              ; Evaluate expression & save
1D3D: 1600    	        ld      D,$00           ; Precedence value
1D3F: D5      	EVAL1:  push    DE              ; Save precedence
1D40: 0E01    	        ld      C,$01
1D42: CDB813  	        call    CHKSTK          ; Check for 1 level of stack
1D45: CDB31D  	        call    OPRND           ; Get next expression value
1D48: 223081  	EVAL2:  ld      (NXTOPR),HL     ; Save address of next operator
1D4B: 2A3081  	EVAL3:  ld      HL,(NXTOPR)     ; Restore address of next opr
1D4E: C1      	        pop     BC              ; Precedence value and operator
1D4F: 78      	        ld      A,B             ; Get precedence value
1D50: FE78    	        cp      $78             ; "AND", "OR", or "XOR" ?
1D52: D42D1D  	        call    NC,TSTNUM       ; No - Make sure it's a number
1D55: 7E      	        ld      A,(HL)          ; Get next operator / function
1D56: 1600    	        ld      D,$00           ; Clear Last relation
1D58: D6BF    	RLTLP:  sub     ZGTR            ; ">" Token
1D5A: DA741D  	        jp      C,FOPRND        ; + - * / ^ AND OR XOR - Test it
1D5D: FE03    	        cp      ZLTH+1-ZGTR     ; < = >
1D5F: D2741D  	        jp      NC,FOPRND       ; Function - Call it
1D62: FE01    	        cp      ZEQUAL-ZGTR     ; "="
1D64: 17      	        rla                     ; <- Test for legal
1D65: AA      	        xor     D               ; <- combinations of < = >
1D66: BA      	        cp      D               ; <- by combining last token
1D67: 57      	        ld      D,A             ; <- with current one
1D68: DADB13  	        jp      C,SNERR         ; Error if "<<' '==" or ">>"
1D6B: 222581  	        ld      (CUROPR),HL     ; Save address of current token
1D6E: CDC918  	        call    GETCHR          ; Get next character
1D71: C3581D  	        jp      RLTLP           ; Treat the two as one
              	
1D74: 7A      	FOPRND: ld      A,D             ; < = > found ?
1D75: B7      	        or      A
1D76: C2AA1E  	        jp      NZ,TSTRED       ; Yes - Test for reduction
1D79: 7E      	        ld      A,(HL)          ; Get operator token
1D7A: 222581  	        ld      (CUROPR),HL     ; Save operator address
1D7D: D6B7    	        sub     ZPLUS           ; Operator or function?
1D7F: D8      	        ret     C               ; Neither - Exit
1D80: FE08    	        cp      ZOR+1-ZPLUS     ; Is it + - * / ^ AND XOR OR ?
1D82: D0      	        ret     NC              ; No - Exit
1D83: 5F      	        ld      E,A             ; Coded operator
1D84: 3A0D81  	        ld      A,(TYPE)        ; Get data type
1D87: 3D      	        dec     A               ; FF = numeric , 00 = string
1D88: B3      	        or      E               ; Combine with coded operator
1D89: 7B      	        ld      A,E             ; Get coded operator
1D8A: CA1F23  	        jp      Z,CONCAT        ; String concatenation
1D8D: 07      	        rlca                    ; Times 2
1D8E: 83      	        add     A,E             ; Times 3
1D8F: 5F      	        ld      E,A             ; To DE (D is 0)
1D90: 214311  	        ld      HL,PRITAB       ; Precedence table
1D93: 19      	        add     HL,DE           ; To the operator concerned
1D94: 78      	        ld      A,B             ; Last operator precedence
1D95: 56      	        ld      D,(HL)          ; Get evaluation precedence
1D96: BA      	        cp      D               ; Compare with eval precedence
1D97: D0      	        ret     NC              ; Exit if higher precedence
1D98: 23      	        inc     HL              ; Point to routine address
1D99: CD2D1D  	        call    TSTNUM          ; Make sure it's a number
              	
1D9C: C5      	STKTHS: push    BC              ; Save last precedence & token
1D9D: 014B1D  	        ld      BC,EVAL3        ; Where to go on prec' break
1DA0: C5      	        push    BC              ; Save on stack for return
1DA1: 43      	        ld      B,E             ; Save operator
1DA2: 4A      	        ld      C,D             ; Save precedence
1DA3: CD9629  	        call    STAKFP          ; Move value to stack
1DA6: 58      	        ld      E,B             ; Restore operator
1DA7: 51      	        ld      D,C             ; Restore precedence
1DA8: 4E      	        ld      C,(HL)          ; Get LSB of routine address
1DA9: 23      	        inc     HL
1DAA: 46      	        ld      B,(HL)          ; Get MSB of routine address
1DAB: 23      	        inc     HL
1DAC: C5      	        push    BC              ; Save routine address
1DAD: 2A2581  	        ld      HL,(CUROPR)     ; Address of current operator
1DB0: C33F1D  	        jp      EVAL1           ; Loop until prec' break
              	
1DB3: AF      	OPRND:  xor     A               ; Get operand routine
1DB4: 320D81  	        ld      (TYPE),A        ; Set numeric expected
1DB7: CDC918  	        call    GETCHR          ; Get next character
1DBA: 1E24    	        ld      E,MO            ; ?MO Error
1DBC: CAEF13  	        jp      Z,ERROR         ; No operand - Error
1DBF: DA6C2A  	        jp      C,ASCTFP        ; Number - Get value
1DC2: CD5F19  	        call    CHKLTR          ; See if a letter
1DC5: D21A1E  	        jp      NC,CONVAR       ; Letter - Find variable
1DC8: FE26    	        cp      '&'             ; &H = HEX, &B = BINARY
1DCA: 2012    	        jr      NZ,NOTAMP
1DCC: CDC918  	        call    GETCHR          ; Get next character
1DCF: FE48    	        cp      'H'             ; Hex number indicated? [function added]
1DD1: CA7D35  	        jp      Z,HEXTFP        ; Convert Hex to FPREG
1DD4: FE42    	        cp      'B'             ; Binary number indicated? [function added]
1DD6: CAED35  	        jp      Z,BINTFP        ; Convert Bin to FPREG
1DD9: 1E02    	        ld      E,SN            ; If neither then a ?SN Error
1DDB: CAEF13  	        jp      Z,ERROR         ;
1DDE: FEB7    	NOTAMP: cp      ZPLUS           ; '+' Token ?
1DE0: CAB31D  	        jp      Z,OPRND         ; Yes - Look for operand
1DE3: FE2E    	        cp      '.'             ; '.' ?
1DE5: CA6C2A  	        jp      Z,ASCTFP        ; Yes - Create FP number
1DE8: FEB8    	        cp      ZMINUS          ; '-' Token ?
1DEA: CA091E  	        jp      Z,MINUS         ; Yes - Do minus
1DED: FE22    	        cp      $22             ; '"'             ; Literal string ?
1DEF: CAE821  	        jp      Z,QTSTR         ; Get string terminated by '"'
1DF2: FEB5    	        cp      ZNOT            ; "NOT" Token ?
1DF4: CA0A1F  	        jp      Z,EVNOT         ; Yes - Eval NOT expression
1DF7: FEB2    	        cp      ZFN             ; "FN" Token ?
1DF9: CA4C21  	        jp      Z,DOFN          ; Yes - Do FN routine
1DFC: D6C2    	        sub     ZSGN            ; Is it a function?
1DFE: D22B1E  	        jp      NC,FNOFST       ; Yes - Evaluate function
1E01: CD381D  	EVLPAR: call    OPNPAR          ; Evaluate expression in "()"
1E04: CDA616  	        call    CHKSYN          ; Make sure ")" follows
1E07: 29      	        defb    ')'
1E08: C9      	        ret
              	
1E09: 167D    	MINUS:  ld      D,$7D           ; '-' precedence
1E0B: CD3F1D  	        call    EVAL1           ; Evaluate until prec' break
1E0E: 2A3081  	        ld      HL,(NXTOPR)     ; Get next operator address
1E11: E5      	        push    HL              ; Save next operator address
1E12: CD8E29  	        call    INVSGN          ; Negate value
1E15: CD2D1D  	RETNUM: call    TSTNUM          ; Make sure it's a number
1E18: E1      	        pop     HL              ; Restore next operator address
1E19: C9      	        ret
              	
1E1A: CD2F1F  	CONVAR: call    GETVAR          ; Get variable address to DE
1E1D: E5      	FRMEVL: push    HL              ; Save code string address
1E1E: EB      	        ex      DE,HL           ; Variable address to HL
1E1F: 224481  	        ld      (FPREG),HL      ; Save address of variable
1E22: 3A0D81  	        ld      A,(TYPE)        ; Get type
1E25: B7      	        or      A               ; Numeric?
1E26: CCA329  	        call    Z,PHLTFP        ; Yes - Move contents to FPREG
1E29: E1      	        pop     HL              ; Restore code string address
1E2A: C9      	        ret
              	
1E2B: 0600    	FNOFST: ld      B,$00           ; Get address of function
1E2D: 07      	        rlca                    ; Double function offset
1E2E: 4F      	        ld      C,A             ; BC = Offset in function table
1E2F: C5      	        push    BC              ; Save adjusted token value
1E30: CDC918  	        call    GETCHR          ; Get next character
1E33: 79      	        ld      A,C             ; Get adjusted token value
1E34: FE39    	        cp      2*(ZLEFT-ZSGN)-1; Adj' LEFT$,RIGHT$ or MID$ ?
1E36: DA521E  	        jp      C,FNVAL         ; No - Do function
1E39: CD381D  	        call    OPNPAR          ; Evaluate expression  (X,...
1E3C: CDA616  	        call    CHKSYN          ; Make sure ',' follows
1E3F: 2C      	        defb    ','
1E40: CD2E1D  	        call    TSTSTR          ; Make sure it's a string
1E43: EB      	        ex      DE,HL           ; Save code string address
1E44: 2A4481  	        ld      HL,(FPREG)      ; Get address of string
1E47: E3      	        ex      (SP),HL         ; Save address of string
1E48: E5      	        push    HL              ; Save adjusted token value
1E49: EB      	        ex      DE,HL           ; Restore code string address
1E4A: CDB124  	        call    GETINT          ; Get integer 0-255
1E4D: EB      	        ex      DE,HL           ; Save code string address
1E4E: E3      	        ex      (SP),HL         ; Save integer,HL = adj' token
1E4F: C35A1E  	        jp      GOFUNC          ; Jump to string function
              	
1E52: CD011E  	FNVAL:  call    EVLPAR          ; Evaluate expression
1E55: E3      	        ex      (SP),HL         ; HL = Adjusted token value
1E56: 11151E  	        ld      DE,RETNUM       ; Return number from function
1E59: D5      	        push    DE              ; Save on stack
1E5A: 013A0F  	GOFUNC: ld      BC,FNCTAB       ; Function routine addresses
1E5D: 09      	        add     HL,BC           ; Point to right address
1E5E: 4E      	        ld      C,(HL)          ; Get LSB of address
1E5F: 23      	        inc     HL              ;
1E60: 66      	        ld      H,(HL)          ; Get MSB of address
1E61: 69      	        ld      L,C             ; Address to HL
1E62: E9      	        jp      (HL)            ; Jump to function
              	
1E63: 15      	SGNEXP: dec     D               ; Dee to flag negative exponent
1E64: FEB8    	        cp      ZMINUS          ; '-' token ?
1E66: C8      	        ret     Z               ; Yes - Return
1E67: FE2D    	        cp      '-'             ; '-' ASCII ?
1E69: C8      	        ret     Z               ; Yes - Return
1E6A: 14      	        inc     D               ; Inc to flag positive exponent
1E6B: FE2B    	        cp      '+'             ; '+' ASCII ?
1E6D: C8      	        ret     Z               ; Yes - Return
1E6E: FEB7    	        cp      ZPLUS           ; '+' token ?
1E70: C8      	        ret     Z               ; Yes - Return
1E71: 2B      	        dec     HL              ; dec 'cos GETCHR INCs
1E72: C9      	        ret                     ; Return "NZ"
              	
              	; execute OR, AND, and XOR operations
1E73: AF      	PAND:   xor     A               ; for AND, Z=1
1E74: 1807    	        jr      CNTLGC          
1E76: AF      	POR     xor     A               ; for OR, Z=0, S=1
1E77: D601    	        sub     $01
1E79: 1802    	        jr      CNTLGC
1E7B: AF      	PXOR:   xor     A               ; for XOR, Z=0, S=0
1E7C: 3C      	        inc     A
1E7D: F5      	CNTLGC: push    AF              ; store operand's flags
1E7E: CD2D1D  	        call    TSTNUM          ; Make sure it's a number
1E81: CD7319  	        call    DEINT           ; Get integer -32768 to 32767
1E84: F1      	        pop     AF              ; retrieve operand's flags
1E85: EB      	        ex      DE,HL           ; <- Get last
1E86: C1      	        pop     BC              ; <-  value
1E87: E3      	        ex      (SP),HL         ; <-  from
1E88: EB      	        ex      DE,HL           ; <-  stack
1E89: CDA629  	        call    FPBCDE          ; Move last value to FPREG
1E8C: F5      	        push    AF              ; store operand's flags
1E8D: CD7319  	        call    DEINT           ; Get integer -32768 to 32767
1E90: F1      	        pop     AF              ; retrieve operand's flags
1E91: C1      	        pop     BC              ; Get value
1E92: 79      	        ld      A,C             ; Get LSB
1E93: 210A21  	        ld      HL,ACPASS       ; Address of save AC as current
1E96: 2005    	        jr      NZ,POR1         ; if X/OR, jump over
1E98: A3      	PAND1:  and     E               ; "AND" LSBs
1E99: 4F      	        ld      C,A             ; Save LSB
1E9A: 78      	        ld      A,B             ; Get MSB
1E9B: A2      	        and     D               ; "AND" MSBs
1E9C: E9      	        jp      (HL)            ; Save AC as current (ACPASS)
1E9D: F2A51E  	POR1:   jp      P,PXOR1         ; if S=0, jump to XOR
1EA0: B3      	        or      E               ; "OR" LSBs
1EA1: 4F      	        ld      C,A             ; Save LSB
1EA2: 78      	        ld      A,B             ; Get MSB
1EA3: B2      	        or      D               ; "OR" MSBs
1EA4: E9      	        jp      (HL)            ; Save AC as current (ACPASS)
1EA5: AB      	PXOR1:  xor     E               ; "XOR" LSBs
1EA6: 4F      	        ld      C,A             ; Save LSB
1EA7: 78      	        ld      A,B             ; Get MSB
1EA8: AA      	        xor     D               ; "XOR" MSBs
1EA9: E9      	        jp      (HL)            ; Save AC as current (ACPASS) 
              	
1EAA: 21BC1E  	TSTRED: ld      HL,CMPLOG       ; Logical compare routine
1EAD: 3A0D81  	        ld      A,(TYPE)        ; Get data type
1EB0: 1F      	        rra                     ; Carry set = string
1EB1: 7A      	        ld      A,D             ; Get last precedence value
1EB2: 17      	        rla                     ; Times 2 plus carry
1EB3: 5F      	        ld      E,A             ; To E
1EB4: 1664    	        ld      D,$64           ; Relational precedence
1EB6: 78      	        ld      A,B             ; Get current precedence
1EB7: BA      	        cp      D               ; Compare with last
1EB8: D0      	        ret     NC              ; Eval if last was rel' or log'
1EB9: C39C1D  	        jp      STKTHS          ; Stack this one and get next
              	
1EBC: BE1E    	CMPLOG: defw    CMPLG1          ; Compare two values / strings
1EBE: 79      	CMPLG1: ld      A,C             ; Get data type
1EBF: B7      	        or      A
1EC0: 1F      	        rra
1EC1: C1      	        pop     BC              ; Get last expression to BCDE
1EC2: D1      	        pop     DE
1EC3: F5      	        push    AF              ; Save status
1EC4: CD2F1D  	        call    CHKTYP          ; Check that types match
1EC7: 21001F  	        ld      HL,CMPRES       ; Result to comparison
1ECA: E5      	        push    HL              ; Save for RETurn
1ECB: CAE029  	        jp      Z,CMPNUM        ; Compare values if numeric
1ECE: AF      	        xor     A               ; Compare two strings
1ECF: 320D81  	        ld      (TYPE),A        ; Set type to numeric
1ED2: D5      	        push    DE              ; Save string name
1ED3: CD6C23  	        call    GSTRCU          ; Get current string
1ED6: 7E      	        ld      A,(HL)          ; Get length of string
1ED7: 23      	        inc     HL
1ED8: 23      	        inc     HL
1ED9: 4E      	        ld      C,(HL)          ; Get LSB of address
1EDA: 23      	        inc     HL
1EDB: 46      	        ld      B,(HL)          ; Get MSB of address
1EDC: D1      	        pop     DE              ; Restore string name
1EDD: C5      	        push    BC              ; Save address of string
1EDE: F5      	        push    AF              ; Save length of string
1EDF: CD7023  	        call    GSTRDE          ; Get second string
1EE2: CDB429  	        call    LOADFP          ; Get address of second string
1EE5: F1      	        pop     AF              ; Restore length of string 1
1EE6: 57      	        ld      D,A             ; Length to D
1EE7: E1      	        pop     HL              ; Restore address of string 1
1EE8: 7B      	CMPSTR: ld      A,E             ; Bytes of string 2 to do
1EE9: B2      	        or      D               ; Bytes of string 1 to do
1EEA: C8      	        ret     Z               ; Exit if all bytes compared
1EEB: 7A      	        ld      A,D             ; Get bytes of string 1 to do
1EEC: D601    	        sub     $01
1EEE: D8      	        ret     C               ; Exit if end of string 1
1EEF: AF      	        xor     A
1EF0: BB      	        cp      E               ; Bytes of string 2 to do
1EF1: 3C      	        inc     A
1EF2: D0      	        ret     NC              ; Exit if end of string 2
1EF3: 15      	        dec     D               ; Count bytes in string 1
1EF4: 1D      	        dec     E               ; Count bytes in string 2
1EF5: 0A      	        ld      A,(BC)          ; Byte in string 2
1EF6: BE      	        cp      (HL)            ; Compare to byte in string 1
1EF7: 23      	        inc     HL              ; Move up string 1
1EF8: 03      	        inc     BC              ; Move up string 2
1EF9: CAE81E  	        jp      Z,CMPSTR        ; Same - Try next bytes
1EFC: 3F      	        ccf                     ; Flag difference (">" or "<")
1EFD: C37029  	        jp      FLGDIF          ; "<" gives -1 , ">" gives +1
              	
1F00: 3C      	CMPRES: inc     A               ; Increment current value
1F01: 8F      	        adc     A,A             ; Double plus carry
1F02: C1      	        pop     BC              ; Get other value
1F03: A0      	        and     B               ; Combine them
1F04: C6FF    	        add     A,-1            ; Carry set if different
1F06: 9F      	        sbc     A,A             ; 00 - Equal , FF - Different
1F07: C37729  	        jp      FLGREL          ; Set current value & continue
              	
1F0A: 165A    	EVNOT:  ld      D,$5A           ; Precedence value for "NOT"
1F0C: CD3F1D  	        call    EVAL1           ; Eval until precedence break
1F0F: CD2D1D  	        call    TSTNUM          ; Make sure it's a number
1F12: CD7319  	        call    DEINT           ; Get integer -32768 - 32767
1F15: 7B      	        ld      A,E             ; Get LSB
1F16: 2F      	        cpl                     ; Invert LSB
1F17: 4F      	        ld      C,A             ; Save "NOT" of LSB
1F18: 7A      	        ld      A,D             ; Get MSB
1F19: 2F      	        cpl                     ; Invert MSB
1F1A: CD0A21  	        call    ACPASS          ; Save AC as current
1F1D: C1      	        pop     BC              ; Clean up stack
1F1E: C34B1D  	        jp      EVAL3           ; Continue evaluation
              	
1F21: 2B      	DIMRET: dec     HL              ; dec 'cos GETCHR INCs
1F22: CDC918  	        call    GETCHR          ; Get next character
1F25: C8      	        ret     Z               ; End of DIM statement
1F26: CDA616  	        call    CHKSYN          ; Make sure ',' follows
1F29: 2C      	        defb    ','
1F2A: 01211F  	DIM:    ld      BC,DIMRET       ; Return to "DIMRET"
1F2D: C5      	        push    BC              ; Save on stack
1F2E: F6      	        defb    $F6             ; Flag "Create" variable
1F2F: AF      	GETVAR: xor     A               ; Find variable address,to DE
1F30: 320C81  	        ld      (LCRFLG),A      ; Set locate / create flag
1F33: 46      	        ld      B,(HL)          ; Get First byte of name
1F34: CD5F19  	GTFNAM: call    CHKLTR          ; See if a letter
1F37: DADB13  	        jp      C,SNERR         ; ?SN Error if not a letter
1F3A: AF      	        xor     A
1F3B: 4F      	        ld      C,A             ; Clear second byte of name
1F3C: 320D81  	        ld      (TYPE),A        ; Set type to numeric
1F3F: CDC918  	        call    GETCHR          ; Get next character
1F42: DA4B1F  	        jp      C,SVNAM2        ; Numeric - Save in name
1F45: CD5F19  	        call    CHKLTR          ; See if a letter
1F48: DA581F  	        jp      C,CHARTY        ; Not a letter - Check type
1F4B: 4F      	SVNAM2: ld      C,A             ; Save second byte of name
1F4C: CDC918  	ENDNAM: call    GETCHR          ; Get next character
1F4F: DA4C1F  	        jp      C,ENDNAM        ; Numeric - Get another
1F52: CD5F19  	        call    CHKLTR          ; See if a letter
1F55: D24C1F  	        jp      NC,ENDNAM       ; Letter - Get another
1F58: D624    	CHARTY: sub     '$'             ; String variable?
1F5A: C2671F  	        jp      NZ,NOTSTR       ; No - Numeric variable
1F5D: 3C      	        inc     A               ; A = 1 (string type)
1F5E: 320D81  	        ld      (TYPE),A        ; Set type to string
1F61: 0F      	        rrca                    ; A = 80H , Flag for string
1F62: 81      	        add     A,C             ; 2nd byte of name has bit 7 on
1F63: 4F      	        ld      C,A             ; Resave second byte on name
1F64: CDC918  	        call    GETCHR          ; Get next character
1F67: 3A2B81  	NOTSTR: ld      A,(FORFLG)      ; Array name needed ?
1F6A: 3D      	        dec     A
1F6B: CA1420  	        jp      Z,ARLDSV        ; Yes - Get array name
1F6E: F2771F  	        jp      P,NSCFOR        ; No array with "FOR" or "FN"
1F71: 7E      	        ld      A,(HL)          ; Get byte again
1F72: D628    	        sub     '('             ; Subscripted variable?
1F74: CAEC1F  	        jp      Z,SBSCPT        ; Yes - Sort out subscript
              	
1F77: AF      	NSCFOR: xor     A               ; Simple variable
1F78: 322B81  	        ld      (FORFLG),A      ; Clear "FOR" flag
1F7B: E5      	        push    HL              ; Save code string address
1F7C: 50      	        ld      D,B             ; DE = Variable name to find
1F7D: 59      	        ld      E,C
1F7E: 2A3E81  	        ld      HL,(FNRGNM)     ; FN argument name
1F81: CDA016  	        call    CPDEHL          ; Is it the FN argument?
1F84: 114081  	        ld      DE,FNARG        ; Point to argument value
1F87: CAA628  	        jp      Z,POPHRT        ; Yes - Return FN argument value
1F8A: 2A3881  	        ld      HL,(VAREND)     ; End of variables
1F8D: EB      	        ex      DE,HL           ; Address of end of search
1F8E: 2A3681  	        ld      HL,(PROGND)     ; Start of variables address
1F91: CDA016  	FNDVAR: call    CPDEHL          ; End of variable list table?
1F94: CAAA1F  	        jp      Z,CFEVAL        ; Yes - Called from EVAL?
1F97: 79      	        ld      A,C             ; Get second byte of name
1F98: 96      	        sub     (HL)            ; Compare with name in list
1F99: 23      	        inc     HL              ; Move on to first byte
1F9A: C29F1F  	        jp      NZ,FNTHR        ; Different - Find another
1F9D: 78      	        ld      A,B             ; Get first byte of name
1F9E: 96      	        sub     (HL)            ; Compare with name in list
1F9F: 23      	FNTHR:  inc     HL              ; Move on to LSB of value
1FA0: CADE1F  	        jp      Z,RETADR        ; Found - Return address
1FA3: 23      	        inc     HL              ; <- Skip
1FA4: 23      	        inc     HL              ; <- over
1FA5: 23      	        inc     HL              ; <- F.P.
1FA6: 23      	        inc     HL              ; <- value
1FA7: C3911F  	        jp      FNDVAR          ; Keep looking
              	
1FAA: E1      	CFEVAL: pop     HL              ; Restore code string address
1FAB: E3      	        ex      (SP),HL         ; Get return address
1FAC: D5      	        push    DE              ; Save address of variable
1FAD: 111D1E  	        ld      DE,FRMEVL       ; Return address in EVAL
1FB0: CDA016  	        call    CPDEHL          ; Called from EVAL ?
1FB3: D1      	        pop     DE              ; Restore address of variable
1FB4: CAE11F  	        jp      Z,RETNUL        ; Yes - Return null variable
1FB7: E3      	        ex      (SP),HL         ; Put back return
1FB8: E5      	        push    HL              ; Save code string address
1FB9: C5      	        push    BC              ; Save variable name
1FBA: 010600  	        ld      BC,$0006        ; 2 byte name plus 4 byte data
1FBD: 2A3A81  	        ld      HL,(ARREND)     ; End of arrays
1FC0: E5      	        push    HL              ; Save end of arrays
1FC1: 09      	        add     HL,BC           ; Move up 6 bytes
1FC2: C1      	        pop     BC              ; Source address in BC
1FC3: E5      	        push    HL              ; Save new end address
1FC4: CDA713  	        call    MOVUP           ; Move arrays up
1FC7: E1      	        pop     HL              ; Restore new end address
1FC8: 223A81  	        ld      (ARREND),HL     ; Set new end address
1FCB: 60      	        ld      H,B             ; End of variables to HL
1FCC: 69      	        ld      L,C
1FCD: 223881  	        ld      (VAREND),HL     ; Set new end address
              	
1FD0: 2B      	ZEROLP: dec     HL              ; Back through to zero variable
1FD1: 3600    	        ld      (HL),$00        ; Zero byte in variable
1FD3: CDA016  	        call    CPDEHL          ; Done them all?
1FD6: C2D01F  	        jp      NZ,ZEROLP       ; No - Keep on going
1FD9: D1      	        pop     DE              ; Get variable name
1FDA: 73      	        ld      (HL),E          ; Store second character
1FDB: 23      	        inc     HL
1FDC: 72      	        ld      (HL),D          ; Store first character
1FDD: 23      	        inc     HL
1FDE: EB      	RETADR: ex      DE,HL           ; Address of variable in DE
1FDF: E1      	        pop     HL              ; Restore code string address
1FE0: C9      	        ret
              	
1FE1: 324781  	RETNUL: ld      (FPEXP),A       ; Set result to zero
1FE4: 217813  	        ld      HL,ZERBYT       ; Also set a null string
1FE7: 224481  	        ld      (FPREG),HL      ; Save for EVAL
1FEA: E1      	        pop     HL              ; Restore code string address
1FEB: C9      	        ret
              	
1FEC: E5      	SBSCPT: push    HL              ; Save code string address
1FED: 2A0C81  	        ld      HL,(LCRFLG)     ; Locate/Create and Type
1FF0: E3      	        ex      (SP),HL         ; Save and get code string
1FF1: 57      	        ld      D,A             ; Zero number of dimensions
1FF2: D5      	SCPTLP: push    DE              ; Save number of dimensions
1FF3: C5      	        push    BC              ; Save array name
1FF4: CD6719  	        call    FPSINT          ; Get subscript (0-32767)
1FF7: C1      	        pop     BC              ; Restore array name
1FF8: F1      	        pop     AF              ; Get number of dimensions
1FF9: EB      	        ex      DE,HL
1FFA: E3      	        ex      (SP),HL         ; Save subscript value
1FFB: E5      	        push    HL              ; Save LCRFLG and TYPE
1FFC: EB      	        ex      DE,HL
1FFD: 3C      	        inc     A               ; Count dimensions
1FFE: 57      	        ld      D,A             ; Save in D
1FFF: 7E      	        ld      A,(HL)          ; Get next byte in code string
2000: FE2C    	        cp      ','             ; Comma (more to come)?
2002: CAF21F  	        jp      Z,SCPTLP        ; Yes - More subscripts
2005: CDA616  	        call    CHKSYN          ; Make sure ")" follows
2008: 29      	        defb    ')'
2009: 223081  	        ld      (NXTOPR),HL     ; Save code string address
200C: E1      	        pop     HL              ; Get LCRFLG and TYPE
200D: 220C81  	        ld      (LCRFLG),HL     ; Restore Locate/create & type
2010: 1E00    	        ld      E,$00           ; Flag not CSAVE* or CLOAD*
2012: D5      	        push    DE              ; Save number of dimensions (D)
2013: 11      	        defb    $11             ; Skip "push HL" and "push AF'
              	
2014: E5      	ARLDSV: push    HL              ; Save code string address
2015: F5      	        push    AF              ; A = 00 , Flags set = Z,N
2016: 2A3881  	        ld      HL,(VAREND)     ; Start of arrays
2019: 3E      	        defb    $3E             ; Skip "add HL,DE"
201A: 19      	FNDARY: add     HL,DE           ; Move to next array start
201B: EB      	        ex      DE,HL
201C: 2A3A81  	        ld      HL,(ARREND)     ; End of arrays
201F: EB      	        ex      DE,HL           ; Current array pointer
2020: CDA016  	        call    CPDEHL          ; End of arrays found?
2023: CA4C20  	        jp      Z,CREARY        ; Yes - Create array
2026: 7E      	        ld      A,(HL)          ; Get second byte of name
2027: B9      	        cp      C               ; Compare with name given
2028: 23      	        inc     HL              ; Move on
2029: C22E20  	        jp      NZ,NXTARY       ; Different - Find next array
202C: 7E      	        ld      A,(HL)          ; Get first byte of name
202D: B8      	        cp      B               ; Compare with name given
202E: 23      	NXTARY: inc     HL              ; Move on
202F: 5E      	        ld      E,(HL)          ; Get LSB of next array address
2030: 23      	        inc     HL
2031: 56      	        ld      D,(HL)          ; Get MSB of next array address
2032: 23      	        inc     HL
2033: C21A20  	        jp      NZ,FNDARY       ; Not found - Keep looking
2036: 3A0C81  	        ld      A,(LCRFLG)      ; Found Locate or Create it?
2039: B7      	        or      A
203A: C2E413  	        jp      NZ,DDERR        ; Create - ?DD Error
203D: F1      	        pop     AF              ; Locate - Get number of dim'ns
203E: 44      	        ld      B,H             ; BC Points to array dim'ns
203F: 4D      	        ld      C,L
2040: CAA628  	        jp      Z,POPHRT        ; Jump if array load/save
2043: 96      	        sub     (HL)            ; Same number of dimensions?
2044: CAAA20  	        jp      Z,FINDEL        ; Yes - Find element
2047: 1E10    	BSERR:  ld      E,BS            ; ?BS Error
2049: C3EF13  	        jp      ERROR           ; Output error
              	
204C: 110400  	CREARY: ld      DE,$0004        ; 4 Bytes per entry
204F: F1      	        pop     AF              ; Array to save or 0 dim'ns?
2050: CA8819  	        jp      Z,FCERR         ; Yes - ?FC Error
2053: 71      	        ld      (HL),C          ; Save second byte of name
2054: 23      	        inc     HL
2055: 70      	        ld      (HL),B          ; Save first byte of name
2056: 23      	        inc     HL
2057: 4F      	        ld      C,A             ; Number of dimensions to C
2058: CDB813  	        call    CHKSTK          ; Check if enough memory
205B: 23      	        inc     HL              ; Point to number of dimensions
205C: 23      	        inc     HL
205D: 222581  	        ld      (CUROPR),HL     ; Save address of pointer
2060: 71      	        ld      (HL),C          ; Set number of dimensions
2061: 23      	        inc     HL
2062: 3A0C81  	        ld      A,(LCRFLG)      ; Locate of Create?
2065: 17      	        rla                     ; Carry set = Create
2066: 79      	        ld      A,C             ; Get number of dimensions
2067: 010B00  	CRARLP: ld      BC,10+1         ; Default dimension size 10
206A: D26F20  	        jp      NC,DEFSIZ       ; Locate - Set default size
206D: C1      	        pop     BC              ; Get specified dimension size
206E: 03      	        inc     BC              ; Include zero element
206F: 71      	DEFSIZ: ld      (HL),C          ; Save LSB of dimension size
2070: 23      	        inc     HL
2071: 70      	        ld      (HL),B          ; Save MSB of dimension size
2072: 23      	        inc     HL
2073: F5      	        push    AF              ; Save num' of dim'ns an status
2074: E5      	        push    HL              ; Save address of dim'n size
2075: CD512A  	        call    MLDEBC          ; Multiply DE by BC to find
2078: EB      	        ex      DE,HL           ; amount of mem needed (to DE)
2079: E1      	        pop     HL              ; Restore address of dimension
207A: F1      	        pop     AF              ; Restore number of dimensions
207B: 3D      	        dec     A               ; Count them
207C: C26720  	        jp      NZ,CRARLP       ; Do next dimension if more
207F: F5      	        push    AF              ; Save locate/create flag
2080: 42      	        ld      B,D             ; MSB of memory needed
2081: 4B      	        ld      C,E             ; LSB of memory needed
2082: EB      	        ex      DE,HL
2083: 19      	        add     HL,DE           ; Add bytes to array start
2084: DAD013  	        jp      C,OMERR         ; Too big - Error
2087: CDC113  	        call    ENFMEM          ; See if enough memory
208A: 223A81  	        ld      (ARREND),HL     ; Save new end of array
              	
208D: 2B      	ZERARY: dec     HL              ; Back through array data
208E: 3600    	        ld      (HL),$00        ; Set array element to zero
2090: CDA016  	        call    CPDEHL          ; All elements zeroed?
2093: C28D20  	        jp      NZ,ZERARY       ; No - Keep on going
2096: 03      	        inc     BC              ; Number of bytes + 1
2097: 57      	        ld      D,A             ; A=0
2098: 2A2581  	        ld      HL,(CUROPR)     ; Get address of array
209B: 5E      	        ld      E,(HL)          ; Number of dimensions
209C: EB      	        ex      DE,HL           ; To HL
209D: 29      	        add     HL,HL           ; Two bytes per dimension size
209E: 09      	        add     HL,BC           ; Add number of bytes
209F: EB      	        ex      DE,HL           ; Bytes needed to DE
20A0: 2B      	        dec     HL
20A1: 2B      	        dec     HL
20A2: 73      	        ld      (HL),E          ; Save LSB of bytes needed
20A3: 23      	        inc     HL
20A4: 72      	        ld      (HL),D          ; Save MSB of bytes needed
20A5: 23      	        inc     HL
20A6: F1      	        pop     AF              ; Locate / Create?
20A7: DACE20  	        jp      C,ENDDIM        ; A is 0 , End if create
20AA: 47      	FINDEL: ld      B,A             ; Find array element
20AB: 4F      	        ld      C,A
20AC: 7E      	        ld      A,(HL)          ; Number of dimensions
20AD: 23      	        inc     HL
20AE: 16      	        defb    $16             ; Skip "pop HL"
20AF: E1      	FNDELP: pop     HL              ; Address of next dim' size
20B0: 5E      	        ld      E,(HL)          ; Get LSB of dim'n size
20B1: 23      	        inc     HL
20B2: 56      	        ld      D,(HL)          ; Get MSB of dim'n size
20B3: 23      	        inc     HL
20B4: E3      	        ex      (SP),HL         ; Save address - Get index
20B5: F5      	        push    AF              ; Save number of dim'ns
20B6: CDA016  	        call    CPDEHL          ; Dimension too large?
20B9: D24720  	        jp      NC,BSERR        ; Yes - ?BS Error
20BC: E5      	        push    HL              ; Save index
20BD: CD512A  	        call    MLDEBC          ; Multiply previous by size
20C0: D1      	        pop     DE              ; Index supplied to DE
20C1: 19      	        add     HL,DE           ; Add index to pointer
20C2: F1      	        pop     AF              ; Number of dimensions
20C3: 3D      	        dec     A               ; Count them
20C4: 44      	        ld      B,H             ; MSB of pointer
20C5: 4D      	        ld      C,L             ; LSB of pointer
20C6: C2AF20  	        jp      NZ,FNDELP       ; More - Keep going
20C9: 29      	        add     HL,HL           ; 4 Bytes per element
20CA: 29      	        add     HL,HL
20CB: C1      	        pop     BC              ; Start of array
20CC: 09      	        add     HL,BC           ; Point to element
20CD: EB      	        ex      DE,HL           ; Address of element to DE
20CE: 2A3081  	ENDDIM: ld      HL,(NXTOPR)     ; Got code string address
20D1: C9      	        ret
              	
20D2: CD2D1D  	TMR:    call    TSTNUM          ; Make sure it's a number
20D5: CD7319  	        call    DEINT           ; Get integer -32768 to 32767
20D8: F3      	        di                      ; we must work with INTs disabled
20D9: 214981  	        ld      HL,TMRCNT       ; load the address of the first byte of the counter
20DC: 7B      	        ld      A,E             ; move param into A
20DD: A7      	        and     A               ; is it 0?
20DE: 2802    	        jr      Z,LSBTMR        ; print the 2 LSBytes of timer
20E0: 23      	        inc     HL              ; else print the 2 MSBytes of timer
20E1: 23      	        inc     HL
20E2: 46      	LSBTMR: ld      B,(HL)          ; Get LSB of contents
20E3: 23      	        inc     HL
20E4: 7E      	        ld      A,(HL)          ; Get MSB of contents
20E5: FB      	        ei                      ; re-enable INTs
20E6: C30B21  	        jp      ABPASS          ;return word into AB
              	
20E9: 2A3A81  	FRE:    ld      HL,(ARREND)     ; Start of free memory
20EC: EB      	        ex      DE,HL           ; To DE
20ED: 210000  	        ld      HL,$0000        ; End of free memory
20F0: 39      	        add     HL,SP           ; Current stack value
20F1: 3A0D81  	        ld      A,(TYPE)        ; Dummy argument type
20F4: B7      	        or      A
20F5: CA0521  	        jp      Z,FRENUM        ; Numeric - Free variable space
20F8: CD6C23  	        call    GSTRCU          ; Current string to pool
20FB: CD6C22  	        call    GARBGE          ; Garbage collection
20FE: 2AAA80  	        ld      HL,(STRSPC)     ; Bottom of string space in use
2101: EB      	        ex      DE,HL           ; To DE
2102: 2A2381  	        ld      HL,(STRBOT)     ; Bottom of string space
2105: 7D      	FRENUM: ld      A,L             ; Get LSB of end
2106: 93      	        sub     E               ; Subtract LSB of beginning
2107: 4F      	        ld      C,A             ; Save difference if C
2108: 7C      	        ld      A,H             ; Get MSB of end
2109: 9A      	        sbc     A,D             ; Subtract MSB of beginning
210A: 41      	ACPASS: ld      B,C             ; Return integer AC
210B: 50      	ABPASS: ld      D,B             ; Return integer AB
210C: 1E00    	        ld      E,$00
210E: 210D81  	        ld      HL,TYPE         ; Point to type
2111: 73      	        ld      (HL),E          ; Set type to numeric
2112: 0690    	        ld      B,$80+$10       ; 16 bit integer
2114: C37C29  	        jp      RETINT          ; Return the integr
              	
              	; returns the X position of the cursor during a print
2117: 3A0B81  	POS:    ld      A,(CURPOS)      ; Get cursor position
211A: 47      	PASSA:  ld      B,A             ; Put A into AB
211B: AF      	        xor     A               ; Zero A
211C: C30B21  	        jp      ABPASS          ; Return integer AB
              	
211F: CDA221  	DEF:    call    CHEKFN          ; Get "FN" and name
2122: CD9421  	        call    IDTEST          ; Test for illegal direct
2125: 01581A  	        ld      BC,DATA         ; To get next statement
2128: C5      	        push    BC              ; Save address for RETurn
2129: D5      	        push    DE              ; Save address of function ptr
212A: CDA616  	        call    CHKSYN          ; Make sure "(" follows
212D: 28      	        defb    '('
212E: CD2F1F  	        call    GETVAR          ; Get argument variable name
2131: E5      	        push    HL              ; Save code string address
2132: EB      	        ex      DE,HL           ; Argument address to HL
2133: 2B      	        dec     HL
2134: 56      	        ld      D,(HL)          ; Get first byte of arg name
2135: 2B      	        dec     HL
2136: 5E      	        ld      E,(HL)          ; Get second byte of arg name
2137: E1      	        pop     HL              ; Restore code string address
2138: CD2D1D  	        call    TSTNUM          ; Make sure numeric argument
213B: CDA616  	        call    CHKSYN          ; Make sure ")" follows
213E: 29      	        defb    ')'
213F: CDA616  	        call    CHKSYN          ; Make sure "=" follows
2142: C0      	        defb    ZEQUAL          ; "=" token
2143: 44      	        ld      B,H             ; Code string address to BC
2144: 4D      	        ld      C,L
2145: E3      	        ex      (SP),HL         ; Save code str , Get FN ptr
2146: 71      	        ld      (HL),C          ; Save LSB of FN code string
2147: 23      	        inc     HL
2148: 70      	        ld      (HL),B          ; Save MSB of FN code string
2149: C3E121  	        jp      SVSTAD          ; Save address and do function
              	
214C: CDA221  	DOFN:   call    CHEKFN          ; Make sure FN follows
214F: D5      	        push    DE              ; Save function pointer address
2150: CD011E  	        call    EVLPAR          ; Evaluate expression in "()"
2153: CD2D1D  	        call    TSTNUM          ; Make sure numeric result
2156: E3      	        ex      (SP),HL         ; Save code str , Get FN ptr
2157: 5E      	        ld      E,(HL)          ; Get LSB of FN code string
2158: 23      	        inc     HL
2159: 56      	        ld      D,(HL)          ; Get MSB of FN code string
215A: 23      	        inc     HL
215B: 7A      	        ld      A,D             ; And function DEFined?
215C: B3      	        or      E
215D: CAE713  	        jp      Z,UFERR         ; No - ?UF Error
2160: 7E      	        ld      A,(HL)          ; Get LSB of argument address
2161: 23      	        inc     HL
2162: 66      	        ld      H,(HL)          ; Get MSB of argument address
2163: 6F      	        ld      L,A             ; HL = Arg variable address
2164: E5      	        push    HL              ; Save it
2165: 2A3E81  	        ld      HL,(FNRGNM)     ; Get old argument name
2168: E3      	        ex      (SP),HL         ; Save old , Get new
2169: 223E81  	        ld      (FNRGNM),HL     ; Set new argument name
216C: 2A4281  	        ld      HL,(FNARG+2)    ; Get LSB,NLSB of old arg value
216F: E5      	        push    HL              ; Save it
2170: 2A4081  	        ld      HL,(FNARG)      ; Get MSB,EXP of old arg value
2173: E5      	        push    HL              ; Save it
2174: 214081  	        ld      HL,FNARG        ; HL = Value of argument
2177: D5      	        push    DE              ; Save FN code string address
2178: CDBD29  	        call    FPTHL           ; Move FPREG to argument
217B: E1      	        pop     HL              ; Get FN code string address
217C: CD2A1D  	        call    GETNUM          ; Get value from function
217F: 2B      	        dec     HL              ; dec 'cos GETCHR INCs
2180: CDC918  	        call    GETCHR          ; Get next character
2183: C2DB13  	        jp      NZ,SNERR        ; Bad character in FN - Error
2186: E1      	        pop     HL              ; Get MSB,EXP of old arg
2187: 224081  	        ld      (FNARG),HL      ; Restore it
218A: E1      	        pop     HL              ; Get LSB,NLSB of old arg
218B: 224281  	        ld      (FNARG+2),HL    ; Restore it
218E: E1      	        pop     HL              ; Get name of old arg
218F: 223E81  	        ld      (FNRGNM),HL     ; Restore it
2192: E1      	        pop     HL              ; Restore code string address
2193: C9      	        ret
              	
2194: E5      	IDTEST: push    HL              ; Save code string address
2195: 2AAC80  	        ld      HL,(LINEAT)     ; Get current line number
2198: 23      	        inc     HL              ; -1 means direct statement
2199: 7C      	        ld      A,H
219A: B5      	        or      L
219B: E1      	        pop     HL              ; Restore code string address
219C: C0      	        ret     NZ              ; Return if in program
219D: 1E16    	        ld      E,ID            ; ?ID Error
219F: C3EF13  	        jp      ERROR
              	
21A2: CDA616  	CHEKFN: call    CHKSYN          ; Make sure FN follows
21A5: B2      	        defb    ZFN             ; "FN" token
21A6: 3E80    	        ld      A,$80
21A8: 322B81  	        ld      (FORFLG),A      ; Flag FN name to find
21AB: B6      	        or      (HL)            ; FN name has bit 7 set
21AC: 47      	        ld      B,A             ; in first byte of name
21AD: CD341F  	        call    GTFNAM          ; Get FN name
21B0: C32D1D  	        jp      TSTNUM          ; Make sure numeric function
              	
21B3: CD2D1D  	STR:    call    TSTNUM          ; Make sure it's a number
21B6: CD0A2B  	        call    NUMASC          ; Turn number into text
21B9: CDE721  	STR1:   call    CRTST           ; Create string entry for it
21BC: CD6C23  	        call    GSTRCU          ; Current string to pool
21BF: 01C723  	        ld      BC,TOPOOL       ; Save in string pool
21C2: C5      	        push    BC              ; Save address on stack
              	
21C3: 7E      	SAVSTR: ld      A,(HL)          ; Get string length
21C4: 23      	        inc     HL
21C5: 23      	        inc     HL
21C6: E5      	        push    HL              ; Save pointer to string
21C7: CD4222  	        call    TESTR           ; See if enough string space
21CA: E1      	        pop     HL              ; Restore pointer to string
21CB: 4E      	        ld      C,(HL)          ; Get LSB of address
21CC: 23      	        inc     HL
21CD: 46      	        ld      B,(HL)          ; Get MSB of address
21CE: CDDB21  	        call    CRTMST          ; Create string entry
21D1: E5      	        push    HL              ; Save pointer to MSB of addr
21D2: 6F      	        ld      L,A             ; Length of string
21D3: CD5F23  	        call    TOSTRA          ; Move to string area
21D6: D1      	        pop     DE              ; Restore pointer to MSB
21D7: C9      	        ret
              	
21D8: CD4222  	MKTMST: call    TESTR           ; See if enough string space
21DB: 211F81  	CRTMST: ld      HL,TMPSTR       ; Temporary string
21DE: E5      	        push    HL              ; Save it
21DF: 77      	        ld      (HL),A          ; Save length of string
21E0: 23      	        inc     HL
21E1: 23      	SVSTAD: inc     HL
21E2: 73      	        ld      (HL),E          ; Save LSB of address
21E3: 23      	        inc     HL
21E4: 72      	        ld      (HL),D          ; Save MSB of address
21E5: E1      	        pop     HL              ; Restore pointer
21E6: C9      	        ret
              	
21E7: 2B      	CRTST:  dec     HL              ; dec - INCed after
21E8: 0622    	QTSTR:  ld      B,$22           ; '"'           ; Terminating quote
21EA: 50      	        ld      D,B             ; Quote to D
21EB: E5      	DTSTR:  push    HL              ; Save start
21EC: 0EFF    	        ld      C,-1            ; Set counter to -1
21EE: 23      	QTSTLP: inc     HL              ; Move on
21EF: 7E      	        ld      A,(HL)          ; Get byte
21F0: 0C      	        inc     C               ; Count bytes
21F1: B7      	        or      A               ; End of line?
21F2: CAFD21  	        jp      Z,CRTSTE        ; Yes - Create string entry
21F5: BA      	        cp      D               ; Terminator D found?
21F6: CAFD21  	        jp      Z,CRTSTE        ; Yes - Create string entry
21F9: B8      	        cp      B               ; Terminator B found?
21FA: C2EE21  	        jp      NZ,QTSTLP       ; No - Keep looking
21FD: FE22    	CRTSTE: cp      $22             ; '"'             ; End with '"'?
21FF: CCC918  	        call    Z,GETCHR        ; Yes - Get next character
2202: E3      	        ex      (SP),HL         ; Starting quote
2203: 23      	        inc     HL              ; First byte of string
2204: EB      	        ex      DE,HL           ; To DE
2205: 79      	        ld      A,C             ; Get length
2206: CDDB21  	        call    CRTMST          ; Create string entry
2209: 111F81  	TSTOPL: ld      DE,TMPSTR       ; Temporary string
220C: 2A1181  	        ld      HL,(TMSTPT)     ; Temporary string pool pointer
220F: 224481  	        ld      (FPREG),HL      ; Save address of string ptr
2212: 3E01    	        ld      A,$01
2214: 320D81  	        ld      (TYPE),A        ; Set type to string
2217: CDC029  	        call    DETHL4          ; Move string to pool
221A: CDA016  	        call    CPDEHL          ; Out of string pool?
221D: 221181  	        ld      (TMSTPT),HL     ; Save new pointer
2220: E1      	        pop     HL              ; Restore code string address
2221: 7E      	        ld      A,(HL)          ; Get next code byte
2222: C0      	        ret     NZ              ; Return if pool OK
2223: 1E1E    	        ld      E,ST            ; ?ST Error
2225: C3EF13  	        jp      ERROR           ; String pool overflow
              	
2228: 23      	PRNUMS: inc     HL              ; Skip leading space
2229: CDE721  	PRS:    call    CRTST           ; Create string entry for it
222C: CD6C23  	PRS1:   call    GSTRCU          ; Current string to pool
222F: CDB429  	        call    LOADFP          ; Move string block to BCDE
2232: 1C      	        inc     E               ; Length + 1
2233: 1D      	PRSLP:  dec     E               ; Count characters
2234: C8      	        ret     Z               ; End of string
2235: 0A      	        ld      A,(BC)          ; Get byte to output
2236: CDB116  	        call    OUTC            ; Output character in A
2239: FE0D    	        cp      CR              ; Return?
223B: CC781B  	        call    Z,CNTEND        ; Yes - Position cursor to 0
223E: 03      	        inc     BC              ; Next byte in string
223F: C33322  	        jp      PRSLP           ; More characters to output
              	
2242: B7      	TESTR:  or      A               ; Test if enough room
2243: 0E      	        defb    $0E             ; No garbage collection done
2244: F1      	GRBDON: pop     AF              ; Garbage collection done
2245: F5      	        push    AF              ; Save status
2246: 2AAA80  	        ld      HL,(STRSPC)     ; Bottom of string space in use
2249: EB      	        ex      DE,HL           ; To DE
224A: 2A2381  	        ld      HL,(STRBOT)     ; Bottom of string area
224D: 2F      	        cpl                     ; Negate length (Top down)
224E: 4F      	        ld      C,A             ; -Length to BC
224F: 06FF    	        ld      B,-1            ; BC = -ve length of string
2251: 09      	        add     HL,BC           ; Add to bottom of space in use
2252: 23      	        inc     HL              ; Plus one for 2's complement
2253: CDA016  	        call    CPDEHL          ; Below string RAM area?
2256: DA6022  	        jp      C,TESTOS        ; Tidy up if not done else err
2259: 222381  	        ld      (STRBOT),HL     ; Save new bottom of area
225C: 23      	        inc     HL              ; Point to first byte of string
225D: EB      	        ex      DE,HL           ; Address to DE
225E: F1      	POPAF:  pop     AF              ; Throw away status push
225F: C9      	        ret
              	
2260: F1      	TESTOS: pop     AF              ; Garbage collect been done?
2261: 1E1A    	        ld      E,OS            ; ?OS Error
2263: CAEF13  	        jp      Z,ERROR         ; Yes - Not enough string apace
2266: BF      	        cp      A               ; Flag garbage collect done
2267: F5      	        push    AF              ; Save status
2268: 014422  	        ld      BC,GRBDON       ; Garbage collection done
226B: C5      	        push    BC              ; Save for RETurn
226C: 2A0F81  	GARBGE: ld      HL,(LSTRAM)     ; Get end of RAM pointer
226F: 222381  	GARBLP: ld      (STRBOT),HL     ; Reset string pointer
2272: 210000  	        ld      HL,$0000
2275: E5      	        push    HL              ; Flag no string found
2276: 2AAA80  	        ld      HL,(STRSPC)     ; Get bottom of string space
2279: E5      	        push    HL              ; Save bottom of string space
227A: 211381  	        ld      HL,TMSTPL       ; Temporary string pool
227D: EB      	GRBLP:  ex      DE,HL
227E: 2A1181  	        ld      HL,(TMSTPT)     ; Temporary string pool pointer
2281: EB      	        ex      DE,HL
2282: CDA016  	        call    CPDEHL          ; Temporary string pool done?
2285: 017D22  	        ld      BC,GRBLP        ; Loop until string pool done
2288: C2D122  	        jp      NZ,STPOOL       ; No - See if in string area
228B: 2A3681  	        ld      HL,(PROGND)     ; Start of simple variables
228E: EB      	SMPVAR: ex      DE,HL
228F: 2A3881  	        ld      HL,(VAREND)     ; End of simple variables
2292: EB      	        ex      DE,HL
2293: CDA016  	        call    CPDEHL          ; All simple strings done?
2296: CAA422  	        jp      Z,ARRLP         ; Yes - Do string arrays
2299: 7E      	        ld      A,(HL)          ; Get type of variable
229A: 23      	        inc     HL
229B: 23      	        inc     HL
229C: B7      	        or      A               ; "S" flag set if string
229D: CDD422  	        call    STRADD          ; See if string in string area
22A0: C38E22  	        jp      SMPVAR          ; Loop until simple ones done
              	
22A3: C1      	GNXARY: pop     BC              ; Scrap address of this array
22A4: EB      	ARRLP:  ex      DE,HL
22A5: 2A3A81  	        ld      HL,(ARREND)     ; End of string arrays
22A8: EB      	        ex      DE,HL
22A9: CDA016  	        call    CPDEHL          ; All string arrays done?
22AC: CAFA22  	        jp      Z,SCNEND        ; Yes - Move string if found
22AF: CDB429  	        call    LOADFP          ; Get array name to BCDE
22B2: 7B      	        ld      A,E             ; Get type of array
22B3: E5      	        push    HL              ; Save address of num of dim'ns
22B4: 09      	        add     HL,BC           ; Start of next array
22B5: B7      	        or      A               ; Test type of array
22B6: F2A322  	        jp      P,GNXARY        ; Numeric array - Ignore it
22B9: 222581  	        ld      (CUROPR),HL     ; Save address of next array
22BC: E1      	        pop     HL              ; Get address of num of dim'ns
22BD: 4E      	        ld      C,(HL)          ; BC = Number of dimensions
22BE: 0600    	        ld      B,$00
22C0: 09      	        add     HL,BC           ; Two bytes per dimension size
22C1: 09      	        add     HL,BC
22C2: 23      	        inc     HL              ; Plus one for number of dim'ns
22C3: EB      	GRBARY: ex      DE,HL
22C4: 2A2581  	        ld      HL,(CUROPR)     ; Get address of next array
22C7: EB      	        ex      DE,HL
22C8: CDA016  	        call    CPDEHL          ; Is this array finished?
22CB: CAA422  	        jp      Z,ARRLP         ; Yes - Get next one
22CE: 01C322  	        ld      BC,GRBARY       ; Loop until array all done
22D1: C5      	STPOOL: push    BC              ; Save return address
22D2: F680    	        or      $80             ; Flag string type
22D4: 7E      	STRADD: ld      A,(HL)          ; Get string length
22D5: 23      	        inc     HL
22D6: 23      	        inc     HL
22D7: 5E      	        ld      E,(HL)          ; Get LSB of string address
22D8: 23      	        inc     HL
22D9: 56      	        ld      D,(HL)          ; Get MSB of string address
22DA: 23      	        inc     HL
22DB: F0      	        ret     P               ; Not a string - Return
22DC: B7      	        or      A               ; Set flags on string length
22DD: C8      	        ret     Z               ; Null string - Return
22DE: 44      	        ld      B,H             ; Save variable pointer
22DF: 4D      	        ld      C,L
22E0: 2A2381  	        ld      HL,(STRBOT)     ; Bottom of new area
22E3: CDA016  	        call    CPDEHL          ; String been done?
22E6: 60      	        ld      H,B             ; Restore variable pointer
22E7: 69      	        ld      L,C
22E8: D8      	        ret     C               ; String done - Ignore
22E9: E1      	        pop     HL              ; Return address
22EA: E3      	        ex      (SP),HL         ; Lowest available string area
22EB: CDA016  	        call    CPDEHL          ; String within string area?
22EE: E3      	        ex      (SP),HL         ; Lowest available string area
22EF: E5      	        push    HL              ; Re-save return address
22F0: 60      	        ld      H,B             ; Restore variable pointer
22F1: 69      	        ld      L,C
22F2: D0      	        ret     NC              ; Outside string area - Ignore
22F3: C1      	        pop     BC              ; Get return , Throw 2 away
22F4: F1      	        pop     AF              ;
22F5: F1      	        pop     AF              ;
22F6: E5      	        push    HL              ; Save variable pointer
22F7: D5      	        push    DE              ; Save address of current
22F8: C5      	        push    BC              ; Put back return address
22F9: C9      	        ret                     ; Go to it
              	
22FA: D1      	SCNEND: pop     DE              ; Addresses of strings
22FB: E1      	        pop     HL              ;
22FC: 7D      	        ld      A,L             ; HL = 0 if no more to do
22FD: B4      	        or      H
22FE: C8      	        ret     Z               ; No more to do - Return
22FF: 2B      	        dec     HL
2300: 46      	        ld      B,(HL)          ; MSB of address of string
2301: 2B      	        dec     HL
2302: 4E      	        ld      C,(HL)          ; LSB of address of string
2303: E5      	        push    HL              ; Save variable address
2304: 2B      	        dec     HL
2305: 2B      	        dec     HL
2306: 6E      	        ld      L,(HL)          ; HL = Length of string
2307: 2600    	        ld      H,$00
2309: 09      	        add     HL,BC           ; Address of end of string+1
230A: 50      	        ld      D,B             ; String address to DE
230B: 59      	        ld      E,C
230C: 2B      	        dec     HL              ; Last byte in string
230D: 44      	        ld      B,H             ; Address to BC
230E: 4D      	        ld      C,L
230F: 2A2381  	        ld      HL,(STRBOT)     ; Current bottom of string area
2312: CDAA13  	        call    MOVSTR          ; Move string to new address
2315: E1      	        pop     HL              ; Restore variable address
2316: 71      	        ld      (HL),C          ; Save new LSB of address
2317: 23      	        inc     HL
2318: 70      	        ld      (HL),B          ; Save new MSB of address
2319: 69      	        ld      L,C             ; Next string area+1 to HL
231A: 60      	        ld      H,B
231B: 2B      	        dec     HL              ; Next string area address
231C: C36F22  	        jp      GARBLP          ; Look for more strings
              	
231F: C5      	CONCAT: push    BC              ; Save prec' opr & code string
2320: E5      	        push    HL              ;
2321: 2A4481  	        ld      HL,(FPREG)      ; Get first string
2324: E3      	        ex      (SP),HL         ; Save first string
2325: CDB31D  	        call    OPRND           ; Get second string
2328: E3      	        ex      (SP),HL         ; Restore first string
2329: CD2E1D  	        call    TSTSTR          ; Make sure it's a string
232C: 7E      	        ld      A,(HL)          ; Get length of second string
232D: E5      	        push    HL              ; Save first string
232E: 2A4481  	        ld      HL,(FPREG)      ; Get second string
2331: E5      	        push    HL              ; Save second string
2332: 86      	        add     A,(HL)          ; Add length of second string
2333: 1E1C    	        ld      E,LS            ; ?LS Error
2335: DAEF13  	        jp      C,ERROR         ; String too long - Error
2338: CDD821  	        call    MKTMST          ; Make temporary string
233B: D1      	        pop     DE              ; Get second string to DE
233C: CD7023  	        call    GSTRDE          ; Move to string pool if needed
233F: E3      	        ex      (SP),HL         ; Get first string
2340: CD6F23  	        call    GSTRHL          ; Move to string pool if needed
2343: E5      	        push    HL              ; Save first string
2344: 2A2181  	        ld      HL,(TMPSTR+2)   ; Temporary string address
2347: EB      	        ex      DE,HL           ; To DE
2348: CD5623  	        call    SSTSA           ; First string to string area
234B: CD5623  	        call    SSTSA           ; Second string to string area
234E: 21481D  	        ld      HL,EVAL2        ; Return to evaluation loop
2351: E3      	        ex      (SP),HL         ; Save return,get code string
2352: E5      	        push    HL              ; Save code string address
2353: C30922  	        jp      TSTOPL          ; To temporary string to pool
              	
2356: E1      	SSTSA:  pop     HL              ; Return address
2357: E3      	        ex      (SP),HL         ; Get string block,save return
2358: 7E      	        ld      A,(HL)          ; Get length of string
2359: 23      	        inc     HL
235A: 23      	        inc     HL
235B: 4E      	        ld      C,(HL)          ; Get LSB of string address
235C: 23      	        inc     HL
235D: 46      	        ld      B,(HL)          ; Get MSB of string address
235E: 6F      	        ld      L,A             ; Length to L
235F: 2C      	TOSTRA: inc     L               ; inc - DECed after
2360: 2D      	TSALP:  dec     L               ; Count bytes moved
2361: C8      	        ret     Z               ; End of string - Return
2362: 0A      	        ld      A,(BC)          ; Get source
2363: 12      	        ld      (DE),A          ; Save destination
2364: 03      	        inc     BC              ; Next source
2365: 13      	        inc     DE              ; Next destination
2366: C36023  	        jp      TSALP           ; Loop until string moved
              	
2369: CD2E1D  	GETSTR: call    TSTSTR          ; Make sure it's a string
236C: 2A4481  	GSTRCU: ld      HL,(FPREG)      ; Get current string
236F: EB      	GSTRHL: ex      DE,HL           ; Save DE
2370: CD8A23  	GSTRDE: call    BAKTMP          ; Was it last tmp-str?
2373: EB      	        ex      DE,HL           ; Restore DE
2374: C0      	        ret     NZ              ; No - Return
2375: D5      	        push    DE              ; Save string
2376: 50      	        ld      D,B             ; String block address to DE
2377: 59      	        ld      E,C
2378: 1B      	        dec     DE              ; Point to length
2379: 4E      	        ld      C,(HL)          ; Get string length
237A: 2A2381  	        ld      HL,(STRBOT)     ; Current bottom of string area
237D: CDA016  	        call    CPDEHL          ; Last one in string area?
2380: C28823  	        jp      NZ,POPHL        ; No - Return
2383: 47      	        ld      B,A             ; Clear B (A=0)
2384: 09      	        add     HL,BC           ; Remove string from str' area
2385: 222381  	        ld      (STRBOT),HL     ; Save new bottom of str' area
2388: E1      	POPHL:  pop     HL              ; Restore string
2389: C9      	        ret
              	
238A: 2A1181  	BAKTMP: ld      HL,(TMSTPT)     ; Get temporary string pool top
238D: 2B      	        dec     HL              ; Back
238E: 46      	        ld      B,(HL)          ; Get MSB of address
238F: 2B      	        dec     HL              ; Back
2390: 4E      	        ld      C,(HL)          ; Get LSB of address
2391: 2B      	        dec     HL              ; Back
2392: 2B      	        dec     HL              ; Back
2393: CDA016  	        call    CPDEHL          ; String last in string pool?
2396: C0      	        ret     NZ              ; Yes - Leave it
2397: 221181  	        ld      (TMSTPT),HL     ; Save new string pool top
239A: C9      	        ret
              	
239B: 011A21  	LEN:    ld      BC,PASSA        ; To return integer A
239E: C5      	        push    BC              ; Save address
239F: CD6923  	GETLEN: call    GETSTR          ; Get string and its length
23A2: AF      	        xor     A
23A3: 57      	        ld      D,A             ; Clear D
23A4: 320D81  	        ld      (TYPE),A        ; Set type to numeric
23A7: 7E      	        ld      A,(HL)          ; Get length of string
23A8: B7      	        or      A               ; Set status flags
23A9: C9      	        ret
              	
23AA: 011A21  	ASC:    ld      BC,PASSA        ; To return integer A
23AD: C5      	        push    BC              ; Save address
23AE: CD9F23  	GTFLNM: call    GETLEN          ; Get length of string
23B1: CA8819  	        jp      Z,FCERR         ; Null string - Error
23B4: 23      	        inc     HL
23B5: 23      	        inc     HL
23B6: 5E      	        ld      E,(HL)          ; Get LSB of address
23B7: 23      	        inc     HL
23B8: 56      	        ld      D,(HL)          ; Get MSB of address
23B9: 1A      	        ld      A,(DE)          ; Get first byte of string
23BA: C9      	        ret
              	
23BB: 3E01    	CHR:    ld      A,$01           ; One character string
23BD: CDD821  	        call    MKTMST          ; Make a temporary string
23C0: CDB424  	        call    MAKINT          ; Make it integer A
23C3: 2A2181  	        ld      HL,(TMPSTR+2)   ; Get address of string
23C6: 73      	        ld      (HL),E          ; Save character
23C7: C1      	TOPOOL: pop     BC              ; Clean up stack
23C8: C30922  	        jp      TSTOPL          ; Temporary string to pool
              	
23CB: CD6424  	LEFT:   call    LFRGNM          ; Get number and ending ")"
23CE: AF      	        xor     A               ; Start at first byte in string
23CF: E3      	RIGHT1: ex      (SP),HL         ; Save code string,Get string
23D0: 4F      	        ld      C,A             ; Starting position in string
23D1: E5      	MID1:   push    HL              ; Save string block address
23D2: 7E      	        ld      A,(HL)          ; Get length of string
23D3: B8      	        cp      B               ; Compare with number given
23D4: DAD923  	        jp      C,ALLFOL        ; All following bytes required
23D7: 78      	        ld      A,B             ; Get new length
23D8: 11      	        defb    $11             ; Skip "ld C,0"
23D9: 0E00    	ALLFOL: ld      C,$00           ; First byte of string
23DB: C5      	        push    BC              ; Save position in string
23DC: CD4222  	        call    TESTR           ; See if enough string space
23DF: C1      	        pop     BC              ; Get position in string
23E0: E1      	        pop     HL              ; Restore string block address
23E1: E5      	        push    HL              ; And re-save it
23E2: 23      	        inc     HL
23E3: 23      	        inc     HL
23E4: 46      	        ld      B,(HL)          ; Get LSB of address
23E5: 23      	        inc     HL
23E6: 66      	        ld      H,(HL)          ; Get MSB of address
23E7: 68      	        ld      L,B             ; HL = address of string
23E8: 0600    	        ld      B,$00           ; BC = starting address
23EA: 09      	        add     HL,BC           ; Point to that byte
23EB: 44      	        ld      B,H             ; BC = source string
23EC: 4D      	        ld      C,L
23ED: CDDB21  	        call    CRTMST          ; Create a string entry
23F0: 6F      	        ld      L,A             ; Length of new string
23F1: CD5F23  	        call    TOSTRA          ; Move string to string area
23F4: D1      	        pop     DE              ; Clear stack
23F5: CD7023  	        call    GSTRDE          ; Move to string pool if needed
23F8: C30922  	        jp      TSTOPL          ; Temporary string to pool
              	
23FB: CD6424  	RIGHT:  call    LFRGNM          ; Get number and ending ")"
23FE: D1      	        pop     DE              ; Get string length
23FF: D5      	        push    DE              ; And re-save
2400: 1A      	        ld      A,(DE)          ; Get length
2401: 90      	        sub     B               ; Move back N bytes
2402: C3CF23  	        jp      RIGHT1          ; Go and get sub-string
              	
2405: EB      	MID:    ex      DE,HL           ; Get code string address
2406: 7E      	        ld      A,(HL)          ; Get next byte ',' or ")"
2407: CD6924  	        call    MIDNUM          ; Get number supplied
240A: 04      	        inc     B               ; Is it character zero?
240B: 05      	        dec     B
240C: CA8819  	        jp      Z,FCERR         ; Yes - Error
240F: C5      	        push    BC              ; Save starting position
2410: 1EFF    	        ld      E,$FF           ; All of string
2412: FE29    	        cp      ')'             ; Any length given?
2414: CA1E24  	        jp      Z,RSTSTR        ; No - Rest of string
2417: CDA616  	        call    CHKSYN          ; Make sure ',' follows
241A: 2C      	        defb    ','
241B: CDB124  	        call    GETINT          ; Get integer 0-255
241E: CDA616  	RSTSTR: call    CHKSYN          ; Make sure ")" follows
2421: 29      	        defb    ')'
2422: F1      	        pop     AF              ; Restore starting position
2423: E3      	        ex      (SP),HL         ; Get string,8ave code string
2424: 01D123  	        ld      BC,MID1         ; Continuation of MID$ routine
2427: C5      	        push    BC              ; Save for return
2428: 3D      	        dec     A               ; Starting position-1
2429: BE      	        cp      (HL)            ; Compare with length
242A: 0600    	        ld      B,$00           ; Zero bytes length
242C: D0      	        ret     NC              ; Null string if start past end
242D: 4F      	        ld      C,A             ; Save starting position-1
242E: 7E      	        ld      A,(HL)          ; Get length of string
242F: 91      	        sub     C               ; Subtract start
2430: BB      	        cp      E               ; Enough string for it?
2431: 47      	        ld      B,A             ; Save maximum length available
2432: D8      	        ret     C               ; Truncate string if needed
2433: 43      	        ld      B,E             ; Set specified length
2434: C9      	        ret                     ; Go and create string
              	
2435: CD9F23  	VAL:    call    GETLEN          ; Get length of string
2438: CA8527  	        jp      Z,RESZER        ; Result zero
243B: 5F      	        ld      E,A             ; Save length
243C: 23      	        inc     HL
243D: 23      	        inc     HL
243E: 7E      	        ld      A,(HL)          ; Get LSB of address
243F: 23      	        inc     HL
2440: 66      	        ld      H,(HL)          ; Get MSB of address
2441: 6F      	        ld      L,A             ; HL = String address
2442: E5      	        push    HL              ; Save string address
2443: 19      	        add     HL,DE
2444: 46      	        ld      B,(HL)          ; Get end of string+1 byte
2445: 72      	        ld      (HL),D          ; Zero it to terminate
2446: E3      	        ex      (SP),HL         ; Save string end,get start
2447: C5      	        push    BC              ; Save end+1 byte
2448: 7E      	        ld      A,(HL)          ; Get starting byte
2449: FE24    	        cp      '$'             ; Hex number indicated? [function added]
244B: C25324  	        jp      NZ,VAL1
244E: CD7D35  	        call    HEXTFP          ; Convert Hex to FPREG
2451: 180D    	        jr      VAL3
2453: FE25    	VAL1:   cp      '%'             ; Binary number indicated? [function added]
2455: C25D24  	        jp      NZ,VAL2
2458: CDED35  	        call    BINTFP          ; Convert Bin to FPREG
245B: 1803    	        jr      VAL3
245D: CD6C2A  	VAL2:   call    ASCTFP          ; Convert ASCII string to FP
2460: C1      	VAL3:   pop     BC              ; Restore end+1 byte
2461: E1      	        pop     HL              ; Restore end+1 address
2462: 70      	        ld      (HL),B          ; Put back original byte
2463: C9      	        ret
              	
2464: EB      	LFRGNM: ex      DE,HL           ; Code string address to HL
2465: CDA616  	        call    CHKSYN          ; Make sure ")" follows
2468: 29      	        defb    ')'
2469: C1      	MIDNUM: pop     BC              ; Get return address
246A: D1      	        pop     DE              ; Get number supplied
246B: C5      	        push    BC              ; Re-save return address
246C: 43      	        ld      B,E             ; Number to B
246D: C9      	        ret
              	
246E: CDB424  	INP:    call    MAKINT          ; Make it integer A
2471: 329D80  	        ld      (INPORT),A      ; Set input port
2474: CD9C80  	        call    INPSUB          ; Get input from port
2477: C31A21  	        jp      PASSA           ; Return integer A
              	
247A: CD9E24  	POUT:   call    SETIO           ; Set up port number
247D: C36480  	        jp      OUTSUB          ; Output data and return
              	
2480: CD9E24  	WAIT:   call    SETIO           ; Set up port number
2483: F5      	        push    AF              ; Save AND mask
2484: 1E00    	        ld      E,$00           ; Assume zero if none given
2486: 2B      	        dec     HL              ; dec 'cos GETCHR INCs
2487: CDC918  	        call    GETCHR          ; Get next character
248A: CA9424  	        jp      Z,NOXOR         ; No XOR byte given
248D: CDA616  	        call    CHKSYN          ; Make sure ',' follows
2490: 2C      	        defb    ','
2491: CDB124  	        call    GETINT          ; Get integer 0-255 to XOR with
2494: C1      	NOXOR:  pop     BC              ; Restore AND mask
2495: CD9C80  	WAITLP: call    INPSUB          ; Get input
2498: AB      	        xor     E               ; Flip selected bits
2499: A0      	        and     B               ; Result non-zero?
249A: CA9524  	        jp      Z,WAITLP        ; No = keep waiting
249D: C9      	        ret
              	
249E: CDB124  	SETIO:  call    GETINT          ; Get integer 0-255
24A1: 329D80  	        ld      (INPORT),A      ; Set input port
24A4: 326580  	        ld      (OTPORT),A      ; Set output port
24A7: CDA616  	        call    CHKSYN          ; Make sure ',' follows
24AA: 2C      	        defb    ','
24AB: C3B124  	        jp      GETINT          ; Get integer 0-255 and return
              	
24AE: CDC918  	FNDNUM: call    GETCHR          ; Get next character
24B1: CD2A1D  	GETINT: call    GETNUM          ; Get a number from 0 to 255
24B4: CD6D19  	MAKINT: call    DEPINT          ; Make sure value 0 - 255
24B7: 7A      	        ld      A,D             ; Get MSB of number
24B8: B7      	        or      A               ; Zero?
24B9: C28819  	        jp      NZ,FCERR        ; No - Error
24BC: 2B      	        dec     HL              ; dec 'cos GETCHR INCs
24BD: CDC918  	        call    GETCHR          ; Get next character
24C0: 7B      	        ld      A,E             ; Get number to A
24C1: C9      	        ret
              	
              	
              	; execute a machine language routine, eventually passing a param into A
24C2: CD2A1D  	SYS:    call    GETNUM          ; Get memory address
24C5: CD7319  	        call    DEINT           ; Get integer -32768 to 32767
24C8: D5      	        push    DE              ; store address
24C9: AF      	        xor     A               ; reset A
24CA: 325E81  	        ld      (TMPBFR1),A     ; store into temp buffer
24CD: 2B      	        dec     HL              ; dec 'cos GETCHR INCs
24CE: CDC918  	        call    GETCHR          ; Get next character
24D1: 280A    	        jr      Z,NOSYSPR       ; jump if nothing follows
24D3: CDA616  	        call    CHKSYN          ; Make sure ',' follows
24D6: 2C      	        defb    ','
24D7: CDB124  	        call    GETINT          ; get value if something follows
24DA: 325E81  	        ld      (TMPBFR1),A     ; store into temp buffer
24DD: 3A5E81  	NOSYSPR:ld      A,(TMPBFR1)     ; recover A
24E0: D1      	        pop     DE              ; recover user routine's address
24E1: E5      	        push    HL              ; save current HL
24E2: EB      	        ex      DE,HL           ; move address into HL
24E3: 11E824  	        ld      DE,SYSRET       ; recover point to return to after the user routine
24E6: D5      	        push    DE              ; store into stack
24E7: E9      	        jp      HL              ; execute user routine
24E8: E1      	SYSRET: pop     HL              ; retrieve HL
24E9: C9      	        ret                     ; return to caller
              	
              	
              	; read the contents of a byte from RAM
24EA: CD7319  	PEEK:   call    DEINT           ; Get memory address
24ED: 1A      	        ld      A,(DE)          ; Get byte in memory
24EE: C31A21  	        jp      PASSA           ; Return integer A
              	
              	; read the contents of a byte from VRAM
24F1: CD7319  	VPEEK:  call    DEINT           ; Get VRAM address into DE
24F4: EB      	        ex      DE,HL           ; Copy param into HL
24F5: F3      	        di                      ; Disable interrupts
24F6: CDE905  	        call    READ_VIDEO_LOC  ; Read data from VRAM at address HL
24F9: FB      	        ei                      ; Re-enable interrupts
24FA: EB      	        ex      DE,HL           ; Restore HL
24FB: C31A21  	        jp      PASSA           ; Return value into A
              	
              	; recover params for POKE/VPOKE commands
              	; returns address into DE and byte to be written into A
24FE: CD2A1D  	PKEPRMS:call    GETNUM          ; Get memory address
2501: CD7319  	        call    DEINT           ; Get integer -32768 to 32767
2504: ED535E81	        ld      (TMPBFR1),DE    ; Store DE into a temp. buffer
2508: CDA616  	        call    CHKSYN          ; Make sure ',' follows
250B: 2C      	        defb    ','
250C: CDB124  	        call    GETINT          ; Get integer 0-255
250F: ED5B5E81	        ld      DE,(TMPBFR1)    ; Restore memory address
2513: C9      	        ret                     ; Return to caller
              	
              	; write a byte into SRAM
2514: CDFE24  	POKE:   call    PKEPRMS         ; Get params: address and value, return into DE and A, resp.
2517: 12      	        ld      (DE),A          ; Load it into memory
2518: C9      	        ret
              	
              	; write a byte into VRAM
2519: CDFE24  	VPOKE:  call    PKEPRMS         ; Get params: address and value, return into DE and A, resp.
251C: EB      	        ex      DE,HL           ; Copy address into HL
251D: F3      	        di                      ; Disable interrupts
251E: CDFE05  	        call    WRITE_VIDEO_LOC ; write data into VRAM at address HL
2521: FB      	        ei                      ; Re-enable interrupts
2522: EB      	        ex      DE,HL           ; Restore HL
2523: C9      	        ret                     ; Return to caller
              	
              	; position the cursor at a specific X,Y location onto screen
2524: CDB124  	LOCATE: call    GETINT          ; get the first param into A
2527: E5      	        push    HL              ; store HL
2528: 214D81  	        ld      HL,SCR_SIZE_W   ; load address of screen width
252B: 5E      	        ld      E,(HL)          ; load screen width into E
252C: E1      	        pop     HL              ; restore HL
252D: BB      	        cp      E               ; compare witdh with param
252E: D28819  	        jp      NC,FCERR        ; value over the width of the screen, exit with Illegal F.C. error
2531: 325E81  	        ld      (TMPBFR1),A     ; Store X into a temp. buffer
2534: CDA616  	        call    CHKSYN          ; Make sure ',' follows
2537: 2C      	        defb    ','
2538: CDB124  	        call    GETINT          ; Get the second param into A
253B: E5      	        push    HL              ; store HL
253C: 214E81  	        ld      HL,SCR_SIZE_H   ; load address of screen width
253F: 5E      	        ld      E,(HL)          ; load screen width into A
2540: E1      	        pop     HL              ; restore HL
2541: BB      	        cp      E               ; compare witdh with param
2542: D28819  	        jp      NC,FCERR        ; value over the height of the screen, exit with Illegal F.C. error
2545: 325681  	        ld      (SCR_CUR_NY),A  ; store new Y
2548: 3A5E81  	        ld      A,(TMPBFR1)     ; recover the new X
254B: 325581  	        ld      (SCR_CUR_NX),A  ; store new X
254E: E5      	        push    HL              ; store HL
254F: F3      	        di                      ; disable INTs
2550: CD2F06  	        call    MOVCRS          ; move cursor to new location
2553: FB      	        ei                      ; re-enable INTs
2554: E1      	        pop     HL              ; restore HL
2555: C9      	        ret                     ; return to caller
              	
              	; write a byte into one of the PSG registers
2556: CDB124  	SREG:   call    GETINT          ; Get register number back into A
2559: FE10    	        cp      $10             ; check if value >= 16 (PSG registers go from 0 to 15)
255B: D28819  	        jp      NC,FCERR        ; If yes, exit and raise an Illegal function call Error
255E: 325E81  	        ld      (TMPBFR1),A     ; Store A into a temp. buffer
2561: CDA616  	        call    CHKSYN          ; Make sure ',' follows
2564: 2C      	        defb    ','
2565: CDB124  	        call    GETINT          ; get second value (0-255), returned into A
2568: 5F      	        ld      E,A             ; store value into E
2569: 3A5E81  	        ld      A,(TMPBFR1)     ; recover VDP register and store into D
256C: 0E40    	        ld      C,PSG_REG       ; output port to access PSG registers
256E: ED79    	        out     (C),A           ; send register # to PSG
2570: 0E41    	        ld      C,PSG_DAT       ; output port to send data to PSG
2572: ED59    	        out     (C),E           ; send byte to write into selected register
2574: C9      	        ret                     ; return to caller
              	
              	; VOLUME ch,vol
              	; set the volume for the audio channels
              	; "ch" is 1~3 for corresponding channel, or 0 for all; "vol" is 0~15 (0=OFF, 15=MAX)
2575: CDB124  	VOLUME: call    GETINT          ; get integer 0-255 (recover channel)
2578: FE04    	        cp      $04             ; check if it's in the range 0~3
257A: D28819  	        jp      NC,FCERR        ; if not, exit with Illegal function call error
257D: 325E81  	        ld      (TMPBFR1),A     ; Store A into a temp. buffer
2580: CDA616  	        call    CHKSYN          ; Make sure ',' follows
2583: 2C      	        defb    ','
2584: CDB124  	        call    GETINT          ; get integer 0-255 (recover channel)
2587: FE10    	        cp      $10             ; check if it's in the range 0~15
2589: D28819  	        jp      NC,FCERR        ; if not, exit with Illegal funcion call
258C: 57      	        ld      D,A             ; store volume into D
258D: 3A5E81  	        ld      A,(TMPBFR1)     ; retrieve channel
2590: A7      	        and     A               ; is it 0? (0=every channel)
2591: 2010    	        jr      NZ,VOLCH        ; no, jump over
2593: 0603    	        ld      B,$03           ; yes, set every channel
2595: 1E08    	        ld      E,$08           ; register volume of first channel
2597: 0E40    	RPVOLCG:ld      C,PSG_REG       ; PSG register port
2599: ED59    	        out     (C),E           ; set register #
259B: 0E41    	        ld      C,PSG_DAT       ; PSG data port
259D: ED51    	        out     (C),D           ; send volume
259F: 1C      	        inc     E               ; next register
25A0: 10F5    	        djnz    RPVOLCG         ; repeat for each channel
25A2: C9      	        ret                     ; return to caller
25A3: 0E40    	VOLCH:  ld      C,PSG_REG       ; PSG register port
25A5: C607    	        add     $07             ; add 7 to A so that we have the correct register (1->8, 2->9, 3->10)
25A7: ED79    	        out     (C),A           ; set register
25A9: 0E41    	        ld      C,PSG_DAT       ; PSG data port
25AB: ED51    	        out     (C),D           ; send volume level
25AD: C9      	        ret                     ; return to caller
              	
              	; SOUND ch,tone,dur
              	; play a tone or noise of "tone" frequency from selected channel "ch" for duration "dur"
              	; "ch" is 1~6 (0=means sound OFF,1~3 for tone, 4~6 for noise) / "tone" is 1~4,095 (0=means no tone) /
              	; "dur" is 1~16383 h.o.s.,0.001~163s (0=means non-stop tone)
25AE: CDB124  	SOUND:  call    GETINT          ; get integer 0-255 (recover channel)
25B1: A7      	        and     A               ; is it zero?
25B2: 2006    	        jr      NZ,CTSNDC       ; no, continue with checking of params
25B4: E5      	        push    HL              ; store HL
25B5: CD860B  	        call    CLRPSGREGS      ; yes, it's zero, so reset PSG registers to shut down every sound
25B8: E1      	        pop     HL              ; retrieve HL
25B9: C9      	        ret                     ; return to caller
25BA: 325E81  	CTSNDC: ld      (TMPBFR1),A     ; no, continue by storing A into a temp. buffer
25BD: FE04    	        cp      $04             ; is channel >3?
25BF: D23F26  	        jp      NC,NOISUP       ; Yes - check to see if it's a noise channel
25C2: CDA616  	        call    CHKSYN          ; No, continue checking by making sure ',' follows
25C5: 2C      	        defb    ','
25C6: CD2A1D  	        call    GETNUM          ; Get tone frequency
25C9: CD7319  	        call    DEINT           ; Get integer -32768 to 32767
25CC: ED536081	        ld      (TMPBFR2),DE    ; Store frequency
25D0: CDA616  	        call    CHKSYN          ; Make sure ',' follows
25D3: 2C      	        defb    ','
25D4: CD2A1D  	        call    GETNUM          ; Get duration
25D7: CD7319  	        call    DEINT           ; Get integer -32768 to 32767
25DA: ED536281	        ld      (TMPBFR3),DE    ; Store duration
              	                                ; CHECK CHANNEL
25DE: 3A5E81  	        ld      A,(TMPBFR1)     ; recover channel
25E1: FE01    	        cp      $01             ; is channel <1?
25E3: DA8819  	        jp      C,FCERR         ; Yes - Illegal function call error
              	                                ; CHECK FREQUENCY
25E6: ED5B6081	        ld      DE,(TMPBFR2)    ; restore frequency from temp buffer
25EA: 7A      	        ld      A,D             ; move D into A and check if it is in the range 0~4095...
25EB: FE10    	        cp      $10             ; ...so D must not be greater than $0F (15)
25ED: D28819  	        jp      NC,FCERR        ; if not in the range, exit with an Illegal function call error
              	                                ; CHECK DURATION
25F0: ED5B6281	        ld      DE,(TMPBFR3)    ; restore duration from temp buffer
25F4: 7A      	        ld      A,D             ; check if it is in the range 0~16383...
25F5: E6C0    	        and     $C0             ; ...(15th & 14th bits must not be set)
25F7: C28819  	        jp      NZ,FCERR        ; if not in the range, exit with an Illegal function call error
              	                                ;
              	                                ; SET TONE:
              	                                ; let's start by setting up the channel
25FA: 3A5E81  	        ld      A,(TMPBFR1)     ; restore channel value
25FD: FE03    	        cp      $03             ; is it 3?
25FF: 2002    	        jr      NZ,SND1         ; no, jump over
2601: 3E04    	        ld      A,%00000100     ; yes, for ch.3, set 3rd bit only (so A=001, B=010, C=100)
2603: 2F      	SND1:   cpl                     ; complement of A - this is used later to set on the channel into the mixer
2604: CD7D26  	        call    WRTSND          ; enable line into mixer of channel stored in A
              	                                ; SET FREQUENCY
              	                                ; we simply get frequency and subtract from 4096. The result
              	                                ; is put into register pair of the corresponding freq tone channel
2607: ED5B6081	        ld      DE,(TMPBFR2)    ; restore frequency from temp buffer
260B: E5      	        push    HL              ; store HL (it will be used by the subroutine)
260C: 210010  	        ld      HL,$1000        ; load 4096 into HL
260F: A7      	        and     A               ; reset C flag
2610: ED52    	        sbc     HL,DE           ; subtract freq from HL - now the frequency is inverted, so we will send the low as high and vice-versa
2612: 3A5E81  	        ld      A,(TMPBFR1)     ; restore channel value
2615: 3D      	        dec     A               ; set A into the range 0~2
2616: 87      	        add     A,A             ; double A to find the register pair that correspond to the channel (A->0,1 / B->2,3, C->4,5)
2617: 0E40    	        ld      C,PSG_REG       ; PSG register port
2619: ED79    	        out     (C),A           ; select first register of the pair
261B: 0E41    	        ld      C,PSG_DAT       ; PSG data port
261D: ED69    	        out     (C),L           ; send high byte
261F: 0E40    	        ld      C,PSG_REG       ; PSG register support
2621: 3C      	        inc     A               ; second register of the pair
2622: ED79    	        out     (C),A           ; select register
2624: 0E41    	        ld      C,PSG_DAT       ; PSG data port
2626: ED61    	        out     (C),H           ; send low byte
2628: ED5B6281	        ld      DE,(TMPBFR3)    ; recover duration
262C: 3A5E81  	        ld      A,(TMPBFR1)     ; recover channel value
262F: 3D      	        dec     A               ; set channel into the range 0~2
2630: 87      	        add     A,A             ; double A to find the correct offset
2631: 219281  	        ld      HL,CHASNDDTN    ; set duration into...
2634: 85      	        add     A,L             ; ...the proper...
2635: 3001    	        jr      NC,SNDOVR       ; (is there a rest? no, jump over
2637: 24      	        inc     H               ; yes, increment H)
2638: 6F      	SNDOVR: ld      L,A             ; ...register pair...
2639: 7323722B	        ld      (HL),DE         ; ...and store the value
263D: E1      	        pop     HL              ; retrieve HL
263E: C9      	        ret                     ; Return to caller
263F: FE07    	NOISUP: cp      $07             ; is channel in range 4 to 6 (for a noise)?
2641: D28819  	        jp      NC,FCERR        ; no, so ILLEGAL FUNCTION CALL
2644: CDA616  	        call    CHKSYN          ; yes, continue checking by making sure ',' follows
2647: 2C      	        defb    ','
2648: CDB124  	        call    GETINT          ; get integer 0-255 (recover frequency)
264B: FE20    	        cp      $20             ; make sure it's in range 0~31
264D: D28819  	        jp      NC,FCERR        ; no, so Illegal function call
2650: 5F      	        ld      E,A             ; store freq into E
2651: 3A5E81  	        ld      A,(TMPBFR1)     ; retrieve channel
2654: D603    	        sub     $03             ; subtract 3 to get channel in range 1~3
2656: FE03    	        cp      $03             ; is it 3?
2658: 2002    	        jr      NZ,NOS1         ; no, jump over
265A: 3E04    	        ld      A,%00000100     ; yes, for ch.3, set 3rd bit only (so A=001, B=010, C=100)
265C: 87      	NOS1:   add     A,A
265D: 87      	        add     A,A
265E: 87      	        add     A,A             ; let's move A 3 bits to left
265F: 47      	        ld      B,A             ; store channel into B
2660: 7B      	        ld      A,E             ; check if
2661: A7      	        and     A               ; freq is 0 (means that noise reproduction must be halted)
2662: 200A    	        jr      NZ,NOS2         ; no, so jump over
2664: 3E07    	        ld      A,$07           ; mixer register
2666: CDD40B  	        call    SETSNDREG       ; set mixer register
2669: ED78    	        in      A,(C)           ; load current mixer value
266B: B0      	        or      B               ; disable noise
266C: 1818    	        jr      NOS3            ; continue over
266E: 78      	NOS2:   ld      A,B             ; recover channel
266F: 2F      	        cpl                     ; complement of A - this is used to set on the channel into the mixer
2670: CD7D26  	        call    WRTSND          ; enable line into mixer of channel stored in A
2673: 3E06    	        ld      A,$06           ; write into noise register
2675: CDD40B  	        call    SETSNDREG       ; set register into PSG
2678: 7B      	        ld      A,E             ; load value for noise frequency
2679: CDD90B  	        call    WRTSNDREG       ; write data into register $06
267C: C9      	        ret
              	        ; enable line into mixer of channel stored in A
267D: 47      	WRTSND: ld      B,A             ; move channel into B
267E: 3E07    	        ld      A,$07           ; mixer register
2680: CDD40B  	        call    SETSNDREG       ; set mixer register
2683: ED78    	        in      A,(C)           ; load current value
2685: A0      	        and     B               ; set on the channel into the mixer (remember that 0=ON)
              	                                ; example: if channel is A (1), complement of 1 is 254 (11111110). So, 255 (in case
              	                                ; the register is still unchanged after reset) is 11111111 and
              	                                ; 11111111 AND 11111110 is equal to 11111110
              	                                ; 11111001 AND 11111110 is equal to 11111000 (in case channels B & C are ON)
2686: 47      	NOS3:   ld      B,A
2687: 3E07    	        ld      A,$07
2689: CDD40B  	        call    SETSNDREG
268C: 78      	        ld      A,B
268D: 00      	        nop
268E: CDD90B  	        call    WRTSNDREG       ; send new value for the mixer
2691: C9      	        ret                     ; return to caller
              	
              	; write a byte into one of the VDP registers
2692: CDB124  	VREG:   call    GETINT          ; Get register number back into A
2695: FE08    	        cp      $08             ; check if value is equal or greater than 8 (VDP registers are only 8, from 0 to 7)
2697: D28819  	        jp      NC,FCERR        ; If yes, exit and raise an Illegal function call Error
269A: 325E81  	        ld      (TMPBFR1),A     ; Store A into a temp. buffer
269D: CDA616  	        call    CHKSYN          ; Make sure ',' follows
26A0: 2C      	        defb    ','
26A1: CDB124  	        call    GETINT          ; get value (0-255)
26A4: 5F      	        ld      E,A             ; store value into E
26A5: 3A5E81  	        ld      A,(TMPBFR1)     ; recover VDP register and store into A
26A8: F3      	        di                      ; disable INTs
26A9: CD1306  	        call    WRITE_VREG      ; write value into VDP register
26AC: FB      	        ei                      ; re-enable INTs
26AD: C9      	        ret                     ; return to caller
              	
              	; read the VDP status register and return it into A
26AE: CD7319  	VSTAT:  call    DEINT           ; Get integer -32768 to 32767 (Note: we do NOT use it)
26B1: F3      	        di                      ; disable INTs
26B2: CD1E06  	        call    READ_VSTAT      ; read VDP register status
26B5: FB      	        ei                      ; re-enable INTs
26B6: C31A21  	        jp      PASSA           ; Return integer A
              	
              	; read from PSG register and return it into A
26B9: CD7319  	SSTAT:  call    DEINT           ; get integer -32768 to 32767
26BC: 7B      	        ld      A,E             ; consider LSB
26BD: FE10    	        cp      $10             ; check if value >= 16 (PSG registers go from 0 to 15)
26BF: D28819  	        jp      NC,FCERR        ; If yes, exit and raise an Illegal function call Error
26C2: 0E40    	        ld      C,PSG_REG       ; output port to set PSG register
26C4: ED79    	        out     (C),A           ; send register to read from
26C6: ED78    	        in      A,(C)           ; read register's contents and store into A
26C8: C31A21  	        jp      PASSA           ; return A
              	
              	; read the temp key buffer and return the value of the current key being pressed
              	; can wait for the number of 100thds of second before to return
26CB: CD9421  	INKEY:  call    IDTEST          ; Test for illegal direct
26CE: CD7319  	        call    DEINT           ; get number param (100thds of second to wait)
26D1: C5      	        push    BC              ; store BC
26D2: 3A4981  	        ld      A,(TMRCNT)      ; Load current value of system timer
26D5: 47      	        ld      B,A             ; move it into B
26D6: 3A4981  	CMP_A:  ld      A,(TMRCNT)      ; make a little delay of 1/100 sec...
26D9: B8      	        cp      B               ; ...to let the sniffer collect...
26DA: 20FA    	        jr      NZ,CMP_A        ; ...at least 1 char before to continue
26DC: 7A      	        ld      A,D             ; check the param
26DD: AB      	        xor     E               ; if DE<>0 then...
26DE: 2005    	        jr      NZ,INKEY2       ; ...jump over...
26E0: 3A9A81  	        ld      A,(TMPKEYBFR)   ; ...else read the buffer and...
26E3: 181C    	        jr      ENDINK          ; ...return it
26E5: 7A      	INKEY2: ld      A,D             ; check if param>1023
26E6: FE04    	        cp      $04             ; to do this we check if MSB>3
26E8: D28819  	        jp      NC,FCERR        ; if MSB >=4 then error
26EB: 3A4981  	        ld      A,(TMRCNT)      ; Load current value of system timer
26EE: 47      	        ld      B,A             ; move it into B
26EF: 3A9A81  	CHKINK: ld      A,(TMPKEYBFR)   ; load current value
26F2: A7      	        and     A               ; is it 0?
26F3: 200C    	        jr      NZ,ENDINK       ; no, so we can return it
26F5: 3A4981  	        ld      A,(TMRCNT)      ; load current value of system timer
26F8: B8      	        cp      B               ; is it the same value?
26F9: 28F4    	        jr      Z,CHKINK        ; yes, so read again
26FB: 47      	        ld      B,A             ; store new value
26FC: 1B      	        dec     DE              ; no, decrement timer
26FD: 7A      	        ld      A,D             ; check if zero reached
26FE: B3      	        or      E               ; by ORing D and E
26FF: 20EE    	        jr      NZ,CHKINK       ; if not 0, repeat
2701: C1      	ENDINK: pop     BC              ; restore BC
2702: F5      	        push    AF              ; store A
2703: F3      	        di                      ; disable INTs
2704: AF      	        xor     A               ; clear the...
2705: 329A81  	        ld      (TMPKEYBFR),A   ; ...TMP KEY buffer for the next read
2708: FB      	        ei                      ; re-enable INTs
2709: F1      	        pop     AF              ; retrieve A
270A: C31A21  	ENDINK2:jp      PASSA           ; return A as ASCII value
              	
270D: 21E32B  	ROUND:  ld      HL,HALF         ; Add 0.5 to FPREG
2710: CDB429  	ADDPHL: call    LOADFP          ; Load FP at (HL) to BCDE
2713: C31F27  	        jp      FPADD           ; Add BCDE to FPREG
              	
2716: CDB429  	SUBPHL: call    LOADFP          ; FPREG = -FPREG + number at HL
2719: 21      	        defb    $21             ; Skip "pop BC" and "pop DE"
271A: C1      	PSUB:   pop     BC              ; Get FP number from stack
271B: D1      	        pop     DE
271C: CD8E29  	SUBCDE: call    INVSGN          ; Negate FPREG
271F: 78      	FPADD:  ld      A,B             ; Get FP exponent
2720: B7      	        or      A               ; Is number zero?
2721: C8      	        ret     Z               ; Yes - Nothing to add
2722: 3A4781  	        ld      A,(FPEXP)       ; Get FPREG exponent
2725: B7      	        or      A               ; Is this number zero?
2726: CAA629  	        jp      Z,FPBCDE        ; Yes - Move BCDE to FPREG
2729: 90      	        sub     B               ; BCDE number larger?
272A: D23927  	        jp      NC,NOSWAP       ; No - Don't swap them
272D: 2F      	        cpl                     ; Two's complement
272E: 3C      	        inc     A               ;  FP exponent
272F: EB      	        ex      DE,HL
2730: CD9629  	        call    STAKFP          ; Put FPREG on stack
2733: EB      	        ex      DE,HL
2734: CDA629  	        call    FPBCDE          ; Move BCDE to FPREG
2737: C1      	        pop     BC              ; Restore number from stack
2738: D1      	        pop     DE
2739: FE19    	NOSWAP: cp      24+1            ; Second number insignificant?
273B: D0      	        ret     NC              ; Yes - First number is result
273C: F5      	        push    AF              ; Save number of bits to scale
273D: CDCB29  	        call    SIGNS           ; Set MSBs & sign of result
2740: 67      	        ld      H,A             ; Save sign of result
2741: F1      	        pop     AF              ; Restore scaling factor
2742: CDE427  	        call    SCALE           ; Scale BCDE to same exponent
2745: B4      	        or      H               ; Result to be positive?
2746: 214481  	        ld      HL,FPREG        ; Point to FPREG
2749: F25F27  	        jp      P,MINCDE        ; No - Subtract FPREG from CDE
274C: CDC427  	        call    PLUCDE          ; Add FPREG to CDE
274F: D2A527  	        jp      NC,RONDUP       ; No overflow - Round it up
2752: 23      	        inc     HL              ; Point to exponent
2753: 34      	        inc     (HL)            ; Increment it
2754: CAEA13  	        jp      Z,OVERR         ; Number overflowed - Error
2757: 2E01    	        ld      L,$01           ; 1 bit to shift right
2759: CDFA27  	        call    SHRT1           ; Shift result right
275C: C3A527  	        jp      RONDUP          ; Round it up
              	
275F: AF      	MINCDE: xor     A               ; Clear A and carry
2760: 90      	        sub     B               ; Negate exponent
2761: 47      	        ld      B,A             ; Re-save exponent
2762: 7E      	        ld      A,(HL)          ; Get LSB of FPREG
2763: 9B      	        sbc     A, E            ; Subtract LSB of BCDE
2764: 5F      	        ld      E,A             ; Save LSB of BCDE
2765: 23      	        inc     HL
2766: 7E      	        ld      A,(HL)          ; Get NMSB of FPREG
2767: 9A      	        sbc     A,D             ; Subtract NMSB of BCDE
2768: 57      	        ld      D,A             ; Save NMSB of BCDE
2769: 23      	        inc     HL
276A: 7E      	        ld      A,(HL)          ; Get MSB of FPREG
276B: 99      	        sbc     A,C             ; Subtract MSB of BCDE
276C: 4F      	        ld      C,A             ; Save MSB of BCDE
276D: DCD027  	CONPOS: call    C,COMPL         ; Overflow - Make it positive
              	
2770: 68      	BNORM:  ld      L,B             ; L = Exponent
2771: 63      	        ld      H,E             ; H = LSB
2772: AF      	        xor     A
2773: 47      	BNRMLP: ld      B,A             ; Save bit count
2774: 79      	        ld      A,C             ; Get MSB
2775: B7      	        or      A               ; Is it zero?
2776: C29227  	        jp      NZ,PNORM        ; No - Do it bit at a time
2779: 4A      	        ld      C,D             ; MSB = NMSB
277A: 54      	        ld      D,H             ; NMSB= LSB
277B: 65      	        ld      H,L             ; LSB = VLSB
277C: 6F      	        ld      L,A             ; VLSB= 0
277D: 78      	        ld      A,B             ; Get exponent
277E: D608    	        sub     $08             ; Count 8 bits
2780: FEE0    	        cp      -24-8           ; Was number zero?
2782: C27327  	        jp      NZ,BNRMLP       ; No - Keep normalising
2785: AF      	RESZER: xor     A               ; Result is zero
2786: 324781  	SAVEXP: ld      (FPEXP),A       ; Save result as zero
2789: C9      	        ret
              	
278A: 05      	NORMAL: dec     B               ; Count bits
278B: 29      	        add     HL,HL           ; Shift HL left
278C: 7A      	        ld      A,D             ; Get NMSB
278D: 17      	        rla                     ; Shift left with last bit
278E: 57      	        ld      D,A             ; Save NMSB
278F: 79      	        ld      A,C             ; Get MSB
2790: 8F      	        adc     A,A             ; Shift left with last bit
2791: 4F      	        ld      C,A             ; Save MSB
2792: F28A27  	PNORM:  jp      P,NORMAL        ; Not done - Keep going
2795: 78      	        ld      A,B             ; Number of bits shifted
2796: 5C      	        ld      E,H             ; Save HL in EB
2797: 45      	        ld      B,L
2798: B7      	        or      A               ; Any shifting done?
2799: CAA527  	        jp      Z,RONDUP        ; No - Round it up
279C: 214781  	        ld      HL,FPEXP        ; Point to exponent
279F: 86      	        add     A,(HL)          ; Add shifted bits
27A0: 77      	        ld      (HL),A          ; Re-save exponent
27A1: D28527  	        jp      NC,RESZER       ; Underflow - Result is zero
27A4: C8      	        ret     Z               ; Result is zero
27A5: 78      	RONDUP: ld      A,B             ; Get VLSB of number
27A6: 214781  	RONDB:  ld      HL,FPEXP        ; Point to exponent
27A9: B7      	        or      A               ; Any rounding?
27AA: FCB727  	        call    M,FPROND        ; Yes - Round number up
27AD: 46      	        ld      B,(HL)          ; B = Exponent
27AE: 23      	        inc     HL
27AF: 7E      	        ld      A,(HL)          ; Get sign of result
27B0: E680    	        and     %10000000       ; Only bit 7 needed
27B2: A9      	        xor     C               ; Set correct sign
27B3: 4F      	        ld      C,A             ; Save correct sign in number
27B4: C3A629  	        jp      FPBCDE          ; Move BCDE to FPREG
              	
27B7: 1C      	FPROND: inc     E               ; Round LSB
27B8: C0      	        ret     NZ              ; Return if ok
27B9: 14      	        inc     D               ; Round NMSB
27BA: C0      	        ret     NZ              ; Return if ok
27BB: 0C      	        inc     C               ; Round MSB
27BC: C0      	        ret     NZ              ; Return if ok
27BD: 0E80    	        ld      C,$80           ; Set normal value
27BF: 34      	        inc     (HL)            ; Increment exponent
27C0: C0      	        ret     NZ              ; Return if ok
27C1: C3EA13  	        jp      OVERR           ; Overflow error
              	
27C4: 7E      	PLUCDE: ld      A,(HL)          ; Get LSB of FPREG
27C5: 83      	        add     A,E             ; Add LSB of BCDE
27C6: 5F      	        ld      E,A             ; Save LSB of BCDE
27C7: 23      	        inc     HL
27C8: 7E      	        ld      A,(HL)          ; Get NMSB of FPREG
27C9: 8A      	        adc     A,D             ; Add NMSB of BCDE
27CA: 57      	        ld      D,A             ; Save NMSB of BCDE
27CB: 23      	        inc     HL
27CC: 7E      	        ld      A,(HL)          ; Get MSB of FPREG
27CD: 89      	        adc     A,C             ; Add MSB of BCDE
27CE: 4F      	        ld      C,A             ; Save MSB of BCDE
27CF: C9      	        ret
              	
27D0: 214881  	COMPL:  ld      HL,SGNRES       ; Sign of result
27D3: 7E      	        ld      A,(HL)          ; Get sign of result
27D4: 2F      	        cpl                     ; Negate it
27D5: 77      	        ld      (HL),A          ; Put it back
27D6: AF      	        xor     A
27D7: 6F      	        ld      L,A             ; Set L to zero
27D8: 90      	        sub     B               ; Negate exponent,set carry
27D9: 47      	        ld      B,A             ; Re-save exponent
27DA: 7D      	        ld      A,L             ; Load zero
27DB: 9B      	        sbc     A,E             ; Negate LSB
27DC: 5F      	        ld      E,A             ; Re-save LSB
27DD: 7D      	        ld      A,L             ; Load zero
27DE: 9A      	        sbc     A,D             ; Negate NMSB
27DF: 57      	        ld      D,A             ; Re-save NMSB
27E0: 7D      	        ld      A,L             ; Load zero
27E1: 99      	        sbc     A,C             ; Negate MSB
27E2: 4F      	        ld      C,A             ; Re-save MSB
27E3: C9      	        ret
              	
27E4: 0600    	SCALE:  ld      B,$00           ; Clear underflow
27E6: D608    	SCALLP: sub     $08             ; 8 bits (a whole byte)?
27E8: DAF327  	        jp      C,SHRITE        ; No - Shift right A bits
27EB: 43      	        ld      B,E             ; <- Shift
27EC: 5A      	        ld      E,D             ; <- right
27ED: 51      	        ld      D,C             ; <- eight
27EE: 0E00    	        ld      C,$00           ; <- bits
27F0: C3E627  	        jp      SCALLP          ; More bits to shift
              	
27F3: C609    	SHRITE: add     A,8+1           ; Adjust count
27F5: 6F      	        ld      L,A             ; Save bits to shift
27F6: AF      	SHRLP:  xor     A               ; Flag for all done
27F7: 2D      	        dec     L               ; All shifting done?
27F8: C8      	        ret     Z               ; Yes - Return
27F9: 79      	        ld      A,C             ; Get MSB
27FA: 1F      	SHRT1:  rra                     ; Shift it right
27FB: 4F      	        ld      C,A             ; Re-save
27FC: 7A      	        ld      A,D             ; Get NMSB
27FD: 1F      	        rra                     ; Shift right with last bit
27FE: 57      	        ld      D,A             ; Re-save it
27FF: 7B      	        ld      A,E             ; Get LSB
2800: 1F      	        rra                     ; Shift right with last bit
2801: 5F      	        ld      E,A             ; Re-save it
2802: 78      	        ld      A,B             ; Get underflow
2803: 1F      	        rra                     ; Shift right with last bit
2804: 47      	        ld      B,A             ; Re-save underflow
2805: C3F627  	        jp      SHRLP           ; More bits to do
              	
2808: 00000081	UNITY:  defb    $00,$00,$00,$81 ; 1.00000
              	
280C: 03      	LOGTAB: defb    $03             ; Table used by LOG
280D: AA561980	        defb    $AA,$56,$19,$80 ; 0.59898
2811: F1227680	        defb    $F1,$22,$76,$80 ; 0.96147
2815: 45AA3882	        defb    $45,$AA,$38,$82 ; 2.88539
              	
2819: CD6529  	LOG:    call    TSTSGN          ; Test sign of value
281C: B7      	        or      A
281D: EA8819  	        jp      PE,FCERR        ; ?FC Error if <= zero
2820: 214781  	        ld      HL,FPEXP        ; Point to exponent
2823: 7E      	        ld      A,(HL)          ; Get exponent
2824: 013580  	        ld      BC,$8035        ; BCDE = SQR(1/2)
2827: 11F304  	        ld      DE,$04F3
282A: 90      	        sub     B               ; Scale value to be < 1
282B: F5      	        push    AF              ; Save scale factor
282C: 70      	        ld      (HL),B          ; Save new exponent
282D: D5      	        push    DE              ; Save SQR(1/2)
282E: C5      	        push    BC
282F: CD1F27  	        call    FPADD           ; Add SQR(1/2) to value
2832: C1      	        pop     BC              ; Restore SQR(1/2)
2833: D1      	        pop     DE
2834: 04      	        inc     B               ; Make it SQR(2)
2835: CDBB28  	        call    DVBCDE          ; Divide by SQR(2)
2838: 210828  	        ld      HL,UNITY        ; Point to 1.
283B: CD1627  	        call    SUBPHL          ; Subtract FPREG from 1
283E: 210C28  	        ld      HL,LOGTAB       ; Coefficient table
2841: CDAD2C  	        call    SUMSER          ; Evaluate sum of series
2844: 018080  	        ld      BC,$8080        ; BCDE = -0.5
2847: 110000  	        ld      DE,$0000
284A: CD1F27  	        call    FPADD           ; Subtract 0.5 from FPREG
284D: F1      	        pop     AF              ; Restore scale factor
284E: CDE02A  	        call    RSCALE          ; Re-scale number
2851: 013180  	MULLN2: ld      BC,$8031        ; BCDE = Ln(2)
2854: 111872  	        ld      DE,$7218
2857: 21      	        defb    $21             ; Skip "pop BC" and "pop DE"
              	
2858: C1      	MULT:   pop     BC              ; Get number from stack
2859: D1      	        pop     DE
285A: CD6529  	FPMULT: call    TSTSGN          ; Test sign of FPREG
285D: C8      	        ret     Z               ; Return zero if zero
285E: 2E00    	        ld      L,$00           ; Flag add exponents
2860: CD2329  	        call    ADDEXP          ; Add exponents
2863: 79      	        ld      A,C             ; Get MSB of multiplier
2864: 32AC81  	        ld      (MULVAL),A      ; Save MSB of multiplier
2867: EB      	        ex      DE,HL
2868: 22AD81  	        ld      (MULVAL+1),HL   ; Save rest of multiplier
286B: 010000  	        ld      BC,$0000        ; Partial product (BCDE) = zero
286E: 50      	        ld      D,B
286F: 58      	        ld      E,B
2870: 217027  	        ld      HL,BNORM        ; Address of normalise
2873: E5      	        push    HL              ; Save for return
2874: 217C28  	        ld      HL,MULT8        ; Address of 8 bit multiply
2877: E5      	        push    HL              ; Save for NMSB,MSB
2878: E5      	        push    HL              ;
2879: 214481  	        ld      HL,FPREG        ; Point to number
287C: 7E      	MULT8:  ld      A,(HL)          ; Get LSB of number
287D: 23      	        inc     HL              ; Point to NMSB
287E: B7      	        or      A               ; Test LSB
287F: CAA828  	        jp      Z,BYTSFT        ; Zero - shift to next byte
2882: E5      	        push    HL              ; Save address of number
2883: 2E08    	        ld      L,$08           ; 8 bits to multiply by
2885: 1F      	MUL8LP: rra                     ; Shift LSB right
2886: 67      	        ld      H,A             ; Save LSB
2887: 79      	        ld      A,C             ; Get MSB
2888: D29628  	        jp      NC,NOMADD       ; Bit was zero - Don't add
288B: E5      	        push    HL              ; Save LSB and count
288C: 2AAD81  	        ld      HL,(MULVAL+1)   ; Get LSB and NMSB
288F: 19      	        add     HL,DE           ; Add NMSB and LSB
2890: EB      	        ex      DE,HL           ; Leave sum in DE
2891: E1      	        pop     HL              ; Restore MSB and count
2892: 3AAC81  	        ld      A,(MULVAL)      ; Get MSB of multiplier
2895: 89      	        adc     A,C             ; Add MSB
2896: 1F      	NOMADD: rra                     ; Shift MSB right
2897: 4F      	        ld      C,A             ; Re-save MSB
2898: 7A      	        ld      A,D             ; Get NMSB
2899: 1F      	        rra                     ; Shift NMSB right
289A: 57      	        ld      D,A             ; Re-save NMSB
289B: 7B      	        ld      A,E             ; Get LSB
289C: 1F      	        rra                     ; Shift LSB right
289D: 5F      	        ld      E,A             ; Re-save LSB
289E: 78      	        ld      A,B             ; Get VLSB
289F: 1F      	        rra                     ; Shift VLSB right
28A0: 47      	        ld      B,A             ; Re-save VLSB
28A1: 2D      	        dec     L               ; Count bits multiplied
28A2: 7C      	        ld      A,H             ; Get LSB of multiplier
28A3: C28528  	        jp      NZ,MUL8LP       ; More - Do it
28A6: E1      	POPHRT: pop     HL              ; Restore address of number
28A7: C9      	        ret
              	
28A8: 43      	BYTSFT: ld      B,E             ; Shift partial product left
28A9: 5A      	        ld      E,D
28AA: 51      	        ld      D,C
28AB: 4F      	        ld      C,A
28AC: C9      	        ret
              	
28AD: CD9629  	DIV10:  call    STAKFP          ; Save FPREG on stack
28B0: 012084  	        ld      BC,$8420        ; BCDE = 10.
28B3: 110000  	        ld      DE,$0000
28B6: CDA629  	        call    FPBCDE          ; Move 10 to FPREG
              	
28B9: C1      	DIV:    pop     BC              ; Get number from stack
28BA: D1      	        pop     DE
28BB: CD6529  	DVBCDE: call    TSTSGN          ; Test sign of FPREG
28BE: CADE13  	        jp      Z,DZERR         ; Error if division by zero
28C1: 2EFF    	        ld      L,-1            ; Flag subtract exponents
28C3: CD2329  	        call    ADDEXP          ; Subtract exponents
28C6: 34      	        inc     (HL)            ; Add 2 to exponent to adjust
28C7: 34      	        inc     (HL)
28C8: 2B      	        dec     HL              ; Point to MSB
28C9: 7E      	        ld      A,(HL)          ; Get MSB of dividend
28CA: 327080  	        ld      (DIV3),A        ; Save for subtraction
28CD: 2B      	        dec     HL
28CE: 7E      	        ld      A,(HL)          ; Get NMSB of dividend
28CF: 326C80  	        ld      (DIV2),A        ; Save for subtraction
28D2: 2B      	        dec     HL
28D3: 7E      	        ld      A,(HL)          ; Get MSB of dividend
28D4: 326880  	        ld      (DIV1),A        ; Save for subtraction
28D7: 41      	        ld      B,C             ; Get MSB
28D8: EB      	        ex      DE,HL           ; NMSB,LSB to HL
28D9: AF      	        xor     A
28DA: 4F      	        ld      C,A             ; Clear MSB of quotient
28DB: 57      	        ld      D,A             ; Clear NMSB of quotient
28DC: 5F      	        ld      E,A             ; Clear LSB of quotient
28DD: 327380  	        ld      (DIV4),A        ; Clear overflow count
28E0: E5      	DIVLP:  push    HL              ; Save divisor
28E1: C5      	        push    BC
28E2: 7D      	        ld      A,L             ; Get LSB of number
28E3: CD6780  	        call    DIVSUP          ; Subt' divisor from dividend
28E6: DE00    	        sbc     A,$00           ; Count for overflows
28E8: 3F      	        ccf
28E9: D2F328  	        jp      NC,RESDIV       ; Restore divisor if borrow
28EC: 327380  	        ld      (DIV4),A        ; Re-save overflow count
28EF: F1      	        pop     AF              ; Scrap divisor
28F0: F1      	        pop     AF
28F1: 37      	        scf                     ; Set carry to
28F2: D2      	        defb    $D2             ; Skip "pop BC" and "pop HL"
              	
28F3: C1      	RESDIV: pop     BC              ; Restore divisor
28F4: E1      	        pop     HL
28F5: 79      	        ld      A,C             ; Get MSB of quotient
28F6: 3C      	        inc     A
28F7: 3D      	        dec     A
28F8: 1F      	        rra                     ; Bit 0 to bit 7
28F9: FAA627  	        jp      M,RONDB         ; Done - Normalise result
28FC: 17      	        rla                     ; Restore carry
28FD: 7B      	        ld      A,E             ; Get LSB of quotient
28FE: 17      	        rla                     ; Double it
28FF: 5F      	        ld      E,A             ; Put it back
2900: 7A      	        ld      A,D             ; Get NMSB of quotient
2901: 17      	        rla                     ; Double it
2902: 57      	        ld      D,A             ; Put it back
2903: 79      	        ld      A,C             ; Get MSB of quotient
2904: 17      	        rla                     ; Double it
2905: 4F      	        ld      C,A             ; Put it back
2906: 29      	        add     HL,HL           ; Double NMSB,LSB of divisor
2907: 78      	        ld      A,B             ; Get MSB of divisor
2908: 17      	        rla                     ; Double it
2909: 47      	        ld      B,A             ; Put it back
290A: 3A7380  	        ld      A,(DIV4)        ; Get VLSB of quotient
290D: 17      	        rla                     ; Double it
290E: 327380  	        ld      (DIV4),A        ; Put it back
2911: 79      	        ld      A,C             ; Get MSB of quotient
2912: B2      	        or      D               ; Merge NMSB
2913: B3      	        or      E               ; Merge LSB
2914: C2E028  	        jp      NZ,DIVLP        ; Not done - Keep dividing
2917: E5      	        push    HL              ; Save divisor
2918: 214781  	        ld      HL,FPEXP        ; Point to exponent
291B: 35      	        dec     (HL)            ; Divide by 2
291C: E1      	        pop     HL              ; Restore divisor
291D: C2E028  	        jp      NZ,DIVLP        ; Ok - Keep going
2920: C3EA13  	        jp      OVERR           ; Overflow error
              	
2923: 78      	ADDEXP: ld      A,B             ; Get exponent of dividend
2924: B7      	        or      A               ; Test it
2925: CA4729  	        jp      Z,OVTST3        ; Zero - Result zero
2928: 7D      	        ld      A,L             ; Get add/subtract flag
2929: 214781  	        ld      HL,FPEXP        ; Point to exponent
292C: AE      	        xor     (HL)            ; Add or subtract it
292D: 80      	        add     A,B             ; Add the other exponent
292E: 47      	        ld      B,A             ; Save new exponent
292F: 1F      	        rra                     ; Test exponent for overflow
2930: A8      	        xor     B
2931: 78      	        ld      A,B             ; Get exponent
2932: F24629  	        jp      P,OVTST2        ; Positive - Test for overflow
2935: C680    	        add     A,$80           ; Add excess 128
2937: 77      	        ld      (HL),A          ; Save new exponent
2938: CAA628  	        jp      Z,POPHRT        ; Zero - Result zero
293B: CDCB29  	        call    SIGNS           ; Set MSBs and sign of result
293E: 77      	        ld      (HL),A          ; Save new exponent
293F: 2B      	        dec     HL              ; Point to MSB
2940: C9      	        ret
              	
2941: CD6529  	OVTST1: call    TSTSGN          ; Test sign of FPREG
2944: 2F      	        cpl                     ; Invert sign
2945: E1      	        pop     HL              ; Clean up stack
2946: B7      	OVTST2: or      A               ; Test if new exponent zero
2947: E1      	OVTST3: pop     HL              ; Clear off return address
2948: F28527  	        jp      P,RESZER        ; Result zero
294B: C3EA13  	        jp      OVERR           ; Overflow error
              	
294E: CDB129  	MLSP10: call    BCDEFP          ; Move FPREG to BCDE
2951: 78      	        ld      A,B             ; Get exponent
2952: B7      	        or      A               ; Is it zero?
2953: C8      	        ret     Z               ; Yes - Result is zero
2954: C602    	        add     A,$02           ; Multiply by 4
2956: DAEA13  	        jp      C,OVERR         ; Overflow - ?OV Error
2959: 47      	        ld      B,A             ; Re-save exponent
295A: CD1F27  	        call    FPADD           ; Add BCDE to FPREG (Times 5)
295D: 214781  	        ld      HL,FPEXP        ; Point to exponent
2960: 34      	        inc     (HL)            ; Double number (Times 10)
2961: C0      	        ret     NZ              ; Ok - Return
2962: C3EA13  	        jp      OVERR           ; Overflow error
              	
2965: 3A4781  	TSTSGN: ld      A,(FPEXP)       ; Get sign of FPREG
2968: B7      	        or      A
2969: C8      	        ret     Z               ; RETurn if number is zero
296A: 3A4681  	        ld      A,(FPREG+2)     ; Get MSB of FPREG
296D: FE      	        defb    0FEH            ; Test sign
296E: 2F      	RETREL: cpl                     ; Invert sign
296F: 17      	        rla                     ; Sign bit to carry
2970: 9F      	FLGDIF: sbc     A,A             ; Carry to all bits of A
2971: C0      	        ret     NZ              ; Return -1 if negative
2972: 3C      	        inc     A               ; Bump to +1
2973: C9      	        ret                     ; Positive - Return +1
              	
2974: CD6529  	SGN:    call    TSTSGN          ; Test sign of FPREG
2977: 0688    	FLGREL: ld      B,$80+8         ; 8 bit integer in exponent
2979: 110000  	        ld      DE,0            ; Zero NMSB and LSB
297C: 214781  	RETINT: ld      HL,FPEXP        ; Point to exponent
297F: 4F      	        ld      C,A             ; CDE = MSB,NMSB and LSB
2980: 70      	        ld      (HL),B          ; Save exponent
2981: 0600    	        ld      B,0             ; CDE = integer to normalise
2983: 23      	        inc     HL              ; Point to sign of result
2984: 3680    	        ld      (HL),$80        ; Set sign of result
2986: 17      	        rla                     ; Carry = sign of integer
2987: C36D27  	        jp      CONPOS          ; Set sign of result
              	
298A: CD6529  	ABS:    call    TSTSGN          ; Test sign of FPREG
298D: F0      	        ret     P               ; Return if positive
298E: 214681  	INVSGN: ld      HL,FPREG+2      ; Point to MSB
2991: 7E      	        ld      A,(HL)          ; Get sign of mantissa
2992: EE80    	        xor     $80             ; Invert sign of mantissa
2994: 77      	        ld      (HL),A          ; Re-save sign of mantissa
2995: C9      	        ret
              	
2996: EB      	STAKFP: ex      DE,HL           ; Save code string address
2997: 2A4481  	        ld      HL,(FPREG)      ; LSB,NLSB of FPREG
299A: E3      	        ex      (SP),HL         ; Stack them,get return
299B: E5      	        push    HL              ; Re-save return
299C: 2A4681  	        ld      HL,(FPREG+2)    ; MSB and exponent of FPREG
299F: E3      	        ex      (SP),HL         ; Stack them,get return
29A0: E5      	        push    HL              ; Re-save return
29A1: EB      	        ex      DE,HL           ; Restore code string address
29A2: C9      	        ret
              	
29A3: CDB429  	PHLTFP: call    LOADFP          ; Number at HL to BCDE
29A6: EB      	FPBCDE: ex      DE,HL           ; Save code string address
29A7: 224481  	        ld      (FPREG),HL      ; Save LSB,NLSB of number
29AA: 60      	        ld      H,B             ; Exponent of number
29AB: 69      	        ld      L,C             ; MSB of number
29AC: 224681  	        ld      (FPREG+2),HL    ; Save MSB and exponent
29AF: EB      	        ex      DE,HL           ; Restore code string address
29B0: C9      	        ret
              	
29B1: 214481  	BCDEFP: ld      HL,FPREG        ; Point to FPREG
29B4: 5E      	LOADFP: ld      E,(HL)          ; Get LSB of number
29B5: 23      	        inc     HL
29B6: 56      	        ld      D,(HL)          ; Get NMSB of number
29B7: 23      	        inc     HL
29B8: 4E      	        ld      C,(HL)          ; Get MSB of number
29B9: 23      	        inc     HL
29BA: 46      	        ld      B,(HL)          ; Get exponent of number
29BB: 23      	INCHL:  inc     HL              ; Used for conditional "inc HL"
29BC: C9      	        ret
              	
29BD: 114481  	FPTHL:  ld      DE,FPREG        ; Point to FPREG
29C0: 0604    	DETHL4: ld      B,$04           ; 4 bytes to move
29C2: 1A      	DETHLB: ld      A,(DE)          ; Get source
29C3: 77      	        ld      (HL),A          ; Save destination
29C4: 13      	        inc     DE              ; Next source
29C5: 23      	        inc     HL              ; Next destination
29C6: 05      	        dec     B               ; Count bytes
29C7: C2C229  	        jp      NZ,DETHLB       ; Loop if more
29CA: C9      	        ret
              	
29CB: 214681  	SIGNS:  ld      HL,FPREG+2      ; Point to MSB of FPREG
29CE: 7E      	        ld      A,(HL)          ; Get MSB
29CF: 07      	        rlca                    ; Old sign to carry
29D0: 37      	        scf                     ; Set MSBit
29D1: 1F      	        rra                     ; Set MSBit of MSB
29D2: 77      	        ld      (HL),A          ; Save new MSB
29D3: 3F      	        ccf                     ; Complement sign
29D4: 1F      	        rra                     ; Old sign to carry
29D5: 23      	        inc     HL
29D6: 23      	        inc     HL
29D7: 77      	        ld      (HL),A          ; Set sign of result
29D8: 79      	        ld      A,C             ; Get MSB
29D9: 07      	        rlca                    ; Old sign to carry
29DA: 37      	        scf                     ; Set MSBit
29DB: 1F      	        rra                     ; Set MSBit of MSB
29DC: 4F      	        ld      C,A             ; Save MSB
29DD: 1F      	        rra
29DE: AE      	        xor     (HL)            ; New sign of result
29DF: C9      	        ret
              	
29E0: 78      	CMPNUM: ld      A,B             ; Get exponent of number
29E1: B7      	        or      A
29E2: CA6529  	        jp      Z,TSTSGN        ; Zero - Test sign of FPREG
29E5: 216E29  	        ld      HL,RETREL       ; Return relation routine
29E8: E5      	        push    HL              ; Save for return
29E9: CD6529  	        call    TSTSGN          ; Test sign of FPREG
29EC: 79      	        ld      A,C             ; Get MSB of number
29ED: C8      	        ret     Z               ; FPREG zero - Number's MSB
29EE: 214681  	        ld      HL,FPREG+2      ; MSB of FPREG
29F1: AE      	        xor     (HL)            ; Combine signs
29F2: 79      	        ld      A,C             ; Get MSB of number
29F3: F8      	        ret     M               ; Exit if signs different
29F4: CDFA29  	        call    CMPFP           ; Compare FP numbers
29F7: 1F      	        rra                     ; Get carry to sign
29F8: A9      	        xor     C               ; Combine with MSB of number
29F9: C9      	        ret
              	
29FA: 23      	CMPFP:  inc     HL              ; Point to exponent
29FB: 78      	        ld      A,B             ; Get exponent
29FC: BE      	        cp      (HL)            ; Compare exponents
29FD: C0      	        ret     NZ              ; Different
29FE: 2B      	        dec     HL              ; Point to MBS
29FF: 79      	        ld      A,C             ; Get MSB
2A00: BE      	        cp      (HL)            ; Compare MSBs
2A01: C0      	        ret     NZ              ; Different
2A02: 2B      	        dec     HL              ; Point to NMSB
2A03: 7A      	        ld      A,D             ; Get NMSB
2A04: BE      	        cp      (HL)            ; Compare NMSBs
2A05: C0      	        ret     NZ              ; Different
2A06: 2B      	        dec     HL              ; Point to LSB
2A07: 7B      	        ld      A,E             ; Get LSB
2A08: 96      	        sub     (HL)            ; Compare LSBs
2A09: C0      	        ret     NZ              ; Different
2A0A: E1      	        pop     HL              ; Drop RETurn
2A0B: E1      	        pop     HL              ; Drop another RETurn
2A0C: C9      	        ret
              	
2A0D: 47      	FPINT:  ld      B,A             ; <- Move
2A0E: 4F      	        ld      C,A             ; <- exponent
2A0F: 57      	        ld      D,A             ; <- to all
2A10: 5F      	        ld      E,A             ; <- bits
2A11: B7      	        or      A               ; Test exponent
2A12: C8      	        ret     Z               ; Zero - Return zero
2A13: E5      	        push    HL              ; Save pointer to number
2A14: CDB129  	        call    BCDEFP          ; Move FPREG to BCDE
2A17: CDCB29  	        call    SIGNS           ; Set MSBs & sign of result
2A1A: AE      	        xor     (HL)            ; Combine with sign of FPREG
2A1B: 67      	        ld      H,A             ; Save combined signs
2A1C: FC312A  	        call    M,DCBCDE        ; Negative - Decrement BCDE
2A1F: 3E98    	        ld      A,$80+24        ; 24 bits
2A21: 90      	        sub     B               ; Bits to shift
2A22: CDE427  	        call    SCALE           ; Shift BCDE
2A25: 7C      	        ld      A,H             ; Get combined sign
2A26: 17      	        rla                     ; Sign to carry
2A27: DCB727  	        call    C,FPROND        ; Negative - Round number up
2A2A: 0600    	        ld      B,$00           ; Zero exponent
2A2C: DCD027  	        call    C,COMPL         ; If negative make positive
2A2F: E1      	        pop     HL              ; Restore pointer to number
2A30: C9      	        ret
              	
2A31: 1B      	DCBCDE: dec     DE              ; Decrement BCDE
2A32: 7A      	        ld      A,D             ; Test LSBs
2A33: A3      	        and     E
2A34: 3C      	        inc     A
2A35: C0      	        ret     NZ              ; Exit if LSBs not FFFF
2A36: 0B      	        dec     BC              ; Decrement MSBs
2A37: C9      	        ret
              	
2A38: 214781  	INT:    ld      HL,FPEXP        ; Point to exponent
2A3B: 7E      	        ld      A,(HL)          ; Get exponent
2A3C: FE98    	        cp      $80+24          ; Integer accuracy only?
2A3E: 3A4481  	        ld      A,(FPREG)       ; Get LSB
2A41: D0      	        ret     NC              ; Yes - Already integer
2A42: 7E      	        ld      A,(HL)          ; Get exponent
2A43: CD0D2A  	        call    FPINT           ; F.P to integer
2A46: 3698    	        ld      (HL),$80+24     ; Save 24 bit integer
2A48: 7B      	        ld      A,E             ; Get LSB of number
2A49: F5      	        push    AF              ; Save LSB
2A4A: 79      	        ld      A,C             ; Get MSB of number
2A4B: 17      	        rla                     ; Sign to carry
2A4C: CD6D27  	        call    CONPOS          ; Set sign of result
2A4F: F1      	        pop     AF              ; Restore LSB of number
2A50: C9      	        ret
              	
2A51: 210000  	MLDEBC: ld      HL,$0000        ; Clear partial product
2A54: 78      	        ld      A,B             ; Test multiplier
2A55: B1      	        or      C
2A56: C8      	        ret     Z               ; Return zero if zero
2A57: 3E10    	        ld      A,$10           ; 16 bits
2A59: 29      	MLDBLP: add     HL,HL           ; Shift P.P left
2A5A: DA4720  	        jp      C,BSERR         ; ?BS Error if overflow
2A5D: EB      	        ex      DE,HL
2A5E: 29      	        add     HL,HL           ; Shift multiplier left
2A5F: EB      	        ex      DE,HL
2A60: D2672A  	        jp      NC,NOMLAD       ; Bit was zero - No add
2A63: 09      	        add     HL,BC           ; Add multiplicand
2A64: DA4720  	        jp      C,BSERR         ; ?BS Error if overflow
2A67: 3D      	NOMLAD: dec     A               ; Count bits
2A68: C2592A  	        jp      NZ,MLDBLP       ; More
2A6B: C9      	        ret
              	
2A6C: FE2D    	ASCTFP: cp      '-'             ; Negative?
2A6E: F5      	        push    AF              ; Save it and flags
2A6F: CA782A  	        jp      Z,CNVNUM        ; Yes - Convert number
2A72: FE2B    	        cp      '+'             ; Positive?
2A74: CA782A  	        jp      Z,CNVNUM        ; Yes - Convert number
2A77: 2B      	        dec     HL              ; dec 'cos GETCHR INCs
2A78: CD8527  	CNVNUM: call    RESZER          ; Set result to zero
2A7B: 47      	        ld      B,A             ; Digits after point counter
2A7C: 57      	        ld      D,A             ; Sign of exponent
2A7D: 5F      	        ld      E,A             ; Exponent of ten
2A7E: 2F      	        cpl
2A7F: 4F      	        ld      C,A             ; Before or after point flag
2A80: CDC918  	MANLP:  call    GETCHR          ; Get next character
2A83: DAC92A  	        jp      C,ADDIG         ; Digit - Add to number
2A86: FE2E    	        cp      '.'
2A88: CAA42A  	        jp      Z,DPOINT        ; '.' - Flag point
2A8B: FE45    	        cp      'E'
2A8D: C2A82A  	        jp      NZ,CONEXP       ; Not 'E' - Scale number
2A90: CDC918  	        call    GETCHR          ; Get next character
2A93: CD631E  	        call    SGNEXP          ; Get sign of exponent
2A96: CDC918  	EXPLP:  call    GETCHR          ; Get next character
2A99: DAEB2A  	        jp      C,EDIGIT        ; Digit - Add to exponent
2A9C: 14      	        inc     D               ; Is sign negative?
2A9D: C2A82A  	        jp      NZ,CONEXP       ; No - Scale number
2AA0: AF      	        xor     A
2AA1: 93      	        sub     E               ; Negate exponent
2AA2: 5F      	        ld      E,A             ; And re-save it
2AA3: 0C      	        inc     C               ; Flag end of number
2AA4: 0C      	DPOINT: inc     C               ; Flag point passed
2AA5: CA802A  	        jp      Z,MANLP         ; Zero - Get another digit
2AA8: E5      	CONEXP: push    HL              ; Save code string address
2AA9: 7B      	        ld      A,E             ; Get exponent
2AAA: 90      	        sub     B               ; Subtract digits after point
2AAB: F4C12A  	SCALMI: call    P,SCALPL        ; Positive - Multiply number
2AAE: F2B72A  	        jp      P,ENDCON        ; Positive - All done
2AB1: F5      	        push    AF              ; Save number of times to /10
2AB2: CDAD28  	        call    DIV10           ; Divide by 10
2AB5: F1      	        pop     AF              ; Restore count
2AB6: 3C      	        inc     A               ; Count divides
              	
2AB7: C2AB2A  	ENDCON: jp      NZ,SCALMI       ; More to do
2ABA: D1      	        pop     DE              ; Restore code string address
2ABB: F1      	        pop     AF              ; Restore sign of number
2ABC: CC8E29  	        call    Z,INVSGN        ; Negative - Negate number
2ABF: EB      	        ex      DE,HL           ; Code string address to HL
2AC0: C9      	        ret
              	
2AC1: C8      	SCALPL: ret     Z               ; Exit if no scaling needed
2AC2: F5      	MULTEN: push    AF              ; Save count
2AC3: CD4E29  	        call    MLSP10          ; Multiply number by 10
2AC6: F1      	        pop     AF              ; Restore count
2AC7: 3D      	        dec     A               ; Count multiplies
2AC8: C9      	        ret
              	
2AC9: D5      	ADDIG:  push    DE              ; Save sign of exponent
2ACA: 57      	        ld      D,A             ; Save digit
2ACB: 78      	        ld      A,B             ; Get digits after point
2ACC: 89      	        adc     A,C             ; Add one if after point
2ACD: 47      	        ld      B,A             ; Re-save counter
2ACE: C5      	        push    BC              ; Save point flags
2ACF: E5      	        push    HL              ; Save code string address
2AD0: D5      	        push    DE              ; Save digit
2AD1: CD4E29  	        call    MLSP10          ; Multiply number by 10
2AD4: F1      	        pop     AF              ; Restore digit
2AD5: D630    	        sub     '0'             ; Make it absolute
2AD7: CDE02A  	        call    RSCALE          ; Re-scale number
2ADA: E1      	        pop     HL              ; Restore code string address
2ADB: C1      	        pop     BC              ; Restore point flags
2ADC: D1      	        pop     DE              ; Restore sign of exponent
2ADD: C3802A  	        jp      MANLP           ; Get another digit
              	
2AE0: CD9629  	RSCALE: call    STAKFP          ; Put number on stack
2AE3: CD7729  	        call    FLGREL          ; Digit to add to FPREG
2AE6: C1      	PADD:   pop     BC              ; Restore number
2AE7: D1      	        pop     DE
2AE8: C31F27  	        jp      FPADD           ; Add BCDE to FPREG and return
              	
2AEB: 7B      	EDIGIT: ld      A,E             ; Get digit
2AEC: 07      	        rlca                    ; Times 2
2AED: 07      	        rlca                    ; Times 4
2AEE: 83      	        add     A,E             ; Times 5
2AEF: 07      	        rlca                    ; Times 10
2AF0: 86      	        add     A,(HL)          ; Add next digit
2AF1: D630    	        sub     '0'             ; Make it absolute
2AF3: 5F      	        ld      E,A             ; Save new digit
2AF4: C3962A  	        jp      EXPLP           ; Look for another digit
              	
2AF7: E5      	LINEIN: push    HL              ; Save code string address
2AF8: 217413  	        ld      HL,INMSG        ; Output " in "
2AFB: CD2922  	        call    PRS             ; Output string at HL
2AFE: E1      	        pop     HL              ; Restore code string address
2AFF: EB      	PRNTHL: ex      DE,HL           ; Code string address to DE
2B00: AF      	        xor     A
2B01: 0698    	        ld      B,$80+24        ; 24 bits
2B03: CD7C29  	        call    RETINT          ; Return the integer
2B06: 212822  	        ld      HL,PRNUMS       ; Print number string
2B09: E5      	        push    HL              ; Save for return
2B0A: 219F81  	NUMASC: ld      HL,PBUFF        ; Convert number to ASCII
2B0D: E5      	        push    HL              ; Save for return
2B0E: CD6529  	        call    TSTSGN          ; Test sign of FPREG
2B11: 3620    	        ld      (HL),SPC        ; Space at start
2B13: F2182B  	        jp      P,SPCFST        ; Positive - Space to start
2B16: 362D    	        ld      (HL),'-'        ; '-' sign at start
2B18: 23      	SPCFST: inc     HL              ; First byte of number
2B19: 3630    	        ld      (HL),'0'        ; '0' if zero
2B1B: CACE2B  	        jp      Z,JSTZER        ; Return '0' if zero
2B1E: E5      	        push    HL              ; Save buffer address
2B1F: FC8E29  	        call    M,INVSGN        ; Negate FPREG if negative
2B22: AF      	        xor     A               ; Zero A
2B23: F5      	        push    AF              ; Save it
2B24: CDD42B  	        call    RNGTST          ; Test number is in range
2B27: 014391  	SIXDIG: ld      BC,$9143        ; BCDE - 99999.9
2B2A: 11F84F  	        ld      DE,$4FF8
2B2D: CDE029  	        call    CMPNUM          ; Compare numbers
2B30: B7      	        or      A
2B31: E2452B  	        jp      PO,INRNG        ; > 99999.9 - Sort it out
2B34: F1      	        pop     AF              ; Restore count
2B35: CDC22A  	        call    MULTEN          ; Multiply by ten
2B38: F5      	        push    AF              ; Re-save count
2B39: C3272B  	        jp      SIXDIG          ; Test it again
              	
2B3C: CDAD28  	GTSIXD: call    DIV10           ; Divide by 10
2B3F: F1      	        pop     AF              ; Get count
2B40: 3C      	        inc     A               ; Count divides
2B41: F5      	        push    AF              ; Re-save count
2B42: CDD42B  	        call    RNGTST          ; Test number is in range
2B45: CD0D27  	INRNG:  call    ROUND           ; Add 0.5 to FPREG
2B48: 3C      	        inc     A
2B49: CD0D2A  	        call    FPINT           ; F.P to integer
2B4C: CDA629  	        call    FPBCDE          ; Move BCDE to FPREG
2B4F: 010603  	        ld      BC,$0306        ; 1E+06 to 1E-03 range
2B52: F1      	        pop     AF              ; Restore count
2B53: 81      	        add     A,C             ; 6 digits before point
2B54: 3C      	        inc     A               ; Add one
2B55: FA612B  	        jp      M,MAKNUM        ; Do it in 'E' form if < 1E-02
2B58: FE08    	        cp      6+1+1           ; More than 999999 ?
2B5A: D2612B  	        jp      NC,MAKNUM       ; Yes - Do it in 'E' form
2B5D: 3C      	        inc     A               ; Adjust for exponent
2B5E: 47      	        ld      B,A             ; Exponent of number
2B5F: 3E02    	        ld      A,2             ; Make it zero after
              	
2B61: 3D      	MAKNUM: dec     A               ; Adjust for digits to do
2B62: 3D      	        dec     A
2B63: E1      	        pop     HL              ; Restore buffer address
2B64: F5      	        push    AF              ; Save count
2B65: 11E72B  	        ld      DE,POWERS       ; Powers of ten
2B68: 05      	        dec     B               ; Count digits before point
2B69: C2722B  	        jp      NZ,DIGTXT       ; Not zero - Do number
2B6C: 362E    	        ld      (HL),'.'        ; Save point
2B6E: 23      	        inc     HL              ; Move on
2B6F: 3630    	        ld      (HL),'0'        ; Save zero
2B71: 23      	        inc     HL              ; Move on
2B72: 05      	DIGTXT: dec     B               ; Count digits before point
2B73: 362E    	        ld      (HL),'.'        ; Save point in case
2B75: CCBB29  	        call    Z,INCHL         ; Last digit - move on
2B78: C5      	        push    BC              ; Save digits before point
2B79: E5      	        push    HL              ; Save buffer address
2B7A: D5      	        push    DE              ; Save powers of ten
2B7B: CDB129  	        call    BCDEFP          ; Move FPREG to BCDE
2B7E: E1      	        pop     HL              ; Powers of ten table
2B7F: 062F    	        ld      B,'0'-1         ; ASCII '0' - 1
2B81: 04      	TRYAGN: inc     B               ; Count subtractions
2B82: 7B      	        ld      A,E             ; Get LSB
2B83: 96      	        sub     (HL)            ; Subtract LSB
2B84: 5F      	        ld      E,A             ; Save LSB
2B85: 23      	        inc     HL
2B86: 7A      	        ld      A,D             ; Get NMSB
2B87: 9E      	        sbc     A,(HL)          ; Subtract NMSB
2B88: 57      	        ld      D,A             ; Save NMSB
2B89: 23      	        inc     HL
2B8A: 79      	        ld      A,C             ; Get MSB
2B8B: 9E      	        sbc     A,(HL)          ; Subtract MSB
2B8C: 4F      	        ld      C,A             ; Save MSB
2B8D: 2B      	        dec     HL              ; Point back to start
2B8E: 2B      	        dec     HL
2B8F: D2812B  	        jp      NC,TRYAGN       ; No overflow - Try again
2B92: CDC427  	        call    PLUCDE          ; Restore number
2B95: 23      	        inc     HL              ; Start of next number
2B96: CDA629  	        call    FPBCDE          ; Move BCDE to FPREG
2B99: EB      	        ex      DE,HL           ; Save point in table
2B9A: E1      	        pop     HL              ; Restore buffer address
2B9B: 70      	        ld      (HL),B          ; Save digit in buffer
2B9C: 23      	        inc     HL              ; And move on
2B9D: C1      	        pop     BC              ; Restore digit count
2B9E: 0D      	        dec     C               ; Count digits
2B9F: C2722B  	        jp      NZ,DIGTXT       ; More - Do them
2BA2: 05      	        dec     B               ; Any decimal part?
2BA3: CAB22B  	        jp      Z,DOEBIT        ; No - Do 'E' bit
2BA6: 2B      	SUPTLZ: dec     HL              ; Move back through buffer
2BA7: 7E      	        ld      A,(HL)          ; Get character
2BA8: FE30    	        cp      '0'             ; '0' character?
2BAA: CAA62B  	        jp      Z,SUPTLZ        ; Yes - Look back for more
2BAD: FE2E    	        cp      '.'             ; A decimal point?
2BAF: C4BB29  	        call    NZ,INCHL        ; Move back over digit
              	
2BB2: F1      	DOEBIT: pop     AF              ; Get 'E' flag
2BB3: CAD12B  	        jp      Z,NOENED        ; No 'E' needed - End buffer
2BB6: 3645    	        ld      (HL),'E'        ; Put 'E' in buffer
2BB8: 23      	        inc     HL              ; And move on
2BB9: 362B    	        ld      (HL),'+'        ; Put '+' in buffer
2BBB: F2C22B  	        jp      P,OUTEXP        ; Positive - Output exponent
2BBE: 362D    	        ld      (HL),'-'        ; Put '-' in buffer
2BC0: 2F      	        cpl                     ; Negate exponent
2BC1: 3C      	        inc     A
2BC2: 062F    	OUTEXP: ld      B,'0'-1         ; ASCII '0' - 1
2BC4: 04      	EXPTEN: inc     B               ; Count subtractions
2BC5: D60A    	        sub     $0A             ; Tens digit
2BC7: D2C42B  	        jp      NC,EXPTEN       ; More to do
2BCA: C63A    	        add     A,'0'+10        ; Restore and make ASCII
2BCC: 23      	        inc     HL              ; Move on
2BCD: 70      	        ld      (HL),B          ; Save MSB of exponent
2BCE: 23      	JSTZER: inc     HL              ;
2BCF: 77      	        ld      (HL),A          ; Save LSB of exponent
2BD0: 23      	        inc     HL
2BD1: 71      	NOENED: ld      (HL),C          ; Mark end of buffer
2BD2: E1      	        pop     HL              ; Restore code string address
2BD3: C9      	        ret
              	
2BD4: 017494  	RNGTST: ld      BC,$9474        ; BCDE = 999999.
2BD7: 11F723  	        ld      DE,$23F7
2BDA: CDE029  	        call    CMPNUM          ; Compare numbers
2BDD: B7      	        or      A
2BDE: E1      	        pop     HL              ; Return address to HL
2BDF: E23C2B  	        jp      PO,GTSIXD       ; Too big - Divide by ten
2BE2: E9      	        jp      (HL)            ; Otherwise return to caller
              	
2BE3: 00000080	HALF:   defb    $00,$00,$00,$80 ; 0.5
              	
2BE7: A08601  	POWERS: defb    $A0,$86,$01  ; 100000
2BEA: 102700  	        defb    $10,$27,$00  ;  10000
2BED: E80300  	        defb    $E8,$03,$00  ;   1000
2BF0: 640000  	        defb    $64,$00,$00  ;    100
2BF3: 0A0000  	        defb    $0A,$00,$00  ;     10
2BF6: 010000  	        defb    $01,$00,$00  ;      1
              	
2BF9: 218E29  	NEGAFT: ld      HL,INVSGN       ; Negate result
2BFC: E3      	        ex      (SP),HL         ; To be done after caller
2BFD: E9      	        jp      (HL)            ; Return to caller
              	
2BFE: CD9629  	SQR:    call    STAKFP          ; Put value on stack
2C01: 21E32B  	        ld      HL,HALF         ; Set power to 1/2
2C04: CDA329  	        call    PHLTFP          ; Move 1/2 to FPREG
              	
2C07: C1      	POWER:  pop     BC              ; Get base
2C08: D1      	        pop     DE
2C09: CD6529  	        call    TSTSGN          ; Test sign of power
2C0C: 78      	        ld      A,B             ; Get exponent of base
2C0D: CA4C2C  	        jp      Z,EXP           ; Make result 1 if zero
2C10: F2172C  	        jp      P,POWER1        ; Positive base - Ok
2C13: B7      	        or      A               ; Zero to negative power?
2C14: CADE13  	        jp      Z,DZERR         ; Yes - ?/0 Error
2C17: B7      	POWER1: or      A               ; Base zero?
2C18: CA8627  	        jp      Z,SAVEXP        ; Yes - Return zero
2C1B: D5      	        push    DE              ; Save base
2C1C: C5      	        push    BC
2C1D: 79      	        ld      A,C             ; Get MSB of base
2C1E: F67F    	        or      %01111111       ; Get sign status
2C20: CDB129  	        call    BCDEFP          ; Move power to BCDE
2C23: F2342C  	        jp      P,POWER2        ; Positive base - Ok
2C26: D5      	        push    DE              ; Save power
2C27: C5      	        push    BC
2C28: CD382A  	        call    INT             ; Get integer of power
2C2B: C1      	        pop     BC              ; Restore power
2C2C: D1      	        pop     DE
2C2D: F5      	        push    AF              ; MSB of base
2C2E: CDE029  	        call    CMPNUM          ; Power an integer?
2C31: E1      	        pop     HL              ; Restore MSB of base
2C32: 7C      	        ld      A,H             ; but don't affect flags
2C33: 1F      	        rra                     ; Exponent odd or even?
2C34: E1      	POWER2: pop     HL              ; Restore MSB and exponent
2C35: 224681  	        ld      (FPREG+2),HL    ; Save base in FPREG
2C38: E1      	        pop     HL              ; LSBs of base
2C39: 224481  	        ld      (FPREG),HL      ; Save in FPREG
2C3C: DCF92B  	        call    C,NEGAFT        ; Odd power - Negate result
2C3F: CC8E29  	        call    Z,INVSGN        ; Negative base - Negate it
2C42: D5      	        push    DE              ; Save power
2C43: C5      	        push    BC
2C44: CD1928  	        call    LOG             ; Get LOG of base
2C47: C1      	        pop     BC              ; Restore power
2C48: D1      	        pop     DE
2C49: CD5A28  	        call    FPMULT          ; Multiply LOG by power
              	
2C4C: CD9629  	EXP:    call    STAKFP          ; Put value on stack
2C4F: 013881  	        ld      BC,$8138        ; BCDE = 1/Ln(2)
2C52: 113BAA  	        ld      DE,$AA3B
2C55: CD5A28  	        call    FPMULT          ; Multiply value by 1/LN(2)
2C58: 3A4781  	        ld      A,(FPEXP)       ; Get exponent
2C5B: FE88    	        cp      $80+8           ; Is it in range?
2C5D: D24129  	        jp      NC,OVTST1       ; No - Test for overflow
2C60: CD382A  	        call    INT             ; Get INT of FPREG
2C63: C680    	        add     A,$80           ; For excess 128
2C65: C602    	        add     A,$02           ; Exponent > 126?
2C67: DA4129  	        jp      C,OVTST1        ; Yes - Test for overflow
2C6A: F5      	        push    AF              ; Save scaling factor
2C6B: 210828  	        ld      HL,UNITY        ; Point to 1.
2C6E: CD1027  	        call    ADDPHL          ; Add 1 to FPREG
2C71: CD5128  	        call    MULLN2          ; Multiply by LN(2)
2C74: F1      	        pop     AF              ; Restore scaling factor
2C75: C1      	        pop     BC              ; Restore exponent
2C76: D1      	        pop     DE
2C77: F5      	        push    AF              ; Save scaling factor
2C78: CD1C27  	        call    SUBCDE          ; Subtract exponent from FPREG
2C7B: CD8E29  	        call    INVSGN          ; Negate result
2C7E: 218C2C  	        ld      HL,EXPTAB       ; Coefficient table
2C81: CDBC2C  	        call    SMSER1          ; Sum the series
2C84: 110000  	        ld      DE,$0000        ; Zero LSBs
2C87: C1      	        pop     BC              ; Scaling factor
2C88: 4A      	        ld      C,D             ; Zero MSB
2C89: C35A28  	        jp      FPMULT          ; Scale result to correct value
              	
2C8C: 08      	EXPTAB: defb    $08             ; Table used by EXP
2C8D: 402E9474	        defb    $40,$2E,$94,$74 ; -1/7! (-1/5040)
2C91: 704F2E77	        defb    $70,$4F,$2E,$77 ;  1/6! ( 1/720)
2C95: 6E02887A	        defb    $6E,$02,$88,$7A ; -1/5! (-1/120)
2C99: E6A02A7C	        defb    $E6,$A0,$2A,$7C ;  1/4! ( 1/24)
2C9D: 50AAAA7E	        defb    $50,$AA,$AA,$7E ; -1/3! (-1/6)
2CA1: FFFF7F7F	        defb    $FF,$FF,$7F,$7F ;  1/2! ( 1/2)
2CA5: 00008081	        defb    $00,$00,$80,$81 ; -1/1! (-1/1)
2CA9: 00000081	        defb    $00,$00,$00,$81 ;  1/0! ( 1/1)
              	
2CAD: CD9629  	SUMSER: call    STAKFP          ; Put FPREG on stack
2CB0: 115828  	        ld      DE,MULT         ; Multiply by "X"
2CB3: D5      	        push    DE              ; To be done after
2CB4: E5      	        push    HL              ; Save address of table
2CB5: CDB129  	        call    BCDEFP          ; Move FPREG to BCDE
2CB8: CD5A28  	        call    FPMULT          ; Square the value
2CBB: E1      	        pop     HL              ; Restore address of table
2CBC: CD9629  	SMSER1: call    STAKFP          ; Put value on stack
2CBF: 7E      	        ld      A,(HL)          ; Get number of coefficients
2CC0: 23      	        inc     HL              ; Point to start of table
2CC1: CDA329  	        call    PHLTFP          ; Move coefficient to FPREG
2CC4: 06      	        defb    06H             ; Skip "pop AF"
2CC5: F1      	SUMLP:  pop     AF              ; Restore count
2CC6: C1      	        pop     BC              ; Restore number
2CC7: D1      	        pop     DE
2CC8: 3D      	        dec     A               ; Cont coefficients
2CC9: C8      	        ret     Z               ; All done
2CCA: D5      	        push    DE              ; Save number
2CCB: C5      	        push    BC
2CCC: F5      	        push    AF              ; Save count
2CCD: E5      	        push    HL              ; Save address in table
2CCE: CD5A28  	        call    FPMULT          ; Multiply FPREG by BCDE
2CD1: E1      	        pop     HL              ; Restore address in table
2CD2: CDB429  	        call    LOADFP          ; Number at HL to BCDE
2CD5: E5      	        push    HL              ; Save address in table
2CD6: CD1F27  	        call    FPADD           ; Add coefficient to FPREG
2CD9: E1      	        pop     HL              ; Restore address in table
2CDA: C3C52C  	        jp      SUMLP           ; More coefficients
              	
2CDD: CD6529  	RND:    call    TSTSGN          ; Test sign of FPREG
2CE0: 217780  	        ld      HL,SEED+2       ; Random number seed
2CE3: FA3E2D  	        jp      M,RESEED        ; Negative - Re-seed
2CE6: 219880  	        ld      HL,LSTRND       ; Last random number
2CE9: CDA329  	        call    PHLTFP          ; Move last RND to FPREG
2CEC: 217780  	        ld      HL,SEED+2       ; Random number seed
2CEF: C8      	        ret     Z               ; Return if RND(0)
2CF0: 86      	        add     A,(HL)          ; Add (SEED)+2)
2CF1: E607    	        and     %00000111       ; 0 to 7
2CF3: 0600    	        ld      B,$00
2CF5: 77      	        ld      (HL),A          ; Re-save seed
2CF6: 23      	        inc     HL              ; Move to coefficient table
2CF7: 87      	        add     A,A             ; 4 bytes
2CF8: 87      	        add     A,A             ; per entry
2CF9: 4F      	        ld      C,A             ; BC = Offset into table
2CFA: 09      	        add     HL,BC           ; Point to coefficient
2CFB: CDB429  	        call    LOADFP          ; Coefficient to BCDE
2CFE: CD5A28  	        call    FPMULT  ;       ; Multiply FPREG by coefficient
2D01: 3A7680  	        ld      A,(SEED+1)      ; Get (SEED+1)
2D04: 3C      	        inc     A               ; Add 1
2D05: E603    	        and     %00000011       ; 0 to 3
2D07: 0600    	        ld      B,$00
2D09: FE01    	        cp      $01             ; Is it zero?
2D0B: 88      	        adc     A,B             ; Yes - Make it 1
2D0C: 327680  	        ld      (SEED+1),A      ; Re-save seed
2D0F: 21422D  	        ld      HL,RNDTAB-4     ; Addition table
2D12: 87      	        add     A,A             ; 4 bytes
2D13: 87      	        add     A,A             ; per entry
2D14: 4F      	        ld      C,A             ; BC = Offset into table
2D15: 09      	        add     HL,BC           ; Point to value
2D16: CD1027  	        call    ADDPHL          ; Add value to FPREG
2D19: CDB129  	RND1:   call    BCDEFP          ; Move FPREG to BCDE
2D1C: 7B      	        ld      A,E             ; Get LSB
2D1D: 59      	        ld      E,C             ; LSB = MSB
2D1E: EE4F    	        xor     %01001111       ; Fiddle around
2D20: 4F      	        ld      C,A             ; New MSB
2D21: 3680    	        ld      (HL),$80        ; Set exponent
2D23: 2B      	        dec     HL              ; Point to MSB
2D24: 46      	        ld      B,(HL)          ; Get MSB
2D25: 3680    	        ld      (HL),$80        ; Make value -0.5
2D27: 217580  	        ld      HL,SEED         ; Random number seed
2D2A: 34      	        inc     (HL)            ; Count seed
2D2B: 7E      	        ld      A,(HL)          ; Get seed
2D2C: D6AB    	        sub     $AB             ; Do it modulo 171
2D2E: C2352D  	        jp      NZ,RND2         ; Non-zero - Ok
2D31: 77      	        ld      (HL),A          ; Zero seed
2D32: 0C      	        inc     C               ; Fillde about
2D33: 15      	        dec     D               ; with the
2D34: 1C      	        inc     E               ; number
2D35: CD7027  	RND2:   call    BNORM           ; Normalise number
2D38: 219880  	        ld      HL,LSTRND       ; Save random number
2D3B: C3BD29  	        jp      FPTHL           ; Move FPREG to last and return
              	
2D3E: 77      	RESEED: ld      (HL),A          ; Re-seed random numbers
2D3F: 2B      	        dec     HL
2D40: 77      	        ld      (HL),A
2D41: 2B      	        dec     HL
2D42: 77      	        ld      (HL),A
2D43: C3192D  	        jp      RND1            ; Return RND seed
              	
2D46: 68B14668	RNDTAB: defb    $68,$B1,$46,$68 ; Table used by RND
2D4A: 99E99269	        defb    $99,$E9,$92,$69
2D4E: 10D17568	        defb    $10,$D1,$75,$68
              	
2D52: 219C2D  	COS:    ld      HL,HALFPI       ; Point to PI/2
2D55: CD1027  	        call    ADDPHL          ; Add it to PPREG
2D58: CD9629  	SIN:    call    STAKFP          ; Put angle on stack
2D5B: 014983  	        ld      BC,$8349        ; BCDE = 2 PI
2D5E: 11DB0F  	        ld      DE,$0FDB
2D61: CDA629  	        call    FPBCDE          ; Move 2 PI to FPREG
2D64: C1      	        pop     BC              ; Restore angle
2D65: D1      	        pop     DE
2D66: CDBB28  	        call    DVBCDE          ; Divide angle by 2 PI
2D69: CD9629  	        call    STAKFP          ; Put it on stack
2D6C: CD382A  	        call    INT             ; Get INT of result
2D6F: C1      	        pop     BC              ; Restore number
2D70: D1      	        pop     DE
2D71: CD1C27  	        call    SUBCDE          ; Make it 0 <= value < 1
2D74: 21A02D  	        ld      HL,QUARTR       ; Point to 0.25
2D77: CD1627  	        call    SUBPHL          ; Subtract value from 0.25
2D7A: CD6529  	        call    TSTSGN          ; Test sign of value
2D7D: 37      	        scf                     ; Flag positive
2D7E: F2882D  	        jp      P,SIN1          ; Positive - Ok
2D81: CD0D27  	        call    ROUND           ; Add 0.5 to value
2D84: CD6529  	        call    TSTSGN          ; Test sign of value
2D87: B7      	        or      A               ; Flag negative
2D88: F5      	SIN1:   push    AF              ; Save sign
2D89: F48E29  	        call    P,INVSGN        ; Negate value if positive
2D8C: 21A02D  	        ld      HL,QUARTR       ; Point to 0.25
2D8F: CD1027  	        call    ADDPHL          ; Add 0.25 to value
2D92: F1      	        pop     AF              ; Restore sign
2D93: D48E29  	        call    NC,INVSGN       ; Negative - Make positive
2D96: 21A42D  	        ld      HL,SINTAB       ; Coefficient table
2D99: C3AD2C  	        jp      SUMSER          ; Evaluate sum of series
              	
2D9C: DB0F4981	HALFPI: defb    $DB,$0F,$49,$81 ; 1.5708 (PI/2)
              	
2DA0: 0000007F	QUARTR: defb    $00,$00,$00,$7F ; 0.25
              	
2DA4: 05      	SINTAB: defb    $05             ; Table used by SIN
2DA5: BAD71E86	        defb    $BA,$D7,$1E,$86 ; 39.711
2DA9: 64269987	        defb    $64,$26,$99,$87 ;-76.575
2DAD: 58342387	        defb    $58,$34,$23,$87 ; 81.602
2DB1: E05DA586	        defb    $E0,$5D,$A5,$86 ;-41.342
2DB5: DA0F4983	        defb    $DA,$0F,$49,$83 ;  6.2832
              	
2DB9: CD9629  	TAN:    call    STAKFP          ; Put angle on stack
2DBC: CD582D  	        call    SIN             ; Get SIN of angle
2DBF: C1      	        pop     BC              ; Restore angle
2DC0: E1      	        pop     HL
2DC1: CD9629  	        call    STAKFP          ; Save SIN of angle
2DC4: EB      	        ex      DE,HL           ; BCDE = Angle
2DC5: CDA629  	        call    FPBCDE          ; Angle to FPREG
2DC8: CD522D  	        call    COS             ; Get COS of angle
2DCB: C3B928  	        jp      DIV             ; TAN = SIN / COS
              	
2DCE: CD6529  	ATN:    call    TSTSGN          ; Test sign of value
2DD1: FCF92B  	        call    M,NEGAFT        ; Negate result after if -ve
2DD4: FC8E29  	        call    M,INVSGN        ; Negate value if -ve
2DD7: 3A4781  	        ld      A,(FPEXP)       ; Get exponent
2DDA: FE81    	        cp      81H             ; Number less than 1?
2DDC: DAEB2D  	        jp      C,ATN1          ; Yes - Get arc tangnt
2DDF: 010081  	        ld      BC,$8100        ; BCDE = 1
2DE2: 51      	        ld      D,C
2DE3: 59      	        ld      E,C
2DE4: CDBB28  	        call    DVBCDE          ; Get reciprocal of number
2DE7: 211627  	        ld      HL,SUBPHL       ; Sub angle from PI/2
2DEA: E5      	        push    HL              ; Save for angle > 1
2DEB: 21F52D  	ATN1:   ld      HL,ATNTAB       ; Coefficient table
2DEE: CDAD2C  	        call    SUMSER          ; Evaluate sum of series
2DF1: 219C2D  	        ld      HL,HALFPI       ; PI/2 - angle in case > 1
2DF4: C9      	        ret                     ; Number > 1 - Sub from PI/2
              	
2DF5: 09      	ATNTAB: defb    $09             ; Table used by ATN
2DF6: 4AD73B78	        defb    $4A,$D7,$3B,$78 ; 1/17
2DFA: 026E847B	        defb    $02,$6E,$84,$7B ;-1/15
2DFE: FEC12F7C	        defb    $FE,$C1,$2F,$7C ; 1/13
2E02: 74319A7D	        defb    $74,$31,$9A,$7D ;-1/11
2E06: 843D5A7D	        defb    $84,$3D,$5A,$7D ; 1/9
2E0A: C87F917E	        defb    $C8,$7F,$91,$7E ;-1/7
2E0E: E4BB4C7E	        defb    $E4,$BB,$4C,$7E ; 1/5
2E12: 6CAAAA7F	        defb    $6C,$AA,$AA,$7F ;-1/3
2E16: 00000081	        defb    $00,$00,$00,$81 ; 1/1
              	
              	
2E1A: C9      	ARET:   ret                     ; A RETurn instruction
              	
2E1B: D7      	GETINP: rst     $10             ; input a character
2E1C: C9      	        ret
              	
2E1D: E5      	CLS:    push    HL
2E1E: D5      	        push    DE
2E1F: 3A4F81  	        ld      A,(SCR_MODE)    ; check screen mode
2E22: FE02    	        cp      $02             ; G2 mode?
2E24: CC3705  	        call    Z,EMPTYVIDBUF   ; yes, reset video buffer
2E27: D1      	        pop     DE
2E28: E1      	        pop     HL
2E29: 3E0C    	        ld      A,CS            ; ASCII Clear screen
2E2B: CDE416  	        call    SND2VID         ; send to screen
2E2E: C31D36  	        jp      MONOUT          ; Output character
              	
2E31: CDB124  	WIDTH:  call    GETINT          ; Get integer 0-255
2E34: 7B      	        ld      A,E             ; Width to A
2E35: 329F80  	        ld      (LWIDTH),A      ; Set width
2E38: C9      	        ret
              	
              	
2E39: CD7319  	DEEK:   call    DEINT           ; Get integer -32768 to 32767
2E3C: D5      	        push    DE              ; Save number
2E3D: E1      	        pop     HL              ; Number to HL
2E3E: 46      	RECWRD: ld      B,(HL)          ; Get LSB of contents
2E3F: 23      	        inc     HL
2E40: 7E      	        ld      A,(HL)          ; Get MSB of contents
2E41: C30B21  	        jp      ABPASS          ; Return integer AB
              	
2E44: CD2A1D  	DOKE:   call    GETNUM          ; Get a number
2E47: CD7319  	        call    DEINT           ; Get integer -32768 to 32767
2E4A: D5      	        push    DE              ; Save address
2E4B: CDA616  	        call    CHKSYN          ; Make sure ',' follows
2E4E: 2C      	        defb    ','
2E4F: CD2A1D  	        call    GETNUM          ; Get a number
2E52: CD7319  	        call    DEINT           ; Get integer -32768 to 32767
2E55: E3      	        ex      (SP),HL         ; Save value,get address
2E56: 73      	        ld      (HL),E          ; Save LSB of value
2E57: 23      	        inc     HL
2E58: 72      	        ld      (HL),D          ; Save MSB of value
2E59: E1      	        pop     HL              ; Restore code string address
2E5A: C9      	        ret
              	
              	; stop the execution of code for a certain bit of time. The pause
              	; is between $0000 and $FFFF 100ths of second (0~655.5 secs)
2E5B: CD2A1D  	PAUSE:  call    GETNUM          ; Get a number
2E5E: CD7319  	        call    DEINT           ; Get integer -32768 to 32767
2E61: 7A      	        ld      A,D             ; load D into A
2E62: B3      	        or      E               ; are D & E equal to $00?
2E63: C8      	        ret     Z               ; if yes, then return
2E64: C5      	DIR_PAU:push    BC              ; store BC
2E65: 3A4981  	        ld      A,(TMRCNT)      ; Load current value of system timer
2E68: 47      	        ld      B,A             ; move it into B
2E69: 3A4981  	RPTPS:  ld      A,(TMRCNT)      ; Load current value of system timer
2E6C: B8      	        cp      B               ; is it the same value?
2E6D: 28FA    	        jr      Z,RPTPS         ; yes, so read again
2E6F: 47      	        ld      B,A             ; no, so store the new value
2E70: 1B      	        dec     DE              ; decrement interval
2E71: 7A      	        ld      A,D             ; load D into A
2E72: B3      	        or      E               ; check if DE is equal to 0 (if D & e are $00 then result is 0)
2E73: 20F4    	        jr      NZ,RPTPS        ; no, repeat
2E75: C1      	        pop     BC              ; yes, recover BC and continue
2E76: C9      	        ret
              	
              	; change the screen mode. Usage: SCREEN X[,Y][,Z]
              	; where X is: 0=text mode (40x24),
              	; 1=graphic mode 1 (32x24 chars); 2=graphic mode 2 (256x192 pixels);
              	; 3=multicolor mode (64x48 pixels); 4=extended graphic mode 2 (32x24 chars mixed between G1 and G2)
              	; Y is: 0=8x8 sprites, 1=16x16 sprites
              	; Z is: 0=no sprite magnification; 1=sprite magnification x2 (8x8=>16x16, and 16x16=32x32)
              	; (the latters are accepted only in graphic modes G1, G2, G3, and G4)
2E77: AF      	SCREEN: xor     A
2E78: 326081  	        ld      (TMPBFR2),A     ; sprite size & magnif. byte set to 0
2E7B: CDB124  	        call    GETINT          ; Get integer 0-255
2E7E: FE05    	        cp      $05             ; is it a valid mode (0~4)?
2E80: D28819  	        jp      NC,FCERR        ; No - Illegal function call Error
2E83: 325E81  	        ld      (TMPBFR1),A     ; store graphic mode
2E86: A7      	        and     A               ; is it 0 (text mode)?
2E87: CAA32E  	        jp      Z,SCVDP         ; yes, ignore other arguments and set mode immediately
2E8A: CDE22E  	SETVDP: call    CHKSCAR         ; no, check if sprite size follows
2E8D: DA952E  	        jp      C,CKMAGN        ; no (set to 0 or missing), so jump over
2E90: 3E02    	        ld      A,$02           ; no, so set sprite size
2E92: 326081  	        ld      (TMPBFR2),A     ; ...to 16x16
2E95: CDE22E  	CKMAGN: call    CHKSCAR         ; check if sprite magnification follows
2E98: DAA32E  	        jp      C,SCVDP         ; no (set to 0 or missing), so jump over
2E9B: 3A6081  	        ld      A,(TMPBFR2)     ; yes, so retrieve sprite attributes...
2E9E: F601    	        or      $01             ; ...set sprite magnification to 2x...
2EA0: 326081  	        ld      (TMPBFR2),A     ; ...and save flags again
2EA3: F3      	SCVDP:  di                      ; disable INTs
2EA4: D5      	        push    DE              ; store DE
2EA5: E5      	        push    HL              ; store HL
2EA6: 3A5E81  	        ld      A,(TMPBFR1)     ; recover graphic mode
2EA9: 5F      	        ld      E,A             ; and store it into E
2EAA: 3A6081  	        ld      A,(TMPBFR2)     ; recover sprite flags
2EAD: 57      	        ld      D,A             ; and store them into D
2EAE: D5      	        push    DE              ; store D & E
2EAF: CD5D03  	        call    initVDP         ; initialize VDP with mode pointed by E
2EB2: D1      	        pop     DE              ; retrieve D & E
2EB3: 7B      	        ld      A,E             ; move graphic mode into A
2EB4: 87      	        add     A,A
2EB5: 87      	        add     A,A
2EB6: 87      	        add     A,A             ; multiply A times 8 to get offset of graphic mode
2EB7: 5F      	        ld      E,A             ; and pass it into E
2EB8: D5      	        push    DE              ; store sprite flags in E
2EB9: 1600    	        ld      D,$00           ; reset D
2EBB: 21150A  	        ld      HL,VDPMODESET+1 ; load address of VDP settings for reg#1
2EBE: 19      	        add     HL,DE           ; load correct reg#1 setting
2EBF: D1      	        pop     DE              ; retrieve sprite flags from E
2EC0: 7E      	        ld      A,(HL)          ; load reg#1 setting
2EC1: E6FC    	        and     %11111100       ; reset size & magn. bits
2EC3: B2      	        or      D               ; set size & magn. bits
2EC4: 5F      	        ld      E,A             ; value into E
2EC5: 3E01    	        ld      A,$01           ; reg #1
2EC7: CD1306  	        call    WRITE_VREG      ; send setting to reg #1
2ECA: 2AAC80  	        ld      HL,(LINEAT)     ; Get current line number
2ECD: 23      	        inc     HL              ; -1 means direct statement
2ECE: 7C      	        ld      A,H
2ECF: B5      	        or      L
2ED0: CC1508  	        call    Z,CURSOR_ON     ; enable cursor if not in program mode
2ED3: FB      	        ei                      ; re-enable interrupts
2ED4: E1      	        pop     HL              ; restore HL
2ED5: D1      	        pop     DE              ; restore DE
2ED6: 3A4E81  	        ld      A,(SCR_SIZE_H)  ; check the screen mode by looking at the screen height
2ED9: FE30    	        cp      $30             ; is it 48 chars or 192 pixels (MC and G2 modes)?
2EDB: D0      	        ret     NC              ; yes, so exit (in graphics 2 and multicolor no print-on-video)
2EDC: 3E01    	        ld      A,$01           ; no (we are in Text, G1 or ExG2), so activate the...
2EDE: 325A81  	        ld      (PRNTVIDEO),A   ; ...video buffer...
2EE1: C9      	        ret                     ; ...and return to caller
              	
              	; check an additional argument for SCREEN
2EE2: 2B      	CHKSCAR:dec     HL              ; dec 'cos GETCHR INCs
2EE3: CDC918  	        call    GETCHR          ; Get next character
2EE6: 37      	        scf                     ; set carry flag
2EE7: C8      	        ret     Z               ; return if nothing follows with Carry=1
2EE8: CDA616  	        call    CHKSYN          ; Make sure ',' follows
2EEB: 2C      	        defb    ','
2EEC: CDB124  	        call    GETINT          ; get value
2EEF: 1F      	        rra                     ; Carry=bit #0
2EF0: 3F      	        ccf                     ; invert Carry, so Carry=0 if arg. is 1, and Carry=1 otherwise (arg<>1)
2EF1: C9      	        ret                     ; return
              	
              	
              	; change the colors of the screen - Syntax is COLOR a,b,c where:
              	; a=foreground color / b=background color / c=border color
              	; a,b,c must be in a range between 1 and 15 (0 is transparent and it's not supported)
2EF2: CDB124  	COLOR:  call    GETINT          ; get first value
2EF5: CD992F  	        call    CHKCLR          ; check if it's in range 1~15
2EF8: 325E81  	        ld      (TMPBFR1),A     ; store it
2EFB: 3A4F81  	        ld      A,(SCR_MODE)    ; check screen mode
2EFE: FE03    	        cp      $03             ; is it multicolor mode?
2F00: 200D    	        jr      NZ,CNTCKCL      ; no, continue
2F02: 3E0F    	        ld      A,$0F           ; white for...
2F04: 325C81  	        ld      (FRGNDCLR),A    ; ...foreground (even it's not used in MC)
2F07: 3A5E81  	        ld      A,(TMPBFR1)     ; yes, so we stop here because in MC mode we just support border color
2F0A: 326281  	        ld      (TMPBFR3),A     ; move color into temp buffer 3
2F0D: 1834    	        jr      CLRMC           ; jump to set color
2F0F: CDA616  	CNTCKCL:call    CHKSYN          ; Make sure ',' follows
2F12: 2C      	        defb    ','
2F13: CDB124  	        call    GETINT          ; get second value
2F16: CD992F  	        call    CHKCLR          ; check if it's in range 1~15
2F19: 326081  	        ld      (TMPBFR2),A     ; store it
2F1C: 325D81  	        ld      (BKGNDCLR),A    ; and set as background color
2F1F: 3A4F81  	        ld      A,(SCR_MODE)    ; check screen mode
2F22: A7      	        and     A               ; is it text mode?
2F23: 281B    	        jr      Z,CLRTXT        ; yes, stop here because in text mode, background and border colors coincide
2F25: CDA616  	        call    CHKSYN          ; Make sure ',' follows
2F28: 2C      	        defb    ','
2F29: CDB124  	        call    GETINT          ; get third value
2F2C: CD992F  	        call    CHKCLR          ; check if it's in range 1~15
2F2F: 326281  	        ld      (TMPBFR3),A     ; store it
2F32: D5      	        push    DE              ; store DE
2F33: 3A4F81  	        ld      A,(SCR_MODE)    ; check screen mode
2F36: FE01    	        cp      $01             ; is it G1 mode?
2F38: 2810    	        jr      Z,CLRG1         ; yes, jump over
2F3A: FE02    	        cp      $02             ; is it G2 mode?
2F3C: 2815    	        jr      Z,CLRG2         ; yes, jump over
2F3E: 181C    	        jr      CLREX2          ; last case can only be ExG2
2F40: CD8C2F  	CLRTXT: call    MIXCLRS         ; mix foreground and background color nibbles in 1 byte
2F43: 326281  	CLRMC:  ld      (TMPBFR3),A     ; store color settings (for MC mode, we only set border color)
2F46: D5      	        push    DE              ; store DE
2F47: F3      	        di                      ; disable INTs
2F48: 182E    	        jr      SETBRCL         ; set colors and exit
2F4A: CD8C2F  	CLRG1:  call    MIXCLRS         ; mix foreground and background color nibbles in 1 byte
2F4D: 1601    	        ld      D,$01           ; repeat 1 time
2F4F: 0620    	        ld      B,$20           ; 32 bytes of colors
2F51: 1810    	        jr      LOADCLR         ; load colors
2F53: CD8C2F  	CLRG2:  call    MIXCLRS         ; mix foreground and background color nibbles in 1 byte
2F56: 1618    	        ld      D,$18           ; 18 pages of...
2F58: 0600    	        ld      B,$00           ; ...256 bytes each
2F5A: 1807    	        jr      LOADCLR         ; load colors
2F5C: CD8C2F  	CLREX2: call    MIXCLRS         ; mix foreground and background color nibbles in 1 byte
2F5F: 1608    	        ld      D,$08           ; 8 pages of...
2F61: 0600    	        ld      B,$00           ; ...256 bytes each
2F63: E5      	LOADCLR:push    HL              ; store HL
2F64: 210020  	        ld      HL,$2000        ; color table start: $2000
2F67: F3      	        di                      ; disable INTs
2F68: CDC905  	        call    SETVDPADRS
2F6B: 0E30    	        ld      C,VDP_DAT       ; VDP data mode
2F6D: ED79    	RPTLDCL:out     (C),A           ; after first byte, the VDP autoincrements VRAM pointer
2F6F: 00      	        nop
2F70: 00      	        nop
2F71: 10FA    	        djnz    RPTLDCL         ; repeat for 256 bytes (1 page)
2F73: 15      	        dec     D               ; did we fill up all the pages?
2F74: 20F7    	        jr      NZ,RPTLDCL      ; no, repeat
2F76: FB      	        ei
2F77: E1      	        pop     HL              ; retrieve HL
2F78: 87      	SETBRCL:add     A,A             ; move high nibble
2F79: 87      	        add     A,A             ; to right to get the
2F7A: 87      	        add     A,A             ; foreground color
2F7B: 87      	        add     A,A             ; into the low nibble
2F7C: 325C81  	        ld      (FRGNDCLR),A    ; store foreground color
2F7F: 3A6281  	        ld      A,(TMPBFR3)     ; recover border color
2F82: 5F      	        ld      E,A             ; move A into E
2F83: 3E07    	        ld      A,$07           ; VDP register 7
2F85: F3      	        di
2F86: CD1306  	        call    WRITE_VREG      ; send value to VDP: set border color
2F89: FB      	        ei                      ; re-enable INTs
2F8A: D1      	        pop     DE              ; retrieve DE
2F8B: C9      	        ret                     ; return to caller
              	
              	
              	; mix 2 color nibbles in 1 byte
2F8C: 3A6081  	MIXCLRS:ld      A,(TMPBFR2)     ; retrieve background color
2F8F: 47      	        ld      B,A             ; move it into B
2F90: 3A5E81  	        ld      A,(TMPBFR1)     ; retrieve foreground color
2F93: 87      	        add     A,A             ; move foreground color into the high nibble of A
2F94: 87      	        add     A,A
2F95: 87      	        add     A,A
2F96: 87      	        add     A,A
2F97: B0      	        or      B               ; put background color into the low nibble of A
2F98: C9      	        ret                     ; return to caller
              	
              	
              	; check if the color is not 0 and into the range 1~15
2F99: A7      	CHKCLR: and     A               ; is it 0?
2F9A: CADB13  	        jp      Z,SNERR         ; yes, raise a SN error
2F9D: FE10    	        cp      $10             ; is it in range 1~15?
2F9F: D2DB13  	        jp      NC,SNERR        ; no, raise a SN error
2FA2: C9      	        ret                     ; param is OK, can return
              	
              	
              	; check if in graphics 2 mode
2FA3: 3A4F81  	CHKG2M: ld      A,(SCR_MODE)    ; check screen mode
2FA6: FE02    	        cp      $02             ; actually, we can paint only in G2
2FA8: C24C33  	        jp      NZ,GMERR        ; no G2, print a No Graphics Mode Error
2FAB: C9      	        ret                     ; return to caller
              	
              	
              	; PLOT X,Y[,color]
              	; plot a pixel in graphic mode 2
2FAC: CDA32F  	PLOT:   call    CHKG2M          ; check if in G2 mode
2FAF: CDB124  	        call    GETINT          ; get X coords.
2FB2: 325E81  	        ld      (TMPBFR1),A     ; store it into a temp buffer
2FB5: CDA616  	        call    CHKSYN          ; Make sure ',' follows
2FB8: 2C      	        defb    ','
2FB9: CDB124  	        call    GETINT          ; get Y coords,
2FBC: FEC0    	        cp      $C0             ; check if Y is in range 0~191
2FBE: D28819  	        jp      NC,FCERR        ; no, raise an FC error
2FC1: 326081  	        ld      (TMPBFR2),A     ; store into a temp buffer
2FC4: CD3333  	        call    CLRPRM          ; check if param "color" has been passed
2FC7: E5      	CNTPLOT:push    HL              ; store HL
2FC8: C5      	        push    BC              ; store BC
2FC9: D5      	        push    DE              ; store DE
              	        ; formula is: ADDRESS=(INT(X/8))*8 + (INT(Y/8))*256 + R(Y/8)
              	        ; where R(Y/8) is the remainder of (Y/8)
              	        ; the pixel to be set is given by R(X/8), and data is taken from the array
2FCA: 3A6081  	        ld      A,(TMPBFR2)     ; retrieve Y
2FCD: FEC0    	        cp      $C0             ; Y>=192?
2FCF: D21930  	        jp      NC,NOGD         ; yes, so leave
2FD2: 1E08    	        ld      E,$08           ; load E with divisor
2FD4: 57      	        ld      D,A             ; and store into D (dividend)
2FD5: CD6F36  	        call    DIV_8_8         ; get Y/8, D is quotient=INT(Y/8), and A is remainder
2FD8: 4F      	        ld      C,A             ; store remainder into C
2FD9: 42      	        ld      B,D             ; B=(INT(Y/8))*256 (we simply copy quotient into B)
2FDA: 6069    	        ld      HL,BC           ; copy BC into HL: now HL has the VRAM address of the byte being set
2FDC: 3A5E81  	        ld      A,(TMPBFR1)     ; retrieve X
2FDF: 57      	        ld      D,A             ; and move it into D (dividend)
2FE0: CD6F36  	        call    DIV_8_8         ; get X/8, D is quotient=INT(X/8), and A is remainder
2FE3: 4F      	        ld      C,A             ; store remainder into C
2FE4: 7A      	        ld      A,D             ; move quotient into A
2FE5: 87      	        add     A,A
2FE6: 87      	        add     A,A
2FE7: 87      	        add     A,A             ; multiply quotient by 8
2FE8: 5F      	        ld      E,A             ; store result into E
2FE9: 1600    	        ld      D,$00           ; reset D
2FEB: 19      	        add     HL,DE           ; add DE to HL, getting the final VRAM address
2FEC: EB      	        ex      DE,HL           ; move VRAM address into DE
2FED: 211D30  	        ld      HL,PXLSET       ; starting address of table for pixel to draw
2FF0: 0600    	        ld      B,$00           ; reset B
2FF2: 09      	        add     HL,BC           ; add C (remainder of X/8) to get address of pixel to turn on
2FF3: 7E      	        ld      A,(HL)          ; load pixel data
2FF4: EB      	        ex      DE,HL           ; retrieve VRAM pattern address into HL
2FF5: 57      	        ld      D,A             ; move pixel value into D
2FF6: 3A6281  	        ld      A,(TMPBFR3)     ; retrieve color
2FF9: 87      	        add     A,A             ; now we move low nibble
2FFA: 87      	        add     A,A             ; in the high nibble
2FFB: 87      	        add     A,A             ; by adding A to itself
2FFC: 87      	        add     A,A             ; 4 times (this is a shift left 4)
2FFD: 5F      	        ld      E,A             ; move it into E
2FFE: F3      	        di                      ; disable INTs
2FFF: CDE905  	        call    READ_VIDEO_LOC  ; load original value of VRAM cell
3002: FB      	        ei
3003: B2      	        or      D               ; plot new pixel preserving original pattern
3004: F3      	        di
3005: CDFE05  	        call    WRITE_VIDEO_LOC ; write new value into VRAM cell
3008: FB      	        ei
3009: CBEC    	        set     5,H             ; set to write into color VRAM (it's like adding $2000 to HL)
300B: F3      	        di
300C: CDE905  	        call    READ_VIDEO_LOC  ; load original colors of pixel
300F: FB      	        ei
3010: E60F    	        and     %00001111       ; reset high nibble (the foreground color)
3012: B3      	        or      E               ; set new foreground color
3013: F3      	        di
3014: CDFE05  	        call    WRITE_VIDEO_LOC ; write new color settings
3017: FB      	        ei                      ; re-enable INTs
3018: 00      	        nop                     ; wait for INTs to be enabled again
3019: D1      	NOGD:   pop     DE              ; retrieve DE
301A: C1      	        pop     BC              ; retrieve BC
301B: E1      	        pop     HL              ; retrieve HL
301C: C9      	        ret                     ; return to caller
301D: 80402010	PXLSET: defb    $80,$40,$20,$10,$08,$04,$02,$01 ; pixel to be set ON
3021: 08040201	
              	        ; where R(X/8)=> 0=80h, 1=40h, 2=20h, 3=10h, 4=08h, 5=04h, 6=02h, 7=$01
              	
              	; DRAW X1,Y1,X2,Y2[,color]
              	; Draw a line using Bresenham's line algorithm from X1,Y1 to X2,Y2
              	; X1,Y1 can be either less than or greater than X2,Y2 (meaning that)
              	; the drawing will be ever done from X1,Y2 to X2,Y2, regardless of
              	; the values. If color is not specified, the foreground color set
              	; with COLOR will be used 
815E:         	X1      equ     TMPBFR1
8160:         	Y1      equ     TMPBFR2
8166:         	X2      equ     VIDEOBUFF
8168:         	Y2      equ     VIDEOBUFF+$02
816A:         	ER      equ     VIDEOBUFF+$04
816C:         	E2      equ     VIDEOBUFF+$06
816E:         	SX      equ     VIDEOBUFF+$08
8170:         	SY      equ     VIDEOBUFF+$0A
8172:         	DX      equ     VIDEOBUFF+$0C
8174:         	DY      equ     VIDEOBUFF+$0E
3025: CDA32F  	DRAW:   call    CHKG2M          ; check if in G2 mode
3028: CD1B33  	        call    CLRVDBF         ; clear VIDEOBUFF
302B: CDB124  	        call    GETINT          ; get X1 coords.
302E: 325E81  	        ld      (X1),A          ; store it into a temp buffer
3031: CDA616  	        call    CHKSYN          ; Make sure ',' follows
3034: 2C      	        defb    ','
3035: CDB124  	        call    GETINT          ; get Y1 coords.
3038: FEC0    	        cp      $C0             ; check if Y1 is in range 0~191
303A: D28819  	        jp      NC,FCERR        ; no, raise an FC error
303D: 326081  	        ld      (Y1),A          ; store into a temp buffer
3040: CDA616  	        call    CHKSYN          ; Make sure ',' follows
3043: 2C      	        defb    ','
3044: CDB124  	        call    GETINT          ; get X2 coords.
3047: 326681  	        ld      (X2),A          ; store it into a temp buffer
304A: CDA616  	        call    CHKSYN          ; Make sure ',' follows
304D: 2C      	        defb    ','
304E: CDB124  	        call    GETINT          ; get Y2 coords
3051: FEC0    	        cp      $C0             ; check if Y2 is in range 0~191
3053: D28819  	        jp      NC,FCERR        ; no, raise an FC error
3056: 326881  	        ld      (Y2),A          ; store it into a temp buffer
3059: CD3333  	        call    CLRPRM          ; check for arg. "color" and store it into TMPBFR3
305C: E5      	        push    HL              ; store register we'll use
305D: D5      	        push    DE              
305E: C5      	        push    BC
305F: ED5B5E81	        ld      DE,(X1)         ; load X1 and
3063: 2A6681  	        ld      HL,(X2)         ; X2
3066: B7      	        or      A               ; clear CARRY
3067: ED52    	        sbc     HL,DE           ; DX=X2-X1
3069: CD6536  	        call    absHL           ; DX=ABS(DX)
306C: 227281  	        ld      (DX),HL         ; store DX
306F: 01FFFF  	        ld      BC,$FFFF        ; SX=-1
3072: 2A5E81  	        ld      HL,(X1)
3075: ED5B6681	        ld      DE,(X2)
3079: CD4036  	        call    CMP16           ; X1<X2?
307C: F28230  	        jp      P,X1GR          ; no, X1>=X2
307F: 010100  	        ld      BC,$0001        ; yes, so set SX=1
3082: ED436E81	X1GR:   ld      (SX),BC         ; store SX
3086: ED5B6081	        ld      DE,(Y1)
308A: 2A6881  	        ld      HL,(Y2)
308D: B7      	        or      A               ; clear Carry
308E: ED52    	        sbc     HL,DE           ; DY=Y2-Y1
3090: CD6536  	        call    absHL           ; DY=ABS(DY)
3093: 227481  	        ld      (DY),HL         ; store DY
3096: 01FFFF  	        ld      BC,$FFFF        ; SY=-1
3099: 2A6081  	        ld      HL,(Y1)
309C: ED5B6881	        ld      DE,(Y2)
30A0: CD4036  	        call    CMP16           ; is Y1<Y2?
30A3: F2A930  	        jp      P,Y1GR          ; no, Y1>=Y2
30A6: 010100  	        ld      BC,$0001        ; yes, so set SY=1
30A9: ED437081	Y1GR:   ld      (SY),BC         ; store SY
30AD: 2A7481  	        ld      HL,(DY)         ; ER=DY
30B0: CD6836  	        call    negHL           ; ER=-DY
30B3: 226A81  	        ld      (ER),HL         ; store ER
30B6: 2A7281  	        ld      HL,(DX)
30B9: ED5B7481	        ld      DE,(DY)
30BD: CD4036  	        call    CMP16           ; DX>DY?
30C0: CACC30  	        jp      Z,ER2           ; no, DX=DY
30C3: FACC30  	        jp      M,ER2           ; no, DX<DY
30C6: 2A7281  	        ld      HL,(DX)         ; reload DX
30C9: 226A81  	        ld      (ER),HL         ; yes: DX>DY, so ER=DX
30CC: 2A6A81  	ER2:    ld      HL,(ER)         ; load ER
30CF: CB2C    	        sra     H               ; right shift (and preserve sign)...
30D1: CB1D    	        rr      L               ; ...of HL, so ER=INT(ER/2)
30D3: 226A81  	STRE2:  ld      (ER),HL         ; store ER
30D6: CDC72F  	RPTDRW: call    CNTPLOT         ; plot first pixel
30D9: 2A5E81  	        ld      HL,(X1)
30DC: ED5B6681	        ld      DE,(X2)
30E0: CD4036  	        call    CMP16           ; X1=X2?
30E3: 200D    	        jr      NZ,CNTDRW       ; no, continue drawing
30E5: 2A6081  	        ld      HL,(Y1)         ; yes, so check
30E8: ED5B6881	        ld      DE,(Y2)         ; also Y
30EC: CD4036  	        call    CMP16           ; Y1=Y2?
30EF: CA4831  	        jp      Z,ENDDRAW       ; yes, finished drawing: exit
30F2: ED5B6A81	CNTDRW: ld      DE,(ER)
30F6: ED536C81	        ld      (E2),DE         ; E2=ER
30FA: 2A7281  	        ld      HL,(DX)
30FD: CD6836  	        call    negHL           ; DX=-DX
3100: EB      	        ex      DE,HL           ; invert DE and HL => HL=E2, DE=-DX
3101: CD4036  	        call    CMP16           ; E2>-DX?
3104: CA2231  	        jp      Z,DXGR          ; no, E2=-DX: jump
3107: FA2231  	        jp      M,DXGR          ; no, E2<-DX: jump
310A: 2A6A81  	        ld      HL,(ER)         ; yes
310D: ED5B7481	        ld      DE,(DY)
3111: B7      	        or      A               ; clear CARRY
3112: ED52    	        sbc     HL,DE           ; ER=ER-DY
3114: 226A81  	        ld      (ER),HL
3117: 2A5E81  	        ld      HL,(X1)
311A: ED5B6E81	        ld      DE,(SX)
311E: 19      	        add     HL,DE           ; X1=X1+SX (increment X1)
311F: 225E81  	        ld      (X1),HL
3122: 2A6C81  	DXGR:   ld      HL,(E2)
3125: ED5B7481	        ld      DE,(DY)
3129: CD4036  	        call    CMP16           ; E2<DY?
312C: F2D630  	        jp      P,RPTDRW        ; no, E2>=DY: so jump over
312F: 2A6A81  	        ld      HL,(ER)         ; yes
3132: ED5B7281	        ld      DE,(DX)
3136: 19      	        add     HL,DE           ; ER=ER+DX
3137: 226A81  	        ld      (ER),HL
313A: 2A6081  	        ld      HL,(Y1)
313D: ED5B7081	        ld      DE,(SY)
3141: 19      	        add     HL,DE           ; Y1=Y1+SY (increment Y1)
3142: 226081  	        ld      (Y1),HL
3145: C3D630  	        jp      RPTDRW          ; repeat
3148: C1      	ENDDRAW:pop     BC              ; retrieve BC
3149: D1      	        pop     DE              ; retrieve DE
314A: E1      	        pop     HL              ; retrieve HL
314B: C9      	        ret                     ; return to caller
              	
              	
              	; CIRCLE X,Y,R[,C]
              	; Draw a circle using Bresenham's circle algorithm with center in X,Y
              	; and radius R, with optional color C. If color is not specified, the
              	; foreground color set with COLOR will be used 
8166:         	XC      equ     VIDEOBUFF
8168:         	YC      equ     VIDEOBUFF+$02
816A:         	RADIUS  equ     VIDEOBUFF+$04
816C:         	XI      equ     VIDEOBUFF+$06
816E:         	YI      equ     VIDEOBUFF+$08
8170:         	DC      equ     VIDEOBUFF+$0A
314C: CDA32F  	CIRCLE: call    CHKG2M          ; check if in G2 mode
314F: CD1B33  	        call    CLRVDBF         ; clear VIDEOBUFF
3152: CDB124  	        call    GETINT          ; get X coords.
3155: 326681  	        ld      (XC),A          ; store it into a temp buffer
3158: CDA616  	        call    CHKSYN          ; Make sure ',' follows
315B: 2C      	        defb    ','
315C: CDB124  	        call    GETINT          ; get Y coords,
315F: 326881  	        ld      (YC),A          ; store it into a temp buffer
3162: CDA616  	        call    CHKSYN          ; Make sure ',' follows
3165: 2C      	        defb    ','
3166: CDB124  	        call    GETINT          ; get radius
3169: 326A81  	        ld      (RADIUS),A      ; store it into a temp buffer
316C: CD3333  	        call    CLRPRM          ; check if param "color" has been passed
316F: C5      	        push    BC              ; store BC
3170: D5      	        push    DE              ; store DE
3171: E5      	        push    HL              ; store HL
3172: AF      	        xor     A               ; clear A,
3173: 47      	        ld      B,A             ; B,
3174: 4F      	        ld      C,A             ; C,
3175: 57      	        ld      D,A             ; D,
3176: 67      	        ld      H,A             ; and H
3177: ED436C81	        ld      (XI),BC         ; clear XI
317B: 3A6A81  	        ld      A,(RADIUS)      ; load RADIUS into A
317E: 6F      	        ld      L,A             ; HL now contains R
317F: 226E81  	        ld      (YI),HL         ; YI=RADIUS
3182: 29      	        add     HL,HL           ; R*2
3183: EB      	        ex      DE,HL           ; put HL into DE
3184: 210300  	        ld      HL,$0003        ; now HL is 3
3187: AF      	        xor     A               ; clear Carry
3188: ED52    	        sbc     HL,DE           ; HL=>D=3-(2*R)
318A: 227081  	        ld      (DC),HL         ; store D
318D: CDEC31  	        call    DRWCRL          ; draw initial point
3190: ED5B6C81	RPTCRL: ld      DE,(XI)         ; load XI
3194: 2A6E81  	        ld      HL,(YI)         ; load YI
3197: CD4036  	        call    CMP16           ; is YI<DI?
319A: CAA331  	        jp      Z,RPTCL1        ; no, YI=XI
319D: F2A331  	        jp      P,RPTCL1        ; no, YI>XI
31A0: C3E831  	        jp      ENDCRL          ; yes, so we've finished
31A3: 216C81  	RPTCL1: ld      HL,XI
31A6: 34      	        inc     (HL)            ; XI=XI+1
31A7: 2A7081  	        ld      HL,(DC)         ; load D
31AA: 7C      	        ld      A,H
31AB: B5      	        or      L               ; is D=0? Yes, jump over
31AC: CAD031  	        jp      Z,DLSZ
31AF: CB7C    	        bit     7,H             ; is D<0?
31B1: 201D    	        jr      NZ,DLSZ         ; yes, jump over
31B3: ED5B6E81	        ld      DE,(YI)         ; D>0
31B7: 1B      	        dec     DE              ; so, YI=YI-1
31B8: ED536E81	        ld      (YI),DE         ; store YI
31BC: AF      	        xor     A               ; clear Carry
31BD: 2A6C81  	        ld      HL,(XI)
31C0: ED52    	        sbc     HL,DE           ; HL=XI-YI
31C2: 29      	        add     HL,HL
31C3: 29      	        add     HL,HL           ; HL=HL*4
31C4: 110A00  	        ld      DE,10
31C7: 19      	        add     HL,DE           ; HL=HL+10
31C8: ED5B7081	        ld      DE,(DC)         ; load D
31CC: EB      	        ex      DE,HL           ; invert DE and HL, so that HL=4*(XI-YI)+10 and DE=D
31CD: 19      	        add     HL,DE           ; D=D+4*(XI-YI)+10
31CE: 180F    	        jr      PLTCRL          ; plot next pixel
31D0: 2A6C81  	DLSZ:   ld      HL,(XI)         ; load XI
31D3: 29      	        add     HL,HL
31D4: 29      	        add     HL,HL           ; XI=XI*4
31D5: 110600  	        ld      DE,$0006
31D8: 19      	        add     HL,DE
31D9: ED5B7081	        ld      DE,(DC)
31DD: EB      	        ex      DE,HL           ; HL=D and DE=4*XI+6
31DE: 19      	        add     HL,DE           ; D=D+4*XI+6
31DF: 227081  	PLTCRL: ld      (DC),HL         ; store new D
31E2: CDEC31  	        call    DRWCRL          ; plot pixel
31E5: C39031  	        jp      RPTCRL          ; repeat
31E8: E1      	ENDCRL: pop     HL
31E9: D1      	        pop     DE
31EA: C1      	        pop     BC
31EB: C9      	        ret                     ; return to caller
31EC: 2A6681  	DRWCRL: ld      HL,(XC)
31EF: ED5B6C81	        ld      DE,(XI)
31F3: 19      	        add     HL,DE           ; X=XC+XI
31F4: 225E81  	        ld      (X1),HL         ; store X
31F7: CD0B33  	        call    VALIDX          ; check if X is valid (0~255)
31FA: DA0E32  	        jp      C,CNTCL1        ; if Carry is set, X is not valid
31FD: 2A6881  	        ld      HL,(YC)
3200: ED5B6E81	        ld      DE,(YI)
3204: 19      	        add     HL,DE           ; Y=YC+YI
3205: 226081  	        ld      (Y1),HL         ; store Y
3208: CD1033  	        call    VALIDY          ; check if Y is valid (0~191)
320B: D4C72F  	        call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
320E: AF      	CNTCL1: xor     A               ; clear Carry
320F: 2A6681  	        ld      HL,(XC)
3212: ED5B6C81	        ld      DE,(XI)
3216: ED52    	        sbc     HL,DE           ; X=XC-XI
3218: 225E81  	        ld      (X1),HL         ; store X
321B: CD0B33  	        call    VALIDX          ; check if X is valid (0~255)
321E: DA3232  	        jp      C,CNTCL2        ; if Carry is set, X is not valid
3221: 2A6881  	        ld      HL,(YC)
3224: ED5B6E81	        ld      DE,(YI)
3228: 19      	        add     HL,DE           ; Y=YC+YI
3229: 226081  	        ld      (Y1),HL         ; store Y
322C: CD1033  	        call    VALIDY          ; check if Y is valid (0~191)
322F: D4C72F  	        call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
3232: 2A6681  	CNTCL2: ld      HL,(XC)
3235: ED5B6C81	        ld      DE,(XI)
3239: 19      	        add     HL,DE           ; X=XC+XI
323A: 225E81  	        ld      (X1),HL         ; store X
323D: CD0B33  	        call    VALIDX          ; check if X is valid (0~255)
3240: DA5632  	        jp      C,CNTCL3        ; if Carry is set, X is not valid
3243: AF      	        xor     A               ; clear Carry
3244: 2A6881  	        ld      HL,(YC)
3247: ED5B6E81	        ld      DE,(YI)
324B: ED52    	        sbc     HL,DE           ; Y=YC-YI
324D: 226081  	        ld      (Y1),HL         ; store Y
3250: CD1033  	        call    VALIDY          ; check if Y is valid (0~191)
3253: D4C72F  	        call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
3256: AF      	CNTCL3: xor     A               ; clear Carry
3257: 2A6681  	        ld      HL,(XC)
325A: ED5B6C81	        ld      DE,(XI)
325E: ED52    	        sbc     HL,DE           ; X=XC-XI
3260: 225E81  	        ld      (X1),HL         ; store X
3263: CD0B33  	        call    VALIDX          ; check if X is valid (0~255)
3266: DA7C32  	        jp      C,CNTCL4        ; if Carry is set, X is not valid
3269: AF      	        xor     A               ; clear Carry
326A: 2A6881  	        ld      HL,(YC)
326D: ED5B6E81	        ld      DE,(YI)
3271: ED52    	        sbc     HL,DE           ; Y=YC-YI
3273: 226081  	        ld      (Y1),HL         ; store Y
3276: CD1033  	        call    VALIDY          ; check if Y is valid (0~191)
3279: D4C72F  	        call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
327C: 2A6681  	CNTCL4: ld      HL,(XC)
327F: ED5B6E81	        ld      DE,(YI)
3283: 19      	        add     HL,DE           ; X=XC+YI
3284: 225E81  	        ld      (X1),HL         ; store X
3287: CD0B33  	        call    VALIDX          ; check if X is valid (0~255)
328A: DA9E32  	        jp      C,CNTCL5        ; if Carry is set, X is not valid
328D: 2A6881  	        ld      HL,(YC)
3290: ED5B6C81	        ld      DE,(XI)
3294: 19      	        add     HL,DE           ; Y=YC+XI
3295: 226081  	        ld      (Y1),HL         ; store Y
3298: CD1033  	        call    VALIDY          ; check if Y is valid (0~191)
329B: D4C72F  	        call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
329E: AF      	CNTCL5: xor     A               ; clear Carry
329F: 2A6681  	        ld      HL,(XC)
32A2: ED5B6E81	        ld      DE,(YI)
32A6: ED52    	        sbc     HL,DE           ; X=XC-YI
32A8: 225E81  	        ld      (X1),HL         ; store X
32AB: CD0B33  	        call    VALIDX          ; check if X is valid (0~255)
32AE: DAC232  	        jp      C,CNTCL6        ; if Carry is set, X is not valid
32B1: 2A6881  	        ld      HL,(YC)
32B4: ED5B6C81	        ld      DE,(XI)
32B8: 19      	        add     HL,DE           ; Y=YC+XI
32B9: 226081  	        ld      (Y1),HL         ; store Y
32BC: CD1033  	        call    VALIDY          ; check if Y is valid (0~191)
32BF: D4C72F  	        call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
32C2: 2A6681  	CNTCL6: ld      HL,(XC)
32C5: ED5B6E81	        ld      DE,(YI)
32C9: 19      	        add     HL,DE           ; X=XC+YI
32CA: 225E81  	        ld      (X1),HL         ; store X
32CD: CD0B33  	        call    VALIDX          ; check if X is valid (0~255)
32D0: DAE632  	        jp      C,CNTCL7        ; if Carry is set, X is not valid
32D3: AF      	        xor     A               ; clear Carry
32D4: 2A6881  	        ld      HL,(YC)
32D7: ED5B6C81	        ld      DE,(XI)
32DB: ED52    	        sbc     HL,DE           ; Y=YC-XI
32DD: 226081  	        ld      (Y1),HL         ; store Y
32E0: CD1033  	        call    VALIDY          ; check if Y is valid (0~191)
32E3: D4C72F  	        call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
32E6: AF      	CNTCL7: xor     A               ; clear Carry
32E7: 2A6681  	        ld      HL,(XC)
32EA: ED5B6E81	        ld      DE,(YI)
32EE: ED52    	        sbc     HL,DE           ; X=XC-YI
32F0: 225E81  	        ld      (X1),HL         ; store X
32F3: CD0B33  	        call    VALIDX          ; check if X is valid (0~255)
32F6: D8      	        ret     C               ; if Carry is set, X is not valid
32F7: AF      	        xor     A               ; clear Carry
32F8: 2A6881  	        ld      HL,(YC)
32FB: ED5B6C81	        ld      DE,(XI)
32FF: ED52    	        sbc     HL,DE           ; Y=YC-XI
3301: 226081  	        ld      (Y1),HL         ; store Y
3304: CD1033  	        call    VALIDY          ; check if Y is valid (0~191)
3307: D4C72F  	        call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
330A: C9      	        ret                     ; return to caller
              	
              	; check if X,Y coordinates are valid: 0<=X<=255 and 0<=Y<=191
              	; input: HL (value to check), can be negative
              	; output: CARRY flag: reset => VALID  //  set => NOT VALID
              	; destroys: A
330B: AF      	VALIDX: xor     A               ; reset A
330C: B4      	        or      H               ; check if H is 0 (this means that X is in range 0~255 and not negative)
330D: C8      	        ret     Z               ; yes, we can return (C is clear)
330E: 37      	        scf                     ; set Carry flag to raise error
330F: C9      	        ret                     ; return to caller
              	
3310: AF      	VALIDY: xor     A               ; reset A
3311: B4      	        or      H               ; check if H is 0 (this means that Y is in range 0~255 and not negative)
3312: 2802    	        jr      Z,CNTVALY       ; yes, continue checking
3314: 37      	        scf                     ; no, raise error by setting Carry flag
3315: C9      	        ret                     ; return to caller
3316: 7D      	CNTVALY:ld      A,L
3317: FEC0    	        cp      $C0             ; is Y<192? Carry is set if Y<192
3319: 3F      	        ccf                     ; invert Carry, so Carry=0 means OK, Carry=1 means ERROR
331A: C9      	        ret                     ; return to caller
              	
              	
              	; clear VIDEOBUFF before using it as temp buffer
331B: AF      	CLRVDBF:xor     A               ; clear A
331C: C5      	        push    BC              ; store BC
331D: E5      	        push    HL              ; store HL
331E: 215E81  	        ld      HL,TMPBFR1      ; address of 1st cell
3321: 0606    	        ld      B,$06           ; 6 cells
3323: 77      	RPTCVB1:ld      (HL),A          ; clear cell
3324: 23      	        inc     HL              ; next cell
3325: 10FC    	        djnz    RPTCVB1         ; repeat
3327: 0628    	        ld      B,$28           ; 40 cells
3329: 216681  	        ld      HL,VIDEOBUFF    ; address of 1st cell
332C: 77      	RPTCVB2:ld      (HL),A          ; clear cell
332D: 23      	        inc     HL              ; next cell
332E: 10FC    	        djnz    RPTCVB2         ; repeat
3330: E1      	        pop     HL              ; retrieve HL
3331: C1      	        pop     BC              ; retrieve BC
3332: C9      	        ret                     ; return to caller
              	
              	
              	; check if a color is passed as argument with PLOT, DRAW, and CIRCLE
              	; commands. If not present, the default foreground color will be used
3333: 3A5C81  	CLRPRM: ld      A,(FRGNDCLR)    ; load foreground color
3336: 326281  	        ld      (TMPBFR3),A     ; store into temp buffer
3339: 2B      	        dec     HL              ; dec 'cos GETCHR INCs
333A: CDC918  	        call    GETCHR          ; Get next character
333D: C8      	        ret     Z               ; return if nothing follows
333E: CDA616  	        call    CHKSYN          ; Make sure ',' follows
3341: 2C      	        defb    ','
3342: CDB124  	        call    GETINT          ; get value
3345: CD992F  	        call    CHKCLR          ; check if color is in range 1~15
3348: 326281  	        ld      (TMPBFR3),A     ; store color into temp buffer
334B: C9      	        ret                     ; return to caller
              	
              	
              	; no graphics mode error: raised when a graphics command is invoked
              	; out of graphic 2 mode.
334C: 1E2A    	GMERR:  ld      E,GM            ; load Graphics Mode Error flag
334E: C3EF13  	        jp      ERROR           ; print error
              	
              	
              	; set a serial port: params are PORT,BPS,DATA,PARITY,STOP
              	; PORT=1/2; BPS=1,200~57,600 (see below), DATA=5/6/7/8
              	; PARITY: 0=no parity; 1=ODD parity; 2=EVEN parity;
              	; STOP=0/1/2/3: 0=0 bit; 1=1 bit; 2=1.5 bits; 3=2 bits
              	; PORT 1 acts as a char device; PORT 2 acts as a block device
8166:         	PRTNUM  equ     VIDEOBUFF
8167:         	BPS     equ     VIDEOBUFF+$01
8169:         	DATABT  equ     BPS+$02
816A:         	PARBT   equ     DATABT+$01
816B:         	STPBT   equ     PARBT+$01
816C:         	SIOBFR  equ     STPBT+$01
3351: CDB124  	SERIAL: call    GETINT          ; get port #
3354: A7      	        and     A               ; is it zero?
3355: CA8819  	        jp      Z,FCERR         ; yes, error
3358: FE03    	        cp      $03             ; is it 1 or 2?
335A: D22535  	        jp      NC,SCERR        ; no, error
335D: 326681  	        ld      (PRTNUM),A      ; store port number into a temp buffer
3360: CDA616  	        call    CHKSYN          ; Make sure ',' follows
3363: 2C      	        defb    ','
3364: CD8D19  	        call    ATOH            ; get bps (returned into DE)
3367: 7A      	        ld      A,D             ; move MSB into A
3368: B3      	        or      E               ; LSB OR MSB, to check if bps=0
3369: 203A    	        jr      NZ,CNTSER       ; no, continue checking
              	        ; if baud rate is 0, then close the serial comm.
336B: 3A6681  	RSTSER1:ld      A,(PRTNUM)      ; yes, so reset the channel. First, load port number
336E: 3D      	        dec     A               ; subtract 1, so that serial channel is 0=>A and 1=>B
336F: C622    	        add     SIO_CA          ; find correct channel
3371: 4F      	        ld      C,A             ; store serial channel
3372: F3      	        di                      ; disable INTs
3373: AF      	        xor     A               ; reset A
3374: 1601    	        ld      D,$01           ; start from WR1
3376: 0605    	        ld      B,$05           ; 5 registers
3378: ED51    	RPTRSSR:out     (C),D           ; select register
337A: ED79    	        out     (C),A           ; reset register
337C: 14      	        inc     D               ; next register
337D: 10F9    	        djnz    RPTRSSR         ; repeat
337F: 3E30    	        ld      A,%00110000     ; write into WR0: error reset, select WR0
3381: ED79    	        out     (C),A           ; send command to serial channel
3383: 3E18    	        ld      A,%00011000     ; write into WR0: channel reset
3385: ED79    	        out     (C),A           ; send command to serial channel
3387: FB      	        ei                      ; re-enable INTs
3388: E5      	        push    HL              ; store HL
3389: 219D81  	        ld      HL,SERIALS_EN   ; serials enabled status byte
338C: DB01    	        in      A,(PIO_DB)      ; read status LEDs
338E: CB41    	        bit     0,C             ; check serial port
3390: 2009    	        jr      NZ,SRPT2        ; if bit is set, jump to port 2
3392: CBB7    	        res     6,A             ; it's port 1
3394: CBA7    	        res     4,A             ; remove possible error LED
3396: CB86    	        res     0,(HL)          ; disable port 1
3398: C3A133  	        jp      SERLED          ; jump over
339B: CBBF    	SRPT2:  res     7,A             ; it's port 2
339D: CBAF    	        res     5,A             ; remove possible error LED
339F: CB8E    	        res     1,(HL)          ; disable port 2
33A1: D301    	SERLED: out     (PIO_DB),A      ; send new configuration
33A3: E1      	        pop     HL              ; retrieve HL
33A4: C9      	        ret                     ; return to caller
              	        ; check if bps=1, meaning reactivate RX on serial
33A5: 7A      	CNTSER: ld      A,D
33A6: B2      	        or      D               ; check if bps<>1 by first checking D=0
33A7: 203B    	        jr      NZ,CNTSER2      ; if not, jump over
33A9: 7B      	        ld      A,E             ; then by checking that
33AA: FE01    	        cp      $01             ; E=1
33AC: 2036    	        jr      NZ,CNTSER2      ; if not, jump over
33AE: 3A6681  	        ld      A,(PRTNUM)      ; load port number
33B1: FE01    	        cp      $01             ; is it port 1? (currently do NOT support on port 2)
33B3: C22535  	        jp      NZ,SCERR        ; no, raise error and exit 
33B6: 57      	        ld      D,A             ; store port on D
33B7: 3A9D81  	        ld      A,(SERIALS_EN)  ; load address of serial status cell
33BA: A2      	        and     D               ; check status
33BB: CA2535  	        jp      Z,SCERR         ; port not open, raise error
33BE: F3      	        di                      ; disable INTs
33BF: 7A      	        ld      A,D             ; move port # into A
33C0: 5F      	        ld      E,A             ; store original A into E
33C1: 87      	        add     A
33C2: 87      	        add     A               ; move A to left times 2
33C3: 57      	        ld      D,A             ; move value into D
33C4: 3A9D81  	        ld      A,(SERIALS_EN)  ; load serial status byte
33C7: B2      	        or      D               ; re-enable RX
33C8: 329D81  	        ld      (SERIALS_EN),A  ; store new serial status
33CB: 7B      	        ld      A,E             ; recover port #
33CC: 3D      	        dec     A               ; check port
33CD: 200A    	        jr      NZ,CNTRX2       ; port is #2
33CF: CD8801  	        call    SIO_A_EI        ; re-enable RX on port 1
33D2: DB01    	        in      A,(PIO_DB)      ; load status LEDs
33D4: CBA7    	        res     4,A             ; remove error LED
33D6: C3E033  	        jp      RXEND           ; terminate setting
33D9: CD8801  	CNTRX2: call    SIO_A_EI        ; re-enable RX on port 2 -> CURRENTLY only port 1 is supported
33DC: DB01    	        in      A,(PIO_DB)      ; load status LEDs
33DE: CBAF    	        res     5,A             ; remove error LED
33E0: D301    	RXEND:  out     (PIO_DB),A      ; set new status for LEDs
33E2: FB      	        ei                      ; re-enable INTs
33E3: C9      	        ret                     ; return to caller
              	        ; set serial port comm.
33E4: D5      	CNTSER2:push    DE              ; store BPS
33E5: 3A6681  	        ld      A,(PRTNUM)      ; load port number
33E8: 57      	        ld      D,A             ; move port # into D
33E9: 3A9D81  	        ld      A,(SERIALS_EN)  ; check if serial port is already open
33EC: A2      	        and     D               ; by ANDing A with D
33ED: D1      	        pop     DE              ; retrieve BPS
33EE: CAF633  	        jp      Z,CNTSER3       ; not open, continue
33F1: 1E2E    	        ld      E,SA            ; already open, so raise a "Serial Port Already Error"
33F3: C3EF13  	        jp      ERROR           ; and leave
33F6: E5      	CNTSER3:push    HL              ; store HL   
33F7: 2100E1  	        ld      HL,$E100        ; check bps. start with HL=57,600
33FA: CD4036  	        call    CMP16           ; is bps<=57,600?
33FD: E1      	        pop     HL              ; but first, recover HL
33FE: DA2535  	        jp      C,SCERR         ; no (bps>57,600) then error
3401: ED536781	        ld      (BPS),DE        ; store bps
3405: CDA616  	        call    CHKSYN          ; Make sure ',' follows
3408: 2C      	        defb    ','
3409: CDB124  	        call    GETINT          ; get data bits
340C: FE05    	        cp      $05             ; is it <5?
340E: DA2535  	        jp      C,SCERR         ; yes, error
3411: FE09    	        cp      $09             ; is it >=9?
3413: D28819  	        jp      NC,FCERR        ; no, error
3416: 326981  	        ld      (DATABT),A      ; store data bits
3419: CDA616  	        call    CHKSYN          ; Make sure ',' follows
341C: 2C      	        defb    ','
341D: CDB124  	        call    GETINT          ; get parity bits
3420: FE03    	        cp      A,$03           ; check if parity is in range 0~2
3422: D22535  	        jp      NC,SCERR        ; no, error
3425: 326A81  	        ld      (PARBT),A       ; store parity
3428: CDA616  	        call    CHKSYN          ; Make sure ',' follows
342B: 2C      	        defb    ','
342C: CDB124  	        call    GETINT          ; get stop bits
342F: FE03    	        cp      $03             ; is it >=3?
3431: D22535  	        jp      NC,SCERR        ; yes, error
3434: 326B81  	        ld      (STPBT),A       ; store stop bits
              	        ; check if bps are legal
3437: E5      	        push    HL              ; store HL 
3438: D5      	        push    DE              ; store DE
3439: DDE5    	        push    IX              ; store IX
343B: DD210035	        ld      IX,SUP_BPS      ; allowed BPSs
343F: 060B    	        ld      B,$0B           ; 11 items
3441: 0E00    	        ld      C,$00           ; reset pointer
3443: 2A6781  	CKBPS:  ld      HL,(BPS)        ; load BPS
3446: DD5E00  	        ld      E,(IX+0)        ; load LSB of item
3449: DD5601  	        ld      D,(IX+1)        ; load MSB of item
344C: CD4036  	        call    CMP16           ; is it equal?
344F: CA5C34  	        jp      Z,FNDBPS        ; yes, found correspondance
3452: DD23    	        inc     IX
3454: DD23    	        inc     IX              ; no, go to next entry
3456: 0C      	        inc     C               ; increment pointer
3457: 10EA    	        djnz    CKBPS           ; repeat for 10 entries
3459: C32135  	        jp      SCERR1          ; if nothing found, raise an error
345C: 3A6681  	FNDBPS: ld      A,(PRTNUM)      ; check serial port
345F: 3D      	        dec     A               ; is it port 1?
3460: CA6634  	        jp      Z,SET_P1        ; yes, set port 1
3463: C32135  	        jp      SCERR1          ; at the moment, only port 1 can be configured
3466:         	SET_P1: ;init CTC CH0: CH0 provides RX/TX clock to SIO port A
              	        ; TO0 output frequency=INPUT CLK/time constant. Time constant is set to get 16 times
              	        ; the requested baud rate. I.e., if bps is 19,200 then time constast is set to 6 because
              	        ; 1,843,200/6 = 307,200 Hz (that is 19,200 x 16)
3466: F3      	        di                      ; disable INTs
3467: 0600    	        ld      B,$00           ; reset B
3469: 211635  	        ld      HL,CTC_CFG      ; address of first CTC divider
346C: 09      	        add     HL,BC           ; adjust for corret CTC divider
346D: 3E47    	        ld      A,%01000111     ; interrupt off, counter mode, prsc=16 (doesn't matter), ext. start,
              	                                ; start upon loading time constant, time constant follows, sw reset, command word
346F: D310    	        out     (CTC_CH0),A     ; configure CTC channel 0
3471: 7E      	        ld      A,(HL)          ; load CTC divider
3472: D310    	        out     (CTC_CH0),A     ; send divider
              	        ; configure SIO
3474: 21F102  	        ld      HL,SIO_A_SETS   ; load default settings for SIO
3477: 116C81  	        ld      DE,SIOBFR       ; into a temp buffer
347A: 010A00  	        ld      BC,$000A        ; 10 items to copy
347D: EDB0    	        ldir                    ; copy SIO settings into TEMP buffer
347F: 3A7181  	        ld      A,(SIOBFR+5)    ; load WR5 setting
3482: 47      	        ld      B,A             ; move it into B
3483: 3A6981  	        ld      A,(DATABT)      ; load DATA bits
3486: FE05    	        cp      $05             ; is it 5 bits?
3488: 2006    	        jr      NZ,BITS6        ; no, jump over
348A: CBB0    	        res     6,B
348C: CBA8    	        res     5,B             ; set D6 & D5 to 0
348E: 1819    	        jr      SETPAR          ; jump to set parity
3490: FE06    	BITS6:  cp      $06             ; is it 6 bits?
3492: 2006    	        jr      NZ,BITS7        ; no, jump over
3494: CBF0    	        set     6,B
3496: CBA8    	        res     5,B             ; set D6 & D5 to 1,0
3498: 180F    	        jr      SETPAR          ; jump to set parity
349A: FE07    	BITS7:  cp      $07             ; is it 7 bits?
349C: 2007    	        jr      NZ,BITS8        ; no, jump over
349E: CBB0    	        res     6,B
34A0: CBE8    	        set     5,B             ; set D6 & D5 to 0,1
34A2: C3A934  	        jp      SETPAR          ; jump to set parity
34A5: CBF0    	BITS8:  set     6,B
34A7: CBE8    	        set     5,B             ; set D6 & D5 to 1,1
34A9: 78      	SETPAR: ld      A,B
34AA: 327181  	        ld      (SIOBFR+5),A    ; save DATA bits
34AD: E660    	        and     %01100000       ; filter only D5&D6 bits
34AF: 87      	        add     A,A             ; shift left times 1
34B0: 329E81  	        ld      (SERABITS),A    ; store for SIO_A_EI & SIO_A_DI functions
34B3: 3A6B81  	        ld      A,(STPBT)       ; load STOP bits
34B6: 87      	        add     A,A
34B7: 87      	        add     A,A             ; 2 left shifts
34B8: 47      	        ld      B,A             ; move forming byte into B
34B9: 3A6A81  	        ld      A,(PARBT)       ; load PARITY setting
34BC: A7      	        and     A               ; is it 0?
34BD: CAC834  	        jp      Z,STRPAR        ; yes, jump over
34C0: CBC0    	        set     0,B             ; set PARITY on
34C2: 3D      	        dec     A               ; is parity ODD?
34C3: CAC834  	        jp      Z,STRPAR        ; yes, so jump over
34C6: CBC8    	        set     1,B             ; no, it's EVEN so set the corresponding bit
34C8: 3A6F81  	STRPAR: ld      A,(SIOBFR+3)    ; load WR4 setting
34CB: E6F0    	        and     %11110000       ; reset STOP & PARITY bits
34CD: B0      	        or      B               ; set new STOP & PARITY bits
34CE: 326F81  	        ld      (SIOBFR+3),A    ; store new value
              	        ;set up TX and RX:
              	        ; the followings are settings for channel A
34D1: 216C81  	        ld      HL,SIOBFR       ; settings for SIO ch. A
34D4: 0606    	        ld      B,$06           ; 6 bytes to send
34D6: 0E22    	        ld      C,SIO_CA        ; I/O address of SIO ch.A
34D8: EDB3    	        otir                    ; send bytes to SIO
              	        ; the following are settings for channel B (don't need to load HL since settings are contigous)
34DA: 0604    	        ld      B,$04           ; other 4 bytes to send
34DC: 0E23    	        ld      C,SIO_CB        ; I/O address of SIO ch.B
34DE: EDB3    	        otir                    ; send bytes to SIO
              	        ; the following are settings for channel A
34E0: 3E01    	        ld      A,$01           ; write into WR0: select WR1
34E2: D322    	        out     (SIO_CA),A
34E4: 3E18    	        ld      A,%00011000     ; interrupts on every RX char; parity is no special condition;
              	                                ; buffer overrun is special condition
34E6: D322    	        out     (SIO_CA),A
34E8: CD8801  	        call    SIO_A_EI        ; enable RX on SIO channel A
34EB: 219D81  	EXITSER:ld      HL,SERIALS_EN
34EE: CBC6    	        set     0,(HL)          ; set serial port 1 status ON
34F0: CBD6    	        set     2,(HL)          ; set serial port 1 RX ON
              	        ; back to normal running
34F2: FB      	        ei                      ; re-enable INTs
34F3: DB01    	        in      A,(PIO_DB)      ; load status LEDs
34F5: CBF7    	        set     6,A             ; set status LED on
34F7: CBA7    	        res     4,A             ; set error LED off
34F9: D301    	        out     (PIO_DB),A      ; send new configuration
34FB: DDE1    	        pop     IX              ; retrieve IX
34FD: D1      	        pop     DE              ; retrieve DE
34FE: E1      	        pop     HL              ; retrieve HL
34FF: C9      	        ret                     ; return to caller
              	
              	; allowed bps (Bauds per second)
3500: 00E10096	SUP_BPS:defw    57600,38400,28800,19200,14400,9600,4800,3600,2400,1200,600
3504: 8070004B	
3508: 40388025	
350C: C012100E	
3510: 6009B004	
3514: 5802    	
              	; corresponding CTC divider
3516: 02030406	CTC_CFG:defb    2,3,4,6,8,12,24,32,48,96,192
351A: 080C1820	
351E: 3060C0  	
              	
              	
              	; serial configuration error
3521: DDE1    	SCERR1: pop     IX              ; retrieve IX
3523: D1      	        pop     DE              ; retrieve DE
3524: E1      	        pop     HL              ; retrieve HL
3525: 1E2C    	SCERR:  ld      E,SC            ; Serial Configuration Error
3527: C3EF13  	        jp      ERROR           ; print error
              	
              	
              	; HEX$(nn) Convert 16 bit number to Hexadecimal string
352A: CD2D1D  	HEX: 	call	TSTNUM          ; Verify it's a number
352D: CD7319  	        call	DEINT           ; Get integer -32768 to 32767
3530: C5      	        push	BC              ; Save contents of BC
3531: 219F81  	        ld      HL,PBUFF        ; load address of PBUFF into HL
3534: 7A      	        ld      A,D             ; Get MSB into A
3535: B7      	        or      A               ; OR with LSB to see if param=0
3536: 280C    	        jr      Z,HEX2          ; Skip output if both high digits are zero
3538: CD6035  	        call    BYT2ASC         ; Convert D to ASCII
353B: 78      	        ld      A,B             ; cechk if B
353C: FE30    	        cp      '0'             ; is 0
353E: 2802    	        jr      Z,HEX1          ; Don't store high digit if zero
3540: 70      	        ld      (HL),B          ; Store it to PBUFF
3541: 23      	        inc     HL              ; Next location
3542: 71      	HEX1:   ld      (HL),C          ; Store C to PBUFF+1
3543: 23      	        inc     HL              ; Next location
3544: 7B      	HEX2:   ld      A,E             ; Get lower byte
3545: CD6035  	        call    BYT2ASC         ; Convert E to ASCII
3548: 7A      	        ld      A,D
3549: B7      	        or      A
354A: 2005    	        jr      NZ,HEX3         ; If upper byte was not zero then always print lower byte
354C: 78      	        ld      A,B
354D: FE30    	        cp      '0'             ; If high digit of lower byte is zero then don't print
354F: 2802    	        jr      Z,HEX4
3551: 70      	HEX3:   ld      (HL),B          ; to PBUFF+2
3552: 23      	        inc     HL              ; Next location
3553: 71      	HEX4:   ld      (HL),C          ; to PBUFF+3
3554: 23      	        inc     HL              ; PBUFF+4 to zero
3555: AF      	        xor     A               ; Terminating character
3556: 77      	        ld      (HL),A          ; Store zero to terminate
3557: 23      	        inc     HL              ; Make sure PBUFF is terminated
3558: 77      	        ld      (HL),A          ; Store the double zero there
3559: C1      	        pop     BC              ; Get BC back
355A: 219F81  	        ld      HL,PBUFF        ; Reset to start of PBUFF
355D: C3B921  	        jp      STR1            ; Convert the PBUFF to a string and return it
3560: 47      	BYT2ASC	ld      B,A             ; Save original value
3561: E60F    	        and     $0F             ; Strip off upper nybble
3563: FE0A    	        cp      $0A             ; 0-9?
3565: 3802    	        jr      C,ADD30         ; If A-F, add 7 more
3567: C607    	        add     A,$07           ; Bring value up to ASCII A-F
3569: C630    	ADD30	add     A,$30           ; And make ASCII
356B: 4F      	        ld      C,A             ; Save converted char to C
356C: 78      	        ld      A,B             ; Retrieve original value
356D: 0F      	        rrca                    ; and Rotate it right
356E: 0F      	        rrca
356F: 0F      	        rrca
3570: 0F      	        rrca
3571: E60F    	        and     $0F             ; Mask off upper nybble
3573: FE0A    	        cp      $0A             ; 0-9? < A hex?
3575: 3802    	        jr      C,ADD301        ; Skip Add 7
3577: C607    	        add     A,$07           ; Bring it up to ASCII A-F
3579: C630    	ADD301	add     A,$30           ; And make it full ASCII
357B: 47      	        ld      B,A             ; Store high order byte
357C: C9      	        ret
              	
              	; Convert "&Hnnnn" to FPREG
              	; Gets a character from (HL) checks for Hexadecimal ASCII numbers "&Hnnnn"
              	; Char is in A, NC if char is ;<=>?@ A-z, CY is set if 0-9
357D: EB      	HEXTFP  ex      DE,HL           ; Move code string pointer to DE
357E: 210000  	        ld      HL,$0000        ; Zero out the value
3581: CD9635  	        call    GETHEX          ; Check the number for valid hex
3584: DAB635  	        jp      C,HXERR         ; First value wasn't hex, HX error
3587: 1805    	        jr      HEXLP1          ; Convert first character
3589: CD9635  	HEXLP   call    GETHEX          ; Get second and addtional characters
358C: 381F    	        jr      C,HEXIT         ; Exit if not a hex character
358E: 29      	HEXLP1  add     HL,HL           ; Rotate 4 bits to the left
358F: 29      	        add     HL,HL
3590: 29      	        add     HL,HL
3591: 29      	        add     HL,HL
3592: B5      	        or      L               ; Add in D0-D3 into L
3593: 6F      	        ld      L,A             ; Save new value
3594: 18F3    	        jr      HEXLP           ; And continue until all hex characters are in
              	
3596: 13      	GETHEX  inc     DE              ; Next location
3597: 1A      	        ld      A,(DE)          ; Load character at pointer
3598: FE20    	        cp      SPC
359A: CA9635  	        jp      Z,GETHEX        ; Skip spaces
359D: D630    	        sub     $30             ; Get absolute value
359F: D8      	        ret     C               ; < "0", error
35A0: FE0A    	        cp      $0A
35A2: 3805    	        jr      C,NOSUB7        ; Is already in the range 0-9
35A4: D607    	        sub     $07             ; Reduce to A-F
35A6: FE0A    	        cp      $0A             ; Value should be $0A-$0F at this point
35A8: D8      	        ret     C               ; CY set if was :            ; < = > ? @
35A9: FE10    	NOSUB7  cp      $10             ; > Greater than "F"?
35AB: 3F      	        ccf
35AC: C9      	        ret                     ; CY set if it wasn't valid hex
              	
35AD: EB      	HEXIT   ex      DE,HL           ; Value into DE, Code string into HL
35AE: 7A      	        ld      A,D             ; Load DE into AC
35AF: 4B      	        ld      C,E             ; For prep to
35B0: E5      	        push    HL
35B1: CD0A21  	        call    ACPASS          ; ACPASS to set AC as integer into FPREG
35B4: E1      	        pop     HL
35B5: C9      	        ret
              	
35B6: 1E26    	HXERR:  ld      E,HX            ; ?HEX Error
35B8: C3EF13  	        jp      ERROR
              	
              	; BIN$(NN) Convert integer to a 1-16 char binary string
35BB: CD2D1D  	BIN:    call    TSTNUM          ; Verify it's a number
35BE: CD7319  	        call    DEINT           ; Get integer -32768 to 32767
35C1: C5      	BIN2:   push    BC              ; Save contents of BC
35C2: 219F81  	        ld      HL,PBUFF
35C5: 0611    	        ld      B,$11           ; One higher than max char count (16+1)
35C7:         	ZEROSUP:                        ; Suppress leading zeros
35C7: 05      	        dec     B               ; Max 16 chars
35C8: 78      	        ld      A,B
35C9: FE01    	        cp      $01
35CB: 2808    	        jr      Z,BITOUT        ; Always output at least one character
35CD: CB13    	        rl      E
35CF: CB12    	        rl      D
35D1: 30F4    	        jr      NC,ZEROSUP
35D3: 1804    	        jr      BITOUT2
35D5: CB13    	BITOUT: rl      E
35D7: CB12    	        rl      D               ; Top bit now in carry
35D9: 3E30    	BITOUT2:ld      A,'0'           ; Char for '0'
35DB: CE00    	        adc     A,$00           ; If carry set then '0' --> '1'
35DD: 77      	        ld      (HL),A
35DE: 23      	        inc     HL
35DF: 05      	        dec     B
35E0: 20F3    	        jr      NZ,BITOUT
35E2: AF      	        xor     A               ; Terminating character
35E3: 77      	        ld      (HL),A          ; Store zero to terminate
35E4: 23      	        inc     HL              ; Make sure PBUFF is terminated
35E5: 77      	        ld      (HL),A          ; Store the double zero there
35E6: C1      	        pop     BC
35E7: 219F81  	        ld      HL,PBUFF
35EA: C3B921  	        jp      STR1
              	
              	; Convert "&Bnnnn" to FPREG
              	; Gets a character from (HL) checks for Binary ASCII numbers "&Bnnnn"
35ED: EB      	BINTFP: ex      DE,HL           ; Move code string pointer to DE
35EE: 210000  	        ld      HL,$0000        ; Zero out the value
35F1: CD0A36  	        call    CHKBIN          ; Check the number for valid bin
35F4: DA1836  	        jp      C,BINERR        ; First value wasn't bin, HX error
35F7: D630    	BINIT:  sub     '0'
35F9: 29      	        add     HL,HL           ; Rotate HL left
35FA: B5      	        or      L
35FB: 6F      	        ld      L,A
35FC: CD0A36  	        call    CHKBIN          ; Get second and addtional characters
35FF: 30F6    	        jr      NC,BINIT        ; Process if a bin character
3601: EB      	        ex      DE,HL           ; Value into DE, Code string into HL
3602: 7A      	        ld      A,D             ; Load DE into AC
3603: 4B      	        ld      C,E             ; For prep to
3604: E5      	        push    HL
3605: CD0A21  	        call    ACPASS          ; ACPASS to set AC as integer into FPREG
3608: E1      	        pop     HL
3609: C9      	        ret
              	
              	; Char is in A, NC if char is 0 or 1
360A: 13      	CHKBIN: inc     DE
360B: 1A      	        ld      A,(DE)
360C: FE20    	        cp      SPC
360E: CA0A36  	        jp      Z,CHKBIN        ; Skip spaces
3611: FE30    	        cp      '0'             ; Set C if < '0'
3613: D8      	        ret     C
3614: FE32    	        cp      '2'
3616: 3F      	        ccf                     ; Set C if > '1'
3617: C9      	        ret
              	
3618: 1E28    	BINERR: ld      E,BN            ; ?BIN Error
361A: C3EF13  	        jp      ERROR
              	
              	
361D: C30800  	MONOUT: jp      $0008           ; output a char
              	
              	
3620: 3A9D81  	RESET:  ld      A,(SERIALS_EN)
3623: E601    	        and     $01             ; is serial port #1 open?
3625: C46B33  	        call    NZ,RSTSER1      ; yes, reset serial 1
3628: C30000  	        jp      $0000           ; Restart
              	
              	
362B: 3E00    	INITST: ld      A,$00           ; Clear break flag
362D: 32A680  	        ld      (BRKFLG),A
3630: C35B0E  	        jp      INIT
              	
              	
3633: F5      	TSTBIT: push    AF              ; Save bit mask
3634: A0      	        and     B               ; Get common bits
3635: C1      	        pop     BC              ; Restore bit mask
3636: B8      	        cp      B               ; Same bit set?
3637: 3E00    	        ld      A,$00           ; Return 0 in A
3639: C9      	        ret
              	
363A: CDB116  	OUTNCR: call    OUTC            ; Output character in A
363D: C36E1B  	        jp      PRNTCRLF        ; Output CRLF
              	; ------------------------------------------------------------------------------
              	; LM80C - UTILITY ROUTINES - R1.1
              	; ------------------------------------------------------------------------------
              	; The following code is intended to be used with LM80C Z80-based computer
              	; designed by Leonardo Miliani. More info at
              	; www DOT leonardomiliani DOT com
              	;
              	; *ALS are routines from "Z80 Assembly Language Subroutines" by Lance
              	; A. Leventhal and Winthrop Saville - Ed. Osborne/McGraw-Hill (1983)
              	;
              	; * WKT are routines from WikiTI:
              	; http://wikiti.brandonw.net/index.php?title=WikiTI_Home
              	;
              	; * LAC are routines from Learn@Cemetch
              	; https://learn.cemetech.net/index.php/Main_Page
              	;
              	; ------------------------------------------------------------------------------
              	; Code Revision:
              	; R1.0 - 20200110 - First release: 16-bit comparision/multiplication/negation
              	; R1.1 - 20200413 - Second release: added ABS(HL) 
              	;
              	; ------------------------------------------------------------------------------
              	
              	; compare two 16-bit registers, HL (minuend) and DE (subtrahend)
              	; values can be both signed or unsigned words
              	; inputs: HL, DE
              	; destroys: A,F,HL
              	; returns: if both registers are 2's complement, use Z and S flags;
              	; otherwise:
              	; if HL=DE: Z,P,NC  - Z=1, S=0; C=0
              	; if HL>DE: NZ,P,NC - Z=0, S=0; C=0
              	; if HL<DE: NZ,M,C  - Z=0, S=1; C=1
              	; Source: ALS
              	
3640: B7      	CMP16:  or      A           ; clear CARRY
3641: ED52    	        sbc     HL,DE       ; subtract DE from HL
3643: E0      	        ret     PO          ; return if no overflow
3644: 7C      	        ld      A,H         ; overflow - invert SIGN flag
3645: 1F      	        rra                 ; save CARRY flag in bit 7
3646: EE40    	        xor     %01000000   ; complement bit 6 (SIGN bit)
3648: 37      	        scf                 ; ensure a Non-Zero result
3649: 8F      	        adc     A,A         ; restore CARRY, complemented SIGN
              	                            ; ZERO flag = 0 for sure
364A: C9      	        ret                 ; return
              	
              	; ----------------------------------------------------------------------
              	
              	; multiply 2 signed/unsigned 16-bit words and return a 16-bit
              	; signed/unsigned product
              	; inputs: HL (multiplicand); DE (multiplier)
              	; destroys: A,F
              	; returns: HL (product)
              	; Source: ALS
              	
              	; initialize partial product, bit count
364B: C5      	MUL16:  push    BC
364C: 4D      	        ld      C,L         ; BC = multiplier
364D: 44      	        ld      B,H
364E: 210000  	        ld      HL,0        ; product = 0
3651: 3E0F    	        ld      A,$0F       ; count = bit lenght - 1 (16-1)
              	        ; shift-and-add algorithm
              	        ; if MSB of multiplier is 1, add multiplicand to partial product
              	        ; shift partial product, multiplier left 1 bit
3653: CB23    	MLP:    sla     E           ; shift multiplier left 1 bit
3655: CB12    	        rl      D
3657: 3001    	        jr      NC,MLP1     ; jump if MSB of multiplier = 0
3659: 09      	        add     HL,BC       ; add multiplicand to partial product
365A: 29      	MLP1:   add     HL,HL       ; shift partial product left
365B: 3D      	        dec     A
365C: 20F5    	        jr      NZ,MLP      ; continue until count = 0
              	        ; add multiplicand one last time if MSB of multiplier is 1
365E: B2      	        or      D           ; sign flag = MSB of multiplier
365F: F26336  	        jp      P,EXMUL16   ; exit if MSB of multiplier is 0
3662: 09      	        add     HL,BC       ; add multiplicand to product
3663: C1      	EXMUL16:pop     BC
3664: C9      	        ret
              	
              	; ----------------------------------------------------------------------
              	; absolute value of HL (same applies to other 16-bit register pairs)
              	; also, invert value of HL (or any other 16-bit register, just adjust the code)
              	;
              	; inputs: HL
              	; destroys: A
              	; operation: ABS(HL)
              	; returns: HL with no sign or negated
              	; Source: WKT
              	
3665: CB7C    	absHL:  bit     7,H
3667: C8      	        ret     Z
3668: AF      	negHL:  xor     A
3669: 95      	        sub     L
366A: 6F      	        ld      L,A
366B: 9F      	        sbc     A,A
366C: 94      	        sub     H
366D: 67      	        ld      H,A
366E: C9      	        ret
              	
              	; ------------------------------------------------------------------------------
              	
              	; 8/8 division
              	; INPUT: D (dividend), E (divisor)
              	; OPERATION: D/E
              	; OUTPUT: D (quotient), A (remainder)
366F: AF      	DIV_8_8:    xor     A
3670: C5      	            push    BC
3671: 0608    	            ld      B,08h
3673: CB22    	DIV_8_8LOOP:sla     D
3675: 17      	            rla
3676: BB      	            cp      E
3677: 3802    	            jr      C,$+4
3679: 93      	            sub     E
367A: 14      	            inc     D
367B: 10F6    	            djnz    DIV_8_8LOOP
367D: C1      	            pop     BC
367E: C9      	            ret
              	
              	; ----------------------------------------------------------------------
              	; divide a 16-bit number by an 8-bit number
              	; (16/8 division)
              	;
              	; inputs: HL (Dividend), C (divisor)
              	; destroys: A
              	; OPERATION: HL/C
              	; returns: HL (quotient), A (remainder)
              	; source: WKT
              	
367F: AF      	DIV_16_8:   xor     A
3680: 0610    	            ld      B,16
3682: 29      	DIV_16_8LP: add     HL,HL
3683: 17      	            rla
3684: 3803    	            jr      C,$+5
3686: B9      	            cp      C
3687: 3802    	            jr      C,$+4
3689: 91      	            sub     C
368A: 2C      	            inc     L
368B: 10F5    	            djnz    DIV_16_8LP
368D: C9      	            ret; ------------------------------------------------------------------------------
              	; LM80C - 6x8 CHARSET - R1.4
              	; ------------------------------------------------------------------------------
              	; The following code is intended to be used with LM80C Z80-based computer
              	; designed by Leonardo Miliani. More info at
              	; www DOT leonardomiliani DOT com
              	; ------------------------------------------------------------------------------
              	; Code Revision:
              	; R1.0 - 20190511 - First revision: ASCII chars (from 0 to 127)
              	; R1.1 - 20190521 - Expanded to 255 chars
              	; R1.2 - 20191209 - Start adding graphic chars to be coherent with 8x8 fonts
              	; R1.3 - 20191226 - Added extended char codes (128-255)
              	; R1.4 - 20200228 - adopted more usual hexadecimal & binary prefixes
              	; ------------------------------------------------------------------------------
              	;
              	;-------------------------------------------------------------------------------
              	;
              	;               6 x 8    C  H  A  R  S  E  T
              	;
              	;-------------------------------------------------------------------------------
              	;
              	;       6X8 CHARS, DESIGNED FOR TEXT BUT USABLE IN GRAPHICS 1 MODE TOO
              	;       UPDATE: NOW GRAPHICS 1 MODE HAS ITS OWN CHAR SET
              	
368E:         	CHRST68 equ $
368E: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 0 (null char)
3692: 00000000	
3696: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 1 F1
369A: 00000000	
369E: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 2 F2
36A2: 00000000	
36A6: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 3 CTRL-C
36AA: 00000000	
36AE: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 4 F3
36B2: 00000000	
36B6: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 5 F4
36BA: 00000000	
36BE: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 6 F5
36C2: 00000000	
36C6: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 7 (bell)
36CA: 00000000	
36CE: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 8 (backspace)
36D2: 00000000	
36D6: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 9 (H. tab)
36DA: 00000000	
36DE: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 10 (line feed)
36E2: 00000000	
36E6: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 11 
36EA: 00000000	
36EE: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 12 Form feed (clear screen)
36F2: 00000000	
36F6: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 13 (carriage return)
36FA: 00000000	
36FE: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 14 CTRL
3702: 00000000	
3706: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 15 CTRL-O
370A: 00000000	
370E: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 16 C=/Graphic key
3712: 00000000	
3716: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 17 CTRL-Q
371A: 00000000	
371E: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 18 CTRL-R
3722: 00000000	
3726: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 19 CTRL-S
372A: 00000000	
372E: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 20 SHIFT
3732: 00000000	
3736: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 21 CTRL-U
373A: 00000000	
373E: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 22 F6
3742: 00000000	
3746: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 23 F7
374A: 00000000	
374E: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 24 HELP
3752: 00000000	
3756: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 25 (home)
375A: 00000000	
375E: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 26
3762: 00000000	
3766: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 27 (escape)
376A: 00000000	
376E: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 28 (cursor left)
3772: 00000000	
3776: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 29 (cursor right)
377A: 00000000	
377E: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 30 (cursor up)
3782: 00000000	
3786: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 31 (cursor down)
378A: 00000000	
378E: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 32: space
3792: 00000000	
3796: 20202020	        defb $20,$20,$20,$20,$20,$00,$20,$00 ; char 33: !
379A: 20002000	
379E: 50500000	        defb $50,$50,$00,$00,$00,$00,$00,$00 ; char 34: "
37A2: 00000000	
37A6: 5050F850	        defb $50,$50,$f8,$50,$f8,$50,$50,$00 ; char 35: #
37AA: F8505000	
37AE: 2078A070	        defb $20,$78,$a0,$70,$28,$f0,$20,$00 ; char 36: $
37B2: 28F02000	
37B6: C0C81020	        defb $c0,$c8,$10,$20,$40,$98,$18,$00 ; char 37: %
37BA: 40981800	
37BE: 6090A040	        defb $60,$90,$a0,$40,$a8,$90,$68,$00 ; char 38: &
37C2: A8906800	
37C6: 60204000	        defb $60,$20,$40,$00,$00,$00,$00,$00 ; char 39: '
37CA: 00000000	
37CE: 10204040	        defb $10,$20,$40,$40,$40,$20,$10,$00 ; char 40: (
37D2: 40201000	
37D6: 40201010	        defb $40,$20,$10,$10,$10,$20,$40,$00 ; char 41: )
37DA: 10204000	
37DE: 0020A870	        defb $00,$20,$a8,$70,$a8,$20,$00,$00 ; char 42: *
37E2: A8200000	
37E6: 002020F8	        defb $00,$20,$20,$f8,$20,$20,$00,$00 ; char 43: +
37EA: 20200000	
37EE: 00000000	        defb $00,$00,$00,$00,$60,$20,$40,$00 ; char 44: ,
37F2: 60204000	
37F6: 000000F8	        defb $00,$00,$00,$f8,$00,$00,$00,$00 ; char 45: -
37FA: 00000000	
37FE: 00000000	        defb $00,$00,$00,$00,$00,$60,$60,$00 ; char 46: .
3802: 00606000	
3806: 00081020	        defb $00,$08,$10,$20,$40,$80,$00,$00 ; char 47: /
380A: 40800000	
380E: 708898A8	        defb $70,$88,$98,$a8,$c8,$88,$70,$00 ; char 48: 0
3812: C8887000	
3816: 20602020	        defb $20,$60,$20,$20,$20,$20,$70,$00 ; char 49: 1
381A: 20207000	
381E: 70880810	        defb $70,$88,$08,$10,$20,$40,$f8,$00 ; char 50: 2
3822: 2040F800	
3826: F8102010	        defb $f8,$10,$20,$10,$08,$88,$70,$00 ; char 51: 3
382A: 08887000	
382E: 10305090	        defb $10,$30,$50,$90,$f8,$10,$10,$00 ; char 52: 4
3832: F8101000	
3836: F880F008	        defb $f8,$80,$f0,$08,$08,$88,$70,$00 ; char 53: 5
383A: 08887000	
383E: 304080F8	        defb $30,$40,$80,$f8,$88,$88,$70,$00 ; char 54: 6
3842: 88887000	
3846: F8081020	        defb $f8,$08,$10,$20,$40,$40,$40,$00 ; char 55: 7
384A: 40404000	
384E: 70888870	        defb $70,$88,$88,$70,$88,$88,$70,$00 ; char 56: 8
3852: 88887000	
3856: 70888878	        defb $70,$88,$88,$78,$08,$10,$60,$00 ; char 57: 9
385A: 08106000	
385E: 00303000	        defb $00,$30,$30,$00,$30,$30,$00,$00 ; char 58: :
3862: 30300000	
3866: 00303000	        defb $00,$30,$30,$00,$30,$10,$20,$00 ; char 59: ;
386A: 30102000	
386E: 10204080	        defb $10,$20,$40,$80,$40,$20,$10,$00 ; char 60: <
3872: 40201000	
3876: 0000F800	        defb $00,$00,$f8,$00,$f8,$00,$00,$00 ; char 61: =
387A: F8000000	
387E: 40201008	        defb $40,$20,$10,$08,$10,$20,$40,$00 ; char 62: >
3882: 10204000	
3886: 70880810	        defb $70,$88,$08,$10,$20,$00,$20,$00 ; char 63: ?
388A: 20002000	
388E: 70880868	        defb $70,$88,$08,$68,$a8,$a8,$70,$00 ; char 64: @
3892: A8A87000	
3896: 70888888	        defb $70,$88,$88,$88,$f8,$88,$88,$00 ; char 65: A
389A: F8888800	
389E: F08888F0	        defb $f0,$88,$88,$f0,$88,$88,$f0,$00 ; char 66: B
38A2: 8888F000	
38A6: 70888080	        defb $70,$88,$80,$80,$80,$88,$70,$00 ; char 67: C
38AA: 80887000	
38AE: E0908888	        defb $e0,$90,$88,$88,$88,$90,$e0,$00 ; char 68: D
38B2: 8890E000	
38B6: F88080F0	        defb $f8,$80,$80,$f0,$80,$80,$f8,$00 ; char 69: E
38BA: 8080F800	
38BE: F88080F0	        defb $f8,$80,$80,$f0,$80,$80,$80,$00 ; char 70: F
38C2: 80808000	
38C6: 708880B8	        defb $70,$88,$80,$b8,$88,$88,$78,$00 ; char 71: G
38CA: 88887800	
38CE: 888888F8	        defb $88,$88,$88,$f8,$88,$88,$88,$00 ; char 72: H
38D2: 88888800	
38D6: 70202020	        defb $70,$20,$20,$20,$20,$20,$70,$00 ; char 73: I
38DA: 20207000	
38DE: 38101010	        defb $38,$10,$10,$10,$10,$90,$60,$00 ; char 74: J
38E2: 10906000	
38E6: 8890A0C0	        defb $88,$90,$a0,$c0,$a0,$90,$88,$00 ; char 75: K
38EA: A0908800	
38EE: 80808080	        defb $80,$80,$80,$80,$80,$80,$f8,$00 ; char 76: L
38F2: 8080F800	
38F6: 88D8A8A8	        defb $88,$d8,$a8,$a8,$88,$88,$88,$00 ; char 77: M
38FA: 88888800	
38FE: 88C8A898	        defb $88,$c8,$a8,$98,$88,$88,$88,$00 ; char 78: N
3902: 88888800	
3906: 70888888	        defb $70,$88,$88,$88,$88,$88,$70,$00 ; char 79: O
390A: 88887000	
390E: F08888F0	        defb $f0,$88,$88,$f0,$80,$80,$80,$00 ; char 80: P
3912: 80808000	
3916: 70888888	        defb $70,$88,$88,$88,$a8,$90,$68,$00 ; char 81: Q
391A: A8906800	
391E: F08888F0	        defb $f0,$88,$88,$f0,$a0,$90,$88,$00 ; char 82: R
3922: A0908800	
3926: 78808070	        defb $78,$80,$80,$70,$08,$08,$f0,$00 ; char 83: S
392A: 0808F000	
392E: F8202020	        defb $f8,$20,$20,$20,$20,$20,$20,$00 ; char 84: T
3932: 20202000	
3936: 88888888	        defb $88,$88,$88,$88,$88,$88,$70,$00 ; char 85: U
393A: 88887000	
393E: 88888888	        defb $88,$88,$88,$88,$88,$50,$20,$00 ; char 86: V
3942: 88502000	
3946: 88888888	        defb $88,$88,$88,$88,$a8,$a8,$50,$00 ; char 87: W
394A: A8A85000	
394E: 88885020	        defb $88,$88,$50,$20,$50,$88,$88,$00 ; char 88: X
3952: 50888800	
3956: 88888850	        defb $88,$88,$88,$50,$20,$20,$20,$00 ; char 89: Y
395A: 20202000	
395E: F8081020	        defb $f8,$08,$10,$20,$40,$80,$f8,$00 ; char 90: Z
3962: 4080F800	
3966: 70404040	        defb $70,$40,$40,$40,$40,$40,$70,$00 ; char 91: [
396A: 40407000	
396E: 00804020	        defb $00,$80,$40,$20,$10,$08,$00,$00 ; char 92: \
3972: 10080000	
3976: 70101010	        defb $70,$10,$10,$10,$10,$10,$70,$00 ; char 93: ]
397A: 10107000	
397E: 20508800	        defb $20,$50,$88,$00,$00,$00,$00,$00 ; char 94: ^
3982: 00000000	
3986: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$FC ; char 95: _ (underscore)
398A: 000000FC	
398E: 40201000	        defb $40,$20,$10,$00,$00,$00,$00,$00 ; char 96: `
3992: 00000000	
3996: 00007008	        defb $00,$00,$70,$08,$78,$88,$78,$00 ; char 97: a
399A: 78887800	
399E: 808080B0	        defb $80,$80,$80,$b0,$c8,$88,$f0,$00 ; char 98: b
39A2: C888F000	
39A6: 00007080	        defb $00,$00,$70,$80,$80,$88,$70,$00 ; char 99: c
39AA: 80887000	
39AE: 08080868	        defb $08,$08,$08,$68,$98,$88,$78,$00 ; char 100: d
39B2: 98887800	
39B6: 00007088	        defb $00,$00,$70,$88,$f8,$80,$70,$00 ; char 101: e
39BA: F8807000	
39BE: 304840E0	        defb $30,$48,$40,$e0,$40,$40,$40,$00 ; char 102: f
39C2: 40404000	
39C6: 00007888	        defb $00,$00,$78,$88,$78,$08,$70,$00 ; char 103: g
39CA: 78087000	
39CE: 8080B0C8	        defb $80,$80,$b0,$c8,$88,$88,$88,$00 ; char 104: h
39D2: 88888800	
39D6: 00200020	        defb $00,$20,$00,$20,$20,$20,$20,$00 ; char 105: i
39DA: 20202000	
39DE: 00100030	        defb $00,$10,$00,$30,$10,$90,$60,$00 ; char 106: j
39E2: 10906000	
39E6: 808090A0	        defb $80,$80,$90,$a0,$c0,$a0,$90,$00 ; char 107: k
39EA: C0A09000	
39EE: 60202020	        defb $60,$20,$20,$20,$20,$20,$70,$00 ; char 108: l
39F2: 20207000	
39F6: 0000D0A8	        defb $00,$00,$d0,$a8,$a8,$88,$88,$00 ; char 109: m
39FA: A8888800	
39FE: 0000B0C8	        defb $00,$00,$b0,$c8,$88,$88,$88,$00 ; char 110: n
3A02: 88888800	
3A06: 00007088	        defb $00,$00,$70,$88,$88,$88,$70,$00 ; char 111: o
3A0A: 88887000	
3A0E: 0000F088	        defb $00,$00,$f0,$88,$f0,$80,$80,$00 ; char 112: p
3A12: F0808000	
3A16: 00007888	        defb $00,$00,$78,$88,$78,$08,$08,$00 ; char 113: q
3A1A: 78080800	
3A1E: 0000B0C8	        defb $00,$00,$b0,$c8,$80,$80,$80,$00 ; char 114: r
3A22: 80808000	
3A26: 00007080	        defb $00,$00,$70,$80,$70,$08,$f0,$00 ; char 115: s
3A2A: 7008F000	
3A2E: 4040E040	        defb $40,$40,$e0,$40,$40,$48,$30,$00 ; char 116: t
3A32: 40483000	
3A36: 00008888	        defb $00,$00,$88,$88,$88,$98,$68,$00 ; char 117: u
3A3A: 88986800	
3A3E: 00008888	        defb $00,$00,$88,$88,$88,$50,$20,$00 ; char 118: v
3A42: 88502000	
3A46: 00008888	        defb $00,$00,$88,$88,$a8,$a8,$50,$00 ; char 119: w
3A4A: A8A85000	
3A4E: 00008850	        defb $00,$00,$88,$50,$20,$50,$88,$00 ; char 120: x
3A52: 20508800	
3A56: 00008898	        defb $00,$00,$88,$98,$68,$08,$70,$00 ; char 121: y
3A5A: 68087000	
3A5E: 0000F810	        defb $00,$00,$f8,$10,$20,$40,$f8,$00 ; char 122: z
3A62: 2040F800	
3A66: 10202040	        defb $10,$20,$20,$40,$20,$20,$10,$00 ; char 123: {
3A6A: 20201000	
3A6E: 20202020	        defb $20,$20,$20,$20,$20,$20,$20,$00 ; char 124: |
3A72: 20202000	
3A76: 20101008	        defb $20,$10,$10,$08,$10,$10,$20,$00 ; char 125: }
3A7A: 10102000	
3A7E: 00285000	        defb $00,$28,$50,$00,$00,$00,$00,$00 ; char 126: ~
3A82: 00000000	
3A86: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 127: (delete) - here end the standard ASCII (0-127)
3A8A: 00000000	
3A8E: 7884CC84	        defb %01111000,%10000100,%11001100,%10000100,%10110100,%10000100,%01111000,%00000000 ; char 128 (open face)
3A92: B4847800	
3A96: 78FCB4FC	        defb %01111000,%11111100,%10110100,%11111100,%10110100,%11001100,%01111000,%00000000 ; char 129 (full face)
3A9A: B4CC7800	
3A9E: 48FCFCFC	        defb %01001000,%11111100,%11111100,%11111100,%11111100,%01111000,%00110000,%00000000 ; char 130 (hearts)
3AA2: FC783000	
3AA6: 002070F8	        defb %00000000,%00100000,%01110000,%11111000,%11111000,%01110000,%00100000,%00000000 ; char 131 (diamonds)
3AAA: F8702000	
3AAE: 7020A8F8	        defb %01110000,%00100000,%10101000,%11111000,%10101000,%00100000,%01110000,%00000000 ; char 132 (clubs)
3AB2: A8207000	
3AB6: 2070F8F8	        defb %00100000,%01110000,%11111000,%11111000,%10101000,%00100000,%01110000,%00000000 ; char 133 (spades)
3ABA: A8207000	
3ABE: 303030FC	        defb %00110000,%00110000,%00110000,%11111100,%11111100,%00110000,%00110000,%00110000 ; char 134 
3AC2: FC303030	
3AC6: 0000003C	        defb %00000000,%00000000,%00000000,%00111100,%00111100,%00110000,%00110000,%00110000 ; char 135 
3ACA: 3C303030	
3ACE: 000000F0	        defb %00000000,%00000000,%00000000,%11110000,%11110000,%00110000,%00110000,%00110000 ; char 136 
3AD2: F0303030	
3AD6: 303030F0	        defb %00110000,%00110000,%00110000,%11110000,%11110000,%00000000,%00000000,%00000000 ; char 137 
3ADA: F0000000	
3ADE: 3030303C	        defb %00110000,%00110000,%00110000,%00111100,%00111100,%00000000,%00000000,%00000000 ; char 138 
3AE2: 3C000000	
3AE6: 303030FC	        defb %00110000,%00110000,%00110000,%11111100,%11111100,%00000000,%00000000,%00000000 ; char 139 
3AEA: FC000000	
3AEE: 3030303C	        defb %00110000,%00110000,%00110000,%00111100,%00111100,%00110000,%00110000,%00110000 ; char 140 
3AF2: 3C303030	
3AF6: 000000FC	        defb %00000000,%00000000,%00000000,%11111100,%11111100,%00110000,%00110000,%00110000 ; char 141 
3AFA: FC303030	
3AFE: 303030F0	        defb %00110000,%00110000,%00110000,%11110000,%11110000,%00110000,%00110000,%00110000 ; char 142 
3B02: F0303030	
3B06: 000000FC	        defb %00000000,%00000000,%00000000,%11111100,%11111100,%00000000,%00000000,%00000000 ; char 143 
3B0A: FC000000	
3B0E: 30303030	        defb %00110000,%00110000,%00110000,%00110000,%00110000,%00110000,%00110000,%00110000 ; char 144 
3B12: 30303030	
3B16: 0C1C1838	        defb %00001100,%00011100,%00011000,%00111000,%01110000,%01100000,%11100000,%11000000 ; char 145 
3B1A: 7060E0C0	
3B1E: C0E06070	        defb %11000000,%11100000,%01100000,%01110000,%00111000,%00011000,%00011100,%00001100 ; char 146 
3B22: 38181C0C	
3B26: CCCC7830	        defb %11001100,%11001100,%01111000,%00110000,%00110000,%01111000,%11001100,%11001100 ; char 147 
3B2A: 3078CCCC	
3B2E: 202020FC	        defb %00100000,%00100000,%00100000,%11111100,%00100000,%00100000,%00100000,%00100000 ; char 148 
3B32: 20202020	
3B36: 0000003C	        defb %00000000,%00000000,%00000000,%00111100,%00100000,%00100000,%00100000,%00100000 ; char 149 
3B3A: 20202020	
3B3E: 000000E0	        defb %00000000,%00000000,%00000000,%11100000,%00100000,%00100000,%00100000,%00100000 ; char 150 
3B42: 20202020	
3B46: 202020E0	        defb %00100000,%00100000,%00100000,%11100000,%00000000,%00000000,%00000000,%00000000 ; char 151 
3B4A: 00000000	
3B4E: 2020203C	        defb %00100000,%00100000,%00100000,%00111100,%00000000,%00000000,%00000000,%00000000 ; char 152 
3B52: 00000000	
3B56: 202020FC	        defb %00100000,%00100000,%00100000,%11111100,%00000000,%00000000,%00000000,%00000000 ; char 153 
3B5A: 00000000	
3B5E: 2020203C	        defb %00100000,%00100000,%00100000,%00111100,%00100000,%00100000,%00100000,%00100000 ; char 154 
3B62: 20202020	
3B66: 000000FC	        defb %00000000,%00000000,%00000000,%11111100,%00100000,%00100000,%00100000,%00100000 ; char 155 
3B6A: 20202020	
3B6E: 202020E0	        defb %00100000,%00100000,%00100000,%11100000,%00100000,%00100000,%00100000,%00100000 ; char 156 
3B72: 20202020	
3B76: 000000FC	        defb %00000000,%00000000,%00000000,%11111100,%00000000,%00000000,%00000000,%00000000 ; char 157 
3B7A: 00000000	
3B7E: 20202020	        defb %00100000,%00100000,%00100000,%00100000,%00100000,%00100000,%00100000,%00100000 ; char 158 
3B82: 20202020	
3B86: 04080810	        defb %00000100,%00001000,%00001000,%00010000,%00100000,%01000000,%01000000,%10000000 ; char 159 
3B8A: 20404080	
3B8E: 80404020	        defb %10000000,%01000000,%01000000,%00100000,%00010000,%00001000,%00001000,%00000100 ; char 160 
3B92: 10080804	
3B96: 84484830	        defb %10000100,%01001000,%01001000,%00110000,%00110000,%01001000,%01001000,%10000100 ; char 161 
3B9A: 30484884	
3B9E: 00000000	        defb %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%11111100,%11111100 ; char 162 
3BA2: 0000FCFC	
3BA6: 00000000	        defb %00000000,%00000000,%00000000,%00000000,%11111100,%11111100,%11111100,%11111100 ; char 163 
3BAA: FCFCFCFC	
3BAE: 0000FCFC	        defb %00000000,%00000000,%11111100,%11111100,%11111100,%11111100,%11111100,%11111100 ; char 164 
3BB2: FCFCFCFC	
3BB6: FCFC0000	        defb %11111100,%11111100,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 165 
3BBA: 00000000	
3BBE: FCFCFCFC	        defb %11111100,%11111100,%11111100,%11111100,%00000000,%00000000,%00000000,%00000000 ; char 166 
3BC2: 00000000	
3BC6: FCFCFCFC	        defb %11111100,%11111100,%11111100,%11111100,%11111100,%11111100,%00000000,%00000000 ; char 167 
3BCA: FCFC0000	
3BCE: 80808080	        defb %10000000,%10000000,%10000000,%10000000,%10000000,%10000000,%10000000,%10000000 ; char 168 
3BD2: 80808080	
3BD6: E0E0E0E0	        defb %11100000,%11100000,%11100000,%11100000,%11100000,%11100000,%11100000,%11100000 ; char 169 
3BDA: E0E0E0E0	
3BDE: F8F8F8F8	        defb %11111000,%11111000,%11111000,%11111000,%11111000,%11111000,%11111000,%11111000 ; char 170 
3BE2: F8F8F8F8	
3BE6: 04040404	        defb %00000100,%00000100,%00000100,%00000100,%00000100,%00000100,%00000100,%00000100 ; char 171 
3BEA: 04040404	
3BEE: 1C1C1C1C	        defb %00011100,%00011100,%00011100,%00011100,%00011100,%00011100,%00011100,%00011100 ; char 172 
3BF2: 1C1C1C1C	
3BF6: 7C7C7C7C	        defb %01111100,%01111100,%01111100,%01111100,%01111100,%01111100,%01111100,%01111100 ; char 173 
3BFA: 7C7C7C7C	
3BFE: FC848484	        defb %11111100,%10000100,%10000100,%10000100,%10000100,%10000100,%10000100,%11111100 ; char 174 
3C02: 848484FC	
3C06: 00000000	        defb %00000000,%00000000,%00000000,%00000000,%11100000,%11100000,%11100000,%11100000 ; char 175 
3C0A: E0E0E0E0	
3C0E: 00000000	        defb %00000000,%00000000,%00000000,%00000000,%00011100,%00011100,%00011100,%00011100 ; char 176 
3C12: 1C1C1C1C	
3C16: 1C1C1C1C	        defb %00011100,%00011100,%00011100,%00011100,%00000000,%00000000,%00000000,%00000000 ; char 177 
3C1A: 00000000	
3C1E: E0E0E0E0	        defb %11100000,%11100000,%11100000,%11100000,%00000000,%00000000,%00000000,%00000000 ; char 178 
3C22: 00000000	
3C26: E0E0E0E0	        defb %11100000,%11100000,%11100000,%11100000,%00011100,%00011100,%00011100,%00011100 ; char 179 
3C2A: 1C1C1C1C	
3C2E: 1C1C1C1C	        defb %00011100,%00011100,%00011100,%00011100,%11100000,%11100000,%11100000,%11100000 ; char 180 
3C32: E0E0E0E0	
3C36: 78787878	        defb %01111000,%01111000,%01111000,%01111000,%01111000,%01111000,%01111000,%01111000 ; char 181 
3C3A: 78787878	
3C3E: CCCCCCCC	        defb %11001100,%11001100,%11001100,%11001100,%11001100,%11001100,%11001100,%11001100 ; char 182 
3C42: CCCCCCCC	
3C46: FCFC0000	        defb %11111100,%11111100,%00000000,%00000000,%00000000,%00000000,%11111100,%11111100 ; char 183 
3C4A: 0000FCFC	
3C4E: 0000FCFC	        defb %00000000,%00000000,%11111100,%11111100,%11111100,%11111100,%00000000,%00000000 ; char 184 
3C52: FCFC0000	
3C56: 3030CCCC	        defb %00110000,%00110000,%11001100,%11001100,%00110000,%00110000,%11001100,%11001100 ; char 185 
3C5A: 3030CCCC	
3C5E: 54A854A8	        defb %01010100,%10101000,%01010100,%10101000,%01010100,%10101000,%01010100,%10101000 ; char 186 
3C62: 54A854A8	
3C66: 643098CC	        defb %01100100,%00110000,%10011000,%11001100,%01100100,%00110000,%10011000,%11001100 ; char 187 
3C6A: 643098CC	
3C6E: CC643098	        defb %11001100,%01100100,%00110000,%10011000,%11001100,%01100100,%00110000,%10011000 ; char 188 
3C72: CC643098	
3C76: 3098CC64	        defb %00110000,%10011000,%11001100,%01100100,%00110000,%10011000,%11001100,%01100100 ; char 189 
3C7A: 3098CC64	
3C7E: 64CC9830	        defb %01100100,%11001100,%10011000,%00110000,%01100100,%11001100,%10011000,%00110000 ; char 190 
3C82: 64CC9830	
3C86: 2020F820	        defb %00100000,%00100000,%11111000,%00100000,%00100000,%00000000,%11111000,%00000000 ; char 191 ()
3C8A: 2000F800	
3C8E: C0300830	        defb %11000000,%00110000,%00001000,%00110000,%11000000,%00000000,%11111000,%00000000 ; char 192 ()
3C92: C000F800	
3C96: 18608060	        defb %00011000,%01100000,%10000000,%01100000,%00011000,%00000000,%11111000,%00000000 ; char 193 ()
3C9A: 1800F800	
3C9E: 3C202020	        defb %00111100,%00100000,%00100000,%00100000,%10100000,%01100000,%00100000,%00000000 ; char 194 (square root)
3CA2: A0602000	
3CA6: 30484830	        defb %00110000,%01001000,%01001000,%00110000,%00000000,%00000000,%00000000,%00000000 ; char 195 ()
3CAA: 00000000	
3CAE: 60103040	        defb %01100000,%00010000,%00110000,%01000000,%01110000,%00000000,%00000000,%00000000 ; char 196 ()
3CB2: 70000000	
3CB6: 000054A8	        defb %00000000,%00000000,%01010100,%10101000,%00000000,%11111100,%00000000,%00000000 ; char 197
3CBA: 00FC0000	
3CBE: 0054A800	        defb %00000000,%01010100,%10101000,%00000000,%01010100,%10101000,%00000000,%00000000 ; char 198 ()
3CC2: 54A80000	
3CC6: 0080C0E0	        defb %00000000,%10000000,%11000000,%11100000,%11100000,%11000000,%10000000,%00000000 ; char 199
3CCA: E0C08000	
3CCE: FC783000	        defb %11111100,%01111000,%00110000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 200
3CD2: 00000000	
3CD6: 00040C1C	        defb %00000000,%00000100,%00001100,%00011100,%00011100,%00001100,%00000100,%00000000 ; char 201
3CDA: 1C0C0400	
3CDE: 00000000	        defb %00000000,%00000000,%00000000,%00000000,%00000000,%00110000,%01111000,%11111100 ; char 202 
3CE2: 003078FC	
3CE6: 2070F820	        defb %00100000,%01110000,%11111000,%00100000,%00100000,%00100000,%00100000,%00000000 ; char 203 (up arrow)
3CEA: 20202000	
3CEE: 3C1C1C24	        defb %00111100,%00011100,%00011100,%00100100,%01000000,%10000000,%00000000,%00000000 ; char 204 (up right arrow)
3CF2: 40800000	
3CF6: 001018FC	        defb %00000000,%00010000,%00011000,%11111100,%00011000,%00010000,%00000000,%00000000 ; char 205 (right arrow)
3CFA: 18100000	
3CFE: 00008040	        defb %00000000,%00000000,%10000000,%01000000,%00100100,%00011100,%00011100,%00111100 ; char 206 (down right arrow)
3D02: 241C1C3C	
3D06: 00202020	        defb %00000000,%00100000,%00100000,%00100000,%00100000,%11111000,%01110000,%00100000 ; char 207 (down arrow)
3D0A: 20F87020	
3D0E: 00000408	        defb %00000000,%00000000,%00000100,%00001000,%10010000,%11100000,%11100000,%11110000 ; char 208 (down left arrow)
3D12: 90E0E0F0	
3D16: 002060FC	        defb %00000000,%00100000,%01100000,%11111100,%01100000,%00100000,%00000000,%00000000 ; char 209 (left arrow)
3D1A: 60200000	
3D1E: F0E0E090	        defb %11110000,%11100000,%11100000,%10010000,%00001000,%00000100,%00000000,%00000000 ; char 210 (up left arrow)
3D22: 08040000	
3D26: 3844F040	        defb %00111000,%01000100,%11110000,%01000000,%11110000,%01000100,%00111000,%00000000 ; char 211 (euro)
3D2A: F0443800	
3D2E: 000478A8	        defb %00000000,%00000100,%01111000,%10101000,%00101000,%00101000,%00101000,%00000000 ; char 212 (greek pi)
3D32: 28282800	
3D36: 00000000	        defb %00000000,%00000000,%00000000,%00000000,%00011100,%00100000,%00100000,%00100000 ; char 213
3D3A: 1C202020	
3D3E: 00000000	        defb %00000000,%00000000,%00000000,%00000000,%11100000,%00010000,%00010000,%00010000 ; char 214
3D42: E0101010	
3D46: 101010E0	        defb %00010000,%00010000,%00010000,%11100000,%00000000,%00000000,%00000000,%00000000 ; char 215
3D4A: 00000000	
3D4E: 2020201C	        defb %00100000,%00100000,%00100000,%00011100,%00000000,%00000000,%00000000,%00000000 ; char 216
3D52: 00000000	
3D56: 0000001C	        defb %00000000,%00000000,%00000000,%00011100,%00111100,%00110000,%00110000,%00110000 ; char 217
3D5A: 3C303030	
3D5E: 000000E0	        defb %00000000,%00000000,%00000000,%11100000,%11110000,%00110000,%00110000,%00110000 ; char 218
3D62: F0303030	
3D66: 303030F0	        defb %00110000,%00110000,%00110000,%11110000,%11100000,%00000000,%00000000,%00000000 ; char 219
3D6A: E0000000	
3D6E: 3030303C	        defb %00110000,%00110000,%00110000,%00111100,%00011100,%00000000,%00000000,%00000000 ; char 220
3D72: 1C000000	
3D76: 00304848	        defb %00000000,%00110000,%01001000,%01001000,%01001000,%00110000,%00000000,%00000000 ; char 221
3D7A: 48300000	
3D7E: 00307878	        defb %00000000,%00110000,%01111000,%01111000,%01111000,%00110000,%00000000,%00000000 ; char 222
3D82: 78300000	
3D86: 003078FC	        defb %00000000,%00110000,%01111000,%11111100,%11111100,%01111000,%00110000,%00000000 ; char 223
3D8A: FC783000	
3D8E: FCF8F0E0	        defb %11111100,%11111000,%11110000,%11100000,%11100000,%11000000,%10000000,%10000000 ; char 224
3D92: E0C08080	
3D96: FC7C3C1C	        defb %11111100,%01111100,%00111100,%00011100,%00011100,%00001100,%00000100,%00000100 ; char 225
3D9A: 1C0C0404	
3D9E: 04040C1C	        defb %00000100,%00000100,%00001100,%00011100,%00011100,%00111100,%01111100,%11111100 ; char 226
3DA2: 1C3C7CFC	
3DA6: 8080C0E0	        defb %10000000,%10000000,%11000000,%11100000,%11100000,%11110000,%11111000,%11111100 ; char 227
3DAA: E0F0F8FC	
3DAE: 00040CD8	        defb %00000000,%00000100,%00001100,%11011000,%11110000,%11100000,%11000000,%00000000 ; char 228 (checkmark)
3DB2: F0E0C000	
3DB6: 00CC7830	        defb %00000000,%11001100,%01111000,%00110000,%01111000,%11001100,%00000000,%00000000 ; char 229 (x)
3DBA: 78CC0000	
3DBE: 70888888	        defb %01110000,%10001000,%10001000,%10001000,%01110000,%00100000,%01110000,%00100000 ; char 230 (female)
3DC2: 70207020	
3DC6: 001C0C74	        defb %00000000,%00011100,%00001100,%01110100,%10010000,%10010000,%01100000,%00000000 ; char 231 (male)
3DCA: 90906000	
3DCE: F8848484	        defb %11111000,%10000100,%10000100,%10000100,%10000100,%10000100,%10000100,%11111100 ; char 232 (new doc)
3DD2: 848484FC	
3DD6: 00F0FC84	        defb %00000000,%11110000,%11111100,%10000100,%10000100,%10000100,%10000100,%11111100 ; char 233 (folder)
3DDA: 848484FC	
3DDE: 3078FC48	        defb %00110000,%01111000,%11111100,%01001000,%01001000,%01001000,%01001000,%01111000 ; char 234 (trash bin)
3DE2: 48484878	
3DE6: FC848484	        defb %11111100,%10000100,%10000100,%10000100,%11111100,%10110100,%10110100,%11111100 ; char 235 (floppy disk)
3DEA: FCB4B4FC	
3DEE: 0000D4D8	        defb %00000000,%00000000,%11010100,%11011000,%11010100,%11010100,%00000000,%00000000 ; char 236 (OK)
3DF2: D4D40000	
3DF6: 3078FC78	        defb %00110000,%01111000,%11111100,%01111000,%01111000,%01001000,%01001000,%01001000 ; char 237 (home)
3DFA: 78484848	
3DFE: 7884A4A4	        defb %01111000,%10000100,%10100100,%10100100,%10110100,%10000100,%01111000,%00000000 ; char 238 (clock)
3E02: B4847800	
3E06: 000008F4	        defb %00000000,%00000000,%00001000,%11110100,%10101000,%10000000,%00000000,%00000000 ; char 239 (key)
3E0A: A8800000	
3E0E: 203078B0	        defb %00100000,%00110000,%01111000,%10110000,%10100000,%10001000,%01110000,%00000000 ; char 240 (undo)
3E12: A0887000	
3E16: 00FCCCB4	        defb %00000000,%11111100,%11001100,%10110100,%10000100,%10000100,%11111100,%00000000 ; char 241 (letter)
3E1A: 8484FC00	
3E1E: 609090F0	        defb %01100000,%10010000,%10010000,%11110000,%11110000,%11110000,%11110000,%00000000 ; char 242 (lock)
3E22: F0F0F000	
3E26: 081414F0	        defb %00001000,%00010100,%00010100,%11110000,%11110000,%11110000,%11110000,%00000000 ; char 243 (unlock)
3E2A: F0F0F000	
3E2E: FCFC84B4	        defb %11111100,%11111100,%10000100,%10110100,%10010100,%10010100,%10000100,%11111100 ; char 244 (calendar)
3E32: 949484FC	
3E36: 00043858	        defb %00000000,%00000100,%00111000,%01011000,%01101000,%01110000,%10000000,%00000000 ; char 245 (diameter)
3E3A: 68708000	
3E3E: 78848484	        defb %01111000,%10000100,%10000100,%10000100,%01101100,%00011000,%00001000,%00000000 ; char 246 (baloon)
3E42: 6C180800	
3E46: 30282828	        defb %00110000,%00101000,%00101000,%00101000,%00100000,%01100000,%11100000,%01000000 ; char 247 (note)
3E4A: 2060E040	
3E4E: 2068E4E4	        defb %00100000,%01101000,%11100100,%11100100,%11100100,%01101000,%00100000,%00000000 ; char 248 (audio on)
3E52: E4682000	
3E56: 2060E0E0	        defb %00100000,%01100000,%11100000,%11100000,%11100000,%01100000,%00100000,%00000000 ; char 249 (audio off)
3E5A: E0602000	
3E5E: 80C0E0F0	        defb %10000000,%11000000,%11100000,%11110000,%11111000,%11111100,%11110000,%10010000 ; char 250 (pointer)
3E62: F8FCF090	
3E66: 7884B4A4	        defb %01111000,%10000100,%10110100,%10100100,%10110100,%10000100,%01111000,%00000000 ; char 251 ()
3E6A: B4847800	
3E6E: 30484040	        defb %00110000,%01001000,%01000000,%01000000,%11100000,%01000000,%01000100,%10111000 ; char 252 ()
3E72: E04044B8	
3E76: 7884F048	        defb %01111000,%10000100,%11110000,%01001000,%01001000,%00111100,%10000100,%01111000 ; char 253 ()
3E7A: 483C8478	
3E7E: 00002000	        defb %00000000,%00000000,%00100000,%00000000,%11111000,%00000000,%00100000,%00000000 ; char 254 ()
3E82: F8002000	
3E86: FCFCFCFC	        defb %11111100,%11111100,%11111100,%11111100,%11111100,%11111100,%11111100,%11111100 ; char 255 (cursor)
3E8A: FCFCFCFC	
              	        ; here ends the ASCII table
              	; ------------------------------------------------------------------------------
              	; LM80C - 8x8 CHARSET - R1.7
              	; ------------------------------------------------------------------------------
              	; The following code is intended to be used with LM80C Z80-based computer
              	; designed by Leonardo Miliani. More info at
              	; www DOT leonardomiliani DOT com
              	; ------------------------------------------------------------------------------
              	; Code Revision:
              	; R1.0 - 20190615 - First revision: ASCII chars (from 0 to 255) - actually, they are 6x8 pixels
              	; R1.1 - 20190616 - Converted to 8x8 pixels
              	; R1.2 - 20191013 - Added new graphic chars and reorganized previous ones
              	; R1.3 - 20191015 - More graphic chars
              	; R1.4 - 20191202 - Fixed char 11/12, added new special chars
              	; R1.5 - 20191210 - Changed several graphic chars
              	; R1.6 - 20200125 - Removed double chars, changed with new ones
              	; R1.7 - 20200228 - adopted more usual hexadecimal & binary prefixes
              	; ------------------------------------------------------------------------------
              	;
              	;-------------------------------------------------------------------------------
              	;
              	;               8 x 8    C  H  A  R  S  E  T
              	;
              	;-------------------------------------------------------------------------------
              	;
              	;       8X8 CHARS, DESIGNED FOR GRAPHICS 1 MODE
              	
3E8E:         	CHRST88 equ $
3E8E: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 0 (null char)
3E92: 00000000	
3E96: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 1 F1
3E9A: 00000000	
3E9E: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 2 F2
3EA2: 00000000	
3EA6: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 3 CTRL-C
3EAA: 00000000	
3EAE: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 4 F3
3EB2: 00000000	
3EB6: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 5 F4
3EBA: 00000000	
3EBE: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 6 F5
3EC2: 00000000	
3EC6: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 7 (bell)
3ECA: 00000000	
3ECE: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 8 (backspace)
3ED2: 00000000	
3ED6: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 9 (H. tab)
3EDA: 00000000	
3EDE: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 10 (line feed)
3EE2: 00000000	
3EE6: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 11
3EEA: 00000000	
3EEE: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 12 Form feed (clear screen)
3EF2: 00000000	
3EF6: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 13 (carriage return)
3EFA: 00000000	
3EFE: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 14 CTRL
3F02: 00000000	
3F06: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 15 CTRL-O
3F0A: 00000000	
3F0E: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 16 C=/Graphic key
3F12: 00000000	
3F16: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 17 CTRL-Q
3F1A: 00000000	
3F1E: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 18 CTRL-R
3F22: 00000000	
3F26: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 19 CTRL-S
3F2A: 00000000	
3F2E: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 20 SHIFT
3F32: 00000000	
3F36: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 21 CTRL-U
3F3A: 00000000	
3F3E: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 22 F6
3F42: 00000000	
3F46: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 23 F7
3F4A: 00000000	
3F4E: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 24 HELP
3F52: 00000000	
3F56: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 25 (home)
3F5A: 00000000	
3F5E: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 26
3F62: 00000000	
3F66: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 27 (escape)
3F6A: 00000000	
3F6E: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 28 (cursor left)
3F72: 00000000	
3F76: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 29 (cursor right)
3F7A: 00000000	
3F7E: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 30 (cursor up)
3F82: 00000000	
3F86: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 31 (cursor down)
3F8A: 00000000	
3F8E: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 32 - space
3F92: 00000000	
3F96: 10101010	        defb %00010000,%00010000,%00010000,%00010000,%00010000,%00000000,%00010000,%00000000 ; char 33 - !
3F9A: 10001000	
3F9E: 28282800	        defb %00101000,%00101000,%00101000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 34 - "
3FA2: 00000000	
3FA6: 2828FE28	        defb %00101000,%00101000,%11111110,%00101000,%11111110,%00101000,%00101000,%00000000 ; char 35 - #
3FAA: FE282800	
3FAE: 103C5038	        defb %00010000,%00111100,%01010000,%00111000,%00010100,%01111000,%00010000,%00000000 ; char 36 - $
3FB2: 14781000	
3FB6: 00626408	        defb %00000000,%01100010,%01100100,%00001000,%00010000,%00100110,%01000110,%00000000 ; char 37 - %
3FBA: 10264600	
3FBE: 00304830	        defb %00000000,%00110000,%01001000,%00110000,%01001010,%01000100,%00111010,%00000000 ; char 38 - &
3FC2: 4A443A00	
3FC6: 08102000	        defb %00001000,%00010000,%00100000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 39 - '
3FCA: 00000000	
3FCE: 08102020	        defb %00001000,%00010000,%00100000,%00100000,%00100000,%00010000,%00001000,%00000000 ; char 40 - (
3FD2: 20100800	
3FD6: 20100808	        defb %00100000,%00010000,%00001000,%00001000,%00001000,%00010000,%00100000,%00000000 ; char 41 - )
3FDA: 08102000	
3FDE: 00105438	        defb %00000000,%00010000,%01010100,%00111000,%00111000,%01010100,%00010000,%00000000 ; char 42 - *
3FE2: 38541000	
3FE6: 0010107C	        defb %00000000,%00010000,%00010000,%01111100,%00010000,%00010000,%00000000,%00000000 ; char 43 - +
3FEA: 10100000	
3FEE: 00000000	        defb %00000000,%00000000,%00000000,%00000000,%00000000,%00011000,%00001000,%00010000 ; char 44 - ,
3FF2: 00180810	
3FF6: 0000007C	        defb %00000000,%00000000,%00000000,%01111100,%00000000,%00000000,%00000000,%00000000 ; char 45 - -
3FFA: 00000000	
3FFE: 00000000	        defb %00000000,%00000000,%00000000,%00000000,%00000000,%00011000,%00011000,%00000000 ; char 46 - .
4002: 00181800	
4006: 00020408	        defb %00000000,%00000010,%00000100,%00001000,%00010000,%00100000,%01000000,%00000000 ; char 47 - /
400A: 10204000	
400E: 38444C54	        defb %00111000,%01000100,%01001100,%01010100,%01100100,%01000100,%00111000,%00000000 ; char 48 - 0
4012: 64443800	
4016: 10305010	        defb %00010000,%00110000,%01010000,%00010000,%00010000,%00010000,%01111100,%00000000 ; char 49 - 1
401A: 10107C00	
401E: 38440408	        defb %00111000,%01000100,%00000100,%00001000,%00010000,%00100000,%01111100,%00000000 ; char 50 - 2
4022: 10207C00	
4026: 7C081008	        defb %01111100,%00001000,%00010000,%00001000,%00000100,%01000100,%00111000,%00000000 ; char 51 - 3
402A: 04443800	
402E: 08182848	        defb %00001000,%00011000,%00101000,%01001000,%01111100,%00001000,%00001000,%00000000 ; char 52 - 4
4032: 7C080800	
4036: 7C407804	        defb %01111100,%01000000,%01111000,%00000100,%00000100,%01000100,%00111000,%00000000 ; char 53 - 5
403A: 04443800	
403E: 38444078	        defb %00111000,%01000100,%01000000,%01111000,%01000100,%01000100,%00111000,%00000000 ; char 54 - 6
4042: 44443800	
4046: 7C040810	        defb %01111100,%00000100,%00001000,%00010000,%00100000,%00100000,%00100000,%00000000 ; char 55 - 7
404A: 20202000	
404E: 38444438	        defb %00111000,%01000100,%01000100,%00111000,%01000100,%01000100,%00111000,%00000000 ; char 56 - 8
4052: 44443800	
4056: 3844443C	        defb %00111000,%01000100,%01000100,%00111100,%00000100,%01000100,%00111000,%00000000 ; char 57 - 9
405A: 04443800	
405E: 00181800	        defb %00000000,%00011000,%00011000,%00000000,%00011000,%00011000,%00000000,%00000000 ; char 58 - :
4062: 18180000	
4066: 00181800	        defb %00000000,%00011000,%00011000,%00000000,%00011000,%00001000,%00010000,%00000000 ; char 59 - ;
406A: 18081000	
406E: 04081020	        defb %00000100,%00001000,%00010000,%00100000,%00010000,%00001000,%00000100,%00000000 ; char 60 - <
4072: 10080400	
4076: 00007E00	        defb %00000000,%00000000,%01111110,%00000000,%01111110,%00000000,%00000000,%00000000 ; char 61 - =
407A: 7E000000	
407E: 20100804	        defb %00100000,%00010000,%00001000,%00000100,%00001000,%00010000,%00100000,%00000000 ; char 62 - >
4082: 08102000	
4086: 38440408	        defb %00111000,%01000100,%00000100,%00001000,%00010000,%00000000,%00010000,%00000000 ; char 63 - ?
408A: 10001000	
408E: 7884BCAC	        defb %01111000,%10000100,%10111100,%10101100,%10111000,%10000000,%10000100,%01111000 ; char 64 - @
4092: B8808478	
4096: 38444444	        defb %00111000,%01000100,%01000100,%01000100,%01111100,%01000100,%01000100,%00000000 ; char 65 - A
409A: 7C444400	
409E: 78444478	        defb %01111000,%01000100,%01000100,%01111000,%01000100,%01000100,%01111000,%00000000 ; char 66 - B
40A2: 44447800	
40A6: 38444040	        defb %00111000,%01000100,%01000000,%01000000,%01000000,%01000100,%00111000,%00000000 ; char 67 - C
40AA: 40443800	
40AE: 78444444	        defb %01111000,%01000100,%01000100,%01000100,%01000100,%01000100,%01111000,%00000000 ; char 68 - D
40B2: 44447800	
40B6: 7C404070	        defb %01111100,%01000000,%01000000,%01110000,%01000000,%01000000,%01111100,%00000000 ; char 69 - E
40BA: 40407C00	
40BE: 7C404070	        defb %01111100,%01000000,%01000000,%01110000,%01000000,%01000000,%01000000,%00000000 ; char 70 - F
40C2: 40404000	
40C6: 38444040	        defb %00111000,%01000100,%01000000,%01000000,%01011100,%01000100,%00111000,%00000000 ; char 71 - G
40CA: 5C443800	
40CE: 4444447C	        defb %01000100,%01000100,%01000100,%01111100,%01000100,%01000100,%01000100,%00000000 ; char 72 - H
40D2: 44444400	
40D6: 38101010	        defb %00111000,%00010000,%00010000,%00010000,%00010000,%00010000,%00111000,%00000000 ; char 73 - I
40DA: 10103800	
40DE: 3C040404	        defb %00111100,%00000100,%00000100,%00000100,%00000100,%01000100,%00111000,%00000000 ; char 74 - J
40E2: 04443800	
40E6: 44444870	        defb %01000100,%01000100,%01001000,%01110000,%01001000,%01000100,%01000100,%00000000 ; char 75 - K
40EA: 48444400	
40EE: 40404040	        defb %01000000,%01000000,%01000000,%01000000,%01000000,%01000000,%01111100,%00000000 ; char 76 - L
40F2: 40407C00	
40F6: 42665A42	        defb %01000010,%01100110,%01011010,%01000010,%01000010,%01000010,%01000010,%00000000 ; char 77 - M
40FA: 42424200	
40FE: 4464544C	        defb %01000100,%01100100,%01010100,%01001100,%01000100,%01000100,%01000100,%00000000 ; char 78 - N
4102: 44444400	
4106: 38444444	        defb %00111000,%01000100,%01000100,%01000100,%01000100,%01000100,%00111000,%00000000 ; char 79 - O
410A: 44443800	
410E: 78444444	        defb %01111000,%01000100,%01000100,%01000100,%01111000,%01000000,%01000000,%00000000 ; char 80 - P
4112: 78404000	
4116: 38444444	        defb %00111000,%01000100,%01000100,%01000100,%01010100,%01001000,%00110100,%00000000 ; char 81 - Q
411A: 54483400	
411E: 78444444	        defb %01111000,%01000100,%01000100,%01000100,%01111000,%01001000,%01000100,%00000000 ; char 82 - R
4122: 78484400	
4126: 3C404038	        defb %00111100,%01000000,%01000000,%00111000,%00000100,%00000100,%01111000,%00000000 ; char 83 - S
412A: 04047800	
412E: 7C101010	        defb %01111100,%00010000,%00010000,%00010000,%00010000,%00010000,%00010000,%00000000 ; char 84 - T
4132: 10101000	
4136: 44444444	        defb %01000100,%01000100,%01000100,%01000100,%01000100,%01000100,%00111000,%00000000 ; char 85 - U
413A: 44443800	
413E: 44444444	        defb %01000100,%01000100,%01000100,%01000100,%01000100,%00101000,%00010000,%00000000 ; char 86 - V
4142: 44281000	
4146: 42424242	        defb %01000010,%01000010,%01000010,%01000010,%01011010,%01011010,%00100100,%00000000 ; char 87 - W
414A: 5A5A2400	
414E: 44442810	        defb %01000100,%01000100,%00101000,%00010000,%00101000,%01000100,%01000100,%00000000 ; char 88 - X
4152: 28444400	
4156: 44444428	        defb %01000100,%01000100,%01000100,%00101000,%00010000,%00010000,%00010000,%00000000 ; char 89 - Y
415A: 10101000	
415E: 7C040810	        defb %01111100,%00000100,%00001000,%00010000,%00100000,%01000000,%01111100,%00000000 ; char 90 - Z
4162: 20407C00	
4166: 38202020	        defb %00111000,%00100000,%00100000,%00100000,%00100000,%00100000,%00111000,%00000000 ; char 91 - [
416A: 20203800	
416E: 00402010	        defb %00000000,%01000000,%00100000,%00010000,%00001000,%00000100,%00000010,%00000000 ; char 92 - \
4172: 08040200	
4176: 38080808	        defb %00111000,%00001000,%00001000,%00001000,%00001000,%00001000,%00111000,%00000000 ; char 93 - ]
417A: 08083800	
417E: 10284400	        defb %00010000,%00101000,%01000100,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 94 - ^
4182: 00000000	
4186: 00000000	        defb %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%01111110,%00000000 ; char 95 _ (underscore)
418A: 00007E00	
418E: 20100800	        defb %00100000,%00010000,%00001000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 96 - `
4192: 00000000	
4196: 00003804	        defb %00000000,%00000000,%00111000,%00000100,%00111100,%01000100,%00111100,%00000000 ; char 97 - a
419A: 3C443C00	
419E: 40404078	        defb %01000000,%01000000,%01000000,%01111000,%01000100,%01000100,%01111000,%00000000 ; char 98 - b
41A2: 44447800	
41A6: 00003840	        defb %00000000,%00000000,%00111000,%01000000,%01000000,%01000100,%00111000,%00000000 ; char 99 - c
41AA: 40443800	
41AE: 0404043C	        defb %00000100,%00000100,%00000100,%00111100,%01000100,%01000100,%00111100,%00000000 ; char 100 - d
41B2: 44443C00	
41B6: 00003844	        defb %00000000,%00000000,%00111000,%01000100,%01111100,%01000000,%00111000,%00000000 ; char 101 - e
41BA: 7C403800	
41BE: 18242070	        defb %00011000,%00100100,%00100000,%01110000,%00100000,%00100000,%00100000,%00000000 ; char 102 - f
41C2: 20202000	
41C6: 00003C44	        defb %00000000,%00000000,%00111100,%01000100,%01000100,%00111100,%00000100,%00111000 ; char 103 - g
41CA: 443C0438	
41CE: 40405864	        defb %01000000,%01000000,%01011000,%01100100,%01000100,%01000100,%01000100,%00000000 ; char 104 - h
41D2: 44444400	
41D6: 00100010	        defb %00000000,%00010000,%00000000,%00010000,%00010000,%00010000,%00010000,%00000000 ; char 105 - i
41DA: 10101000	
41DE: 08001808	        defb %00001000,%00000000,%00011000,%00001000,%00001000,%00001000,%01001000,%00110000 ; char 106 - j
41E2: 08084830	
41E6: 40404850	        defb %01000000,%01000000,%01001000,%01010000,%01100000,%01010000,%01001000,%00000000 ; char 107 - k
41EA: 60504800	
41EE: 30101010	        defb %00110000,%00010000,%00010000,%00010000,%00010000,%00010000,%00111000,%00000000 ; char 108 - l
41F2: 10103800	
41F6: 0000546A	        defb %00000000,%00000000,%01010100,%01101010,%01001010,%01000010,%01000010,%00000000 ; char 109 - m
41FA: 4A424200	
41FE: 00005864	        defb %00000000,%00000000,%01011000,%01100100,%01000100,%01000100,%01000100,%00000000 ; char 110 - n
4202: 44444400	
4206: 00003844	        defb %00000000,%00000000,%00111000,%01000100,%01000100,%01000100,%00111000,%00000000 ; char 111: o
420A: 44443800	
420E: 00007844	        defb %00000000,%00000000,%01111000,%01000100,%01000100,%01111000,%01000000,%01000000 ; char 112: p
4212: 44784040	
4216: 00003C44	        defb %00000000,%00000000,%00111100,%01000100,%01000100,%00111100,%00000100,%00000100 ; char 113: q
421A: 443C0404	
421E: 00005864	        defb %00000000,%00000000,%01011000,%01100100,%01000000,%01000000,%01000000,%00000000 ; char 114: r
4222: 40404000	
4226: 00003840	        defb %00000000,%00000000,%00111000,%01000000,%00111000,%00000100,%01111000,%00000000 ; char 115: s
422A: 38047800	
422E: 20207020	        defb %00100000,%00100000,%01110000,%00100000,%00100000,%00100100,%00011000,%00000000 ; char 116: t
4232: 20241800	
4236: 00004444	        defb %00000000,%00000000,%01000100,%01000100,%01000100,%01001100,%00110100,%00000000 ; char 117: u
423A: 444C3400	
423E: 00004444	        defb %00000000,%00000000,%01000100,%01000100,%01000100,%00101000,%00010000,%00000000 ; char 118: v
4242: 44281000	
4246: 00004444	        defb %00000000,%00000000,%01000100,%01000100,%01010100,%01010100,%00101000,%00000000 ; char 119: w
424A: 54542800	
424E: 00004428	        defb %00000000,%00000000,%01000100,%00101000,%00010000,%00101000,%01000100,%00000000 ; char 120: x
4252: 10284400	
4256: 00004444	        defb %00000000,%00000000,%01000100,%01000100,%01001100,%00110100,%00000100,%00111000 ; char 121: y
425A: 4C340438	
425E: 00007C08	        defb %00000000,%00000000,%01111100,%00001000,%00010000,%00100000,%01111100,%00000000 ; char 122: z
4262: 10207C00	
4266: 18202040	        defb %00011000,%00100000,%00100000,%01000000,%00100000,%00100000,%00011000,%00000000 ; char 123: {
426A: 20201800	
426E: 10101010	        defb %00010000,%00010000,%00010000,%00010000,%00010000,%00010000,%00010000,%00000000 ; char 124: |
4272: 10101000	
4276: 30080804	        defb %00110000,%00001000,%00001000,%00000100,%00001000,%00001000,%00110000,%00000000 ; char 125: }
427A: 08083000	
427E: 20540800	        defb %00100000,%01010100,%00001000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 126: ~
4282: 00000000	
4286: 00000000	        defb %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 127 (delete) - end the standard ASCII (0-127)
428A: 00000000	
428E: 3C42A581	        defb %00111100,%01000010,%10100101,%10000001,%10100101,%10011001,%01000010,%00111100 ; char 128 (open face)
4292: A599423C	
4296: 3C7EDBFF	        defb %00111100,%01111110,%11011011,%11111111,%11011011,%11100111,%01111110,%00111100 ; char 129 (full face)
429A: DBE77E3C	
429E: 6CFEFEFE	        defb %01101100,%11111110,%11111110,%11111110,%01111100,%00111000,%00010000,%00000000 ; char 130 (hearts)
42A2: 7C381000	
42A6: 10387CFE	        defb %00010000,%00111000,%01111100,%11111110,%01111100,%00111000,%00010000,%00000000 ; char 131 (diamonds)
42AA: 7C381000	
42AE: 103854FE	        defb %00010000,%00111000,%01010100,%11111110,%01010100,%00010000,%01111100,%00000000 ; char 132 (clus)
42B2: 54107C00	
42B6: 10387CFE	        defb %00010000,%00111000,%01111100,%11111110,%11010110,%00010000,%01111100,%00000000 ; char 133 (spades)
42BA: D6107C00	
42BE: 181818FF	        defb %00011000,%00011000,%00011000,%11111111,%11111111,%00011000,%00011000,%00011000 ; char 134
42C2: FF181818	
42C6: 0000001F	        defb %00000000,%00000000,%00000000,%00011111,%00011111,%00011000,%00011000,%00011000 ; char 135
42CA: 1F181818	
42CE: 000000F8	        defb %00000000,%00000000,%00000000,%11111000,%11111000,%00011000,%00011000,%00011000 ; char 136
42D2: F8181818	
42D6: 181818F8	        defb %00011000,%00011000,%00011000,%11111000,%11111000,%00000000,%00000000,%00000000 ; char 137
42DA: F8000000	
42DE: 1818181F	        defb %00011000,%00011000,%00011000,%00011111,%00011111,%00000000,%00000000,%00000000 ; char 138
42E2: 1F000000	
42E6: 181818FF	        defb %00011000,%00011000,%00011000,%11111111,%11111111,%00000000,%00000000,%00000000 ; char 139
42EA: FF000000	
42EE: 1818181F	        defb %00011000,%00011000,%00011000,%00011111,%00011111,%00011000,%00011000,%00011000 ; char 140
42F2: 1F181818	
42F6: 000000FF	        defb %00000000,%00000000,%00000000,%11111111,%11111111,%00011000,%00011000,%00011000 ; char 141
42FA: FF181818	
42FE: 181818F8	        defb %00011000,%00011000,%00011000,%11111000,%11111000,%00011000,%00011000,%00011000 ; char 142
4302: F8181818	
4306: 000000FF	        defb %00000000,%00000000,%00000000,%11111111,%11111111,%00000000,%00000000,%00000000 ; char 143
430A: FF000000	
430E: 18181818	        defb %00011000,%00011000,%00011000,%00011000,%00011000,%00011000,%00011000,%00011000 ; char 144
4312: 18181818	
4316: 03070E1C	        defb %00000011,%00000111,%00001110,%00011100,%00111000,%01110000,%11100000,%11000000 ; char 145
431A: 3870E0C0	
431E: C0E07038	        defb %11000000,%11100000,%01110000,%00111000,%00011100,%00001110,%00000111,%00000011 ; char 146
4322: 1C0E0703	
4326: C3E77E3C	        defb %11000011,%11100111,%01111110,%00111100,%00111100,%01111110,%11100111,%11000011 ; char 147
432A: 3C7EE7C3	
432E: 101010FF	        defb %00010000,%00010000,%00010000,%11111111,%00010000,%00010000,%00010000,%00010000 ; char 148
4332: 10101010	
4336: 0000001F	        defb %00000000,%00000000,%00000000,%00011111,%00010000,%00010000,%00010000,%00010000 ; char 149
433A: 10101010	
433E: 000000F0	        defb %00000000,%00000000,%00000000,%11110000,%00010000,%00010000,%00010000,%00010000 ; char 150
4342: 10101010	
4346: 101010F0	        defb %00010000,%00010000,%00010000,%11110000,%00000000,%00000000,%00000000,%00000000 ; char 151
434A: 00000000	
434E: 1010101F	        defb %00010000,%00010000,%00010000,%00011111,%00000000,%00000000,%00000000,%00000000 ; char 152
4352: 00000000	
4356: 101010FF	        defb %00010000,%00010000,%00010000,%11111111,%00000000,%00000000,%00000000,%00000000 ; char 153
435A: 00000000	
435E: 1010101F	        defb %00010000,%00010000,%00010000,%00011111,%00010000,%00010000,%00010000,%00010000 ; char 154
4362: 10101010	
4366: 000000FF	        defb %00000000,%00000000,%00000000,%11111111,%00010000,%00010000,%00010000,%00010000 ; char 155
436A: 10101010	
436E: 101010F0	        defb %00010000,%00010000,%00010000,%11110000,%00010000,%00010000,%00010000,%00010000 ; char 156
4372: 10101010	
4376: 000000FF	        defb %00000000,%00000000,%00000000,%11111111,%00000000,%00000000,%00000000,%00000000 ; char 157
437A: 00000000	
437E: 10101010	        defb %00010000,%00010000,%00010000,%00010000,%00010000,%00010000,%00010000,%00010000 ; char 158
4382: 10101010	
4386: 01020408	        defb %00000001,%00000010,%00000100,%00001000,%00010000,%00100000,%01000000,%10000000 ; char 159
438A: 10204080	
438E: 80402010	        defb %10000000,%01000000,%00100000,%00010000,%00001000,%00000100,%00000010,%00000001 ; char 160
4392: 08040201	
4396: 81422418	        defb %10000001,%01000010,%00100100,%00011000,%00011000,%00100100,%01000010,%10000001 ; char 161
439A: 18244281	
439E: 00000000	        defb %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%11111111,%11111111 ; char 162
43A2: 0000FFFF	
43A6: 00000000	        defb %00000000,%00000000,%00000000,%00000000,%11111111,%11111111,%11111111,%11111111 ; char 163
43AA: FFFFFFFF	
43AE: 0000FFFF	        defb %00000000,%00000000,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111 ; char 164
43B2: FFFFFFFF	
43B6: FFFF0000	        defb %11111111,%11111111,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 165
43BA: 00000000	
43BE: FFFFFFFF	        defb %11111111,%11111111,%11111111,%11111111,%00000000,%00000000,%00000000,%00000000 ; char 166
43C2: 00000000	
43C6: FFFFFFFF	        defb %11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%00000000,%00000000 ; char 167
43CA: FFFF0000	
43CE: C0C0C0C0	        defb %11000000,%11000000,%11000000,%11000000,%11000000,%11000000,%11000000,%11000000 ; char 168
43D2: C0C0C0C0	
43D6: F0F0F0F0	        defb %11110000,%11110000,%11110000,%11110000,%11110000,%11110000,%11110000,%11110000 ; char 169
43DA: F0F0F0F0	
43DE: FCFCFCFC	        defb %11111100,%11111100,%11111100,%11111100,%11111100,%11111100,%11111100,%11111100 ; char 170
43E2: FCFCFCFC	
43E6: 03030303	        defb %00000011,%00000011,%00000011,%00000011,%00000011,%00000011,%00000011,%00000011 ; char 171
43EA: 03030303	
43EE: 0F0F0F0F	        defb %00001111,%00001111,%00001111,%00001111,%00001111,%00001111,%00001111,%00001111 ; char 172
43F2: 0F0F0F0F	
43F6: 3F3F3F3F	        defb %00111111,%00111111,%00111111,%00111111,%00111111,%00111111,%00111111,%00111111 ; char 173
43FA: 3F3F3F3F	
43FE: FF818181	        defb %11111111,%10000001,%10000001,%10000001,%10000001,%10000001,%10000001,%11111111 ; char 174
4402: 818181FF	
4406: 00000000	        defb %00000000,%00000000,%00000000,%00000000,%11110000,%11110000,%11110000,%11110000 ; char 175
440A: F0F0F0F0	
440E: 00000000	        defb %00000000,%00000000,%00000000,%00000000,%00001111,%00001111,%00001111,%00001111 ; char 176
4412: 0F0F0F0F	
4416: 0F0F0F0F	        defb %00001111,%00001111,%00001111,%00001111,%00000000,%00000000,%00000000,%00000000 ; char 177
441A: 00000000	
441E: F0F0F0F0	        defb %11110000,%11110000,%11110000,%11110000,%00000000,%00000000,%00000000,%00000000 ; char 178
4422: 00000000	
4426: F0F0F0F0	        defb %11110000,%11110000,%11110000,%11110000,%00001111,%00001111,%00001111,%00001111 ; char 179
442A: 0F0F0F0F	
442E: 0F0F0F0F	        defb %00001111,%00001111,%00001111,%00001111,%11110000,%11110000,%11110000,%11110000 ; char 180
4432: F0F0F0F0	
4436: 3C3C3C3C	        defb %00111100,%00111100,%00111100,%00111100,%00111100,%00111100,%00111100,%00111100 ; char 181
443A: 3C3C3C3C	
443E: C3C3C3C3	        defb %11000011,%11000011,%11000011,%11000011,%11000011,%11000011,%11000011,%11000011 ; char 182
4442: C3C3C3C3	
4446: FFFF0000	        defb %11111111,%11111111,%00000000,%00000000,%00000000,%00000000,%11111111,%11111111 ; char 183
444A: 0000FFFF	
444E: 0000FFFF	        defb %00000000,%00000000,%11111111,%11111111,%11111111,%11111111,%00000000,%00000000 ; char 184
4452: FFFF0000	
4456: 3333CCCC	        defb %00110011,%00110011,%11001100,%11001100,%00110011,%00110011,%11001100,%11001100 ; char 185
445A: 3333CCCC	
445E: 55AA55AA	        defb %01010101,%10101010,%01010101,%10101010,%01010101,%10101010,%01010101,%10101010 ; char 186
4462: 55AA55AA	
4466: 663399CC	        defb %01100110,%00110011,%10011001,%11001100,%01100110,%00110011,%10011001,%11001100 ; char 187
446A: 663399CC	
446E: CC993366	        defb %11001100,%10011001,%00110011,%01100110,%11001100,%10011001,%00110011,%01100110 ; char 188
4472: CC993366	
4476: 3399CC66	        defb %00110011,%10011001,%11001100,%01100110,%00110011,%10011001,%11001100,%01100110 ; char 189
447A: 3399CC66	
447E: 66CC9933	        defb %01100110,%11001100,%10011001,%00110011,%01100110,%11001100,%10011001,%00110011 ; char 190
4482: 66CC9933	
4486: 10107C10	        defb %00010000,%00010000,%01111100,%00010000,%00010000,%00000000,%01111100,%00000000 ; char 191 ()
448A: 10007C00	
448E: 60180618	        defb %01100000,%00011000,%00000110,%00011000,%01100000,%00000000,%01111110,%00000000 ; char 192 ()
4492: 60007E00	
4496: 06186018	        defb %00000110,%00011000,%01100000,%00011000,%00000110,%00000000,%01111110,%00000000 ; char 193 ()
449A: 06007E00	
449E: 3E202020	        defb %00111110,%00100000,%00100000,%00100000,%10100000,%01100000,%00100000,%00000000 ; char 194 (square root)
44A2: A0602000	
44A6: 30484830	        defb %00110000,%01001000,%01001000,%00110000,%00000000,%00000000,%00000000,%00000000 ; char 195 ()
44AA: 00000000	
44AE: 60103040	        defb %01100000,%00010000,%00110000,%01000000,%01110000,%00000000,%00000000,%00000000 ; char 196 ()
44B2: 70000000	
44B6: 00002A54	        defb %00000000,%00000000,%00101010,%01010100,%00000000,%01111110,%00000000,%00000000 ; char 197
44BA: 007E0000	
44BE: 0054A800	        defb %00000000,%01010100,%10101000,%00000000,%01010100,%10101000,%00000000,%00000000 ; char 198 ()
44C2: 54A80000	
44C6: 80C0E0F0	        defb %10000000,%11000000,%11100000,%11110000,%11100000,%11000000,%10000000,%00000000 ; char 199
44CA: E0C08000	
44CE: FE7C3810	        defb %11111110,%01111100,%00111000,%00010000,%00000000,%00000000,%00000000,%00000000 ; char 200
44D2: 00000000	
44D6: 0103070F	        defb %00000001,%00000011,%00000111,%00001111,%00000111,%00000011,%00000001,%00000000 ; char 201
44DA: 07030100	
44DE: 00000000	        defb %00000000,%00000000,%00000000,%00000000,%00010000,%00111000,%01111100,%11111110 ; char 202
44E2: 10387CFE	
44E6: 10387C10	        defb %00010000,%00111000,%01111100,%00010000,%00010000,%00010000,%00010000,%00000000 ; char 203 (up arrow)
44EA: 10101000	
44EE: 1E0E0E12	        defb %00011110,%00001110,%00001110,%00010010,%00100000,%01000000,%00000000,%00000000 ; char 204 (up right arrow)
44F2: 20400000	
44F6: 00080CFE	        defb %00000000,%00001000,%00001100,%11111110,%00001100,%00001000,%00000000,%00000000 ; char 205 (right arrow)
44FA: 0C080000	
44FE: 00402012	        defb %00000000,%01000000,%00100000,%00010010,%00001110,%00001110,%00011110,%00000000 ; char 206 (down right arrow)
4502: 0E0E1E00	
4506: 10101010	        defb %00010000,%00010000,%00010000,%00010000,%01111100,%00111000,%00010000,%00000000 ; char 207 (down arrow)
450A: 7C381000	
450E: 00040890	        defb %00000000,%00000100,%00001000,%10010000,%11100000,%11100000,%11110000,%00000000 ; char 208 (down left arrow)
4512: E0E0F000	
4516: 002060FE	        defb %00000000,%00100000,%01100000,%11111110,%01100000,%00100000,%00000000,%00000000 ; char 209 (left arrow)
451A: 60200000	
451E: F0E0E090	        defb %11110000,%11100000,%11100000,%10010000,%00001000,%00000100,%00000000,%00000000 ; char 210 (up left arrow)
4522: 08040000	
4526: 3844F040	        defb %00111000,%01000100,%11110000,%01000000,%11110000,%01000100,%00111000,%00000000 ; char 211 (euro)
452A: F0443800	
452E: 00027CA8	        defb %00000000,%00000010,%01111100,%10101000,%00101000,%00101000,%00101000,%00000000 ; char 212 (greek pi)
4532: 28282800	
4536: 00000007	        defb %00000000,%00000000,%00000000,%00000111,%00001000,%00010000,%00010000,%00010000 ; char 213
453A: 08101010	
453E: 000000E0	        defb %00000000,%00000000,%00000000,%11100000,%00010000,%00001000,%00001000,%00001000 ; char 214
4542: 10080808	
4546: 08080810	        defb %00001000,%00001000,%00001000,%00010000,%11100000,%00000000,%00000000,%00000000 ; char 215
454A: E0000000	
454E: 10101008	        defb %00010000,%00010000,%00010000,%00001000,%00000111,%00000000,%00000000,%00000000 ; char 216
4552: 07000000	
4556: 00000007	        defb %00000000,%00000000,%00000000,%00000111,%00001111,%00011100,%00011000,%00011000 ; char 217
455A: 0F1C1818	
455E: 000000E0	        defb %00000000,%00000000,%00000000,%11100000,%11110000,%00111000,%00011000,%00011000 ; char 218
4562: F0381818	
4566: 181838F0	        defb %00011000,%00011000,%00111000,%11110000,%11100000,%00000000,%00000000,%00000000 ; char 219
456A: E0000000	
456E: 18181C0F	        defb %00011000,%00011000,%00011100,%00001111,%00000111,%00000000,%00000000,%00000000 ; char 220
4572: 07000000	
4576: 003C4242	        defb %00000000,%00111100,%01000010,%01000010,%01000010,%01000010,%00111100,%00000000 ; char 221
457A: 42423C00	
457E: 003C7E7E	        defb %00000000,%00111100,%01111110,%01111110,%01111110,%01111110,%00111100,%00000000 ; char 222
4582: 7E7E3C00	
4586: 00183C7E	        defb %00000000,%00011000,%00111100,%01111110,%01111110,%00111100,%00011000,%00000000 ; char 223
458A: 7E3C1800	
458E: FFFEFCF8	        defb %11111111,%11111110,%11111100,%11111000,%11110000,%11100000,%11000000,%10000000 ; char 224
4592: F0E0C080	
4596: FF7F3F1F	        defb %11111111,%01111111,%00111111,%00011111,%00001111,%00000111,%00000011,%00000001 ; char 225
459A: 0F070301	
459E: 0103070F	        defb %00000001,%00000011,%00000111,%00001111,%00011111,%00111111,%01111111,%11111111 ; char 226
45A2: 1F3F7FFF	
45A6: 80C0E0F0	        defb %10000000,%11000000,%11100000,%11110000,%11111000,%11111100,%11111110,%11111111 ; char 227
45AA: F8FCFEFF	
45AE: 0002066C	        defb %00000000,%00000010,%00000110,%01101100,%01111000,%01110000,%01100000,%00000000 ; char 228 (checkmark)
45B2: 78706000	
45B6: 00663C18	        defb %00000000,%01100110,%00111100,%00011000,%00111100,%01100110,%00000000,%00000000 ; char 229 (x)
45BA: 3C660000	
45BE: 38444444	        defb %00111000,%01000100,%01000100,%01000100,%00111000,%00010000,%00111000,%00010000 ; char 230 (female)
45C2: 38103810	
45C6: 07033D44	        defb %00000111,%00000011,%00111101,%01000100,%01000100,%01000100,%00111000,%00000000 ; char 231 (male)
45CA: 44443800	
45CE: 78444242	        defb %01111000,%01000100,%01000010,%01000010,%01000010,%01000010,%01000010,%01111110 ; char 232 (new doc)
45D2: 4242427E	
45D6: 00F8FF81	        defb %00000000,%11111000,%11111111,%10000001,%10000001,%10000001,%10000001,%11111111 ; char 233 (folder)
45DA: 818181FF	
45DE: 107CFE54	        defb %00010000,%01111100,%11111110,%01010100,%01010100,%01010100,%01010100,%01111100 ; char 234 (trash bin)
45E2: 5454547C	
45E6: FF818181	        defb %11111111,%10000001,%10000001,%10000001,%10111101,%10101101,%10101101,%11111111 ; char 235 (floppy disk)
45EA: BDADADFF	
45EE: 00EAAAAC	        defb %00000000,%11101010,%10101010,%10101100,%10101100,%10101010,%11101010,%00000000 ; char 236 (OK)
45F2: ACAAEA00	
45F6: 187EFF7E	        defb %00011000,%01111110,%11111111,%01111110,%01111110,%01100110,%01100110,%01100110 ; char 237 (home)
45FA: 7E666666	
45FE: 3C429191	        defb %00111100,%01000010,%10010001,%10010001,%10011101,%10000001,%01000010,%00111100 ; char 238 (clock)
4602: 9D81423C	
4606: 000205FD	        defb %00000000,%00000010,%00000101,%11111101,%10100101,%10100010,%00000000,%00000000 ; char 239 (key)
460A: A5A20000	
460E: 080C3E4C	        defb %00001000,%00001100,%00111110,%01001100,%01001000,%01000010,%01000010,%00111100 ; char 240 (undo)
4612: 4842423C	
4616: 00FFC3A5	        defb %00000000,%11111111,%11000011,%10100101,%10011001,%10000001,%11111111,%00000000 ; char 241 (letter)
461A: 9981FF00	
461E: 3844447C	        defb %00111000,%01000100,%01000100,%01111100,%01111100,%01111100,%01111100,%00000000 ; char 242 (lock)
4622: 7C7C7C00	
4626: 060909F8	        defb %00000110,%00001001,%00001001,%11111000,%11111000,%11111000,%11111000,%00000000 ; char 243 (unlock)
462A: F8F8F800	
462E: FFFF81AD	        defb %11111111,%11111111,%10000001,%10101101,%10100101,%10100101,%10000001,%11111111 ; char 244 (calendar)
4632: A5A581FF	
4636: 011A244A	        defb %00000001,%00011010,%00100100,%01001010,%01010010,%00100100,%01011000,%10000000 ; char 245 (diameter)
463A: 52245880	
463E: 7E818181	        defb %01111110,%10000001,%10000001,%10000001,%10000001,%01110110,%00001100,%00000100 ; char 246 (baloon)
4642: 81760C04	
4646: 0C0A0A0A	        defb %00001100,%00001010,%00001010,%00001010,%00001000,%00011000,%00111000,%00010000 ; char 247 (note)
464A: 08183810	
464E: 1231F5F5	        defb %00010010,%00110001,%11110101,%11110101,%11110101,%11110101,%00110001,%00010010 ; char 248 (audio on)
4652: F5F53112	
4656: 1030F0F0	        defb %00010000,%00110000,%11110000,%11110000,%11110000,%11110000,%00110000,%00010000 ; char 249 (audio off)
465A: F0F03010	
465E: 40607078	        defb %01000000,%01100000,%01110000,%01111000,%01111100,%01111110,%01111000,%01001000 ; char 250 (pointer)
4662: 7C7E7848	
4666: 3C4299A1	        defb %00111100,%01000010,%10011001,%10100001,%10100001,%10011001,%01000010,%00111100 ; char 251 ()
466A: A199423C	
466E: 30484040	        defb %00110000,%01001000,%01000000,%01000000,%11110000,%01000000,%01000010,%10111100 ; char 252 ()
4672: F04042BC	
4676: 3C427824	        defb %00111100,%01000010,%01111000,%00100100,%00100100,%00011110,%01000010,%00111100 ; char 253 ()
467A: 241E423C	
467E: 00001000	        defb %00000000,%00000000,%00010000,%00000000,%01111100,%00000000,%00010000,%00000000 ; char 254 ()
4682: 7C001000	
4686: FFFFFFFF	        defb %11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111 ; char 255 (cursor)
468A: FFFFFFFF	
              	
              	; ------------------------------------------------------------------------------
              	; LM80C - LOGO CHARSET - R1.1
              	; ------------------------------------------------------------------------------
              	; The following code is intended to be used with LM80C Z80-based computer
              	; designed by Leonardo Miliani. More info at
              	; www DOT leonardomiliani DOT com
              	; ------------------------------------------------------------------------------
              	; Code Revision:
              	; R1.0 - 20200124 - First revision: logo chars
              	; R1.1 - 20200229 - Adopted usual hexadecimal & binary prefixes
              	; ------------------------------------------------------------------------------
              	
468E:         	LOGOFONT:   equ $
468E: 00000000	            defb %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000 ; 0
4692: 00000000	
4696: FFFFFFFF	            defb %11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111 ; 1
469A: FFFFFFFF	
469E: FFFFFFFF	            defb %11111111,%11111111,%11111111,%11111111,%00000000,%00000000,%00000000,%00000000 ; 2
46A2: 00000000	
46A6: 0F0F0F0F	            defb %00001111,%00001111,%00001111,%00001111,%00001111,%00001111,%00001111,%00001111 ; 3
46AA: 0F0F0F0F	
46AE: 00000000	            defb %00000000,%00000000,%00000000,%00000000,%11111111,%11111111,%11111111,%11111111 ; 4
46B2: FFFFFFFF	
46B6: F0F0F0F0	            defb %11110000,%11110000,%11110000,%11110000,%11110000,%11110000,%11110000,%11110000 ; 5
46BA: F0F0F0F0	
46BE: 00000000	            defb %00000000,%00000000,%00000000,%00000000,%00001111,%00001111,%00001111,%00001111 ; 6
46C2: 0F0F0F0F	
46C6: 00000000	            defb %00000000,%00000000,%00000000,%00000000,%11110000,%11110000,%11110000,%11110000 ; 7
46CA: F0F0F0F0	
46CE: F0F0F0F0	            defb %11110000,%11110000,%11110000,%11110000,%00000000,%00000000,%00000000,%00000000 ; 8
46D2: 00000000	
46D6: 0F0F0F0F	            defb %00001111,%00001111,%00001111,%00001111,%00000000,%00000000,%00000000,%00000000 ; 9
46DA: 00000000	
46DE: 000000FC	            defb %00000000,%00000000,%00000000,%11111100,%11111111,%00000111,%00000011,%00000000 ; 10
46E2: FF070300	
46E6: 0000003F	            defb %00000000,%00000000,%00000000,%00111111,%11111111,%11100000,%11000000,%00000000 ; 11
46EA: FFE0C000	
46EE: 18181F19	            defb %00011000,%00011000,%00011111,%00011001,%00011001,%00011111,%00011000,%00011000 ; 12
46F2: 191F1818	
46F6: 1818F898	            defb %00011000,%00011000,%11111000,%10011000,%10011000,%11111000,%00011000,%00011000 ; 13
46FA: 98F81818	
46FE: 18181C1F	            defb %00011000,%00011000,%00011100,%00011111,%00001111,%00000000,%00000000,%00000000 ; 14
4702: 0F000000	
4706: 0000000F	            defb %00000000,%00000000,%00000000,%00001111,%00011111,%00011100,%00011000,%00011000 ; 15
470A: 1F1C1818	
470E: 000000F0	            defb %00000000,%00000000,%00000000,%11110000,%11111000,%00111000,%00011000,%00011000 ; 16
4712: F8381818	
4716: 181838F8	            defb %00011000,%00011000,%00111000,%11111000,%11110000,%00000000,%00000000,%00000000 ; 17
471A: F0000000	
471E: 000000FF	            defb %00000000,%00000000,%00000000,%11111111,%11111111,%00000000,%00000000,%00000000 ; 18
4722: FF000000	
4726: 0F0F0F0F	            defb %00001111,%00001111,%00001111,%00001111,%11111111,%11111111,%11111111,%11111111 ; 19
472A: FFFFFFFF	
472E: F0F0F0F0	            defb %11110000,%11110000,%11110000,%11110000,%11111111,%11111111,%11111111,%11111111 ; 20
4732: FFFFFFFF	
4736: FFFFFFFF	            defb %11111111,%11111111,%11111111,%11111111,%11110000,%11110000,%11110000,%11110000 ; 21
473A: F0F0F0F0	
473E: FFFFFFFF	            defb %11111111,%11111111,%11111111,%11111111,%00001111,%00001111,%00001111,%00001111 ; 22
4742: 0F0F0F0F	
4746: 00307878	            defb %00000000,%00110000,%01111000,%01111000,%00110000,%00000000,%00000000,%00000000 ; 23
474A: 30000000	
              	            ; ------------------------------------------------------------------------------
              	; LM80C - FIRMWARE - R3.6
              	; ------------------------------------------------------------------------------
              	; The following code is intended to be used with LM80C Z80-based computer
              	; designed by Leonardo Miliani. More info at
              	; www DOT leonardomiliani DOT com
              	; ------------------------------------------------------------------------------
              	; Coding/Editing/Compiling:
              	; Original init code for MC68B05 by Grant Searle
              	; Original SIO/CTC/PIO init code by Mario Blunk
              	; NASCOM BASIC originally modified by Gran Searle
              	; Code modified and adapted for LM80C by Leonardo Miliani
              	;
              	; Edited with Atom Editor
              	;
              	; Compiled with ZASM assembler 4.2.4
              	; https://k1.spdns.de/Develop/Projects/zasm-4.0/Distributions/
              	; ------------------------------------------------------------------------------
              	; Copyright notes:
              	; Parts of the code (c) Grant Searle - free for non commercial use
              	; Please include this advice and the note to the attribution of the original
              	; version to Grant Searle if you intend to redistribuite it
              	; http://searle.hostei.com/grant/index.html
              	; eMail: home.micros01@btinternet.com
              	;
              	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
              	; Parts of the code (c) Mario Blunk
              	; http://www.trainz.de
              	;
              	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
              	; NASCOM ROM BASIC Ver 4.7, (C) 1978 Microsoft
              	; Scanned from source published in 80-BUS NEWS from Vol 2, Issue 3
              	; (May-June 1983) to Vol 3, Issue 3 (May-June 1984)
              	; Adapted for the freeware Zilog Macro Assembler 2.10 to produce
              	; the original ROM code (checksum A934H). PA
              	;
              	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
              	; The following code is intended to be used with LM80C Z80-based computer
              	; designed by Leonardo Miliani. Code and computer schematics are released under
              	; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
              	; kind of warranty: you can use them at your own risk.
              	; You are free to use them for any non-commercial use: you are only asked to
              	; maintain the copyright notices, include this advice and the note to the
              	; attribution of the original version to Leonardo Miliani, if you intend to
              	; redistribuite them.
              	; https://www.leonardomiliani.com
              	;
              	; Please support me by visiting the following links:
              	; Main project page: https://www.leonardomiliani.com
              	; Schematics and code: https://github.com/leomil72/LM80C
              	; Videos about the computer: https://www.youtube.com/user/leomil72/videos
              	; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
              	; ------------------------------------------------------------------------------
              	; Code Revision:
              	; R1.3   - 20190521 - Added preliminary support for video cursor management
              	; R1.4   - 20190524 - Added scrolling capabilities
              	; R1.5   - 20190525 - Added backspace functionality
              	; R1.6   - 20190601 - Fixed scrolling bugs
              	; R1.7   - 20190606 - Added "screen" command; code revision
              	; R1.8   - 20190615 - Better cursor integration; added VPOKE & VPEEK statements; 6x8 & 8x8 fonts
              	; R1.9   - 20190620 - New VREG, VSTAT, & LOCATE statement; 8x8 pixels font completed
              	; R2.0   - 20190714 - Added SREG & SSTAT to write to/read from PSG
              	; R2.1   - 20190818 - Added SOUND command to play simple tones and VOLUME command
              	; R2.1a  - 20190908 - Cursor management improvements
              	; R2.2   - 20190920 - Fixed cursor bug within SCREEN statement; new command PAUSE
              	; R2.3   - 20190930 - Fixed bugs in SOUND command
              	; R2.4   - 20191013 - Added new graphic chars and reorganized previous ones
              	; R2.4a  - 20191015 - More graphic chars
              	; R2.5   - 20191026 - Revision of init PSG code; revision of serial buffer exp. code;
              	;                     fixed a bug into the video buffer manager
              	; R2.6   - 20191102 - New function INKEY to read a key without a prompt;
              	;                     source code cleaning
              	; R2.7   - 20191116 - Fixed a bug into the INKEY code
              	; R2.8   - 20191207 - Minor bug fixes; added support for built-in keyboard;
              	;                     revision of some char codes;
              	; R2.8.1 - 20191208 - Introduced support for SHIFT key for uppercase letters & alternate chars
              	; R2.8.2 - 20191215 - Fixed a bug introduced with 2.8.1 that lead to wrong functioning of
              	;                     several BASIC statements (system tick counter, Locate, etc..)
              	; R2.9   - 20192212 - Code cleaning; improved SOUND statement; revision of PSG code;
              	;                     revision of release notes; add support for cursor keys & cursor movements
              	; R2.9   - 20191222 - Code cleaning; improved SOUND statement; revision of PSG code;
              	;                     revision of release notes; add support for cursor keys & cursor movements
              	; R2.10  - 20191226 - SIO init code cleaning & improved support for serial RX; added extended
              	;                     char codes (128-255) for 6x8 fonts; removed double chars in 8x8 fonts
              	; R2.11  - 20200110 - Set graphics 2 VRAM in a better way; fixed TAB() function; new SCREEN 4 mode;
              	;                     new PLOT, DRAW, and CIRCLE commands
              	; R2.12  - 20200124 - Code optimizing; fixed a bug into the CIRCLE routine; new splash screen
              	;                     with a graphic logo
              	; R2.13  - 20200127 - Implemented ALT & CTRL keys to print graphic chars with keyboard;
              	;                     code improvements; faster cursor flashing
              	; R2.14  - 20200203 - Better CLS code (no more color flashes in graphics modes); added SYS command
              	; R2.15  - 20200225 - Now the computer starts as a stand-alone system, with serial disabled;
              	;                     new SERIAL command
              	; R3.0   - 20200228 - Major changes to kernel, now the computer has a full-screen inline editor:
              	;                     it now acts as an old home computer of the '80s, getting statements from
              	;                     anywhere the cursor is; removed MONITOR statement; code cleaning & optimization;
              	;                     adopted usual hexadecimal & binary prefixes
              	; R3.1   - 20200304 - Added XOR statement; fixed a bug for SERIAL (chars sent over serial were $01);
              	;                     removed NULL statement; added compilation date & time into ROM file
              	; R3.2   - 20200309 - Added sprite size and sprite magnification settings to SCREEN statement;
              	;                     fixed a bug in warm/cold reset input routine
              	; R3.3   - 20200315 - Code cleaning; improved LIST command
              	; R3.4   - 20200329 - Removed POINT and SET statements and their legacies; changed default colors for
              	;                     screens 1 & 4; enhanced serial communication on port 1, fixed freezing bug and
              	;                     added new function to SERIAL statement; fixed TAB function
              	; R3.5   - 20200408 - Fixed a bug into the new code of LIST statement; serial & BASIC buffers expanded
              	;                     to 88 chars; fixed a little bug into editor (pressing RETURN over a multi-line text
              	;                     did not reposition the cursor after the end of it)
              	; R3.6   - 20200419 - Minor improvement in LIST code; fixed a bug in sound management (automatic cutting down
              	;                     of a sound wrongly altered the sound mixer); added management of noise from PSG;
              	;                     fixed some timing issues in VDP access that lead to graphic glitches in graphic mode 2;
              	;                     code improvements
              	;
              	; -----------------------------------------------------------------------------
              	
              	; this line instructs the assembler to prepare a file for a ROM target
              	; meaning that blank cells will be filled up with $FF
              	#target rom
              	
              	; this line instructs the assembler to compile taking account that code
              	; starts at $0000 (the address reached by Z80 upon reset)
0000:         	#code BOOT, $0000
              	
              	; ------------------------------------------------------------------------------
              	; include the latest version of the bootloader: this sets up the address aliases
              	; configure the hardware, checks if warm or cold startup and loads the BASIC interpreter
              	
              	; END OF ASSEMBLY SOURCE
              	#end
              	
              	;-------------------------------------------------------------------------------


; +++ segments +++

#CODE          = $0000 =     0,  size = $474E = 18254
#CODE BOOT     = $0000 =     0,  size = $0000 =     0

; +++ global symbols +++

ABPASS           = $210B =  8459          rom.asm:4704
ABS              = $298A = 10634          rom.asm:6056
ACCSUM           = $1952 =  6482          rom.asm:3581 (unused)
ACPASS           = $210A =  8458          rom.asm:4703
ADD30            = $3569 = 13673          rom.asm:7712
ADD301           = $3579 = 13689          rom.asm:7723
ADDEXP           = $2923 = 10531          rom.asm:5991
ADDIG            = $2AC9 = 10953          rom.asm:6279
ADDNEWLINE       = $094B =  2379          rom.asm:1508
ADDPHL           = $2710 = 10000          rom.asm:5638
ALLFOL           = $23D9 =  9177          rom.asm:5152
ANTVLU           = $1C4F =  7247          rom.asm:3987
ARET             = $2E1A = 11802          rom.asm:6719 (unused)
ARLDSV           = $2014 =  8212          rom.asm:4544
ARREND           = $813A = 33082          rom.asm:2180
ARRLP            = $22A4 =  8868          rom.asm:4943
ASC              = $23AA =  9130          rom.asm:5122
ASCTFP           = $2A6C = 10860          rom.asm:6225
ASPCS            = $1BB0 =  7088          rom.asm:3909
ATHOME           = $05DF =  1503          rom.asm:998
ATN              = $2DCE = 11726          rom.asm:6690
ATN1             = $2DEB = 11755          rom.asm:6702
ATNTAB           = $2DF5 = 11765          rom.asm:6707
ATOH             = $198D =  6541          rom.asm:3614
A_RTS_OFF        = $0160 =   352          rom.asm:244
A_RTS_ON         = $016E =   366          rom.asm:255
BACKSPACE        = $0748 =  1864          rom.asm:1219
BADINP           = $1BD3 =  7123          rom.asm:3921
BAKSTK           = $1384 =  4996          rom.asm:2724
BAKTMP           = $238A =  9098          rom.asm:5100
BASTXT           = $80AE = 32942          rom.asm:2156
BCDEFP           = $29B1 = 10673          rom.asm:6083
BEEPOFF          = $0509 =  1289          rom.asm:865
BFREE            = $0EF1 =  3825          rom.asm:2344
BIN              = $35BB = 13755          rom.asm:7772
BIN2             = $35C1 = 13761          rom.asm:7774 (unused)
BINERR           = $3618 = 13848          rom.asm:7833
BINIT            = $35F7 = 13815          rom.asm:7808
BINTFP           = $35ED = 13805          rom.asm:7804
BITOUT           = $35D5 = 13781          rom.asm:7786
BITOUT2          = $35D9 = 13785          rom.asm:7788
BITS6            = $3490 = 13456          rom.asm:7595
BITS7            = $349A = 13466          rom.asm:7600
BITS8            = $34A5 = 13477          rom.asm:7605
BKGNDCLR         = $815D = 33117          rom.asm:2203
BKSP             = $0008 =     8          rom.asm:2108
BN               = $0028 =    40          rom.asm:2254
BNMSG            = $12A1 =  4769          rom.asm:2644
BNORM            = $2770 = 10096          rom.asm:5697
BNPTR            = $1313 =  4883          rom.asm:2670 (unused)
BNRMLP           = $2773 = 10099          rom.asm:5700
BOOT             = $0000 =     0  BOOT    rom.asm:8719 (unused)
BOOT_end         = $0000 =     0  BOOT    rom.asm:8719 (unused)
BOOT_size        = $0000 =     0  BOOT    rom.asm:8719 (unused)
BPS              = $8167 = 33127          rom.asm:7426
BRK              = $190C =  6412          rom.asm:3543
BRKFLG           = $80A6 = 32934          rom.asm:2152
BRKLIN           = $812E = 33070          rom.asm:2174
BRKMSG           = $137E =  4990          rom.asm:2722
BRKRET           = $0EE8 =  3816          rom.asm:2340
BS               = $0010 =    16          rom.asm:2242
BSERR            = $2047 =  8263          rom.asm:4575
BSMSG            = $11D0 =  4560          rom.asm:2632
BSPTR            = $12FB =  4859          rom.asm:2658 (unused)
BUFFER           = $80B1 = 32945          rom.asm:2157
BYT2ASC          = $3560 = 13664          rom.asm:7707
BYTSFT           = $28A8 = 10408          rom.asm:5908
CFEVAL           = $1FAA =  8106          rom.asm:4475
CH3_TIMER        = $0232 =   562          rom.asm:395
CHABFREMPTY      = $01C3 =   451          rom.asm:309
CHAR2VID         = $068B =  1675          rom.asm:1117
CHARINTOBFR      = $0133 =   307          rom.asm:214
CHARTY           = $1F58 =  8024          rom.asm:4431
CHASNDDTN        = $8192 = 33170          rom.asm:2214
CHBSNDDTN        = $8194 = 33172          rom.asm:2215
CHCKYPOS         = $076E =  1902          rom.asm:1238
CHCKYPOS2        = $07D9 =  2009          rom.asm:1298
CHCSNDDTN        = $8196 = 33174          rom.asm:2216
CHECKALT         = $0C5F =  3167          rom.asm:1866
CHECKCTRL        = $0C6D =  3181          rom.asm:1872
CHECKKBD         = $0C7B =  3195          rom.asm:1878
CHECKWARM        = $02B2 =   690          rom.asm:461
CHEKFN           = $21A2 =  8610          rom.asm:4796
CHKALT           = $0CF3 =  3315          rom.asm:1938
CHKBIN           = $360A = 13834          rom.asm:7823
CHKBKSP          = $06B5 =  1717          rom.asm:1137
CHKCLR           = $2F99 = 12185          rom.asm:6954
CHKCR            = $06AC =  1708          rom.asm:1133
CHKCRSDWN        = $06D9 =  1753          rom.asm:1153
CHKCRSLFT        = $06BE =  1726          rom.asm:1141
CHKCRSR          = $0241 =   577          rom.asm:405
CHKCRSRGT        = $06D0 =  1744          rom.asm:1149
CHKCRSUP         = $06C7 =  1735          rom.asm:1145
CHKCS            = $06A3 =  1699          rom.asm:1129
CHKCTRL          = $0CEA =  3306          rom.asm:1934
CHKG2M           = $2FA3 = 12195          rom.asm:6962
CHKINK           = $26EF =  9967          rom.asm:5617
CHKLF            = $06E2 =  1762          rom.asm:1157
CHKLN            = $0CD6 =  3286          rom.asm:1925
CHKLTR           = $195F =  6495          rom.asm:3590
CHKSCAR          = $2EE2 = 12002          rom.asm:6850
CHKSNDCH         = $0BE8 =  3048          rom.asm:1794
CHKSTK           = $13B8 =  5048          rom.asm:2761
CHKSUM           = $80A3 = 32931          rom.asm:2150
CHKSYN           = $16A6 =  5798          rom.asm:3198
CHKTYP           = $1D2F =  7471          rom.asm:4102
CHKYPOS          = $0795 =  1941          rom.asm:1259
CHR              = $23BB =  9147          rom.asm:5134
CHR4VID          = $815B = 33115          rom.asm:2201
CHRST68          = $368E = 13966          rom.asm:8020
CHRST88          = $3E8E = 16014          rom.asm:8304
CIRCLE           = $314C = 12620          rom.asm:7178
CKBPS            = $3443 = 13379          rom.asm:7555
CKINCHAR         = $021F =   543          rom.asm:376
CKMAGN           = $2E95 = 11925          rom.asm:6803
CLEAR            = $19B2 =  6578          rom.asm:3638
CLEARVIDBUF      = $05D2 =  1490          rom.asm:991
CLOTST           = $16F2 =  5874          rom.asm:3245
CLREG            = $1514 =  5396          rom.asm:2972
CLREX2           = $2F5C = 12124          rom.asm:6910
CLRG1            = $2F4A = 12106          rom.asm:6902
CLRG2            = $2F53 = 12115          rom.asm:6906
CLRG2PTNTBL      = $0572 =  1394          rom.asm:929
CLRMC            = $2F43 = 12099          rom.asm:6898
CLRPRM           = $3333 = 13107          rom.asm:7401
CLRPSGREGS       = $0B86 =  2950          rom.asm:1739
CLRPTR           = $14EF =  5359          rom.asm:2952
CLRTABLE         = $0532 =  1330          rom.asm:896
CLRTXT           = $2F40 = 12096          rom.asm:6897
CLRVDBF          = $331B = 13083          rom.asm:7381
CLS              = $2E1D = 11805          rom.asm:6724
CMP16            = $3640 = 13888          rom.asm:7894
CMPFP            = $29FA = 10746          rom.asm:6141
CMPLG1           = $1EBE =  7870          rom.asm:4337
CMPLOG           = $1EBC =  7868          rom.asm:4336
CMPNUM           = $29E0 = 10720          rom.asm:6124
CMPRES           = $1F00 =  7936          rom.asm:4385
CMPSTR           = $1EE8 =  7912          rom.asm:4365
CMP_A            = $26D6 =  9942          rom.asm:5604
CN               = $0020 =    32          rom.asm:2250
CNMSG            = $1261 =  4705          rom.asm:2640
CNPTR            = $130B =  4875          rom.asm:2666 (unused)
CNTCHKSND        = $0C1F =  3103          rom.asm:1827
CNTCKCL          = $2F0F = 12047          rom.asm:6876
CNTCL1           = $320E = 12814          rom.asm:7265
CNTCL2           = $3232 = 12850          rom.asm:7278
CNTCL3           = $3256 = 12886          rom.asm:7291
CNTCL4           = $327C = 12924          rom.asm:7305
CNTCL5           = $329E = 12958          rom.asm:7317
CNTCL6           = $32C2 = 12994          rom.asm:7330
CNTCL7           = $32E6 = 13030          rom.asm:7343
CNTDRW           = $30F2 = 12530          rom.asm:7132
CNTEND           = $1B78 =  7032          rom.asm:3879
CNTKBCK          = $0D20 =  3360          rom.asm:1961
CNTLGC           = $1E7D =  7805          rom.asm:4291
CNTNULL          = $08DB =  2267          rom.asm:1451
CNTNULL2         = $0905 =  2309          rom.asm:1473
CNTPLOT          = $2FC7 = 12231          rom.asm:6980
CNTRX2           = $33D9 = 13273          rom.asm:7506
CNTRXCHA         = $011D =   285          rom.asm:198
CNTSER           = $33A5 = 13221          rom.asm:7477
CNTSER2          = $33E4 = 13284          rom.asm:7513
CNTSER3          = $33F6 = 13302          rom.asm:7522
CNTTXA           = $01FC =   508          rom.asm:348
CNTVALY          = $3316 = 13078          rom.asm:7374
CNTWTSP          = $1809 =  6153          rom.asm:3379
CNVNUM           = $2A78 = 10872          rom.asm:6231
COLD             = $0E47 =  3655          rom.asm:2259
COLDSTART        = $02AA =   682          rom.asm:458
COLOR            = $2EF2 = 12018          rom.asm:6865
COMMAN           = $80A0 = 32928          rom.asm:2147
COMPL            = $27D0 = 10192          rom.asm:5771
CONCAT           = $231F =  8991          rom.asm:5033
CONEXP           = $2AA8 = 10920          rom.asm:6255
CONPOS           = $276D = 10093          rom.asm:5695
CONT             = $193F =  6463          rom.asm:3570
CONTAD           = $8134 = 33076          rom.asm:2177
CONTCRSLFT       = $077F =  1919          rom.asm:1246
CONTCRSRGT       = $07EC =  2028          rom.asm:1308
CONTROLKEYS      = $819C = 33180          rom.asm:2221
CONT_POS_CURS    = $066B =  1643          rom.asm:1094
CONVAR           = $1E1A =  7706          rom.asm:4226
CORW             = $029E =   670          rom.asm:453
COS              = $2D52 = 11602          rom.asm:6638
COUNTER          = $02E6 =   742          rom.asm:491
CPDEHL           = $16A0 =  5792          rom.asm:3191
CPYLIT           = $15E9 =  5609          rom.asm:3091
CR               = $000D =    13          rom.asm:2111
CRARLP           = $2067 =  8295          rom.asm:4595
CREARY           = $204C =  8268          rom.asm:4578
CRESTR           = $1AB1 =  6833          rom.asm:3777
CRGRETURN        = $08AD =  2221          rom.asm:1427
CRNCLP           = $154A =  5450          rom.asm:2999
CRSDN            = $001F =    31          rom.asm:2125
CRSLFT           = $001C =    28          rom.asm:2122
CRSRGT           = $001D =    29          rom.asm:2123
CRSR_STATE       = $8158 = 33112          rom.asm:2198
CRSUP            = $001E =    30          rom.asm:2124
CRTMST           = $21DB =  8667          rom.asm:4829
CRTST            = $21E7 =  8679          rom.asm:4840
CRTSTE           = $21FD =  8701          rom.asm:4854
CRUNCH           = $1541 =  5441          rom.asm:2995
CS               = $000C =    12          rom.asm:2110
CSTART           = $0E54 =  3668          rom.asm:2265
CTC_CFG          = $3516 = 13590          rom.asm:7661
CTC_CH0          = $0010 =    16          rom.asm:93
CTC_CH1          = $0011 =    17          rom.asm:94
CTC_CH2          = $0012 =    18          rom.asm:95
CTC_CH3          = $0013 =    19          rom.asm:96
CTLOFG           = $80A2 = 32930          rom.asm:2149
CTRLC            = $0003 =     3          rom.asm:2106
CTRLG            = $0007 =     7          rom.asm:2107
CTRLO            = $000F =    15          rom.asm:2112
CTRLQ            = $0011 =    17          rom.asm:2113
CTRLR            = $0012 =    18          rom.asm:2114
CTRLS            = $0013 =    19          rom.asm:2115
CTRLU            = $0015 =    21          rom.asm:2116
CTSNDC           = $25BA =  9658          rom.asm:5446
CUROPR           = $8125 = 33061          rom.asm:2168
CURPOS           = $810B = 33035          rom.asm:2159
CURSORDOWN       = $07F5 =  2037          rom.asm:1316
CURSORLEFT       = $075B =  1883          rom.asm:1229
CURSORRIGHT      = $07C0 =  1984          rom.asm:1285
CURSORUP         = $07A7 =  1959          rom.asm:1270
CURSOR_OFF       = $082B =  2091          rom.asm:1349
CURSOR_ON        = $0815 =  2069          rom.asm:1336
CUR_POS          = $815E = 33118          rom.asm:1424
DATA             = $1A58 =  6744          rom.asm:3729
DATABT           = $8169 = 33129          rom.asm:7427
DATFLG           = $810E = 33038          rom.asm:2162
DATLIN           = $8129 = 33065          rom.asm:2170
DATSNR           = $13D5 =  5077          rom.asm:2781
DC               = $8170 = 33136          rom.asm:7177
DCBCDE           = $2A31 = 10801          rom.asm:6184
DD               = $0012 =    18          rom.asm:2243
DDERR            = $13E4 =  5092          rom.asm:2789
DDMSG            = $11DE =  4574          rom.asm:2633
DDPTR            = $12FD =  4861          rom.asm:2659 (unused)
DEC_D            = $04C9 =  1225          rom.asm:824
DEC_E            = $02E4 =   740          rom.asm:490
DEEK             = $2E39 = 11833          rom.asm:6741
DEF              = $211F =  8479          rom.asm:4717
DEFSIZ           = $206F =  8303          rom.asm:4599
DEINT            = $1973 =  6515          rom.asm:3601
DEL              = $007F =   127          rom.asm:2120
DELCHR           = $1619 =  5657          rom.asm:3121
DEPINT           = $196D =  6509          rom.asm:3599
DETHL4           = $29C0 = 10688          rom.asm:6095
DETHLB           = $29C2 = 10690          rom.asm:6096
DIGTXT           = $2B72 = 11122          rom.asm:6377
DIM              = $1F2A =  7978          rom.asm:4411
DIMRET           = $1F21 =  7969          rom.asm:4406
DINPOS           = $16D5 =  5845          rom.asm:3225
DIR_PAU          = $2E64 = 11876          rom.asm:6770 (unused)
DIV              = $28B9 = 10425          rom.asm:5919
DIV1             = $8068 = 32872          rom.asm:2138
DIV10            = $28AD = 10413          rom.asm:5914
DIV2             = $806C = 32876          rom.asm:2139
DIV3             = $8070 = 32880          rom.asm:2140
DIV4             = $8073 = 32883          rom.asm:2141
DIVLP            = $28E0 = 10464          rom.asm:5943
DIVSUP           = $8067 = 32871          rom.asm:2137
DIV_16_8         = $367F = 13951          rom.asm:7986
DIV_16_8LP       = $3682 = 13954          rom.asm:7988
DIV_8_8          = $366F = 13935          rom.asm:7963
DIV_8_8LOOP      = $3673 = 13939          rom.asm:7966
DLSZ             = $31D0 = 12752          rom.asm:7238
DOAGN            = $152D =  5421          rom.asm:2985
DOCOM            = $1B7D =  7037          rom.asm:3883
DODEL            = $15F9 =  5625          rom.asm:3105
DOEBIT           = $2BB2 = 11186          rom.asm:6420
DOFN             = $214C =  8524          rom.asm:4745
DOKE             = $2E44 = 11844          rom.asm:6749
DOSPC            = $1BAB =  7083          rom.asm:3906
DOTAB            = $1B96 =  7062          rom.asm:3895
DPOINT           = $2AA4 = 10916          rom.asm:6253
DRAW             = $3025 = 12325          rom.asm:7059
DRWCRL           = $31EC = 12780          rom.asm:7253
DTSTR            = $21EB =  8683          rom.asm:4843
DVBCDE           = $28BB = 10427          rom.asm:5921
DX               = $8172 = 33138          rom.asm:7057
DXGR             = $3122 = 12578          rom.asm:7149
DY               = $8174 = 33140          rom.asm:7058
DZ               = $0014 =    20          rom.asm:2244
DZERR            = $13DE =  5086          rom.asm:2785
DZMSG            = $11F3 =  4595          rom.asm:2634
DZPTR            = $12FF =  4863          rom.asm:2660 (unused)
E2               = $816C = 33132          rom.asm:7054
ECHDEL           = $160D =  5645          rom.asm:3114
ECHO_CHAR        = $02BC =   700          rom.asm:467
EDIGIT           = $2AEB = 10987          rom.asm:6302
EMPTSNDBFR       = $0B82 =  2946          rom.asm:1736
EMPTVRM          = $09C3 =  2499          rom.asm:1537
EMPTYCHABFR      = $01B5 =   437          rom.asm:302
EMPTYG2          = $0560 =  1376          rom.asm:921
EMPTYMC          = $0591 =  1425          rom.asm:947
EMPTYVIDBUF      = $0537 =  1335          rom.asm:900
EMPTY_RAM        = $09CC =  2508          rom.asm:1545
EMPTY_VRAM       = $09B8 =  2488          rom.asm:1530
ENDBUF           = $15F0 =  5616          rom.asm:3097
ENDCON           = $2AB7 = 10935          rom.asm:6265
ENDCRL           = $31E8 = 12776          rom.asm:7249
ENDCTRLCK        = $0CC1 =  3265          rom.asm:1914
ENDDIM           = $20CE =  8398          rom.asm:4668
ENDDRAW          = $3148 = 12616          rom.asm:7162
ENDINK           = $2701 =  9985          rom.asm:5628
ENDINK2          = $270A =  9994          rom.asm:5635 (unused)
ENDINP           = $1B64 =  7012          rom.asm:3870
ENDNAM           = $1F4C =  8012          rom.asm:4427
ENDPRG           = $191B =  6427          rom.asm:3553
ENDTXT           = $8162 = 33122          rom.asm:1426
ENDVDPSET        = $0466 =  1126          rom.asm:769
ENFMEM           = $13C1 =  5057          rom.asm:2767
ER               = $816A = 33130          rom.asm:7053
ER2              = $30CC = 12492          rom.asm:7119
ERASECLRTBL      = $04E5 =  1253          rom.asm:841
ERRIN            = $1410 =  5136          rom.asm:2812
ERRLIN           = $8132 = 33074          rom.asm:2176
ERRMSG           = $136D =  4973          rom.asm:2718
ERROR            = $13EF =  5103          rom.asm:2797
ERRORS           = $115B =  4443          rom.asm:2623 (unused)
ERRTBL           = $12EB =  4843          rom.asm:2649
ESC              = $001B =    27          rom.asm:2118
EVAL             = $1D3C =  7484          rom.asm:4110
EVAL1            = $1D3F =  7487          rom.asm:4112
EVAL2            = $1D48 =  7496          rom.asm:4116
EVAL3            = $1D4B =  7499          rom.asm:4117
EVLPAR           = $1E01 =  7681          rom.asm:4212
EVNOT            = $1F0A =  7946          rom.asm:4393
EXCUTE           = $18A9 =  6313          rom.asm:3473
EXG2MD           = $0428 =  1064          rom.asm:737
EXITCHAR2VID     = $0716 =  1814          rom.asm:1183
EXITCURSORDOWN   = $0812 =  2066          rom.asm:1330
EXITCURSORLEFT   = $0782 =  1922          rom.asm:1247
EXITCURSORRGHT   = $07F2 =  2034          rom.asm:1310
EXITCURSORUP     = $07BE =  1982          rom.asm:1280
EXITCURSOR_ON    = $0829 =  2089          rom.asm:1345
EXITSER          = $34EB = 13547          rom.asm:7644 (unused)
EXMUL16          = $3663 = 13923          rom.asm:7934
EXP              = $2C4C = 11340          rom.asm:6507
EXPLP            = $2A96 = 10902          rom.asm:6245
EXPTAB           = $2C8C = 11404          rom.asm:6535
EXPTEN           = $2BC4 = 11204          rom.asm:6430
EXTIG            = $1CAB =  7339          rom.asm:4035
EXTXA            = $0210 =   528          rom.asm:359
FANDT            = $1CD4 =  7380          rom.asm:4053
FC               = $0008 =     8          rom.asm:2238
FCERR            = $1988 =  6536          rom.asm:3611
FCMSG            = $1194 =  4500          rom.asm:2628
FCPTR            = $12F3 =  4851          rom.asm:2654 (unused)
FDTLP            = $1CBB =  7355          rom.asm:4037
FINDEL           = $20AA =  8362          rom.asm:4640
FINDKEY          = $0CD4 =  3284          rom.asm:1924
FLASHCURSOR      = $0724 =  1828          rom.asm:1196
FLGDIF           = $2970 = 10608          rom.asm:6039
FLGREL           = $2977 = 10615          rom.asm:6045
FNARG            = $8140 = 33088          rom.asm:2183
FNCTAB           = $0F3A =  3898          rom.asm:2361
FNDARY           = $201A =  8218          rom.asm:4548
FNDBPS           = $345C = 13404          rom.asm:7565
FNDELP           = $20AF =  8367          rom.asm:4645
FNDEND           = $14C2 =  5314          rom.asm:2915
FNDNUM           = $24AE =  9390          rom.asm:5284
FNDTOK           = $17CB =  6091          rom.asm:3344
FNDVAR           = $1F91 =  8081          rom.asm:4459
FNDWRD           = $1574 =  5492          rom.asm:3019
FNOFST           = $1E2B =  7723          rom.asm:4236
FNRGNM           = $813E = 33086          rom.asm:2182
FNTHR            = $1F9F =  8095          rom.asm:4467
FNVAL            = $1E52 =  7762          rom.asm:4258
FOPRND           = $1D74 =  7540          rom.asm:4138
FOR              = $1810 =  6160          rom.asm:3384
FORFLG           = $812B = 33067          rom.asm:2171
FORFND           = $1840 =  6208          rom.asm:3412
FORSLP           = $1824 =  6180          rom.asm:3393
FPADD            = $271F = 10015          rom.asm:5646
FPBCDE           = $29A6 = 10662          rom.asm:6075
FPEXP            = $8147 = 33095          rom.asm:2185
FPINT            = $2A0D = 10765          rom.asm:6161
FPMULT           = $285A = 10330          rom.asm:5857
FPREG            = $8144 = 33092          rom.asm:2184
FPROND           = $27B7 = 10167          rom.asm:5747
FPSINT           = $1967 =  6503          rom.asm:3597
FPTHL            = $29BD = 10685          rom.asm:6094
FRE              = $20E9 =  8425          rom.asm:4686
FRENUM           = $2105 =  8453          rom.asm:4698
FRGNDCLR         = $815C = 33116          rom.asm:2202
FRMEVL           = $1E1D =  7709          rom.asm:4227
FWVER            = $00E0 =   224          rom.asm:182 (unused)
G1MD             = $03A7 =   935          rom.asm:676
G2MD             = $03E3 =   995          rom.asm:707
GARBGE           = $226C =  8812          rom.asm:4916
GARBLP           = $226F =  8815          rom.asm:4917
GETCHR           = $18C9 =  6345          rom.asm:3496
GETCMD           = $1434 =  5172          rom.asm:2830
GETHEX           = $3596 = 13718          rom.asm:7745
GETINP           = $2E1B = 11803          rom.asm:6721
GETINT           = $24B1 =  9393          rom.asm:5285
GETLEN           = $239F =  9119          rom.asm:5114
GETLIN           = $162A =  5674          rom.asm:3129
GETLN            = $198E =  6542          rom.asm:3615
GETNUM           = $1D2A =  7466          rom.asm:4099
GETNXT           = $158F =  5519          rom.asm:3034
GETSTR           = $2369 =  9065          rom.asm:5080
GETVAR           = $1F2F =  7983          rom.asm:4414
GM               = $002A =    42          rom.asm:2255
GMERR            = $334C = 13132          rom.asm:7416
GMMSG            = $12AC =  4780          rom.asm:2645
GMPRT            = $1315 =  4885          rom.asm:2671 (unused)
GNXARY           = $22A3 =  8867          rom.asm:4942
GOFUNC           = $1E5A =  7770          rom.asm:4262
GOSUB            = $1A04 =  6660          rom.asm:3680
GOTO             = $1A15 =  6677          rom.asm:3692
GRBARY           = $22C3 =  8899          rom.asm:4961
GRBDON           = $2244 =  8772          rom.asm:4891
GRBLP            = $227D =  8829          rom.asm:4923
GSTRCU           = $236C =  9068          rom.asm:5081
GSTRDE           = $2370 =  9072          rom.asm:5083
GSTRHL           = $236F =  9071          rom.asm:5082
GTFLNM           = $23AE =  9134          rom.asm:5124 (unused)
GTFNAM           = $1F34 =  7988          rom.asm:4417
GTLNLP           = $1991 =  6545          rom.asm:3616
GTSIXD           = $2B3C = 11068          rom.asm:6346
GTVLUS           = $1C27 =  7207          rom.asm:3965
HALF             = $2BE3 = 11235          rom.asm:6451
HALFPI           = $2D9C = 11676          rom.asm:6669
HELLOWRLD        = $02D6 =   726          rom.asm:482
HEX              = $352A = 13610          rom.asm:7673
HEX1             = $3542 = 13634          rom.asm:7686
HEX2             = $3544 = 13636          rom.asm:7688
HEX3             = $3551 = 13649          rom.asm:7696
HEX4             = $3553 = 13651          rom.asm:7698
HEXIT            = $35AD = 13741          rom.asm:7760
HEXLP            = $3589 = 13705          rom.asm:7735
HEXLP1           = $358E = 13710          rom.asm:7737
HEXTFP           = $357D = 13693          rom.asm:7730
HL2XY            = $067A =  1658          rom.asm:1105
HOME             = $0019 =    25          rom.asm:2117
HX               = $0026 =    38          rom.asm:2253
HXERR            = $35B6 = 13750          rom.asm:7768
HXMSG            = $1296 =  4758          rom.asm:2643
HXPTR            = $1311 =  4881          rom.asm:2669 (unused)
ID               = $0016 =    22          rom.asm:2245
IDMSG            = $1204 =  4612          rom.asm:2635
IDPTR            = $1301 =  4865          rom.asm:2661 (unused)
IDTEST           = $2194 =  8596          rom.asm:4786
IF               = $1AE7 =  6887          rom.asm:3810
IFGO             = $1AF5 =  6901          rom.asm:3817
IFJMP            = $18B0 =  6320          rom.asm:3476
INCHL            = $29BB = 10683          rom.asm:6091
INCLEN           = $16D1 =  5841          rom.asm:3223
INCTMR3          = $023B =   571          rom.asm:401
INDFND           = $139E =  5022          rom.asm:2743
INEWLN           = $148A =  5258          rom.asm:2875
INIT             = $0E5B =  3675          rom.asm:2269
INITAB           = $131B =  4891          rom.asm:2677
INITBE           = $136D =  4973          rom.asm:2714
INITST           = $362B = 13867          rom.asm:7846
INIT_HW          = $0251 =   593          rom.asm:420
INKEY            = $26CB =  9931          rom.asm:5599
INKEY2           = $26E5 =  9957          rom.asm:5612
INMSG            = $1374 =  4980          rom.asm:2719
INP              = $246E =  9326          rom.asm:5253
INPBIN           = $1C79 =  7289          rom.asm:4009
INPBRK           = $1918 =  6424          rom.asm:3551
INPORT           = $809D = 32925          rom.asm:2145
INPSUB           = $809C = 32924          rom.asm:2144
INPUT            = $1BE4 =  7140          rom.asm:3929
INRNG            = $2B45 = 11077          rom.asm:6351
INT              = $2A38 = 10808          rom.asm:6192
INTVAR           = $14FE =  5374          rom.asm:2963
INVSGN           = $298E = 10638          rom.asm:6058
ITMSEP           = $1C6A =  7274          rom.asm:4000
JSTZER           = $2BCE = 11214          rom.asm:6436
KBDNPT           = $8198 = 33176          rom.asm:2217
KBMAP            = $0D47 =  3399          rom.asm:1981
KBMAP_ALT        = $0DC7 =  3527          rom.asm:2001
KBMAP_CTRL       = $0E07 =  3591          rom.asm:2011
KBMAP_SFT        = $0D87 =  3463          rom.asm:1991
KBTMP            = $8199 = 33177          rom.asm:2218
KEYBOARD         = $0C3F =  3135          rom.asm:1850
KILFOR           = $1D1A =  7450          rom.asm:4090
KILIN            = $1624 =  5668          rom.asm:3126
LASTKEYPRSD      = $819B = 33179          rom.asm:2220
LCRFLG           = $810C = 33036          rom.asm:2160
LDCLRTBEX2       = $045D =  1117          rom.asm:762
LDCLRTBMD1       = $03DA =   986          rom.asm:700
LDCOLSTOEMPTY    = $0551 =  1361          rom.asm:911
LDREGVLS         = $09E9 =  2537          rom.asm:1565
LEDLIGHT         = $02E0 =   736          rom.asm:488
LEFT             = $23CB =  9163          rom.asm:5142
LEN              = $239B =  9115          rom.asm:5112
LET              = $1A6F =  6767          rom.asm:3745
LETNUM           = $1AC2 =  6850          rom.asm:3787
LETSTR           = $1A8A =  6794          rom.asm:3758
LF               = $000A =    10          rom.asm:2109
LFRGNM           = $2464 =  9316          rom.asm:5244
LINEAT           = $80AC = 32940          rom.asm:2155
LINEIN           = $2AF7 = 10999          rom.asm:6312
LINFND           = $1473 =  5235          rom.asm:2861
LIST             = $1705 =  5893          rom.asm:3257
LISTLP           = $1788 =  6024          rom.asm:3306
LM80CLOGO        = $0A3C =  2620          rom.asm:1650
LOADCHARSET      = $09F3 =  2547          rom.asm:1574
LOADCLR          = $2F63 = 12131          rom.asm:6913
LOADFP           = $29B4 = 10676          rom.asm:6084
LOADLOGOCHRS     = $0511 =  1297          rom.asm:871
LOADMAP          = $0CFA =  3322          rom.asm:1941
LOADNEXTCOL      = $085D =  2141          rom.asm:1376
LOAD_CRSR_POS    = $0656 =  1622          rom.asm:1083
LOCATE           = $2524 =  9508          rom.asm:5360
LOG              = $2819 = 10265          rom.asm:5825
LOGOFONT         = $468E = 18062          rom.asm:8574
LOGTAB           = $280C = 10252          rom.asm:5820
LOKFOR           = $1388 =  5000          rom.asm:2726
LOOPST           = $8127 = 33063          rom.asm:2169
LS               = $001C =    28          rom.asm:2248
LSBTMR           = $20E2 =  8418          rom.asm:4680
LSMSG            = $1236 =  4662          rom.asm:2638
LSPTR            = $1307 =  4871          rom.asm:2664 (unused)
LST01            = $1731 =  5937          rom.asm:3274
LST03            = $176E =  5998          rom.asm:3295
LST04            = $174B =  5963          rom.asm:3283 (unused)
LST05            = $177C =  6012          rom.asm:3302
LST06            = $1752 =  5970          rom.asm:3285
LST07            = $17AD =  6061          rom.asm:3326
LST08            = $17AA =  6058          rom.asm:3325
LSTALL           = $1756 =  5974          rom.asm:3287
LSTBIN           = $812C = 33068          rom.asm:2172
LSTCSRSTA        = $8159 = 33113          rom.asm:2199
LSTLP2           = $17B9 =  6073          rom.asm:3335
LSTLP3           = $17BC =  6076          rom.asm:3336
LSTRAM           = $810F = 33039          rom.asm:2163
LSTRND           = $8098 = 32920          rom.asm:2143
LTSTND           = $1C84 =  7300          rom.asm:4014
LVKBRDCHK        = $0D46 =  3398          rom.asm:1977
LVKBRDCHK2       = $0D42 =  3394          rom.asm:1975
LVRXCHA          = $012E =   302          rom.asm:206
LWIDTH           = $809F = 32927          rom.asm:2146
MAKINT           = $24B4 =  9396          rom.asm:5286
MAKNUM           = $2B61 = 11105          rom.asm:6366
MANLP            = $2A80 = 10880          rom.asm:6237
MATCH            = $15C1 =  5569          rom.asm:3066
MCMD             = $0405 =  1029          rom.asm:722
MEMMSG           = $0F2F =  3887          rom.asm:2350
MID              = $2405 =  9221          rom.asm:5182
MID1             = $23D1 =  9169          rom.asm:5146
MIDNUM           = $2469 =  9321          rom.asm:5247
MINCDE           = $275F = 10079          rom.asm:5681
MINUS            = $1E09 =  7689          rom.asm:4217
MIXCLRS          = $2F8C = 12172          rom.asm:6942
MKTMST           = $21D8 =  8664          rom.asm:4828
MLDBLP           = $2A59 = 10841          rom.asm:6213
MLDEBC           = $2A51 = 10833          rom.asm:6208
MLOOP            = $0E89 =  3721          rom.asm:2287
MLP              = $3653 = 13907          rom.asm:7923
MLP1             = $365A = 13914          rom.asm:7927
MLSP10           = $294E = 10574          rom.asm:6019
MNGSNDS          = $0BDE =  3038          rom.asm:1790
MNOASK           = $0E86 =  3718          rom.asm:2286
MO               = $0024 =    36          rom.asm:2252
MOMSG            = $1286 =  4742          rom.asm:2642
MONOUT           = $361D = 13853          rom.asm:7837
MOPTR            = $130F =  4879          rom.asm:2668 (unused)
MORDT            = $1C90 =  7312          rom.asm:4019
MORINP           = $1633 =  5683          rom.asm:3134
MOVBUF           = $14A9 =  5289          rom.asm:2896
MOVCRS           = $062F =  1583          rom.asm:1061
MOVDIR           = $15C9 =  5577          rom.asm:3074
MOVLP            = $13AD =  5037          rom.asm:2753
MOVSTR           = $13AA =  5034          rom.asm:2750
MOVUP            = $13A7 =  5031          rom.asm:2749
MRPRNT           = $1B07 =  6919          rom.asm:3824
MSGTXT1          = $031A =   794          rom.asm:546
MSGTXT2          = $0343 =   835          rom.asm:548
MSIZE            = $0E76 =  3702          rom.asm:2280
MUL16            = $364B = 13899          rom.asm:7915
MUL8LP           = $2885 = 10373          rom.asm:5880
MULLN2           = $2851 = 10321          rom.asm:5851
MULT             = $2858 = 10328          rom.asm:5855
MULT8            = $287C = 10364          rom.asm:5874
MULTEN           = $2AC2 = 10946          rom.asm:6273
MULVAL           = $81AC = 33196          rom.asm:2227
MVCRS2LFT        = $0784 =  1924          rom.asm:1251
MVSTPT           = $1AB9 =  6841          rom.asm:3781
NEDMOR           = $1C23 =  7203          rom.asm:3963
NEGAFT           = $2BF9 = 11257          rom.asm:6460
NEW              = $14EE =  5358          rom.asm:2951
NEWCRSRCOORD     = $0638 =  1592          rom.asm:1067
NEXITM           = $1BBA =  7098          rom.asm:3915
NEXT             = $1CDF =  7391          rom.asm:4058
NEXT1            = $1CE2 =  7394          rom.asm:4059
NF               = $0000 =     0          rom.asm:2234
NFERR            = $13E1 =  5089          rom.asm:2787
NFMSG            = $115B =  4443          rom.asm:2624
NFPTR            = $12EB =  4843          rom.asm:2650 (unused)
NLLCR            = $0000 =     0          rom.asm:2105
NMIFLG           = $80A5 = 32933          rom.asm:2151
NOBEEP           = $0BB0 =  2992          rom.asm:1759
NOBPDAT          = $0BCC =  3020          rom.asm:1773
NOCHNG           = $15B9 =  5561          rom.asm:3061
NOENED           = $2BD1 = 11217          rom.asm:6439
NOGD             = $3019 = 12313          rom.asm:7036
NOISUP           = $263F =  9791          rom.asm:5514
NOKEYPRSD        = $0CC5 =  3269          rom.asm:1916
NOLIN            = $192E =  6446          rom.asm:3562
NOMADD           = $2896 = 10390          rom.asm:5891
NOMLAD           = $2A67 = 10855          rom.asm:6221
NOPMPT           = $1BFE =  7166          rom.asm:3941
NORMAL           = $278A = 10122          rom.asm:5716
NOS1             = $265C =  9820          rom.asm:5527
NOS2             = $266E =  9838          rom.asm:5539
NOS3             = $2686 =  9862          rom.asm:5557
NOSPC            = $15B0 =  5552          rom.asm:3056
NOSUB7           = $35A9 = 13737          rom.asm:7756
NOSWAP           = $2739 = 10041          rom.asm:5662
NOSYSPR          = $24DD =  9437          rom.asm:5309
NOTAMP           = $1DDE =  7646          rom.asm:4198
NOTFULL          = $013D =   317          rom.asm:220
NOTRDWRAP        = $01DD =   477          rom.asm:327
NOTSTR           = $1F67 =  8039          rom.asm:4439
NOTWRAP          = $0149 =   329          rom.asm:226
NOXOR            = $2494 =  9364          rom.asm:5270
NSCFOR           = $1F77 =  8055          rom.asm:4447
NULFLG           = $80A1 = 32929          rom.asm:2148
NUMASC           = $2B0A = 11018          rom.asm:6322
NXTARY           = $202E =  8238          rom.asm:4560
NXTBYT           = $159F =  5535          rom.asm:3046
NXTCHAR          = $0A06 =  2566          rom.asm:1585
NXTCHR           = $15E0 =  5600          rom.asm:3086
NXTDAT           = $813C = 33084          rom.asm:2181
NXTDTA           = $1A57 =  6743          rom.asm:3727
NXTITM           = $1C1B =  7195          rom.asm:3958
NXTLN            = $17E3 =  6115          rom.asm:3357
NXTOPR           = $8130 = 33072          rom.asm:2175
NXTSTL           = $1A5E =  6750          rom.asm:3732
NXTSTT           = $1A61 =  6753          rom.asm:3735
OD               = $0006 =     6          rom.asm:2237
ODMSG            = $1188 =  4488          rom.asm:2627
ODPTR            = $12F1 =  4849          rom.asm:2653 (unused)
OKMSG            = $1379 =  4985          rom.asm:2721
OM               = $000C =    12          rom.asm:2240
OMERR            = $13D0 =  5072          rom.asm:2778
OMMSG            = $11B3 =  4531          rom.asm:2630
OMPTR            = $12F7 =  4855          rom.asm:2656 (unused)
ON               = $1AC9 =  6857          rom.asm:3793
ONGO             = $1AD8 =  6872          rom.asm:3801
ONGOLP           = $1AD9 =  6873          rom.asm:3802
ONJMP            = $18B1 =  6321          rom.asm:3478
OPNPAR           = $1D38 =  7480          rom.asm:4108
OPRND            = $1DB3 =  7603          rom.asm:4181
OS               = $001A =    26          rom.asm:2247
OSMSG            = $1222 =  4642          rom.asm:2637
OSPTR            = $1305 =  4869          rom.asm:2663 (unused)
OTKLN            = $1621 =  5665          rom.asm:3125
OTPORT           = $8065 = 32869          rom.asm:2136
OUTC             = $16B1 =  5809          rom.asm:3206
OUTEXP           = $2BC2 = 11202          rom.asm:6429
OUTIT            = $1695 =  5781          rom.asm:3184
OUTNBS           = $1698 =  5784          rom.asm:3187
OUTNCR           = $363A = 13882          rom.asm:7858
OUTSUB           = $8064 = 32868          rom.asm:2135
OUTWRD           = $17D5 =  6101          rom.asm:3350
OV               = $000A =    10          rom.asm:2239
OVERR            = $13EA =  5098          rom.asm:2793
OVMSG            = $11AA =  4522          rom.asm:2629
OVPTR            = $12F5 =  4853          rom.asm:2655 (unused)
OVTST1           = $2941 = 10561          rom.asm:6011
OVTST2           = $2946 = 10566          rom.asm:6014
OVTST3           = $2947 = 10567          rom.asm:6015
PADD             = $2AE6 = 10982          rom.asm:6298
PAND             = $1E73 =  7795          rom.asm:4284
PAND1            = $1E98 =  7832          rom.asm:4307 (unused)
PARBT            = $816A = 33130          rom.asm:7428
PASSA            = $211A =  8474          rom.asm:4713
PAUSE            = $2E5B = 11867          rom.asm:6765
PBUFF            = $819F = 33183          rom.asm:2226
PEEK             = $24EA =  9450          rom.asm:5321
PEND             = $1913 =  6419          rom.asm:3548
PHLTFP           = $29A3 = 10659          rom.asm:6074
PIO_CA           = $0002 =     2          rom.asm:89 (unused)
PIO_CB           = $0003 =     3          rom.asm:90
PIO_DA           = $0000 =     0          rom.asm:87 (unused)
PIO_DB           = $0001 =     1          rom.asm:88
PKEPRMS          = $24FE =  9470          rom.asm:5336
PLOT             = $2FAC = 12204          rom.asm:6970
PLTCRL           = $31DF = 12767          rom.asm:7246
PLUCDE           = $27C4 = 10180          rom.asm:5758
PNORM            = $2792 = 10130          rom.asm:5724
PNT2VD           = $0D3F =  3391          rom.asm:1974
POKE             = $2514 =  9492          rom.asm:5346
POPAF            = $225E =  8798          rom.asm:4906
POPHL            = $2388 =  9096          rom.asm:5097
POPHRT           = $28A6 = 10406          rom.asm:5905
POPNOK           = $1426 =  5158          rom.asm:2822
POR              = $1E76 =  7798          rom.asm:4286
POR1             = $1E9D =  7837          rom.asm:4312
POS              = $2117 =  8471          rom.asm:4712
POSINT           = $196A =  6506          rom.asm:3598
POS_CURSOR       = $0625 =  1573          rom.asm:1055
POS_TB_CRS_32    = $0958 =  2392          rom.asm:1520
POS_TB_CRS_40    = $0988 =  2440          rom.asm:1524
POUT             = $247A =  9338          rom.asm:5258
POWER            = $2C07 = 11271          rom.asm:6468
POWER1           = $2C17 = 11287          rom.asm:6476
POWER2           = $2C34 = 11316          rom.asm:6494
POWERS           = $2BE7 = 11239          rom.asm:6453
PRINT            = $1B0B =  6923          rom.asm:3826
PRITAB           = $1143 =  4419          rom.asm:2597
PRNTCRLF         = $1B6E =  7022          rom.asm:3875
PRNTHL           = $2AFF = 11007          rom.asm:6316
PRNTLP           = $1B0E =  6926          rom.asm:3827
PRNTNB           = $1B51 =  6993          rom.asm:3859
PRNTOK           = $1427 =  5159          rom.asm:2825
PRNTRETURN       = $0937 =  2359          rom.asm:1497
PRNTST           = $1B55 =  6997          rom.asm:3861
PRNTVIDEO        = $815A = 33114          rom.asm:2200
PRNUMS           = $2228 =  8744          rom.asm:4875
PROCES           = $164C =  5708          rom.asm:3145
PROGND           = $8136 = 33078          rom.asm:2178
PROGST           = $81AF = 33199          rom.asm:2228
PROMPT           = $1531 =  5425          rom.asm:2988
PRS              = $2229 =  8745          rom.asm:4876
PRS1             = $222C =  8748          rom.asm:4877
PRSLP            = $2233 =  8755          rom.asm:4880
PRTNUM           = $8166 = 33126          rom.asm:7425
PSG_DAT          = $0041 =    65          rom.asm:110
PSG_REG          = $0040 =    64          rom.asm:109
PSUB             = $271A = 10010          rom.asm:5643
PTRLP            = $14B6 =  5302          rom.asm:2905
PUTBUF           = $1681 =  5761          rom.asm:3173
PUTCHRBUF        = $0D32 =  3378          rom.asm:1969
PUTCRSCHR        = $0744 =  1860          rom.asm:1214
PUTCTL           = $1686 =  5766          rom.asm:3175
PUTFID           = $1885 =  6277          rom.asm:3450
PXLSET           = $301D = 12317          rom.asm:7040
PXOR             = $1E7B =  7803          rom.asm:4289
PXOR1            = $1EA5 =  7845          rom.asm:4318
QTSTLP           = $21EE =  8686          rom.asm:4845
QTSTR            = $21E8 =  8680          rom.asm:4841
QUARTR           = $2DA0 = 11680          rom.asm:6671
RADIUS           = $816A = 33130          rom.asm:7174
RAWPRINT         = $0224 =   548          rom.asm:382
READ             = $1C16 =  7190          rom.asm:3955
READFG           = $812D = 33069          rom.asm:2173
READKBLN         = $0C2A =  3114          rom.asm:1836
READ_VIDEO_LOC   = $05E9 =  1513          rom.asm:1005
READ_VSTAT       = $061E =  1566          rom.asm:1048
RECWRD           = $2E3E = 11838          rom.asm:6744 (unused)
REDO             = $1BC1 =  7105          rom.asm:3919
REM              = $1A5A =  6746          rom.asm:3730
RESDIV           = $28F3 = 10483          rom.asm:5956
RESEED           = $2D3E = 11582          rom.asm:6627
RESET            = $3620 = 13856          rom.asm:7840
RESTMR           = $0315 =   789          rom.asm:540
RESTNL           = $18EE =  6382          rom.asm:3519
RESTOR           = $18D9 =  6361          rom.asm:3508
RESZER           = $2785 = 10117          rom.asm:5712
RETADR           = $1FDE =  8158          rom.asm:4507
RETINT           = $297C = 10620          rom.asm:6047
RETLIN           = $1A52 =  6738          rom.asm:3724
RETNAD           = $15C5 =  5573          rom.asm:3070
RETNUL           = $1FE1 =  8161          rom.asm:4511
RETNUM           = $1E15 =  7701          rom.asm:4222
RETREL           = $296E = 10606          rom.asm:6037
RETURN           = $1A33 =  6707          rom.asm:3708
RG               = $0004 =     4          rom.asm:2236
RGMSG            = $1173 =  4467          rom.asm:2626
RGPTR            = $12EF =  4847          rom.asm:2652 (unused)
RIGHT            = $23FB =  9211          rom.asm:5175
RIGHT1           = $23CF =  9167          rom.asm:5144
RINPUT           = $80A7 = 32935          rom.asm:2153
RLTLP            = $1D58 =  7512          rom.asm:4124
RND              = $2CDD = 11485          rom.asm:6574
RND1             = $2D19 = 11545          rom.asm:6605
RND2             = $2D35 = 11573          rom.asm:6623
RNDTAB           = $2D46 = 11590          rom.asm:6634
RNGTST           = $2BD4 = 11220          rom.asm:6443
RONDB            = $27A6 = 10150          rom.asm:5736
RONDUP           = $27A5 = 10149          rom.asm:5735
ROUND            = $270D =  9997          rom.asm:5637
RPT100           = $04F3 =  1267          rom.asm:848
RPT101           = $049A =  1178          rom.asm:796
RPT102           = $049D =  1181          rom.asm:798
RPT103           = $04B3 =  1203          rom.asm:811
RPT104           = $04BB =  1211          rom.asm:815
RPTCL1           = $31A3 = 12707          rom.asm:7216
RPTCRL           = $3190 = 12688          rom.asm:7210
RPTCVB1          = $3323 = 13091          rom.asm:7386
RPTCVB2          = $332C = 13100          rom.asm:7391
RPTDRW           = $30D6 = 12502          rom.asm:7123
RPTEMPTYBUF      = $0557 =  1367          rom.asm:915
RPTEMPTYROW      = $08A1 =  2209          rom.asm:1412
RPTFLL1          = $05BF =  1471          rom.asm:975
RPTKBDRD         = $0C7F =  3199          rom.asm:1880
RPTLDCL          = $2F6D = 12141          rom.asm:6918
RPTNLLSRC        = $08CB =  2251          rom.asm:1441
RPTNLLSRC2       = $08F6 =  2294          rom.asm:1465
RPTPS            = $2E69 = 11881          rom.asm:6773
RPTRSSR          = $3378 = 13176          rom.asm:7452
RPTWLCMBP        = $0BB6 =  2998          rom.asm:1762
RPVOLCG          = $2597 =  9623          rom.asm:5421
RSCALE           = $2AE0 = 10976          rom.asm:6296
RST00            = $0000 =     0          rom.asm:132 (unused)
RST08            = $0008 =     8          rom.asm:138 (unused)
RST10            = $0010 =    16          rom.asm:153 (unused)
RST18            = $0018 =    24          rom.asm:164 (unused)
RSTCHRCRS        = $064D =  1613          rom.asm:1077
RSTPSG           = $0B8D =  2957          rom.asm:1742
RSTSER1          = $336B = 13163          rom.asm:7444
RSTSTR           = $241E =  9246          rom.asm:5195
RSTVDPRAMREG     = $09D2 =  2514          rom.asm:1549
RUN              = $19F8 =  6648          rom.asm:3675
RUNCNT           = $1889 =  6281          rom.asm:3454
RUNFST           = $14FA =  5370          rom.asm:2960
RUNLIN           = $1A14 =  6676          rom.asm:3691
RXA              = $01C8 =   456          rom.asm:316
RXA_EXIT         = $01EE =   494          rom.asm:334
RXEND            = $33E0 = 13280          rom.asm:7509
RX_CHA_AVAIL     = $0100 =   256          rom.asm:186
SA               = $002E =    46          rom.asm:2257
SAMSG            = $12D2 =  4818          rom.asm:2647
SAPTR            = $1319 =  4889          rom.asm:2673 (unused)
SAVEXP           = $2786 = 10118          rom.asm:5713
SAVSTP           = $187C =  6268          rom.asm:3443
SAVSTR           = $21C3 =  8643          rom.asm:4812
SBSCPT           = $1FEC =  8172          rom.asm:4517
SC               = $002C =    44          rom.asm:2256
SCALE            = $27E4 = 10212          rom.asm:5790
SCALLP           = $27E6 = 10214          rom.asm:5791
SCALMI           = $2AAB = 10923          rom.asm:6258
SCALPL           = $2AC1 = 10945          rom.asm:6272
SCERR            = $3525 = 13605          rom.asm:7668
SCERR1           = $3521 = 13601          rom.asm:7665
SCMSG            = $12BD =  4797          rom.asm:2646
SCNEND           = $22FA =  8954          rom.asm:5002
SCPTLP           = $1FF2 =  8178          rom.asm:4521
SCPTR            = $1317 =  4887          rom.asm:2672 (unused)
SCREEN           = $2E77 = 11895          rom.asm:6791
SCROLLNXTRW      = $084B =  2123          rom.asm:1368
SCROLLUP         = $0832 =  2098          rom.asm:1356
SCR_CURS_X       = $8153 = 33107          rom.asm:2193
SCR_CURS_Y       = $8154 = 33108          rom.asm:2194
SCR_CUR_NX       = $8155 = 33109          rom.asm:2195
SCR_CUR_NY       = $8156 = 33110          rom.asm:2196
SCR_MODE         = $814F = 33103          rom.asm:2191
SCR_NAM_TB       = $8151 = 33105          rom.asm:2192
SCR_ORG_CHR      = $8157 = 33111          rom.asm:2197
SCR_SIZE_H       = $814E = 33102          rom.asm:2190
SCR_SIZE_W       = $814D = 33101          rom.asm:2189
SCVDP            = $2EA3 = 11939          rom.asm:6808
SEARCH           = $158D =  5517          rom.asm:3032
SEED             = $8075 = 32885          rom.asm:2142
SENDCHRPTRNS     = $0A0A =  2570          rom.asm:1587
SENDSND          = $0BB3 =  2995          rom.asm:1760
SERABITS         = $819E = 33182          rom.asm:2225
SERBUF_START     = $8000 = 32768          rom.asm:120
SERIAL           = $3351 = 13137          rom.asm:7431
SERIALS_EN       = $819D = 33181          rom.asm:2224
SERLED           = $33A1 = 13217          rom.asm:7473
SER_BUFSIZE      = $0058 =    88          rom.asm:116
SER_EMPTYSIZE    = $0005 =     5          rom.asm:118
SER_FULLSIZE     = $0050 =    80          rom.asm:117
SETBEEP          = $04FD =  1277          rom.asm:857
SETBRCL          = $2F78 = 12152          rom.asm:6926
SETCRSRY         = $070B =  1803          rom.asm:1178
SETCSRCOORDS     = $070C =  1804          rom.asm:1179
SETIO            = $249E =  9374          rom.asm:5277
SETLIT           = $15D7 =  5591          rom.asm:3082
SETNAMETABLE     = $05B6 =  1462          rom.asm:970
SETPAR           = $34A9 = 13481          rom.asm:7607
SETPTR           = $14B1 =  5297          rom.asm:2902
SETSNDREG        = $0BD4 =  3028          rom.asm:1777
SETTOP           = $0EAD =  3757          rom.asm:2312
SETVDP           = $2E8A = 11914          rom.asm:6799 (unused)
SETVDPADRS       = $05C9 =  1481          rom.asm:984
SET_GFX_MODE     = $09D7 =  2519          rom.asm:1556
SET_GFX_MODE2    = $09DF =  2527          rom.asm:1560
SET_P1           = $3466 = 13414          rom.asm:7569
SFTPRG           = $147B =  5243          rom.asm:2865
SGN              = $2974 = 10612          rom.asm:6044
SGNEXP           = $1E63 =  7779          rom.asm:4270
SGNRES           = $8148 = 33096          rom.asm:2186
SHOW_LOGO        = $0471 =  1137          rom.asm:777
SHRITE           = $27F3 = 10227          rom.asm:5799
SHRLP            = $27F6 = 10230          rom.asm:5801
SHRT1            = $27FA = 10234          rom.asm:5805
SIGNON           = $0EFE =  3838          rom.asm:2346
SIGNS            = $29CB = 10699          rom.asm:6104
SIN              = $2D58 = 11608          rom.asm:6640
SIN1             = $2D88 = 11656          rom.asm:6660
SINTAB           = $2DA4 = 11684          rom.asm:6673
SIOBFR           = $816C = 33132          rom.asm:7430
SIO_A_DI         = $017C =   380          rom.asm:265
SIO_A_EI         = $0188 =   392          rom.asm:274
SIO_A_SETS       = $02F1 =   753          rom.asm:501
SIO_B_SETS       = $02F7 =   759          rom.asm:507 (unused)
SIO_CA           = $0022 =    34          rom.asm:99
SIO_CB           = $0023 =    35          rom.asm:100
SIO_DA           = $0020 =    32          rom.asm:101
SIO_DB           = $0021 =    33          rom.asm:102 (unused)
SIXDIG           = $2B27 = 11047          rom.asm:6336
SMPVAR           = $228E =  8846          rom.asm:4930
SMSER1           = $2CBC = 11452          rom.asm:6552
SN               = $0002 =     2          rom.asm:2235
SND1             = $2603 =  9731          rom.asm:5480
SND2VID          = $16E4 =  5860          rom.asm:3236
SNDCHRTOBFR      = $0918 =  2328          rom.asm:1481
SNDCLRSET        = $05AC =  1452          rom.asm:961
SNDLOGPT         = $0528 =  1320          rom.asm:887
SNDOVR           = $2638 =  9784          rom.asm:5510
SNDREGCFG        = $0B9A =  2970          rom.asm:1751
SNERR            = $13DB =  5083          rom.asm:2783
SNMSG            = $116C =  4460          rom.asm:2625
SNPTR            = $12ED =  4845          rom.asm:2651 (unused)
SOUND            = $25AE =  9646          rom.asm:5439
SPC              = $0020 =    32          rom.asm:2119
SPCFST           = $2B18 = 11032          rom.asm:6328
SPCLP            = $1BB2 =  7090          rom.asm:3911
SPEC_RX_CONDITON = $0196 =   406          rom.asm:287
SQR              = $2BFE = 11262          rom.asm:6464
SRCHLIN          = $17F1 =  6129          rom.asm:3363
SRCHLN           = $14CE =  5326          rom.asm:2924
SRCHLP           = $14D1 =  5329          rom.asm:2925
SREG             = $2556 =  9558          rom.asm:5388
SRPT2            = $339B = 13211          rom.asm:7470
SRTTXT           = $8160 = 33120          rom.asm:1425
SSTAT            = $26B9 =  9913          rom.asm:5588
SSTSA            = $2356 =  9046          rom.asm:5062
ST               = $001E =    30          rom.asm:2249
STACK            = $80B6 = 32950          rom.asm:2158
STAKFP           = $2996 = 10646          rom.asm:6064
STALL            = $1902 =  6402          rom.asm:3536
STARTB           = $0E4D =  3661          rom.asm:2262
STARTEMPTY       = $05A8 =  1448          rom.asm:959
STKTHS           = $1D9C =  7580          rom.asm:4165
STLOOK           = $8213 = 33299          rom.asm:2229
STMSG            = $1246 =  4678          rom.asm:2639
STOP             = $1911 =  6417          rom.asm:3546
STORED           = $19D5 =  6613          rom.asm:3655
STPBT            = $816B = 33131          rom.asm:7429
STPOOL           = $22D1 =  8913          rom.asm:4967
STPTR            = $1309 =  4873          rom.asm:2665 (unused)
STR              = $21B3 =  8627          rom.asm:4805
STR1             = $21B9 =  8633          rom.asm:4807
STRADD           = $22D4 =  8916          rom.asm:4969
STRBOT           = $8123 = 33059          rom.asm:2167
STRE2            = $30D3 = 12499          rom.asm:7122 (unused)
STRENT           = $1C6D =  7277          rom.asm:4002
STRPAR           = $34C8 = 13512          rom.asm:7623
STRSPC           = $80AA = 32938          rom.asm:2154
STTLIN           = $1B5C =  7004          rom.asm:3865
SUBCDE           = $271C = 10012          rom.asm:5645
SUBPHL           = $2716 = 10006          rom.asm:5641
SUMLP            = $2CC5 = 11461          rom.asm:6557
SUMSER           = $2CAD = 11437          rom.asm:6545
SUPTLZ           = $2BA6 = 11174          rom.asm:6413
SUP_BPS          = $3500 = 13568          rom.asm:7659
SVNAM2           = $1F4B =  8011          rom.asm:4426
SVSTAD           = $21E1 =  8673          rom.asm:4833
SX               = $816E = 33134          rom.asm:7055
SY               = $8170 = 33136          rom.asm:7056
SYS              = $24C2 =  9410          rom.asm:5297
SYSRET           = $24E8 =  9448          rom.asm:5316
TAN              = $2DB9 = 11705          rom.asm:6680
TEMPSTACK        = $8108 = 33032          rom.asm:126
TESTALT          = $0CAE =  3246          rom.asm:1905
TESTCTRL         = $0CBB =  3259          rom.asm:1911
TESTOS           = $2260 =  8800          rom.asm:4909
TESTR            = $2242 =  8770          rom.asm:4889
TM               = $0018 =    24          rom.asm:2246
TMERR            = $13ED =  5101          rom.asm:2795
TMMSG            = $1213 =  4627          rom.asm:2636
TMPBFR1          = $815E = 33118          rom.asm:2204
TMPBFR2          = $8160 = 33120          rom.asm:2205
TMPBFR3          = $8162 = 33122          rom.asm:2206
TMPBFR4          = $8164 = 33124          rom.asm:2207
TMPKEYBFR        = $819A = 33178          rom.asm:2219
TMPSTR           = $811F = 33055          rom.asm:2166
TMPTR            = $1303 =  4867          rom.asm:2662 (unused)
TMR              = $20D2 =  8402          rom.asm:4671
TMRCNT           = $8149 = 33097          rom.asm:2187
TMSTPL           = $8113 = 33043          rom.asm:2165
TMSTPT           = $8111 = 33041          rom.asm:2164
TOPOOL           = $23C7 =  9159          rom.asm:5139
TOSTRA           = $235F =  9055          rom.asm:5071
TRYAGN           = $2B81 = 11137          rom.asm:6386
TSALP            = $2360 =  9056          rom.asm:5072
TSTBIT           = $3633 = 13875          rom.asm:7851 (unused)
TSTBRK           = $18F4 =  6388          rom.asm:3525
TSTMEM           = $0E9B =  3739          rom.asm:2300
TSTNUM           = $1D2D =  7469          rom.asm:4100
TSTOPL           = $2209 =  8713          rom.asm:4861
TSTRED           = $1EAA =  7850          rom.asm:4324
TSTREM           = $15DA =  5594          rom.asm:3083
TSTSGN           = $2965 = 10597          rom.asm:6032
TSTSPC           = $17F7 =  6135          rom.asm:3370
TSTSTR           = $1D2E =  7470          rom.asm:4101
TTYLIN           = $162A =  5674          rom.asm:3130
TXA              = $01F2 =   498          rom.asm:342
TXA_EXIT         = $020B =   523          rom.asm:356
TXTMD            = $0382 =   898          rom.asm:657 (unused)
TX_EMP           = $0213 =   531          rom.asm:365
TYPE             = $810D = 33037          rom.asm:2161
UF               = $0022 =    34          rom.asm:2251
UFERR            = $13E7 =  5095          rom.asm:2791
UFMSG            = $1270 =  4720          rom.asm:2641
UFPTR            = $130D =  4877          rom.asm:2667 (unused)
UL               = $000E =    14          rom.asm:2241
ULERR            = $1A2E =  6702          rom.asm:3705
ULMSG            = $11C1 =  4545          rom.asm:2631
ULPTR            = $12F9 =  4857          rom.asm:2657 (unused)
UNITY            = $2808 = 10248          rom.asm:5818
UPDATA           = $18EF =  6383          rom.asm:3520
USR              = $8061 = 32865          rom.asm:2134
VAL              = $2435 =  9269          rom.asm:5214
VAL1             = $2453 =  9299          rom.asm:5234
VAL2             = $245D =  9309          rom.asm:5238
VAL3             = $2460 =  9312          rom.asm:5239
VALIDX           = $330B = 13067          rom.asm:7363
VALIDY           = $3310 = 13072          rom.asm:7369
VAREND           = $8138 = 33080          rom.asm:2179
VDPMODESET       = $0A14 =  2580          rom.asm:1601
VDPMODESET1      = $0A1C =  2588          rom.asm:1610 (unused)
VDPMODESET2      = $0A24 =  2596          rom.asm:1620 (unused)
VDPMODESETEX2    = $0A34 =  2612          rom.asm:1640 (unused)
VDPMODESETMC     = $0A2C =  2604          rom.asm:1630 (unused)
VDP_DAT          = $0030 =    48          rom.asm:105
VDP_SET          = $0032 =    50          rom.asm:106
VIDEOBUFF        = $8166 = 33126          rom.asm:2208
VIDTMP1          = $818E = 33166          rom.asm:2209
VIDTMP2          = $8190 = 33168          rom.asm:2210
VOLCH            = $25A3 =  9635          rom.asm:5428
VOLUME           = $2575 =  9589          rom.asm:5406
VPEEK            = $24F1 =  9457          rom.asm:5326
VPOKE            = $2519 =  9497          rom.asm:5351
VREG             = $2692 =  9874          rom.asm:5566
VSTAT            = $26AE =  9902          rom.asm:5581
WAIT             = $2480 =  9344          rom.asm:5261
WAITLP           = $2495 =  9365          rom.asm:5271
WARM             = $0E4A =  3658          rom.asm:2260
WARMST           = $0EE5 =  3813          rom.asm:2339
WIDTH            = $2E31 = 11825          rom.asm:6735
WLCBPDAT         = $0BC4 =  3012          rom.asm:1772
WLCMBEEP         = $0BAA =  2986          rom.asm:1757
WORDS            = $0F7A =  3962          rom.asm:2398
WORDTB           = $10E3 =  4323          rom.asm:2505
WRITEBUF         = $0886 =  2182          rom.asm:1397
WRITE_VIDEO_LOC  = $05FE =  1534          rom.asm:1022
WRITE_VREG       = $0613 =  1555          rom.asm:1039
WRKSPC           = $805E = 32862          rom.asm:2133
WRTSND           = $267D =  9853          rom.asm:5548
WRTSNDREG        = $0BD9 =  3033          rom.asm:1782
WTSPC            = $17FD =  6141          rom.asm:3373
X1               = $815E = 33118          rom.asm:7049
X1GR             = $3082 = 12418          rom.asm:7095
X2               = $8166 = 33126          rom.asm:7051
XC               = $8166 = 33126          rom.asm:7172
XI               = $816C = 33132          rom.asm:7175
Y1               = $8160 = 33120          rom.asm:7050
Y1GR             = $30A9 = 12457          rom.asm:7108
Y2               = $8168 = 33128          rom.asm:7052
YC               = $8168 = 33128          rom.asm:7173
YI               = $816E = 33134          rom.asm:7176
ZDATA            = $0083 =   131          rom.asm:2567
ZDIV             = $00BA =   186          rom.asm:2585 (unused)
ZEND             = $0080 =   128          rom.asm:2565
ZEQUAL           = $00C0 =   192          rom.asm:2588
ZERARY           = $208D =  8333          rom.asm:4620
ZERBYT           = $1378 =  4984          rom.asm:2720
ZEROLP           = $1FD0 =  8144          rom.asm:4498
ZEROSUP          = $35C7 = 13767          rom.asm:7777
ZFN              = $00B2 =   178          rom.asm:2576
ZFOR             = $0081 =   129          rom.asm:2566
ZGOSUB           = $008C =   140          rom.asm:2569
ZGOTO            = $0088 =   136          rom.asm:2568
ZGTR             = $00BF =   191          rom.asm:2587
ZLEFT            = $00DF =   223          rom.asm:2592
ZLTH             = $00C1 =   193          rom.asm:2589
ZMINUS           = $00B8 =   184          rom.asm:2583
ZNEW             = $00AF =   175          rom.asm:2572
ZNOT             = $00B5 =   181          rom.asm:2579
ZONELP           = $1B8B =  7051          rom.asm:3889
ZOR              = $00BE =   190          rom.asm:2586
ZPLUS            = $00B7 =   183          rom.asm:2582
ZPRINT           = $00A9 =   169          rom.asm:2571
ZREM             = $008E =   142          rom.asm:2570
ZSGN             = $00C2 =   194          rom.asm:2591
ZSPC             = $00B3 =   179          rom.asm:2577
ZSTEP            = $00B6 =   182          rom.asm:2580
ZTAB             = $00B0 =   176          rom.asm:2574
ZTHEN            = $00B4 =   180          rom.asm:2578
ZTIMES           = $00B9 =   185          rom.asm:2584 (unused)
ZTO              = $00B1 =   177          rom.asm:2575
_end             = $474E = 18254          rom.asm:130 (unused)
_size            = $474E = 18254          rom.asm:130 (unused)
absHL            = $3665 = 13925          rom.asm:7947
basicStarted     = $805D = 32861          rom.asm:124
bufWrap          = $0058 =    88          rom.asm:125
initCTC          = $02FB =   763          rom.asm:516
initPSG          = $0B7C =  2940          rom.asm:1733
initVDP          = $035D =   861          rom.asm:637
negHL            = $3668 = 13928          rom.asm:7949
serBufUsed       = $805C = 32860          rom.asm:123
serInPtr         = $8058 = 32856          rom.asm:121
serRdPtr         = $805A = 32858          rom.asm:122


total time: 0.1305 sec.
no errors
