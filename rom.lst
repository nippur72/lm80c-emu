              	; --------------------------------------
              	; zasm: assemble "rom.asm"
              	; date: 2020-05-31 08:47:06
              	; --------------------------------------


              	; 
              	; ------------------------------------------------------------------------------
              	; LM80C - BOOTLOADER - R3.13
              	; ------------------------------------------------------------------------------
              	; The following code is intended to be used with LM80C Z80-based computer
              	; designed by Leonardo Miliani. Code and computer schematics are released under
              	; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
              	; kind of warranty: you can use them at your own risk.
              	; You are free to use them for any non-commercial use: you are only asked to
              	; maintain the copyright notices, include this advice and the note to the 
              	; attribution of the original version to Leonardo Miliani, if you intend to
              	; redistribuite them.
              	; https://www.leonardomiliani.com
              	; 
              	; Please support me by visiting the following links:
              	; Main project page: https://www.leonardomiliani.com
              	; Schematics and code: https://github.com/leomil72/LM80C
              	; Videos about the computer: https://www.youtube.com/user/leomil72/videos
              	; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
              	; ------------------------------------------------------------------------------
              	
              	; ADDRESS DECODING (bits A6/A5/A4)
              	; 0000xxxx : PIO
              	; 0001xxxx : CTC
              	; 0010xxxx : SIO
              	; 0011xxxx : VDP
              	; 0100xxxx : PSG
              	
              	; label defining for PIO (Parallel Input/Output)
0000:         	PIO_DA          equ %00000000
0001:         	PIO_DB          equ %00000001
0002:         	PIO_CA          equ %00000010
0003:         	PIO_CB          equ %00000011
              	
              	; label defining for CTC (Counter Timer Circuit)
0010:         	CTC_CH0         equ %00010000
0011:         	CTC_CH1         equ %00010001
0012:         	CTC_CH2         equ %00010010
0013:         	CTC_CH3         equ %00010011
              	
              	;label defining for SIO (Serial Input/Output)
0022:         	SIO_CA          equ %00100010
0023:         	SIO_CB          equ %00100011
0020:         	SIO_DA          equ %00100000
0021:         	SIO_DB          equ %00100001
              	
              	;label defining for VDP (Video Display Processor)
0030:         	VDP_DAT         equ %00110000
0032:         	VDP_SET         equ %00110010
              	
              	; label defining for PSG (Programmable Sound Generator)
0040:         	PSG_REG         equ %01000000
0041:         	PSG_DAT         equ %01000001
              	
              	; Interrupt-driven serial I/O interface lead by the Z80 SIO to run modified
              	; NASCOM Basic 4.7 - Full input buffering with incoming data hardware handshaking
              	; Handshake shows full before the buffer is totally filled to allow run-on from the sender
              	
0058:         	SER_BUFSIZE     equ     $58
0050:         	SER_FULLSIZE    equ     $50
0005:         	SER_EMPTYSIZE   equ     $05
              	
8000:         	SERBUF_START    equ     $8000           ; RAM starts here
8058:         	serInPtr        equ     SERBUF_START + SER_BUFSIZE
805A:         	serRdPtr        equ     serInPtr+2
805C:         	serBufUsed      equ     serRdPtr+2
805D:         	basicStarted    equ     serBufUsed+1
0058:         	bufWrap         equ     (SERBUF_START + SER_BUFSIZE) & $FF
818D:         	TEMPSTACK       equ     CURPOS - 3      ; top of BASIC line input buffer so is "free ram" when BASIC resets
              	
              	;------------------------------------------------------------------------------
              	; BASE MEMORY - RESET LOCATION - $0000
              	; the CPU jumps to 0000h after a reset
0000:         	                org     $0000
0000: F3      	RST00:          di                      ; be sure that INTs are disabled
0001: C35A02  	                jp      INIT_HW         ; jump to system initialization
              	
              	;------------------------------------------------------------------------------
              	; send a character over serial
0004: FFFFFFFF	                org     $0008
0008: C3F701  	RST08:          jp      TXA
              	
              	;------------------------------------------------------------------------------
              	; interrupt vector when SIO has a char available in its buffer
000B: FF      	                org     $000C
000C: 0001    	                defw    RX_CHA_AVAIL
              	
              	;------------------------------------------------------------------------------
              	; interrupt vector for SIO special conditions (i.e. buf overrun)
              	                org     $000E
000E: 9B01    	                defw    SPEC_RX_CONDITON
              	
              	;------------------------------------------------------------------------------
              	; receive a character over serial
              	                org     $0010
0010: C3CD01  	RST10:          jp      RXA
              	
              	;------------------------------------------------------------------------------
              	; check serial status
              	
0013: FFFFFFFF	                org     $0018
0017: FF      	
0018: C32402  	RST18:          jp      CKINCHAR
              	
              	;------------------------------------------------------------------------------
              	; interrupt vectors for CTC 
001B: FFFFFFFF	                org     $0040               ; for CH0 Timer - unused
001F: FF...   	
0040: D281    	                defw    CTC0IV
              	                
              	                org     $0042               ; for CH1 Timer - unused
0042: D581    	                defw    CTC1IV
              	                
              	                org     $0044               ; for CH2 timer - unused
0044: D881    	                defw    CTC2IV
              	                
              	                org     $0046               ; for CH3 Timer - used for 100ths/s counter
0046: DB81    	                defw    CTC3IV
              	
              	;------------------------------------------------------------------------------
              	; interrupt routine for NMI
0048: FFFFFFFF	                org     $0066
004C: FF...   	
0066: C36180  	                jp      NMIUSR              ; jump to execute NMI service routine
              	
              	;------------------------------------------------------------------------------
              	
0069: FFFFFFFF	                org     $00A0
006D: FF...   	
00A0: 4C4D3830	                defb    $4C,$4D,$38,$30,$43,$20,$43,$4F
00A4: 4320434F	
00A8: 4C4F5200	                defb    $4C,$4F,$52,$00,$00,$00,$00,$00
00AC: 00000000	
00B0: 434F4D50	                defb    $43,$4F,$4D,$50,$55,$54,$45,$52
00B4: 55544552	
00B8: 20283230	                defb    $20,$28,$32,$30,$32,$30,$29,$00
00BC: 32302900	
00C0: 44657369	                defb    $44,$65,$73,$69,$67,$6E,$65,$64
00C4: 676E6564	
00C8: 20627900	                defb    $20,$62,$79,$00,$00,$00,$00,$00
00CC: 00000000	
00D0: 4C656F6E	                defb    $4C,$65,$6F,$6E,$61,$72,$64,$6F
00D4: 6172646F	
00D8: 204D696C	                defb    $20,$4D,$69,$6C,$69,$61,$6E,$69
00DC: 69616E69	
00E0: 46572033	FWVER:          defm    'FW 3.13',$20,__date__,$20,__time__,$00
00E4: 2E313320	
00E8: 32303230	
00EC: 2D30352D	
00F0: 33312030	
00F4: 383A3437	
00F8: 3A303600	
              	;------------------------------------------------------------------------------
              	; interrupt driven routine to get chars from Z80 SIO
00FC: FFFFFFFF	                org     $0100
0100: F5      	RX_CHA_AVAIL:   push    AF              ; store A
0101: E5      	                push    HL              ; and HL
0102: CD6501  	                call    A_RTS_OFF       ; disable RTS line
0105: DB20    	                in      A,(SIO_DA)      ; read char from RX buffer into A
0107: 322B82  	                ld      (TMPKEYBFR),A   ; store it into the temp key buffer
010A: CD3601  	                call    CHARINTOBFR     ; sub-routine to put the char into the input buffer
010D: D23101  	                jp      NC,LVRXCHA      ; if buffer is full, then leave without doing anything else
0110: 3A2B82  	                ld      A,(TMPKEYBFR)   ; retrieve char
0113: 32EC81  	                ld      (CHR4VID),A     ; write into buffer for video printing
0116: FE0D    	                cp      CR              ; is it RETURN?
0118: CA2001  	                jp      Z,CNTRXCHA      ; yes, continue
011B: FE20    	                cp      $20             ; is it another control char (code < 32)?
011D: DA3101  	                jp      C,LVRXCHA       ; yes, leave w/o printing it on video nor sending back to serial
0120: F5      	CNTRXCHA:       push    AF              ; store char
0121: AF      	                xor     A
0122: 322982  	                ld      (KBDNPT),A      ; a char from serial is like a char printed by BASIC
0125: 3AEB81  	                ld      A,(PRNTVIDEO)   ; load status of print-on-video
0128: FE01    	                cp      $01             ; is the print on video on?
012A: CCAC06  	                call    Z,CHAR2VID      ; yes, print on screen
012D: F1      	                pop     AF              ; retrieve char
012E: CDF701  	                call    TXA             ; send back to serial
0131: E1      	LVRXCHA:        pop     HL              ; retrieve HL
0132: F1      	                pop     AF              ; and A
0133: FB      	                ei                      ; re-enable interrupts
0134: ED4D    	                reti                    ; and exit
              	
              	; put a char into the input buffer, char is into A
              	; this sub is called both from the ISR "RX_CHA_AVAIL" and when
              	; the RETURN key is pressed on the keyboard
0136: F5      	CHARINTOBFR:    push    AF              ; store it
0137: 3A5C80  	                ld      A,(serBufUsed)  ; load buffer size
013A: FE58    	                cp      SER_BUFSIZE     ; if buffer is not full
013C: DA4101  	                jp      C,NOTFULL       ; then store the char
013F: F1      	                pop     AF              ; else drop it
0140: C9      	                ret                     ; and exit
0141: 2A5880  	NOTFULL:        ld      HL,(serInPtr)   ; buffer is not full, can store the char
0144: 23      	                inc     HL              ; load pointer to find first free cell
0145: 7D      	                ld      A,L             ; only check low byte because buffer<256
0146: FE58    	                cp      bufWrap         ; check if the pointer is at the last cell
0148: 2003    	                jr      NZ,NOTWRAP      ; if not then continue
014A: 210080  	                ld      HL,SERBUF_START ; else load the address of the first cell
014D: 225880  	NOTWRAP:        ld      (serInPtr),HL   ; store the new pointer
0150: F1      	                pop     AF              ; then recover the char
0151: 77      	                ld      (HL),A          ; and store it in the appropriate cell
0152: 3A5C80  	                ld      A,(serBufUsed)  ; load the size of the input buffer
0155: 3C      	                inc     A               ; increment it
0156: 325C80  	                ld      (serBufUsed),A  ; and store the new size
0159: FE50    	                cp      SER_FULLSIZE    ; check if input buffer is full
015B: D8      	                ret     C               ; exit if buffer is not full
015C: 3A2E82  	                ld      A,(SERIALS_EN)  ; check if serial 1 is open
015F: 1F      	                rra                     ; bit 0 into Carry: if Carry is 1 then serial 0 is open and...
0160: DC6501  	                call    C,A_RTS_OFF     ; ...stop receiving further chars
0163: AF      	                xor     A               ; clear Carry to set a buffer full condition
0164: C9      	                ret
              	
              	;-------------------------------------------------------------------------------
              	; Z80 SIO MANAGEMENT
              	;-------------------------------------------------------------------------------
              	; disable RTS:
              	; by resetting RTS bit (set to 0), the RTS line is disabled (HIGH)
0165: F5      	A_RTS_OFF:      push    AF              ; store A
0166: 3E05    	                ld      A,%00000101     ; write into WR0: select WR5
0168: D322    	                out     (SIO_CA),A
016A: 3A2F82  	                ld      A,(SERABITS)    ; load data bits
016D: F628    	                or      %00101000       ; TX enable; RTS disable
016F: D322    	                out     (SIO_CA),A      ; send setting
0171: F1      	                pop     AF              ; retrieve A
0172: C9      	                ret                     ; exit
              	
              	; enable RTS
              	; by setting RTS bit (set to 1), the RTS line is enabled (LOW)
0173: F5      	A_RTS_ON:       push    AF              ; store A
0174: 3E05    	                ld      A,%00000101     ; write into WR0: select WR5
0176: D322    	                out     (SIO_CA),A
0178: 3A2F82  	                ld      A,(SERABITS)    ; load data bits
017B: F62A    	                or      %00101010       ; TX enable; RTS enable
017D: D322    	                out     (SIO_CA),A      ; send setting
017F: F1      	                pop     AF              ; retrieve A
0180: C9      	                ret                     ; return
              	
              	; disable SIO RX channel A
0181: F5      	SIO_A_DI:       push    AF              ; store A
0182: 3E03    	                ld      A,%00000011     ; write into WR0: select WR3
0184: D322    	                out     (SIO_CA),A
0186: 3A2F82  	                ld      A,(SERABITS)    ; load the serial bits; RX disabled; auto enable is OFF
0189: D322    	                out     (SIO_CA),A
018B: F1      	                pop     AF              ; retrieve A
018C: C9      	                ret                     ; return
              	
              	; enable SIO RX channel A
018D: F5      	SIO_A_EI:       push    AF              ; store A
018E: 3E03    	                ld      A,%00000011     ; write into WR0: select WR3
0190: D322    	                out     (SIO_CA),A      ; select register
0192: 3A2F82  	                ld      A,(SERABITS)    ; load the serial data bits
0195: CBC7    	                set     0,A             ; set RX enabled; auto enable is OFF
0197: D322    	                out     (SIO_CA),A      ; send setting to SIO
0199: F1      	                pop     AF              ; retrieve A
019A: C9      	                ret
              	
              	
              	; special SIO condition (i.e., buffer overrun)
              	; if buffer overruns then show an error, empty the RX buffer and send
              	; a break char
019B:         	SPEC_RX_CONDITON:
019B: F5      	                push    AF
019C: E5      	                push    HL
019D: CD6501  	                call    A_RTS_OFF       ; disable RTS
01A0: CD8101  	                call    SIO_A_DI        ; disable RX on ch. A
01A3: 3A2E82  	                ld      A,(SERIALS_EN)  ; load serial status
01A6: CB97    	                res     2,A             ; disable RX on port 1
01A8: 322E82  	                ld      (SERIALS_EN),A  ; store new serial status 
01AB: DB01    	                in      A,(PIO_DB)      ; read status LEDs
01AD: CBE7    	                set     4,A             ; set 5th pin ON
01AF: D301    	                out     (PIO_DB),A      ; send new setting
01B1: 3E30    	                ld      A,%00110000     ; write into WR0: error reset, select WR0
01B3: D322    	                out     (SIO_CA),A      ; send command to SIO
01B5: 3E03    	                ld      A,CTRLC
01B7: CD3601  	                call    CHARINTOBFR     ; send CTRL-C to BASIC
01BA: AF      	EMPTYCHABFR:    xor     A
01BB: D322    	                out     (SIO_CA),A      ; write to WR0, select RR0
01BD: DB22    	                in      A,(SIO_CA)      ; read RR0 register
01BF: E601    	                and     $01             ; check if input buffer if empty
01C1: CAC801  	                jp      Z,CHABFREMPTY   ; if yes (bit 0 = 0) then leave
01C4: DB20    	                in      A,(SIO_DA)      ; read chars
01C6: 18F2    	                jr      EMPTYCHABFR     ; repeat
01C8: E1      	CHABFREMPTY:    pop     HL
01C9: F1      	                pop     AF
01CA: FB      	                ei                      ; re-enable interrupts
01CB: ED4D    	                reti                    ; return from interrupt
              	
              	;------------------------------------------------------------------------------
              	; retrieve a char from the input buffer
01CD: 3A5C80  	RXA:            ld      A,(serBufUsed)  ; load the buffer size
01D0: A7      	                and     A               ; check if it's 0 (empty)
01D1: CACD01  	                jp      Z,RXA           ; if it's empty, wait for a char
01D4: F3      	                di                      ; disable interrupts
01D5: E5      	                push    HL              ; store HL
01D6: 2A5A80  	                ld      HL,(serRdPtr)   ; load pointer to first available char
01D9: 23      	                inc     HL              ; increment it (go to the next char)
01DA: 7D      	                ld      A,L             ; check if the end of the buffer has been reached
01DB: FE58    	                cp      bufWrap         ; (only check low byte because buffer<256)
01DD: 2003    	                jr      NZ,NOTRDWRAP    ; if not, jump straight
01DF: 210080  	                ld      HL,SERBUF_START ; else reload the starting address of the buffer
01E2: 225A80  	NOTRDWRAP:      ld      (serRdPtr),HL   ; store new pointer to the next char to read
01E5: 3A5C80  	                ld      A,(serBufUsed)  ; load buffer size
01E8: 3D      	                dec     A               ; decrement it
01E9: 325C80  	                ld      (serBufUsed),A  ; and store the new size
01EC: FE05    	                cp      SER_EMPTYSIZE   ; check if input buffer can be considered empty
01EE: 3003    	                jr      NC,RXA_EXIT     ; if not empty yet, then exit
01F0: CD7301  	                call    A_RTS_ON        ; else re-enable receiving chars
01F3: 7E      	RXA_EXIT:       ld      A,(HL)          ; recover the char and return it into A
01F4: E1      	                pop     HL              ; retrieve HL
01F5: FB      	                ei                      ; re-enable interrupts
01F6: C9      	                ret                     ; return
              	
              	;------------------------------------------------------------------------------
              	; sends a char over the serial (trick for INTs from WikiTI)
              	; char is into A
01F7: F5      	TXA:            push    AF              ; store AF
01F8: C5      	                push    BC              ; store BC
01F9: 47      	                ld      B,A             ; store char
01FA: ED57    	                ld      A,I             ; when loading I into A, P/V is set to the value of IFF (P/V is set if INTs enabled)
01FC: EA0102  	                jp      PE,CNTTXA       ; if set, jump over
01FF: ED57    	                ld      A,I             ; if not set, test again to fix "false negative" from interrupt occurring at first test
0201: F5      	CNTTXA:         push    AF              ; store current P/V flag
0202: F3      	                di                      ; disable INTs
0203: 3A2E82  	                ld      A,(SERIALS_EN)  ; load serial status
0206: FE05    	                cp      %00000101       ; check if serial 1 is open and RX/TX is enabled 
0208: 2006    	                jr      NZ,TXA_EXIT     ; no, jump over
020A: 78      	                ld      A,B             ; retrieve char
020B: D320    	                out     (SIO_DA),A      ; send char to the SIO
020D: CD1802  	                call    TX_EMP          ; wait for outgoing char to be sent
0210: F1      	TXA_EXIT:       pop     AF              ; retrieve P/V flag
0211: E21502  	                jp      PO,EXTXA        ; if P is reset, INTs were disabled so we can leave right now
0214: FB      	                ei                      ; INTs were enabled, so re-enable interrupts
0215: C1      	EXTXA:          pop     BC              ; retrieve BC
0216: F1      	                pop     AF              ; retrieve AF
0217: C9      	                ret                     ; return
              	
              	;------------------------------------------------------------------------------
              	; wait until outgoing serial has been sent
0218: 97      	TX_EMP:         sub     A               ; set A to 0
0219: 3C      	                inc     A               ; set A to 1
021A: D322    	                out     (SIO_CA),A      ; write to WR0, select RR1
021C: DB22    	                in      A,(SIO_CA)      ; read RR1 register
021E: CB47    	                bit     0,A             ; check if all chars have been sent
0220: CA1802  	                jp      Z,TX_EMP        ; if not (bit 0 = 0) then retrieve
0223: C9      	                ret                     ; else exit
              	
              	
              	;------------------------------------------------------------------------------
              	; check if there is some chars into the buffer
0224: 3A5C80  	CKINCHAR        ld      A,(serBufUsed)  ; load char in buffer
0227: A7      	                and     A               ; compare to 0
0228: C9      	                ret                     ; return
              	
              	;------------------------------------------------------------------------------
              	; print a text from memory, and terminate when $00 is found
0229: 7E      	RAWPRINT:       ld      A,(HL)          ; load character from memory cell pointed by HL
022A: B7      	                or      A               ; is it $00 (end string)?
022B: C8      	                ret     Z               ; Yes, then return
022C: 32EC81  	                ld      (CHR4VID),A     ; store char
022F: F3      	                di
0230: CDAC06  	                call    CHAR2VID        ; and send it to screen
0233: FB      	                ei
0234: 23      	                inc     HL              ; and select the next one
0235: 18F2    	                jr      RAWPRINT        ; repeat
              	
              	;-------------------------------------------------
              	; Interrupt service routine (ISR) for CH3 timer
              	; this is used to increment the 100ths of a second counter and for cursor flashing
0237: F5      	CH3_TIMER:      push    AF              ; save regs. A,
0238: C5      	                push    BC              ; BC,
0239: D5      	                push    DE              ; DE,
023A: E5      	                push    HL              ; HL
023B: 21CE81  	                ld      HL,TMRCNT       ; load starting address of the timer
023E: 0604    	                ld      B,$04           ; 4 bytes to check
0240: 34      	INCTMR3:        inc     (HL)            ; increment timer
0241: 2003    	                jr      NZ,CHKCRSR      ; if not zero then exit (finished increment)
0243: 23      	                inc     HL              ; if yes, there was an overflow, so increment next byte
0244: 10FA    	                djnz    INCTMR3         ; repeat for 4 bytes
0246: CD4507  	CHKCRSR:        call    FLASHCURSOR     ; call the flashing cursor routine
0249: CDFF0B  	                call    MNGSNDS         ; call the tone managemenet
024C: 3ACE81  	                ld      A,(TMRCNT)      ; check for keyboard management
024F: 1F      	                rra                     ; bit 0 = 1 ?
0250: D4640C  	                call    NC,KEYBOARD     ; no, so read the keyboard inputs
0253: E1      	                pop     HL              ; retrieve HL,
0254: D1      	                pop     DE              ; DE,
0255: C1      	                pop     BC              ; BC,
0256: F1      	                pop     AF              ; and A
0257: FB      	                ei                      ; re-enable interrupts
0258: ED4D    	                reti                    ; exit from ISR
              	
              	;------------------------------------------------------------------------------
              	;------------------------------------------------------------------------------
              	; HARDWARE INITIALISATION
              	; first run - setup HW & SW
              	;
025A: 218D81  	INIT_HW:        ld      HL,TEMPSTACK    ; load temp stack pointer
025D: F9      	                ld      SP,HL           ; set stack to temp stack pointer
025E: 210080  	                ld      HL,SERBUF_START ; set beginning of input buffer
0261: 225880  	                ld      (serInPtr),HL   ; for incoming chars to store into buffer
0264: 225A80  	                ld      (serRdPtr),HL   ; and for chars to be read from buffer
0267: AF      	                xor     A               ; reset A
0268: 325C80  	                ld      (serBufUsed),A  ; actual buffer size is 0
026B: 322E82  	                ld      (SERIALS_EN),A  ; set serial ports status to OFF
026E: CDDF02  	                call    HELLOWRLD       ; little serial blink with LEDs
0271: CD0403  	                call    initCTC         ; configure CTC, then...
0274: CD9D0B  	                call    initPSG         ; ...configure PSG
0277: CD9204  	                call    SHOW_LOGO       ; show computer logo
027A: 1E01    	                ld      E,$01           ; E chooses the video mode: 1:graphics 1
027C: CD7E03  	                call    initVDP         ; set video display
027F: AF      	                xor     A
0280: ED47    	                ld      I,A             ; set high byte of interrupt vectors to point to page 0
0282: ED5E    	                im      2               ; interrupt mode 2
0284: FB      	                ei                      ; enable interrupts
              	                ; print system messages
0285: AF      	                xor     A               ; A=0 so...
0286: 322982  	                ld      (KBDNPT),A      ; ...inputs don't come from keyboard
0289: 3C      	                inc     A               ; A=1...
028A: 32EB81  	                ld      (PRNTVIDEO),A   ; ...to activate the print-on-video
028D: 213A03  	                ld      HL,MSGTXT1      ; sign-on message
0290: CD2902  	                call    RAWPRINT        ; print message
0293: CD3608  	                call    CURSOR_ON       ; enable cursor
0296: 3A5D80  	                ld      A,(basicStarted); check if BASIC is already started
0299: FE59    	                cp      'Y'             ; to see if this is a power-up
029B: 2016    	                jr      NZ,COLDSTART    ; if not, then do a COLD start
029D: 216403  	                ld      HL,MSGTXT2      ; message to choose kind of start
02A0: CD2902  	                call    RAWPRINT        ; print message
02A3: AF      	                xor     A
02A4: 32EB81  	                ld      (PRNTVIDEO),A   ; disable print-on-video
02A7: CDCD01  	CORW:           call    RXA             ; look for a pressed key
02AA: E6DF    	                and     %11011111       ; only UPPERCASE char
02AC: FE43    	                cp      'C'             ; cold start?
02AE: 200B    	                jr      NZ,CHECKWARM    ; no, let's check for warm start
02B0: CDC502  	                call    ECHO_CHAR       ; echoes the char
02B3: 3E59    	COLDSTART:      ld      A,'Y'           ; yes, set the "BASIC started" flag
02B5: 325D80  	                ld      (basicStarted),A
02B8: C3CC0E  	                jp      COLD            ; start BASIC COLD
02BB: FE57    	CHECKWARM:      cp      'W'
02BD: 20E8    	                jr      NZ,CORW         ; char not recognized, wait again
02BF: CDC502  	                call    ECHO_CHAR       ; echoes the char
02C2: C3CF0E  	                jp      WARM            ; start BASIC WARM
              	
              	;-------------------------------------------------------------------------------
02C5: 32EC81  	ECHO_CHAR:      ld      (CHR4VID),A     ; set char for video printing
02C8: AF      	                xor     A
02C9: 322982  	                ld      (KBDNPT),A      ; input is not from keyboard
02CC: F3      	                di                      ; disable INTs
02CD: CDAC06  	                call    CHAR2VID        ; echoes back the pressed key,
02D0: 3E0D    	                ld      A,CR            ; then set a CR
02D2: 32EC81  	                ld      (CHR4VID),A     ; set char for video printing
02D5: CDAC06  	                call    CHAR2VID        ; and send it to screen
02D8: FB      	                ei                      ; re-enable INTs
02D9: 3E01    	                ld      A,$01
02DB: 32EB81  	                ld      (PRNTVIDEO),A   ; re-enable video printing
02DE: C9      	                ret                     ; return to caller
              	                
              	;-------------------------------------------------------------------------------
              	; little serial blink with LEDs
02DF: 0E09    	HELLOWRLD:      ld      C,$09           ; 8 LEDs to be turned off + 1 more step to turn off the last LED
02E1: 3ECF    	                ld      A,%11001111     ; set mode 3 (mode control)
02E3: D303    	                out     (PIO_CB),A      ; for PIO port B
02E5: AF      	                xor     A               ; set pins to OUTPUT
02E6: D303    	                out     (PIO_CB),A      ; for port B
02E8: 3C      	                inc     A               ; LSB on
02E9: D301    	LEDLIGHT:       out     (PIO_DB),A      ; turn LEDs on/off for a "Supercar" sequence
02EB: 1E20    	                ld      E,$20           ; little delay
02ED: 0600    	DEC_E:          ld      B,$00           ; count to 256
02EF: 10FE    	COUNTER:        djnz    COUNTER         ; decrement inner counter
02F1: 1D      	                dec     E               ; decrement outer counter
02F2: 20F9    	                jr      NZ,DEC_E        ; finish delay
02F4: CB27    	                sla     A               ; shift reg.A to left 1 bit
02F6: 0D      	                dec     C               ; next LED
02F7: 20F0    	                jr      NZ,LEDLIGHT     ; all LEDs done? no, repeat
02F9: C9      	                ret                     ; return to caller
              	
              	;-------------------------------------------------------------------------------
              	; Z80 SIO default settings for channel A
02FA: 30      	SIO_A_SETS:     defb    %00110000       ; write into WR0: error reset, select WR0
02FB: 18      	                defb    %00011000       ; write into WR0: channel reset
02FC: 04      	                defb    %00000100       ; write into WR0: select WR4
02FD: 44      	                defb    %01000100       ; write into WR4: presc. 16x, 1 stop bit, no parity
02FE: 05      	                defb    %00000101       ; write into WR0: select WR5
02FF: E8      	                defb    %11101000       ; write into WR5: DTR on, TX 8 bits, BREAK off, TX on, RTS off
0300: 01      	SIO_B_SETS:     defb    %00000001       ; write into WR0: select WR1
0301: 04      	                defb    %00000100       ; write into WR1: status affects interrupt vectors
0302: 02      	                defb    %00000010       ; write into WR0: select WR2
0303: 00      	                defb    %00000000       ; write into WR2: set interrupt vector, but bits D3/D2/D1 of this vector
              	                                        ; will be affected by the channel & condition that raised the interrupt
              	                                        ; (see datasheet): in our example, 0x0C for Ch.A receiving A char, 0x0E
              	                                        ; for special conditions
              	;------------------------------------------------------------------------------
              	; Z80 CTC setting up
0304:         	initCTC:
0304: 212E03  	                ld      HL,CTCCONF      ; CTC configuration
0307: 11D281  	                ld      DE,CTC0IV       ; CTC interrupt vector table
030A: 010C00  	                ld      BC,$000C        ; 12 bytes
030D: EDB0    	                ldir                    ; copy data
              	;CH0, CH1, & CH2 disabled
030F: 3E03    	                ld      A,%00000011     ; interrupt off, timer mode, prescaler=16, don't care ext. TRG edge,
              	                                        ; start timer on loading constant, no time constant follows, software reset, command word
0311: D310    	                out     (CTC_CH0),A     ; set CH0
0313: D311    	                out     (CTC_CH1),A     ; set CH1
0315: D312    	                out     (CTC_CH2),A     ; set CH2
              	
              	;init CH3
              	;CH3 divides CPU CLK by 144*256 providing an interrupt signal at 100 Hz (1/100 sec).
              	;f = CPU_CLK/(144*256) => 3,686,400 / ( 36,864 ) => 100Hz
0317: 3EA7    	                ld      A,%10100111     ; interrupt on; timer mode; prescaler=256; don't care ext; automatic trigger;
              	                                        ; time constant follows; cont. operation; command word
0319: D313    	                out     (CTC_CH3),A     ; send to CH3
031B: 3E90    	                ld      A,$90           ; time constant - 90$ (144d)
031D: D313    	                out     (CTC_CH3),A     ; send to CH3
031F: 3E40    	                ld      A,%01000000     ; D7..D3 provide the first part of the int vector (in our case, $0100), followed by
              	                                        ; D2..D1, provided by the CTC (they point to the channel), D0=interrupt word
              	                                        ; so int vector is 01000xx00
0321: D310    	                out     (CTC_CH0),A     ; send to CTC
              	                ; reset cells of 100ths of a second counter
0323: AF      	                xor     A               ; reset A
0324: 21CE81  	                ld      HL,TMRCNT       ; load TMR pointer
0327: 0604    	                ld      B,$04           ; 4 memory cells
0329: 77      	RESTMR:         ld      (HL),A          ; reset n-cell of TMR
032A: 23      	                inc     HL              ; next cell
032B: 10FC    	                djnz    RESTMR          ; repeat for 4 cells
032D: C9      	                ret
              	
032E: FBED4D  	CTCCONF:        defb    $FB,$ED,$4D     ; CTC0 interrupt vector (ei; reti)
0331: FBED4D  	                defb    $FB,$ED,$4D     ; CTC1 interrupt vector (ei; reti)
0334: FBED4D  	                defb    $FB,$ED,$4D     ; CTC2 interrupt vector (ei; reti)
0337: C33702  	                jp      CH3_TIMER       ; CTC3 interrupt vector (sys tick timer)
              	;------------------------------------------------------------------------------
033A: 4C4D3830	MSGTXT1:        defm    "LM80C by Leonardo Miliani",CR
033E: 43206279	
0342: 204C656F	
0346: 6E617264	
034A: 6F204D69	
034E: 6C69616E	
0352: 690D    	
0354: 4669726D	                defm    "Firmware R3.13",CR,0
0358: 77617265	
035C: 2052332E	
0360: 31330D00	
0364: 0D      	MSGTXT2:        defb    CR
0365: 3C433E6F	                defm    "<C>old or <W>arm start? ",0
0369: 6C64206F	
036D: 72203C57	
0371: 3E61726D	
0375: 20737461	
0379: 72743F20	
037D: 00      	
              	; ------------------------------------------------------------------------------
              	; LM80C - VDP ROUTINES - R3.13
              	; ------------------------------------------------------------------------------
              	; The following code is intended to be used with LM80C Z80-based computer
              	; designed by Leonardo Miliani. Code and computer schematics are released under
              	; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
              	; kind of warranty: you can use them at your own risk.
              	; You are free to use them for any non-commercial use: you are only asked to
              	; maintain the copyright notices, include this advice and the note to the 
              	; attribution of the original version to Leonardo Miliani, if you intend to
              	; redistribuite them.
              	; https://www.leonardomiliani.com
              	; 
              	; Please support me by visiting the following links:
              	; Main project page: https://www.leonardomiliani.com
              	; Schematics and code: https://github.com/leomil72/LM80C
              	; Videos about the computer: https://www.youtube.com/user/leomil72/videos
              	; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
              	; ------------------------------------------------------------------------------
              	;
              	;------------------------------------------------------------------------------
              	; VDP INITIALISATION
              	; initialize VDP for a specific graphics mode
              	; INPUT: E -> contains the graphics mode:
              	; 0=text; 1=graphics 1; 2=graphics 2; 3=multicolor; 4=extended graphics 2
037E: D5      	initVDP:        push    DE              ; store E
037F: CDD909  	                call    EMPTY_VRAM      ; reset VRAM
0382: CDF809  	                call    SET_GFX_MODE    ; load register settings
0385: CDED09  	                call    CLR_RAM_REG     ; reset RAM registers
0388: D1      	                pop     DE              ; restore reg. E
0389: AF      	                xor     A               ; reset A
038A: 47      	                ld      B,A             ; reset B (will be used later)
038B: 7B      	                ld      A,E             ; move E into A
038C: 32E081  	                ld      (SCR_MODE),A    ; store screen mode
038F: FE01    	                cp      $01             ; is it graphics 1 (A=1)?
0391: CAC803  	                jp      Z,G1MD          ; yes, jump over
0394: FE02    	                cp      $02             ; is it graphics 2 (A=2)?
0396: CA0404  	                jp      Z,G2MD          ; yes, jump over
0399: FE03    	                cp      $03             ; is it multicolor (A=3)?
039B: CA2604  	                jp      Z,MCMD          ; yes, jump over
039E: FE04    	                cp      $04             ; is it extended graphics 2 (A=4)?
03A0: CA4904  	                jp      Z,EXG2MD        ; yes, jump over; otherwise, it must be $00 so we assume that it's text mode
              	
              	                ; LOAD VDP SETTINGS FOR SELECTED VIDEO MODE:
              	                ; TEXT MODE (G0)
03A3:         	TXTMD:          ; load charset
03A3: 60      	                ld      H,B
03A4: 68      	                ld      L,B             ; HL=first pattern cell $0000
03A5: CD140A  	                call    LOADCHARSET     ; load patterns into VRAM
              	                ; set cursor & video overlay
03A8: AF      	                xor     A               ; reset A
03A9: 32E481  	                ld      (SCR_CURS_X),A  ; set cursor position at X=0
03AC: 32E581  	                ld      (SCR_CURS_Y),A  ; and Y=0
03AF: 3E05    	                ld      A,$05           ; light blue
03B1: 32EE81  	                ld      (BKGNDCLR),A    ; set background/border color
03B4: 3E28    	                ld      A,$28
03B6: 32DE81  	                ld      (SCR_SIZE_W),A  ; screen width = 40 cols
03B9: 3E18    	                ld      A,$18
03BB: 32DF81  	                ld      (SCR_SIZE_H),A  ; screen height = 24 rows
03BE: 110008  	                ld      DE,$0800
03C1: ED53E281	                ld      (SCR_NAM_TB),DE ; set name table address
03C5: C38704  	                jp      ENDVDPSET       ; execute the rest of the video setting
              	
              	                ; GRAPHICS 1 MODE (G1)
03C8:         	G1MD:           ; load pattern table
03C8: 68      	                ld      L,B
03C9: 60      	                ld      H,B             ; HL=first pattern cell $0000
03CA: CD140A  	                call    LOADCHARSET     ; load patterns into VRAM
              	                ; set cursor & video overlay
03CD: AF      	                xor     A               ; position cursor
03CE: 32E481  	                ld      (SCR_CURS_X),A  ; at X=0
03D1: 32E581  	                ld      (SCR_CURS_Y),A  ; and Y=0
03D4: 3E20    	                ld      A,$20
03D6: 32DE81  	                ld      (SCR_SIZE_W),A  ; screen width = 32 cols
03D9: 3E18    	                ld      A,$18
03DB: 32DF81  	                ld      (SCR_SIZE_H),A  ; screen height = 24 rows
03DE: 110018  	                ld      DE,$1800
03E1: ED53E281	                ld      (SCR_NAM_TB),DE ; set name table address
              	                ; load color table
03E5: 210020  	                ld      HL,$2000        ; color table start: $2000
03E8: CDEA05  	                call    SETVDPADRS
03EB: 3E01    	                ld      A,$01           ; foreground color...
03ED: 32ED81  	                ld      (FRGNDCLR),A    ; ...set to black
03F0: 3E0F    	                ld      A,$0F           ; background color...
03F2: 32EE81  	                ld      (BKGNDCLR),A    ; ...set to white
03F5: 3E1F    	                ld      A,$1F           ; reg.A loaded with colors for chars: bloack pixels on white background
03F7: 0620    	                ld      B,$20           ; 32 bytes of colors
03F9: 0E30    	                ld      C,VDP_DAT       ; VDP data mode
03FB: ED79    	LDCLRTBMD1:     out     (C),A           ; after first byte, the VDP autoincrements VRAM pointer
03FD: 00      	                nop
03FE: 00      	                nop
03FF: 10FA    	                djnz    LDCLRTBMD1      ; repeat for 32 bytes
0401: C38704  	                jp      ENDVDPSET       ; execute the rest of the video setting
              	
              	                ; GRAPHICS 2 MODE (G2)
0404: AF      	G2MD:           xor     A               ; position cursor
0405: 32E481  	                ld      (SCR_CURS_X),A  ; at X=0
0408: 32E581  	                ld      (SCR_CURS_Y),A  ; and Y=0
040B: 32DE81  	                ld      (SCR_SIZE_W),A  ; screen width = 256 pixels (0=256)
040E: 3C      	                inc     A               ; black on...
040F: 32ED81  	                ld      (FRGNDCLR),A    ; ...foreground
0412: 3E0F    	                ld      A,$0F           ; white on...
0414: 32EE81  	                ld      (BKGNDCLR),A    ; ...background
0417: 3EC0    	                ld      A,$C0
0419: 32DF81  	                ld      (SCR_SIZE_H),A  ; screen height = 192 pixels
041C: 110018  	                ld      DE,$1800
041F: ED53E281	                ld      (SCR_NAM_TB),DE ; set name table address
0423: C38704  	                jp      ENDVDPSET       ; execute the rest of the video setting
              	
              	                ; MULTICOLOR MODE (G3)
0426: AF      	MCMD:           xor     A               ; position cursor
0427: 32E481  	                ld      (SCR_CURS_X),A  ; at X=0
042A: 32E581  	                ld      (SCR_CURS_Y),A  ; and Y=0
042D: 3E0F    	                ld      A,$0F           ; white color for...
042F: 32EE81  	                ld      (BKGNDCLR),A    ; ...background and...
0432: 32ED81  	                ld      (FRGNDCLR),A    ; ...foreground (even this is not used in MC)
0435: 3E40    	                ld      A,$40
0437: 32DE81  	                ld      (SCR_SIZE_W),A  ; screen width = 64 blocks
043A: 3E30    	                ld      A,$30
043C: 32DF81  	                ld      (SCR_SIZE_H),A  ; screen height = 48 blocks
043F: 110008  	                ld      DE,$0800
0442: ED53E281	                ld      (SCR_NAM_TB),DE ; set name table address
0446: C38704  	                jp      ENDVDPSET       ; execute the rest of the video setting
              	
              	                ; EXTENDED GRAPHICS 2 (G4)
0449:         	EXG2MD:         ; load pattern table
0449: 60      	                ld      H,B
044A: 68      	                ld      L,B             ; HL=first pattern cell $0000
044B: CD140A  	                call    LOADCHARSET     ; load patterns into VRAM
              	                ; set cursor & video overlay
044E: AF      	                xor     A               ; position cursor
044F: 32E481  	                ld      (SCR_CURS_X),A  ; at X=0
0452: 32E581  	                ld      (SCR_CURS_Y),A  ; and Y=0
0455: 3E20    	                ld      A,$20
0457: 32DE81  	                ld      (SCR_SIZE_W),A  ; screen width = 32 cols
045A: 3E18    	                ld      A,$18
045C: 32DF81  	                ld      (SCR_SIZE_H),A  ; screen height = 24 rows
045F: 110038  	                ld      DE,$3800
0462: ED53E281	                ld      (SCR_NAM_TB),DE ; set name table address
              	                 ; load color table
0466: 210020  	                ld      HL,$2000        ; color table start: $2000
0469: CDEA05  	                call    SETVDPADRS
046C: 3E01    	                ld      A,$01           ; foreground color is...
046E: 32ED81  	                ld      (FRGNDCLR),A    ; ...set to black
0471: 3E0F    	                ld      A,$0F           ; whitefor...
0473: 32EE81  	                ld      (BKGNDCLR),A    ; ...background
0476: 3E1F    	                ld      A,$1F           ; reg.A loaded with colors for chars: bloack pixels on white background
0478: 1608    	                ld      D,$08           ; 8 pages of 
047A: 0600    	                ld      B,$00           ; 256 bytes of colors (total of 2,048 cells)
047C: 0E30    	                ld      C,VDP_DAT       ; VDP data mode
047E: ED79    	LDCLRTBEX2:     out     (C),A           ; after first byte, the VDP autoincrements VRAM pointer
0480: 00      	                nop
0481: 00      	                nop
0482: 10FA    	                djnz    LDCLRTBEX2      ; repeat for 256 bytes
0484: 15      	                dec     D               ; did we fill up all the cells?
0485: 20F7    	                jr      NZ,LDCLRTBEX2   ; no, repeat
              	                ; LAST VDP SETTINGS
0487: CD4C08  	ENDVDPSET:      call    CURSOR_OFF      ; disable cursor
048A: CD5805  	                call    EMPTYVIDBUF     ; empty video buffer
048D: AF      	                xor     A
048E: 32E881  	                ld      (SCR_ORG_CHR),A ; store byte used tochar used to empty the video buffer
0491: C9      	                ret                     ; return to caller
              	
              	
              	; show initial logo
0492: CDD909  	SHOW_LOGO:      call    EMPTY_VRAM      ; reset VRAM
              	                ; set VDP for G2 mode
0495: 0607    	                ld      B,$07           ; set only the first 7 registers
0497: 111000  	                ld      DE,$0010        ; load settings for G2 mode
049A: CD000A  	                call    SET_GFX_MODE2   ; load register settings
049D: 1601    	                ld      D,$01           ; backdrop color set to black
049F: ED51    	                out     (C),D           ; send data to VDP
04A1: ED79    	                out     (C),A           ; indicate the register to send data to
              	                ; set name table 
04A3: 210018  	                ld      HL,$1800        ; name table address
04A6: CDD705  	                call    SETNAMETABLE    ; set name table (load names into table)
04A9: CD0605  	                call    ERASECLRTBL     ; erase color table (set foreground & background to black)
              	                ; set colors for logo
04AC: 210028  	                ld      HL,$2800        ; 2nd page of color table
04AF: CDEA05  	                call    SETVDPADRS
04B2: 0605    	                ld      B,5             ; 5 bands
04B4: 215305  	                ld      HL,CLRTABLE
04B7: 0E30    	                ld      C,VDP_DAT
04B9: 1E08    	                ld      E,$08           ; 8 pixels each pattern        
04BB: 1640    	RPT101:         ld      D,$40           ; 64 chars each band
04BD: 7E      	                ld      A,(HL)
04BE: ED79    	RPT102:         out     (C),A
04C0: 00      	                nop
04C1: 1D      	                dec     E
04C2: 20FA    	                jr      NZ,RPT102
04C4: 1E08    	                ld      E,$08
04C6: 15      	                dec     D
04C7: 20F5    	                jr      NZ,RPT102
04C9: 23      	                inc     HL
04CA: 10EF    	                djnz    RPT101
              	                ; set pattern table
04CC: 210008  	                ld      HL,$0800        ; address of first cell of 2nd area of pattern table
04CF: 115D0A  	                ld      DE,LM80CLOGO    ; pointer to logo pattern
04D2: 0600    	                ld      B,$00           ; 256 bytes, 8 rows
04D4: CD3205  	RPT103:         call    LOADLOGOCHRS
04D7: 13      	                inc     DE              ; next logo pattern
04D8: 10FA    	                djnz    RPT103
04DA: 0620    	                ld      B,$20           ; repeat for another 2 rows
04DC: CD3205  	RPT104:         call    LOADLOGOCHRS
04DF: 13      	                inc     DE              ; next logo pattern
04E0: 10FA    	                djnz    RPT104
              	                ; show logo/message, play a beep and wait a while
04E2: 0602    	                ld      B,$02
04E4: AF      	                xor     A
04E5: 57      	                ld      D,A             ; 256 times
04E6: 5F      	                ld      E,A             ; x 256 times
04E7: 32EF81  	                ld      (TMPBFR1),A     ; sound flag set to 0
04EA: 00      	DEC_D:          nop                     ; does nothing...
04EB: 00      	                nop
04EC: 00      	                nop
04ED: 00      	                nop
04EE: 00      	                nop
04EF: 00      	                nop
04F0: 1D      	                dec     E               ; decrement E
04F1: 20F7    	                jr      NZ,DEC_D        ; repeat until $00
04F3: 7A      	                ld      A,D
04F4: FE40    	                cp      $40             ; ...equal to 64
04F6: CC1E05  	                call    Z,SETBEEP       ; if yes, start sound
04F9: 15      	                dec     D
04FA: 20EE    	                jr      NZ,DEC_D        ; repeat
04FC: 3AEF81  	                ld      A,(TMPBFR1)
04FF: FE02    	                cp      $02
0501: C42A05  	                call    NZ,BEEPOFF
0504: 10E4    	                djnz    DEC_D
0506:         	ERASECLRTBL:    ; erase color table
0506: 3E11    	                ld      A,$11           ; foreground and background set to black
0508: 160A    	                ld      D,$0A           ; 10 pages
050A: 0600    	                ld      B,$00           ; 256 color cells per page
050C: 210028  	                ld      HL,$2800        ; first cell of 2nd color table
050F: CDEA05  	                call    SETVDPADRS      ; send address
0512: 0E30    	                ld      C,VDP_DAT       ; VDP address for passing data
0514: ED79    	RPT100:         out     (C),A           ; send data
0516: 00      	                nop
0517: 00      	                nop                     ; little delay
0518: 10FA    	                djnz    RPT100          ; repeat for entire page
051A: 15      	                dec     D
051B: 20F7    	                jr      NZ,RPT100       ; repeat for all the pages ($0A00 cells)
051D: C9      	                ret                     ; return to caller
              	
              	; play a beep
051E: 3AEF81  	SETBEEP:        ld      A,(TMPBFR1)     ; check the already-beeped flag?
0521: B7      	                or      A               ; is it 0?
0522: C0      	                ret     NZ              ; no, exit
0523: 3C      	                inc     A               ; flag to 1
0524: 32EF81  	                ld      (TMPBFR1),A     ; set sound
0527: C3CB0B  	                jp      WLCMBEEP        ; play a beep & return
              	
              	; beep off
052A: 3E02    	BEEPOFF:        ld      A,$02           ; flag for sound off
052C: 32EF81  	                ld      (TMPBFR1),A     ; set flag
052F: C3D10B  	                jp      NOBEEP          ; stop beep and return
              	
              	
              	; used to load the chars that will compose the logo of the splash screen
0532: 1A      	LOADLOGOCHRS:   ld      A,(DE)          ; load a pattern char of the logo
0533: 87      	                add     A,A
0534: 87      	                add     A,A
0535: 87      	                add     A,A             ; multiply times 8 to get the offset
0536: C5      	                push    BC
0537: D5      	                push    DE              ; store BC and DE
0538: E5      	                push    HL              ; store VRAM address to write to
0539: 21964C  	                ld      HL,LOGOFONT     ; start of logo font data
053C: 5F      	                ld      E,A
053D: 1600    	                ld      D,$00           ; put offset (A) into DE
053F: 19      	                add     HL,DE           ; get address of pattern data
0540: EB      	                ex      DE,HL           ; move address into DE
0541: E1      	                pop     HL              ; retrieve VRAM address
0542: 0608    	                ld      B,$08           ; 8 bytes per pattern
0544: CDEA05  	                call    SETVDPADRS      ; set VDP address
0547: 0E30    	                ld      C,VDP_DAT
0549: 1A      	SNDLOGPT:       ld      A,(DE)          ; load data from RAM
054A: ED79    	                out     (C),A           ; and send to VRAM
054C: 13      	                inc     DE              ; next byte into RAM
054D: 23      	                inc     HL              ; next byte into VRAM (used in future iterations)
054E: 10F9    	                djnz    SNDLOGPT        ; repeat 8 times
0550: D1      	                pop     DE
0551: C1      	                pop     BC              ; retrieve BC & DE
0552: C9      	                ret                     ; return to caller
              	
0553:         	CLRTABLE:       equ $
0553: 181B1314	                defb    $18,$1B,$13,$14,$1D ; colors of background bands of the logo
0557: 1D      	
              	                
              	; empty video buffer
0558: 3AE081  	EMPTYVIDBUF:    ld      A,(SCR_MODE)    ; check screen mode
055B: FE02    	                cp      $02             ; is it G2 mode?
055D: CA8105  	                jp      Z,EMPTYG2       ; yes, jump over
0560: FE03    	                cp      $03             ; is it MC mode?
0562: CAB205  	                jp      Z,EMPTYMC       ; yes, jump over
0565: 3ADF81  	                ld      A,(SCR_SIZE_H)  ; load height of screen
0568: 47      	                ld      B,A             ; move rows into B
0569: AF      	                xor     A               ; filling char is $00
056A: 2AE281  	                ld      HL,(SCR_NAM_TB) ; load the name table address
056D: CDEA05  	                call    SETVDPADRS      ; send address to VDP
0570: 0E30    	                ld      C,VDP_DAT       ; VDP address for passing data
0572: 5F      	LDCOLSTOEMPTY:  ld      E,A             ; store filling char into E
0573: 3ADE81  	                ld      A,(SCR_SIZE_W)  ; load # of cols to empty into A
0576: 57      	                ld      D,A             ; move A into D
0577: 7B      	                ld      A,E             ; recover filling char
0578: ED79    	RPTEMPTYBUF:    out     (C),A           ; write empty byte into VRAM
057A: 00      	                nop
057B: 15      	                dec     D               ; decr. D
057C: 20FA    	                jr      NZ,RPTEMPTYBUF  ; repeat for the # of cols
057E: 10F2    	                djnz    LDCOLSTOEMPTY   ; repeat for the # of rows
0580: C9      	                ret                     ; return to caller
0581: 2AE281  	EMPTYG2:        ld      HL,(SCR_NAM_TB) ; yes, additional setup for G2 - load G2 name table address (usually $1800)
0584: CDD705  	                call    SETNAMETABLE    ; set name table
0587: 210000  	                ld      HL,$0000        ; set pattern table
058A: CDEA05  	                call    SETVDPADRS      ; send address to VDP
058D: AF      	                xor     A               ; empty pattern
058E: 1618    	                ld      D,$18           ; 6144 ($1800) cell to clean, 24 pages ($18)
0590: 47      	                ld      B,A             ; 256 bytes for page
0591: 0E30    	                ld      C,VDP_DAT       ; VDP data mode
0593: ED79    	CLRG2PTNTBL:    out     (C),A           ; clear pattern
0595: 00      	                nop                     ; little delay
0596: 00      	                nop
0597: 10FA    	                djnz    CLRG2PTNTBL     ; repeat for 1 page
0599: 15      	                dec     D               ; next page
059A: 20F7    	                jr      NZ,CLRG2PTNTBL  ; repeat
059C: 210020  	                ld      HL,$2000        ; load the color table address
059F: CDEA05  	                call    SETVDPADRS      ; send address to VDP
05A2: 3AED81  	                ld      A,(FRGNDCLR)    ; load foreground
05A5: 87      	                add     A,A
05A6: 87      	                add     A,A
05A7: 87      	                add     A,A
05A8: 87      	                add     A,A             ; move to high nibble
05A9: 57      	                ld      D,A             ; store into D
05AA: 3AEE81  	                ld      A,(BKGNDCLR)    ; load background color
05AD: B2      	                or      D               ; combine with background color
05AE: 1618    	                ld      D,$18           ; 6144 ($1800) cells to fill, so 24 pages ($18)
05B0: 1817    	                jr      STARTEMPTY
05B2: 210008  	EMPTYMC:        ld      HL,$0800        ; MC name table
05B5: CDD705  	                call    SETNAMETABLE    ; set name table
05B8: 210000  	                ld      HL,$0000        ; color table address
05BB: CDEA05  	                call    SETVDPADRS      ; send address to VDP
05BE: 3AEE81  	                ld      A,(BKGNDCLR)    ; load background
05C1: 57      	                ld      D,A             ; store into D
05C2: 87      	                add     A,A
05C3: 87      	                add     A,A
05C4: 87      	                add     A,A
05C5: 87      	                add     A,A             ; move to high nibble
05C6: B2      	                or      D               ; set background color for high and low nibble
05C7: 1608    	                ld      D,$08           ; 2048 ($0800) cells to fill, so 8 pages ($08)
05C9: 0E30    	STARTEMPTY:     ld      C,VDP_DAT       ; VDP address for passing data
05CB: 0600    	                ld      B,$00           ; 256 bytes each page ($00=256)
05CD: ED79    	SNDCLRSET:      out     (C),A           ; send color setting
05CF: 00      	                nop                     ; wait a while
05D0: 00      	                nop
05D1: 10FA    	                djnz    SNDCLRSET       ; repeat for 1 page
05D3: 15      	                dec     D               ; have we filled all the pages?
05D4: 20F7    	                jr      NZ,SNDCLRSET    ; no, repeat
05D6: C9      	                ret                     ; return to caller
              	
              	; set name table for G2 mode (patterns from $00 to $FF for each of the 3 areas of the screen)
05D7: CDEA05  	SETNAMETABLE:   call    SETVDPADRS      ; send address to VDP
05DA: 0E30    	                ld      C,VDP_DAT       ; VDP address for passing data
05DC: 1603    	                ld      D,$03           ; 3 pages to fill into VRAM (768 cells)
05DE: AF      	                xor     A               ; starting char name #0 (chars go from 0 to 255)
05DF: 47      	                ld      B,A             ; reset B
05E0: ED79    	RPTFLL1:        out     (C),A           ; send name to VRAM
05E2: 00      	                nop
05E3: 3C      	                inc     A               ; increment # of name
05E4: 10FA    	                djnz    RPTFLL1         ; repeat for 256 cells (1 page)
05E6: 15      	                dec     D               ; did we fill all the pages?
05E7: 20F7    	                jr      NZ,RPTFLL1      ; no, continue
05E9: C9      	                ret                     ; return to caller
              	
              	; set an address into VRAM: address is in HL
05EA: 0E32    	SETVDPADRS:     ld      C,VDP_SET       ; VDP address mode
05EC: CBF4    	                set     6,H             ; set bit #6 of address, to write to VRAM
05EE: ED69    	                out     (C),L           ; send low and...
05F0: ED61    	                out     (C),H           ; ...high byte of the first cell
05F2: C9      	                ret                     ; return to caller
              	
              	; clear the video buffer and position the cursor at 0,0
05F3: CD5805  	CLEARVIDBUF:    call    EMPTYVIDBUF     ; clear video buffer
05F6: AF      	                xor     A               ; reset A
05F7: 32E481  	                ld      (SCR_CURS_X),A  ; cursor X to 0
05FA: 32E581  	                ld      (SCR_CURS_Y),A  ; cursor Y to 0
05FD: C34606  	                jp      POS_CURSOR      ; position cursor & return to caller
              	
              	; HOME: position the cursor at coords. 0,0 
0600: AF      	ATHOME:         xor     A               ; position cursor at 0,0 by storing...
0601: 32E781  	                ld      (SCR_CUR_NY),A  ; ...new Y...
0604: 32E681  	                ld      (SCR_CUR_NX),A  ; ...and new X
0607: C35006  	                jp      MOVCRS          ; move cursor to new location & return to caller
              	
              	; load the char or byte at the VRAM position set by HL
              	; value is returned into A
060A: C5      	READ_VIDEO_LOC: push    BC              ; store BC
060B: 0E32    	                ld      C,VDP_SET       ; VDP setting mode
060D: 44      	                ld      B,H
060E: CBB8    	                res     7,B
0610: CBB0    	                res     6,B
0612: ED69    	                out     (C),L           ; low byte then...
0614: ED41    	                out     (C),B           ; high byte
0616: 0E30    	                ld      C,VDP_DAT       ; VDP data mode
0618: 00      	                nop                     ; wait...
0619: 00      	                nop                     ; ...a while
061A: 00      	                nop
061B: ED78    	                in      A,(C)           ; read byte at current VRAM location
061D: C1      	                pop     BC              ; restore BC
061E: C9      	                ret                     ; return to caller
              	
              	; write a byte at the VRAM position pointed by HL
              	; value is in A
061F: C5      	WRITE_VIDEO_LOC:push    BC              ; store BC
0620: 0E32    	                ld      C,VDP_SET       ; VDP setting mode
0622: 44      	                ld      B,H             ; copy H into B
0623: CBB8    	                res     7,B
0625: CBF0    	                set     6,B             ; write to VRAM
0627: ED69    	                out     (C),L           ; low byte then...
0629: ED41    	                out     (C),B           ; high byte of VRAM address
062B: 0E30    	                ld      C,VDP_DAT       ; VDP data mode
062D: 00      	                nop                     ; wait...
062E: 00      	                nop                     ; ...a while
062F: 00      	                nop
0630: ED79    	                out     (C),A           ; write byte into VRAM
0632: C1      	                pop     BC              ; restore BC
0633: C9      	                ret                     ; return to caller
              	
              	; write a value into a specific VDP register
              	; value is in E, register is in A
0634: C5      	WRITE_VREG:     push    BC              ; store BC
0635: C680    	                add     A,$80           ; set VDP to write to registers
0637: 0E32    	                ld      C,VDP_SET       ; VDP setting mode
0639: ED59    	                out     (C),E           ; send data to VDP
063B: ED79    	                out     (C),A           ; select the destination register
063D: C1      	                pop     BC              ; restore BC
063E: C9      	                ret                     ; return to caller
              	
              	; read VDP status register and return value into A
063F: C5      	READ_VSTAT:     push    BC              ; store BC
0640: 0E32    	                ld      C,VDP_SET       ; VDP register access
0642: ED78    	                in      A,(C)           ; read status register
0644: C1      	                pop     BC              ; restore BC
0645: C9      	                ret                     ; return to caller
              	
              	; position the cursor at the current coordinates, preserving underlying char
0646: CD7706  	POS_CURSOR:     call    LOAD_CRSR_POS   ; load the VRAM address of cursor into HL
0649: CD0A06  	                call    READ_VIDEO_LOC  ; load the current char at the cursor position (return in A)
064C: 32E881  	                ld      (SCR_ORG_CHR),A ; store the current char
064F: C9      	                ret
              	
              	; move cursor to new X,Y coordinates
0650: CD6E06  	MOVCRS:         call    RSTCHRCRS       ; restore the char in the current cursor position
0653: CD5906  	                call    NEWCRSRCOORD    ; set new cursor's coordinates
0656: C34606  	                jp      POS_CURSOR      ; position cursor into new location & return to caller
              	
              	
              	; set new cursor's coordinates:
0659: 3AE681  	NEWCRSRCOORD:   ld      A,(SCR_CUR_NX)  ; load new X
065C: 32E481  	                ld      (SCR_CURS_X),A  ; write new X
065F: 3AE781  	                ld      A,(SCR_CUR_NY)  ; load new Y
0662: 32E581  	                ld      (SCR_CURS_Y),A  ; write new Y
0665: 3EFF    	                ld      A,$FF           ; delete new values
0667: 32E681  	                ld      (SCR_CUR_NX),A  ; of X
066A: 32E781  	                ld      (SCR_CUR_NY),A  ; and Y
066D: C9      	                ret
              	
              	; recover char under the cursor and prints it onto the screen
066E: CD7706  	RSTCHRCRS:      call    LOAD_CRSR_POS   ; recover old cursor position
0671: 3AE881  	                ld      A,(SCR_ORG_CHR) ; recover old char
0674: C31F06  	                jp      WRITE_VIDEO_LOC ; write char into VRAM & return
              	
              	; retrieve cursor position from either current coordinates or next place
              	; return address position into HL
0677: 3AE581  	LOAD_CRSR_POS:  ld      A,(SCR_CURS_Y)  ; load cursor Y
067A: 6F      	                ld      L,A             ; move it into reg.L
067B: AF      	                xor     A               ; reset A
067C: 67      	                ld      H,A             ; reset H
067D: 47      	                ld      B,A             ; reset B
067E: 29      	                add     HL,HL           ; create offset (each address is 2-bytes long so we need to double HL)
067F: 11A909  	                ld      DE,POS_TB_CRS_40; load position table address of cursor for 40 cols
0682: 3ADE81  	                ld      A,(SCR_SIZE_W)  ; load screen width
0685: FE28    	                cp      $28             ; is it 40 cols?
0687: 2803    	                jr      Z,CONT_POS_CURS ; yes, jump over
0689: 117909  	                ld      DE,POS_TB_CRS_32; no, load position table address of cursor for 32 cols
068C: 19      	CONT_POS_CURS:  add     HL,DE           ; the correct starting address of the required row is now into HL
068D: 5E23562B	                ld      DE,(HL)         ; load starting address of the required row into DE
0691: 2AE281  	                ld      HL,(SCR_NAM_TB) ; load starting address of name table
0694: 19      	                add     HL,DE           ; starting address of the current row into name table
0695: 3AE481  	                ld      A,(SCR_CURS_X)  ; load cursor X
0698: 4F      	                ld      C,A             ; transfer A into C
0699: 09      	                add     HL,BC           ; add X offset: now HL contains the address of the current cursor position
069A: C9      	                ret
              	
              	; find X,Y coordinates of a screen address pointed in VRAM by HL
              	; return them into L & A for X,Y
069B: D5      	HL2XY:          push    DE              ; store DE
069C: ED5BE281	                ld      DE,(SCR_NAM_TB) ; load starting address of name table into DE
06A0: AF      	                xor     A               ; clear Carry
06A1: ED52    	                sbc     HL,DE           ; find position relative to screen (from 0,0)
06A3: D1      	                pop     DE
06A4: 3ADE81  	                ld      A,(SCR_SIZE_W)  ; load screen width
06A7: 4F      	                ld      C,A             ; move it into C
06A8: CD873C  	                call    DIV_16_8        ; divide position by C: return Y into L and X into A
06AB: C9      	                ret                     ; return to caller
              	
              	;-------------------------------------------------------------------------------
              	; send current char to video buffer
06AC: F5      	CHAR2VID:       push    AF              ; store AF
06AD: C5      	                push    BC              ; store BC
06AE: D5      	                push    DE              ; store DE
06AF: E5      	                push    HL              ; store HL
06B0: 3AE981  	                ld      A,(CRSR_STATE)  ; store cursor state...
06B3: F5      	                push    AF              ; into stack
06B4: CD4C08  	                call    CURSOR_OFF      ; cursor off
06B7: 3AEC81  	                ld      A,(CHR4VID)     ; recover char
06BA: FE19    	                cp      HOME            ; is it HOME char ($19?)
06BC: 2006    	                jr      NZ,CHKCS        ; no, check over
06BE: CD0006  	                call    ATHOME          ; yes, move the cursor to 0,0
06C1: C33707  	                jp      EXITCHAR2VID    ; exit
06C4: FE0C    	CHKCS:          cp      CS              ; is it the CLEAR char ($0C)?
06C6: 2005    	                jr      NZ,CHKCR        ; no, check over
06C8: CDF305  	                call    CLEARVIDBUF     ; yes, clear video buffer and position cursor at 0,0
06CB: 186A    	                jr      EXITCHAR2VID    ; exit
06CD: FE0D    	CHKCR:          cp      CR              ; is it a carriage return ($0D)?
06CF: 2005    	                jr      NZ,CHKBKSP      ; no, jump over
06D1: CDCE08  	                call    CRGRETURN       ; yes, go to the beginning of the next line
06D4: 1861    	                jr      EXITCHAR2VID    ; exit
06D6: FE08    	CHKBKSP:        cp      BKSP            ; is it the backspace ($08)?
06D8: 2005    	                jr      NZ,CHKCRSLFT    ; no, jump over
06DA: CD6907  	                call    BACKSPACE       ; move cursor left 1 position
06DD: 1858    	                jr      EXITCHAR2VID    ; exit
06DF: FE1C    	CHKCRSLFT:      cp      CRSLFT          ; is it cursor left?
06E1: 2005    	                jr      NZ,CHKCRSUP     ; no, jump over
06E3: CD7C07  	                call    CURSORLEFT      ; move cursor left...
06E6: 184F    	                jr      EXITCHAR2VID    ; ...and exit
06E8: FE1E    	CHKCRSUP:       cp      CRSUP           ; is it cursor up?
06EA: 2005    	                jr      NZ,CHKCRSRGT    ; no, jump over
06EC: CDC807  	                call    CURSORUP        ; move cursor up...
06EF: 1846    	                jr      EXITCHAR2VID    ; ...and exit
06F1: FE1D    	CHKCRSRGT:      cp      CRSRGT          ; is it cursor right?
06F3: 2005    	                jr      NZ,CHKCRSDWN    ; no, jump over
06F5: CDE107  	                call    CURSORRIGHT     ; move cursor right...
06F8: 183D    	                jr      EXITCHAR2VID    ; ...and exit
06FA: FE1F    	CHKCRSDWN:      cp      CRSDN           ; is it cursor down?
06FC: 2005    	                jr      NZ,CHKLF        ; no, jump over
06FE: CD1608  	                call    CURSORDOWN      ; move cursor up...
0701: 1834    	                jr      EXITCHAR2VID    ; ...and exit
0703: FE0A    	CHKLF:          cp      LF              ; is it a line feed ($0A)?
0705: 2830    	                jr      Z,EXITCHAR2VID  ; CURRENTLY WE DON'T PRINT LF, WE JUST USE CR TO SUBSTITUTE CR+LF COMBINATION
0707: CD7706  	                call    LOAD_CRSR_POS   ; recover position of cursor
070A: 3AEC81  	                ld      A,(CHR4VID)     ; recover char to print
070D: CD1F06  	                call    WRITE_VIDEO_LOC ; write A into VRAM at (HL)
0710: 3AE581  	                ld      A,(SCR_CURS_Y)  ; load cursor Y into A
0713: 5F      	                ld      E,A             ; store cursor Y into E
0714: 3AE481  	                ld      A,(SCR_CURS_X)  ; load cursor X
0717: 3C      	                inc     A               ; move 1 step to right
0718: 21DE81  	                ld      HL,SCR_SIZE_W   ; cell that keeps the width of screen
071B: BE      	                cp      (HL)            ; have we reached the most right position?
071C: 200F    	                jr      NZ,SETCSRCOORDS ; no, go over
071E: 1C      	                inc     E               ; yes, increment cursor Y (go to next line)
071F: 7B      	                ld      A,E             ; move cursor Y into A
0720: 21DF81  	                ld      HL,SCR_SIZE_H   ; cell that keeps the height of screen
0723: BE      	                cp      (HL)            ; have we reached the bottom of the screen?
0724: 2006    	                jr      NZ,SETCRSRY     ; no, jump over
0726: D5      	                push    DE
0727: CD5308  	                call    SCROLLUP        ; scroll screen up
072A: D1      	                pop     DE
072B: 1D      	                dec     E               ; decrement 1 row, to set cursor Y on the last line
072C: AF      	SETCRSRY:       xor     A               ; then set cursor X to 0 (go to beginning of line)
072D: 32E481  	SETCSRCOORDS:   ld      (SCR_CURS_X),A  ; store current cursor X
0730: 7B      	                ld      A,E             ; recover Y
0731: 32E581  	                ld      (SCR_CURS_Y),A  ; store current cursor Y
0734: CD4606  	                call    POS_CURSOR      ; position cursor to new location
0737: AF      	EXITCHAR2VID:   xor     A               ; reset char
0738: 32EC81  	                ld      (CHR4VID),A     ; to be sent to screen
073B: F1      	                pop     AF              ; recover cursor state
073C: A7      	                and     A               ; was it off (A=0)?
073D: C43608  	                call    NZ,CURSOR_ON    ; no, set cursor on
0740: E1      	                pop     HL              ; restore HL
0741: D1      	                pop     DE              ; restore DE
0742: C1      	                pop     BC              ; restore BC
0743: F1      	                pop     AF              ; restore AF
0744: C9      	                ret                     ; return to caller
              	
              	; flash the cursor at the current position
              	; (this sub-routine is called by CH3 timer ISR)
0745: 3AE981  	FLASHCURSOR:    ld      A,(CRSR_STATE)  ; now, check the cursor
0748: A7      	                and     A               ; cursor off (A=0)?
0749: C8      	                ret     Z               ; yes, return
074A: 3ACE81  	                ld      A,(TMRCNT)      ; no, load the first byte of the 100ths of A second's counter
074D: E620    	                and     $20             ; check if it's time to flash the cursor (check bit #6)
074F: 21EA81  	                ld      HL,LSTCSRSTA    ; load address of cell that stores the last cursor state
0752: 46      	                ld      B,(HL)          ; load last state
0753: B8      	                cp      B               ; compare current state with last state
0754: C8      	                ret     Z               ; same state, no change required - exit
0755: 77      	                ld      (HL),A          ; save new state
0756: F5      	                push    AF              ; store A (keep state for later use)
0757: CD7706  	                call    LOAD_CRSR_POS   ; load current cursor position into HL
075A: F1      	                pop     AF              ; recover current state
075B: 06FF    	                ld      B,$FF           ; cursor char
075D: FE20    	                cp      $20             ; is the cursor on video (A == $20)?
075F: 2804    	                jr      Z,PUTCRSCHR     ; yes, jump over
0761: 3AE881  	                ld      A,(SCR_ORG_CHR) ; no, load the original char
0764: 47      	                ld      B,A             ; move char into B
0765: 78      	PUTCRSCHR:      ld      A,B             ; recover char from B
0766: C31F06  	                jp      WRITE_VIDEO_LOC ; print cursor/char at the current position & return
              	
              	
              	; delete the char at the left of the cursor
0769: CDA507  	BACKSPACE:      call    MVCRS2LFT       ; prepare to move cursor to left
076C: CD6E06  	                call    RSTCHRCRS       ; restore char under the cursor
076F: CD5906  	                call    NEWCRSRCOORD    ; set new cursor's coordinates
0772: CD7706  	                call    LOAD_CRSR_POS   ; find address of new video cell
0775: AF      	                xor     A               ; null char
0776: CD1F06  	                call    WRITE_VIDEO_LOC ; write into video cell
0779: C34606  	                jp      POS_CURSOR      ; position cursor and return
              	
              	
              	; move cursor to left
077C: F5      	CURSORLEFT:     push    AF              ; store A
077D: 3AE481  	                ld      A,(SCR_CURS_X)  ; load cursor X into A
0780: A7      	                and     A               ; is it at the most left of the screen (X=0)?
0781: 280C    	                jr      Z,CHCKYPOS      ; yes, check Y position
0783: 3D      	                dec     A               ; no, decrement X
0784: 32E681  	                ld      (SCR_CUR_NX),A  ; store new X
0787: 3AE581  	                ld      A,(SCR_CURS_Y)  ; load current cursor Y
078A: 32E781  	                ld      (SCR_CUR_NY),A  ; no move over Y axis
078D: 1811    	                jr      CONTCRSLFT      ; go on moving cursor
078F: 3AE581  	CHCKYPOS:       ld      A,(SCR_CURS_Y)  ; load cursor Y
0792: A7      	                and     A               ; is it at the most top of the screen (Y=0)?
0793: 280E    	                jr      Z,EXITCURSORLEFT; yes, exit doing nothing
0795: 3D      	                dec     A               ; no, decrement Y
0796: 32E781  	                ld      (SCR_CUR_NY),A  ; store new Y
0799: 3ADE81  	                ld      A,(SCR_SIZE_W)  ; load current screen width
079C: 3D      	                dec     A               ; cursor to the most right position (width-0)
079D: 32E681  	                ld      (SCR_CUR_NX),A  ; set new cursor X
07A0: CD5006  	CONTCRSLFT:     call    MOVCRS          ; move cursor into new position
07A3: F1      	EXITCURSORLEFT: pop     AF              ; restore A
07A4: C9      	                ret                     ; return to caller
              	
              	; move cursor 1 position to the left
07A5: 3AE481  	MVCRS2LFT:      ld      A,(SCR_CURS_X)  ; load cursor X into A
07A8: A7      	                and     A               ; is it at the most left of the screen (X=0)?
07A9: 280B    	                jr      Z,CHKYPOS       ; yes, check Y position
07AB: 3D      	                dec     A               ; no, decrement X
07AC: 32E681  	                ld      (SCR_CUR_NX),A  ; store new X
07AF: 3AE581  	                ld      A,(SCR_CURS_Y)  ; load current cursor Y
07B2: 32E781  	                ld      (SCR_CUR_NY),A  ; no move over Y axis
07B5: C9      	                ret                     ; go on moving cursor
07B6: 3AE581  	CHKYPOS:        ld      A,(SCR_CURS_Y)  ; load cursor Y
07B9: A7      	                and     A               ; is it at the most top of the screen (Y=0)?
07BA: 28E7    	                jr      Z,EXITCURSORLEFT; yes, exit doing nothing
07BC: 3D      	                dec     A               ; no, decrement Y
07BD: 32E781  	                ld      (SCR_CUR_NY),A  ; store new Y
07C0: 3ADE81  	                ld      A,(SCR_SIZE_W)  ; load current screen width
07C3: 3D      	                dec     A               ; cursor to the most right position (width-1)
07C4: 32E681  	                ld      (SCR_CUR_NX),A  ; set new cursor X
07C7: C9      	                ret                     ; return to caller
              	
              	; move cursor up
07C8: F5      	CURSORUP:       push    AF              ; store A
07C9: 3AE581  	                ld      A,(SCR_CURS_Y)  ; load cursor Y into A
07CC: A7      	                and     A               ; is it at the most top of the screen (Y=0)?
07CD: 2810    	                jr      Z,EXITCURSORUP  ; yes, exit doing nothing
07CF: 3D      	                dec     A               ; no, decrement Y
07D0: 32E781  	                ld      (SCR_CUR_NY),A  ; store new Y
07D3: 3AE481  	                ld      A,(SCR_CURS_X)  ; load current cursor X
07D6: 32E681  	                ld      (SCR_CUR_NX),A  ; set new cursor X
07D9: CD6E06  	                call    RSTCHRCRS       ; restore char under the cursor and print it
07DC: CD5006  	                call    MOVCRS          ; move cursor into new position
07DF: F1      	EXITCURSORUP:   pop     AF              ; restore A
07E0: C9      	                ret                     ; return to caller
              	
              	
              	; move cursor to right
07E1: F5      	CURSORRIGHT:    push    AF              ; store A
07E2: C5      	                push    BC              ; store B
07E3: 3ADE81  	                ld      A,(SCR_SIZE_W)  ; load current screen width (in text modes it's 32 or 40)
07E6: 3D      	                dec     A               ; decrement it (most right can only be 31 or 39)
07E7: 47      	                ld      B,A             ; move A into B
07E8: 3AE481  	                ld      A,(SCR_CURS_X)  ; load cursor X into A    
07EB: B8      	                cp      B               ; is cursor at the most right position on the screen?
07EC: 300C    	                jr      NC,CHCKYPOS2    ; yes, so jump to check Y position
07EE: 3C      	                inc     A               ; no, so increment X
07EF: 32E681  	                ld      (SCR_CUR_NX),A  ; store new X
07F2: 3AE581  	                ld      A,(SCR_CURS_Y)  ; load current cursor Y
07F5: 32E781  	                ld      (SCR_CUR_NY),A  ; no move over Y axis
07F8: 1813    	                jr      CONTCRSRGT      ; go on moving cursor
07FA: 3ADF81  	CHCKYPOS2:      ld      A,(SCR_SIZE_H)  ; load screen height
07FD: 3D      	                dec     A               ; decrement it (last row can only be 23)
07FE: 47      	                ld      B,A             ; move bottom into B
07FF: 3AE581  	                ld      A,(SCR_CURS_Y)  ; load cursor Y into A
0802: B8      	                cp      B               ; is the cursor at the bottom of the screen?
0803: 300E    	                jr      NC,EXITCURSORRGHT; yes, exit doing nothing
0805: 3C      	                inc     A               ; no, increment Y
0806: 32E781  	                ld      (SCR_CUR_NY),A  ; store new Y
0809: AF      	                xor     A               ; move cursor to top left
080A: 32E681  	                ld      (SCR_CUR_NX),A  ; store new X
080D: CD6E06  	CONTCRSRGT:     call    RSTCHRCRS       ; restore char under the cursor and print it
0810: CD5006  	                call    MOVCRS          ; move cursor into new position
0813: C1      	EXITCURSORRGHT: pop     BC              ; retrieve BC
0814: F1      	                pop     AF              ; restore A
0815: C9      	                ret                     ; return to caller
              	
              	
              	; move cursor down
0816: F5      	CURSORDOWN:     push    AF              ; store A
0817: C5      	                push    BC              ; store B
0818: 3ADF81  	                ld      A,(SCR_SIZE_H)  ; load current screen height (in text modes it's 24)
081B: 3D      	                dec     A               ; decrement it (positions can only vary between 0 and 23)
081C: 47      	                ld      B,A             ; move X into B
081D: 3AE581  	                ld      A,(SCR_CURS_Y)  ; load cursor Y into A             
0820: B8      	                cp      B               ; is current cursor position < 23?
0821: 3010    	                jr      NC,EXITCURSORDOWN; no, exit doing nothing
0823: 3C      	                inc     A               ; yes, increment Y
0824: 32E781  	                ld      (SCR_CUR_NY),A  ; store new Y
0827: 3AE481  	                ld      A,(SCR_CURS_X)  ; load current cursor X
082A: 32E681  	                ld      (SCR_CUR_NX),A  ; set new cursor X
082D: CD6E06  	                call    RSTCHRCRS       ; restore char under the cursor and print it
0830: CD5006  	                call    MOVCRS          ; move cursor into new position
0833: C1      	EXITCURSORDOWN: pop     BC              ; retrieve BC
0834: F1      	                pop     AF              ; retrieve A
0835: C9      	                ret                     ; return to caller
              	
              	
              	; set cursor on (visible on screen)
0836: F5      	CURSOR_ON:      push    AF              ; store AF
0837: 3AE981  	                ld      A,(CRSR_STATE)  ; load cursor state
083A: FE01    	                cp      $01             ; is it on?
083C: 280C    	                jr      Z,EXITCURSOR_ON ; yes, so nothing to do
083E: 3ADF81  	                ld      A,(SCR_SIZE_H)  ; check the video mode
0841: FE30    	                cp      $30             ; graphics 2 or 3 (if value>=48)?
0843: 3005    	                jr      NC,EXITCURSOR_ON; yes, so exit (no cursor in graphics 2 or 3)
0845: 3E01    	                ld      A,$01           ; cursor state ON
0847: 32E981  	                ld      (CRSR_STATE),A  ; set state
084A: F1      	EXITCURSOR_ON:  pop     AF              ; restore AF
084B: C9      	                ret                     ; return to caller
              	
              	; set cursor off (invisible on screen)
084C: F5      	CURSOR_OFF:     push    AF              ; store AF
084D: AF      	                xor     A               ; cursor state OFF
084E: 32E981  	                ld      (CRSR_STATE),A  ; set state
0851: F1      	                pop     AF              ; restore AF
0852: C9      	                ret
              	
              	; scroll the screen 1 row up
0853: AF      	SCROLLUP:       xor     A
0854: 32EB81  	                ld      (PRNTVIDEO),A
0857: 2AE281  	                ld      HL,(SCR_NAM_TB) ; start address of the name table
085A: 221F82  	                ld      (VIDTMP1),HL    ; store address of the destination row (1st row of the screen)
085D: 3ADE81  	                ld      A,(SCR_SIZE_W)  ; load the screen width
0860: 5F      	                ld      E,A             ; move width into E
0861: 1600    	                ld      D,$00           ; reset D
0863: 19      	                add     HL,DE           ; HL now contains the address of the source row (2nd row of the screen)
0864: 222182  	                ld      (VIDTMP2),HL    ; store address of source row
0867: 3ADF81  	                ld      A,(SCR_SIZE_H)  ; load the screen height
086A: 3D      	                dec     A               ; decrement the # of rows: now, A contains the # of rows to be moved
086B: 47      	                ld      B,A             ; move # of rows into B
086C: 3ADE81  	SCROLLNXTRW:    ld      A,(SCR_SIZE_W)  ; (re)load the screen width
086F: 5F      	                ld      E,A             ; move width into E
0870: 2A2182  	                ld      HL,(VIDTMP2)    ; load source address
0873: 0E32    	                ld      C,VDP_SET       ; VDP setting mode
0875: ED69    	                out     (C),L           ; low byte of source
0877: ED61    	                out     (C),H           ; high byte of source
0879: 21F781  	                ld      HL,VIDEOBUFF    ; load address of the first cell of the video buffer
087C: 0E30    	                ld      C,VDP_DAT       ; VDP data mode
087E: ED78    	LOADNEXTCOL:    in      A,(C)           ; load char
0880: 77      	                ld      (HL),A          ; store char
0881: 23      	                inc     HL              ; next cell of the buffer
0882: 1D      	                dec     E               ; count the chars to be read
0883: 20F9    	                jr      NZ,LOADNEXTCOL  ; repeat until we read the entire row
0885: 3ADE81  	                ld      A,(SCR_SIZE_W)  ; reload the screen width
0888: 5F      	                ld      E,A             ; move # of rows into E
0889: 1600    	                ld      D,$00           ; reset D
088B: 2A1F82  	                ld      HL,(VIDTMP1)    ; load address of destination row
088E: E5      	                push    HL              ; store HL
088F: 2A2182  	                ld      HL,(VIDTMP2)    ; current source will be..
0892: 221F82  	                ld      (VIDTMP1),HL    ; ..new destination
0895: 19      	                add     HL,DE           ; address of new
0896: 222182  	                ld      (VIDTMP2),HL    ; source row
0899: E1      	                pop     HL              ; restore address of current destination row
089A: CBF4    	                set     6,H             ; writing mode
089C: 0E32    	                ld      C,VDP_SET       ; VDP setting mode
089E: ED69    	                out     (C),L           ; low byte
08A0: ED61    	                out     (C),H           ; high byte of address
08A2: 21F781  	                ld      HL,VIDEOBUFF    ; video buffer address
08A5: 0E30    	                ld      C,VDP_DAT       ; VDP data mode
08A7: 7E      	WRITEBUF:       ld      A,(HL)          ; load char
08A8: ED79    	                out     (C),A           ; send char
08AA: 23      	                inc     HL              ; increment buffer index
08AB: 1D      	                dec     E               ; next row
08AC: 20F9    	                jr      NZ,WRITEBUF     ; repeat until 0
08AE: 10BC    	                djnz    SCROLLNXTRW     ; repeat for the entire screen
08B0: 3ADE81  	                ld      A,(SCR_SIZE_W)  ; reload screen width
08B3: 47      	                ld      B,A             ; cells to empty into B
08B4: AF      	                xor     A               ; null char
08B5: 0E32    	                ld      C,VDP_SET       ; VDP set mode
08B7: 2A1F82  	                ld      HL,(VIDTMP1)    ; load address of the last row
08BA: CBF4    	                set     6,H             ; writing mode
08BC: ED69    	                out     (C),L           ; low byte then..
08BE: ED61    	                out     (C),H           ; high byte of address
08C0: 0E30    	                ld      C,VDP_DAT       ; VDP data mode
08C2: ED79    	RPTEMPTYROW:    out     (C),A           ; empty cell
08C4: 00      	                nop                     ; delay
08C5: 00      	                nop
08C6: 10FA    	                djnz    RPTEMPTYROW     ; repeat until the last row has been cleaned
08C8: 3E01    	                ld      A,$01
08CA: 32EB81  	                ld      (PRNTVIDEO),A   ; set print-on-video on
08CD: C9      	                ret                     ; return to caller
              	
              	; carriage return: first, it looks for char $00 at the beginning of the line (look for the first null char),
              	; then it starts sendind every char it finds on the screen to the terminal buffer of the BASIC interpreter
              	; until another null char is found. Finally, move to the next line and position the cursor at the beginning
              	; of the row (equivalent to CR+LF), then gets back control to the screen editor to let it interpret the line
81EF:         	CUR_POS         equ     TMPBFR1         ; cursor position
81F1:         	SRTTXT          equ     TMPBFR2         ; start of text line
81F3:         	ENDTXT          equ     TMPBFR3         ; end of text line
08CE:         	CRGRETURN:      ; preliminary: disable cursor if on, and retrieve char under it
08CE: 3AE981  	                ld      A,(CRSR_STATE)  ; recover cursor state
08D1: 32F581  	                ld      (TMPBFR4),A     ; store status
08D4: A7      	                and     A               ; is cursor on?
08D5: C44C08  	                call    NZ,CURSOR_OFF   ; yes, so set cursor off
08D8: CD6E06  	                call    RSTCHRCRS       ; restore char under it
              	                ; first, check if cursor if off, so that we just interpret return as a new line command
08DB: 3A2982  	                ld      A,(KBDNPT)      ; check if input from keyboad
08DE: A7      	                and     A               ; if 0, input is not from keyboard...
08DF: CA5809  	                jp      Z,PRNTRETURN    ; ...so just print a carriage return; otherwise, interpret the return
              	                ; first part: look for the beginning of the text line on screen
08E2: CD7706  	                call    LOAD_CRSR_POS   ; load cursor position into HL
08E5: 22EF81  	                ld      (CUR_POS),HL    ; store it
08E8: ED5BE281	                ld      DE,(SCR_NAM_TB) ; load VRAM address of top-left cell of screen ("home")
08EC: E5      	RPTNLLSRC:      push    HL
08ED: CD483C  	                call    CMP16           ; check if at "home"
08F0: E1      	                pop     HL
08F1: CAFC08  	                jp      Z,CNTNULL       ; yes, exit because there is nothing before
08F4: 2B      	                dec     HL              ; go 1 step back
08F5: CD0A06  	                call    READ_VIDEO_LOC  ; read char of current position
08F8: A7      	                and     A               ; is it $00 (null char)?
08F9: 20F1    	                jr      NZ,RPTNLLSRC    ; no, continue searching
08FB: 23      	                inc     HL              ; move 1 step forward to go back to the last cell with something in
              	                ; second part: look for the ending of the text on screen
08FC: 22F181  	CNTNULL:        ld      (SRTTXT),HL     ; store beginning of text
08FF: 3ADF81  	                ld      A,(SCR_SIZE_H)
0902: 5F      	                ld      E,A             ; load screen height into DE
0903: 3ADE81  	                ld      A,(SCR_SIZE_W)
0906: 6F      	                ld      L,A             ; load screen width into HL
0907: AF      	                xor     A
0908: 67      	                ld      H,A
0909: 57      	                ld      D,A
090A: CD533C  	                call    MUL16           ; multiply HL times DE to get the screen size
090D: ED5BE281	                ld      DE,(SCR_NAM_TB) ; load screen name table start address into DE
0911: 19      	                add     HL,DE           ; get the address...
0912: 2B      	                dec     HL              ; ...of the "last" video cell
0913: EB      	                ex      DE,HL           ; store address into DE
0914: 2AEF81  	                ld      HL,(CUR_POS)    ; retrieve original cursor position
0917: E5      	RPTNLLSRC2:     push    HL
0918: CD483C  	                call    CMP16           ; check if at last position on screen (bottom right corner)
091B: E1      	                pop     HL
091C: CA2609  	                jp      Z,CNTNULL2      ; if yes, exit because these is nothing after
091F: 23      	                inc     HL              ; 1 more step forward
0920: CD0A06  	                call    READ_VIDEO_LOC  ; read char of current position
0923: A7      	                and     A               ; is it $00 (null char)?
0924: 20F1    	                jr      NZ,RPTNLLSRC2   ; no, continue searching
0926: 22F381  	CNTNULL2:       ld      (ENDTXT),HL     ; store ending of text line
0929: ED5BF181	                ld      DE,(SRTTXT)     ; load beginning of text line
092D: A7      	                and     A               ; clear Carry
092E: ED52    	                sbc     HL,DE           ; how many chars?
0930: 2826    	                jr      Z,PRNTRETURN    ; no chars found (HL-DE=0), so just print return & leave
              	                ;---    central part: send the text on the screen to the interpreter
0932: 2AF181  	                ld      HL,(SRTTXT)     ; load beginning of text line
0935: ED5BF381	                ld      DE,(ENDTXT)     ; load ending of text line
0939: CD0A06  	SNDCHRTOBFR:    call    READ_VIDEO_LOC  ; read char
093C: E5      	                push    HL
093D: CD3601  	                call    CHARINTOBFR     ; send char to buffer
0940: E1      	                pop     HL
0941: 23      	                inc     HL              ; go to next char
0942: E5      	                push    HL              ; store HL
0943: CD483C  	                call    CMP16           ; check if DE=HL (finish chars)
0946: E1      	                pop     HL
0947: 20F0    	                jr      NZ,SNDCHRTOBFR  ; no, repeat
0949: 3E0D    	                ld      A,CR            ; yes, so now send carriage return
094B: CD3601  	                call    CHARINTOBFR     ; send to buffer
094E: 2AF381  	                ld      HL,(ENDTXT)     ; recover address of last char of input text
0951: CD9B06  	                call    HL2XY           ; retrieve X,Y from address
0954: 7D      	                ld      A,L             ; move Y into A (we don't need X anymore)
0955: 32E581  	                ld      (SCR_CURS_Y),A  ; store new Y
              	                ;---    final part: go at the beginning of a new line on the screen
0958: AF      	PRNTRETURN:     xor     A               ; move to col 0
0959: 32E481  	                ld      (SCR_CURS_X),A  ; store new X
095C: 3AE581  	                ld      A,(SCR_CURS_Y)  ; load cursor Y into A
095F: 3C      	                inc     A               ; new row
0960: 21DF81  	                ld      HL,SCR_SIZE_H   ; load address of cell that keeps screen height
0963: BE      	                cp      (HL)            ; is the cursor over the bottom of the screen?
0964: 3806    	                jr      C,ADDNEWLINE    ; no, jump over
0966: 3D      	                dec     A               ; yes, so come back 1 row, then...
0967: F5      	                push    AF              ; (store A)
0968: CD5308  	                call    SCROLLUP        ; ...scroll the screen before to...
096B: F1      	                pop     AF              ; (retrieve A)
096C: 32E581  	ADDNEWLINE:     ld      (SCR_CURS_Y),A  ; ...store new Y
096F: 3AF581  	                ld      A,(TMPBFR4)     ; retrieve cursor state
0972: A7      	                and     A               ; was it off (A=0)?
0973: C43608  	                call    NZ,CURSOR_ON    ; no, set cursor on
0976: C34606  	                jp      POS_CURSOR      ; position cursor to new location & return to caller
              	
              	; ------------------------------------------------------------------------------
              	                ; this table contains the values of the offsets to be added to
              	                ; the starting address of the name table to find the correct
              	                ; value of the first cell of the corresponding row
              	                ; (by doing so, it's faster than doing a multipication)
              	                ; table for graphics 1 text mode: 32 cols
0979: 00002000	POS_TB_CRS_32   defw    $0000,$0020,$0040,$0060,$0080,$00A0,$00C0,$00E0
097D: 40006000	
0981: 8000A000	
0985: C000E000	
0989: 00012001	                defw    $0100,$0120,$0140,$0160,$0180,$01A0,$01C0,$01E0
098D: 40016001	
0991: 8001A001	
0995: C001E001	
0999: 00022002	                defw    $0200,$0220,$0240,$0260,$0280,$02A0,$02C0,$02E0
099D: 40026002	
09A1: 8002A002	
09A5: C002E002	
              	                ; table for pure text mode: 40 cols
09A9: 00002800	POS_TB_CRS_40   defw    $0000,$0028,$0050,$0078,$00A0,$00C8,$00F0,$0118
09AD: 50007800	
09B1: A000C800	
09B5: F0001801	
09B9: 40016801	                defw    $0140,$0168,$0190,$01B8,$01E0,$0208,$0230,$0258
09BD: 9001B801	
09C1: E0010802	
09C5: 30025802	
09C9: 8002A802	                defw    $0280,$02A8,$02D0,$02F8,$0320,$0348,$0370,$0398
09CD: D002F802	
09D1: 20034803	
09D5: 70039803	
              	
              	; ------------------------------------------------------------------------------
              	; reset VRAM
09D9: AF      	EMPTY_VRAM:     xor     A               ; reg.A cleared: we fill up VRAM with $00
09DA: 67      	                ld      H,A
09DB: 6F      	                ld      L,A             ; reset HL
09DC: CDEA05  	                call    SETVDPADRS      ; set address of first VRAM cell to $0000
09DF: 0640    	                ld      B,$40           ; $40 pages of RAM...
09E1: 57      	                ld      D,A             ; ...each one with $100 cells (tot. $4000 bytes)
09E2: 0E30    	                ld      C,VDP_DAT       ; VDP data mode
09E4: ED79    	EMPTVRM:        out     (C),A           ; after first byte, the VDP autoincrements VRAM pointer
09E6: 14      	                inc     D               ; next cell
09E7: 00      	                nop
09E8: 20FA    	                jr      NZ,EMPTVRM      ; repeat until page is fully cleared
09EA: 10F8    	                djnz    EMPTVRM         ; repeat for $40 pages
09EC: C9      	                ret                     ; return to caller
              	
              	; clear video registers in SRAM
09ED: 21DE81  	CLR_RAM_REG:    ld      HL,SCR_SIZE_W   ; address of first register
09F0: AF      	                xor     A               ; $00 to clean the registers
09F1: 0645    	                ld      B,CHASNDDTN-SCR_SIZE_W; how many bytes (registers) to clean (dinamically calculated)
09F3: 77      	RSTVDPRAMREG:   ld      (HL),A          ; reset register
09F4: 23      	                inc     HL              ; next register
09F5: 10FC    	                djnz    RSTVDPRAMREG    ; repeat
09F7: C9      	                ret                     ; return to caller
              	
              	; ------------------------------------------------------------------------------
              	; set a specific graphics mode, passed into reg. E
09F8: 0608    	SET_GFX_MODE:   ld      B,$08           ; 8 registers means 8 bytes..
09FA: CB23    	                sla     E               ; multiply E by 8..
09FC: CB23    	                sla     E               ; so that reg. E can point..
09FE: CB23    	                sla     E               ; to the correct settings
0A00: 1600    	SET_GFX_MODE2:  ld      D,$00           ; reset D
0A02: 21350A  	                ld      HL,VDPMODESET   ; pointer to register settings | <= here points the SHOW_LOGO sub-routine
0A05: 19      	                add     HL,DE           ; add offset to get the correct set of values for the required mode
0A06: 3E80    	                ld      A,$80           ; start with REG0 ($80+register number)
0A08: 0E32    	                ld      C,VDP_SET       ; VDP set
0A0A: 56      	LDREGVLS:       ld      D,(HL)          ; load register's value
0A0B: ED51    	                out     (C),D           ; send data to VDP
0A0D: ED79    	                out     (C),A           ; indicate the register to send data to
0A0F: 3C      	                inc     A               ; next register
0A10: 23      	                inc     HL              ; next value
0A11: 10F7    	                djnz    LDREGVLS        ; repeat for 8 registers
0A13: C9      	                ret
              	
              	; ------------------------------------------------------------------------------
0A14:         	LOADCHARSET:    ; reg. A contains the video mode
              	                ; reg. HL contains address of pattern table into VRAM
0A14: 0600    	                ld      B,$00           ; 0=256 chars to load (complete charset)
0A16: CBF4    	                set     $06,H           ; add $4000 to address to indicate that we want to write into VRAM
0A18: 0E32    	                ld      C,VDP_SET       ; load VDP address into C
0A1A: ED69    	                out     (C),L           ; send low byte of address
0A1C: ED61    	                out     (C),H           ; send high byte
0A1E: 21963C  	                ld      HL,CHRST68      ; starting address of 6x8 charset into ROM
0A21: A7      	                and     A               ; is it text mode (A=0)?
0A22: 2803    	                jr      Z,NXTCHAR       ; yes, so jump to load chars into VRAM
0A24: 219644  	                ld      HL,CHRST88      ; no, so we change and load the 8x8 charset
0A27: 1608    	NXTCHAR:        ld      D,$08           ; 8 bytes per pattern char
0A29: 0E30    	                ld      C,VDP_DAT       ; VDP data mode
0A2B: 7E      	SENDCHRPTRNS:   ld      A,(HL)          ; load byte to send to VDP
0A2C: ED79    	                out     (C),A           ; write byte into VRAM
0A2E: 23      	                inc     HL              ; inc byte pointer
0A2F: 15      	                dec     D               ; 8 bytes sents (0 char)?
0A30: 20F9    	                jr      NZ,SENDCHRPTRNS ; no, continue
0A32: 10F3    	                djnz    NXTCHAR         ; yes, decrement chars counter and continue for all the chars
0A34: C9      	                ret                     ; return to caller
              	
              	;------------------------------------------------------------------------------
              	; NAME TABLE:       buffer video - contains the chars to be shown on video
              	; PATTERN TABLE:    charset - contains the chars/tiles to be loaded into the name table
              	; COLOR TABLE:      color settings for chars/tiles
              	
              	                ; VDP register settings for a text display
0A35: 00      	VDPMODESET      defb    %00000000       ; reg.0: external video off
0A36: D0      	                defb    %11010000       ; reg.1: 16K VRAM, video on, int. off, text mode (40x24)
0A37: 02      	                defb    $02             ; reg.2: name table set to $0800 ($02x$400)
0A38: 00      	                defb    $00             ; reg.3: not used in text mode
0A39: 00      	                defb    $00             ; reg.4: pattern table set to $0000
0A3A: 00      	                defb    $00             ; reg.5: not used in text mode
0A3B: 00      	                defb    $00             ; reg.6: not used in text mode
0A3C: F5      	                defb    $f5             ; reg.7: white text on light blue background
              	
0A3D:         	VDPMODESET1     ; VDP register settings for a graphics 1 mode
0A3D: 00      	                defb    %00000000       ; reg.0: ext. video off
0A3E: C0      	                defb    %11000000       ; reg.1: 16K Vram; video on, int off, graphics mode 1, sprite size 8x8, sprite magn. 0
0A3F: 06      	                defb    $06             ; reg.2: name table address: $1800
0A40: 80      	                defb    $80             ; reg.3: color table address: $2000
0A41: 00      	                defb    $00             ; reg.4: pattern table address: $0000
0A42: 36      	                defb    $36             ; reg.5: sprite attr. table address: $1B00
0A43: 07      	                defb    $07             ; reg.6: sprite pattern table addr.: $3800
0A44: 05      	                defb    $05             ; reg.7: backdrop color (light blue)
              	
0A45:         	VDPMODESET2     ; VDP register settings for a graphics 2 mode
0A45: 02      	                defb    %00000010       ; reg.0: graphics 2 mode, ext. video dis.
0A46: C0      	                defb    %11000000       ; reg.1: 16K VRAM, video on, INT off, sprite size 8x8, sprite magn. 0
0A47: 06      	                defb    $06             ; reg.2: name table addr.: $1800
0A48: FF      	                defb    $FF             ; reg.3: color table addr.: $2000
0A49: 03      	                defb    $03             ; reg.4: pattern table addr.: $0000
0A4A: 36      	                defb    $36             ; reg.5: sprite attr. table addr.: $1B00
0A4B: 07      	                defb    $07             ; reg.6: sprite pattern table addr.: $3800
0A4C: 05      	                defb    $05             ; reg.7: backdrop color: light blue
              	
0A4D:         	VDPMODESETMC    ; VDP register settings for a multicolor mode
0A4D: 00      	                defb    %00000000       ; reg.0: ext. video dis.
0A4E: CB      	                defb    %11001011       ; reg.1: 16K VRAM, video on, INT off, multicolor mode, sprite size 8x8, sprite magn. 0
0A4F: 02      	                defb    $02             ; reg.2: name table addr.: $0800
0A50: 00      	                defb    $00             ; reg.3: don't care
0A51: 00      	                defb    $00             ; reg.4: pattern table addr.: $0000
0A52: 36      	                defb    $36             ; reg.5: sprite attr. table addr.: $1B00
0A53: 07      	                defb    $07             ; reg.6: sprite pattern table addr.: $3800
0A54: 0F      	                defb    $0F             ; reg.7: backdrop color (white)
              	
0A55:         	VDPMODESETEX2   ; VDP register settings for an extended graphics 2 mode
0A55: 02      	                defb    %00000010       ; reg.0: graphics 2 mode, ext. video dis.
0A56: C0      	                defb    %11000000       ; reg.1: 16K VRAM, video on, INT off, sprite size 8x8, sprite magn. 0
0A57: 0E      	                defb    $0E             ; reg.2: name table addr.: $3800
0A58: 9F      	                defb    $9F             ; reg.3: color table addr.: $2000
0A59: 00      	                defb    $00             ; reg.4: pattern table addr.: $0000
0A5A: 76      	                defb    $76             ; reg.5: sprite attr. table addr.: $3B00
0A5B: 03      	                defb    $03             ; reg.6: sprite pattern table addr.: $1800
0A5C: 05      	                defb    $05             ; reg.7: backdrop color: light blue
              	
0A5D:         	LM80CLOGO       ; patterns to compose the splash screen logo
0A5D: 00000000	                defb    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0A61: 00...   	
0A7D: 00000F0A	                defb    0,0,15,10,11,16,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0A81: 0B100000	
0A85: 00000000	
0A89: 00...   	
0A9D: 00000D17	                defb    0,0,13,23,0,12,0,0,0,1,0,0,0,20,0,0,6,5,6,21,22,7,6,21,22,7,6,1,1,7,0,0
0AA1: 000C0000	
0AA5: 00010000	
0AA9: 00140000	
0AAD: 06050615	
0AB1: 16070615	
0AB5: 16070601	
0AB9: 01070000	
0ABD: 00000D00	                defb    0,0,13,0,0,12,0,0,0,1,0,0,0,1,20,6,1,5,3,5,3,5,3,5,3,5,3,5,3,5,0,0
0AC1: 000C0000	
0AC5: 00010000	
0AC9: 00011406	
0ACD: 01050305	
0AD1: 03050305	
0AD5: 03050305	
0AD9: 03050000	
0ADD: 00000D00	                defb    0,0,13,0,0,12,0,0,0,1,0,0,0,1,1,1,1,5,9,20,19,8,3,5,19,5,3,5,0,0,0,0
0AE1: 000C0000	
0AE5: 00010000	
0AE9: 00010101	
0AED: 01050914	
0AF1: 13080305	
0AF5: 13050305	
0AF9: 00000000	
0AFD: 00000D00	                defb    0,0,13,0,0,12,0,0,0,1,0,0,0,1,0,8,3,5,6,21,22,7,3,1,22,5,3,5,0,0,0,0
0B01: 000C0000	
0B05: 00010000	
0B09: 00010008	
0B0D: 03050615	
0B11: 16070301	
0B15: 16050305	
0B19: 00000000	
0B1D: 00000D00	                defb    0,0,13,0,0,12,0,0,0,1,0,0,0,1,0,0,3,5,3,5,3,5,3,5,3,5,3,5,3,5,0,0
0B21: 000C0000	
0B25: 00010000	
0B29: 00010000	
0B2D: 03050305	
0B31: 03050305	
0B35: 03050305	
0B39: 03050000	
0B3D: 00000D00	                defb    0,0,13,0,0,12,0,0,0,1,4,4,0,1,0,0,3,5,9,20,19,8,9,20,19,8,9,1,1,8,0,0
0B41: 000C0000	
0B45: 00010404	
0B49: 00010000	
0B4D: 03050914	
0B51: 13080914	
0B55: 13080901	
0B59: 01080000	
0B5D: 00000E12	                defb    0,0,14,18,18,17,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0B61: 12110000	
0B65: 00000000	
0B69: 00...   	
0B7D: 00000000	                defb    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0; ------------------------------------------------------------------------------
0B81: 00...   	
              	; LM80C - PSG ROUTINES - R3.13
              	; ------------------------------------------------------------------------------
              	; The following code is intended to be used with LM80C Z80-based computer
              	; designed by Leonardo Miliani. Code and computer schematics are released under
              	; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
              	; kind of warranty: you can use them at your own risk.
              	; You are free to use them for any non-commercial use: you are only asked to
              	; maintain the copyright notices, include this advice and the note to the 
              	; attribution of the original version to Leonardo Miliani, if you intend to
              	; redistribuite them.
              	; https://www.leonardomiliani.com
              	; 
              	; Please support me by visiting the following links:
              	; Main project page: https://www.leonardomiliani.com
              	; Schematics and code: https://github.com/leomil72/LM80C
              	; Videos about the computer: https://www.youtube.com/user/leomil72/videos
              	; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
              	; ------------------------------------------------------------------------------
              	;
              	; ------------------------------------------------------------------------------
              	
              	;------------------------------------------------------------------------------
              	; configure the PSG
0B9D: 212382  	initPSG:        ld      HL,CHASNDDTN    ; starting address of sound & keyboard RAM registers
0BA0: 060B    	                ld      B,SERIALS_EN-CHASNDDTN; # of PSG sound & keyboard registers
0BA2: AF      	                xor     A               ; reset A
0BA3: 77      	EMPTSNDBFR:     ld      (HL),A          ; reset RAM register
0BA4: 23      	                inc     HL              ; next register
0BA5: 10FC    	                djnz    EMPTSNDBFR      ; repeat
0BA7: 0610    	CLRPSGREGS:     ld      B,$10           ; 16 registers to set
0BA9: 21BB0B  	                ld      HL,SNDREGCFG    ; starting address of register settings
0BAC: 1600    	                ld      D,$00           ; first register
0BAE: 7A      	RSTPSG:         ld      A,D             ; register value
0BAF: CDF50B  	                call    SETSNDREG       ; select register
0BB2: 7E      	                ld      A,(HL)          ; load value
0BB3: CDFA0B  	                call    WRTSNDREG       ; write to register
0BB6: 14      	                inc     D               ; next register
0BB7: 23      	                inc     HL              ; next value
0BB8: 10F4    	                djnz    RSTPSG          ; repeat for each register
0BBA: C9      	                ret                     ; return to caller
              	
0BBB: 00000000	SNDREGCFG:      defb $00,$00,$00,$00,$00,$00,$00,%10111111
0BBF: 000000BF	
0BC3: 00000000	                defb $00,$00,$00,$00,$00,$00,$ff,$ff
0BC7: 0000FFFF	
              	                ; reg. 7: set I/O ch.A to OUTPUT, I/O ch.B to INPUT; set noise to OFF; set audio to OFF
              	
              	
              	; routine to play a welcome beep on channel C (tone 4010) and to shut it off
0BCB: 21E50B  	WLCMBEEP:       ld      HL,WLCBPDAT     ; data address
0BCE: C3D40B  	                jp      SENDSND
0BD1: 21ED0B  	NOBEEP:         ld      HL,NOBPDAT      ; data address
0BD4: C5      	SENDSND:        push    BC
0BD5: 0604    	                ld      B,$04           ; 4 pairs
0BD7: 7E      	RPTWLCMBP:      ld      A,(HL)          ; read register #
0BD8: CDF50B  	                call    SETSNDREG
0BDB: 23      	                inc     HL              ; next cell
0BDC: 7E      	                ld      A,(HL)          ; read value
0BDD: CDFA0B  	                call    WRTSNDREG
0BE0: 23      	                inc     HL
0BE1: 10F4    	                djnz    RPTWLCMBP       ; repeat
0BE3: C1      	                pop     BC
0BE4: C9      	                ret                     ; return to caller
              	
0BE5: 077B0456	WLCBPDAT:       defb    $07,%01111011,$04,$56,$05,$00,$0A,$0F
0BE9: 05000A0F	
0BED: 04000500	NOBPDAT:        defb    $04,$00,$05,$00,$0A,$00,$07,%01111111
0BF1: 0A00077F	
              	
              	
              	; select register on PSG
0BF5: 0E40    	SETSNDREG:      ld      C,PSG_REG       ; PSG register port
0BF7: ED79    	                out     (C),A           ; set register
0BF9: C9      	                ret                     ; return to caller
              	
              	; send data to PSG
0BFA: 0E41    	WRTSNDREG:      ld      C,PSG_DAT       ; PSG data port
0BFC: ED79    	                out     (C),A           ; send data
0BFE: C9      	                ret                     ; return to caller
              	
              	; manage the sounds' duration: each time this subroutine is called, it
              	; decrements the single sound durations (measured in ms) and eventually
              	; shut off the audio channel whose counter has reached 0.
              	; (this sub-routine is called by CH3 timer ISR)
0BFF: DDE5    	MNGSNDS:        push    IX              ; store IX
0C01: DD212382	                ld      IX,CHASNDDTN    ; starting address of tones duration
0C05: 0603    	                ld      B,$03           ; 3 channels to check
0C07: 2601    	                ld      H,$01           ; mixer channels: A=>bit 1, B=>bit 2, C=>bit 3
0C09: DD5E00  	CHKSNDCH:       ld      E,(IX+0)        ; load LSB into E
0C0C: DD5601  	                ld      D,(IX+1)        ; load MSB into D
0C0F: 7B      	                ld      A,E             ; load E into A
0C10: B2      	                or      D               ; check that DE=0
0C11: 2831    	                jr      Z,CNTCHKSND     ; yes, jump over
0C13: 1B      	                dec     DE              ; no, so decrement DE
0C14: 7B      	                ld      A,E             ; reload E into A...
0C15: DD7300  	                ld      (IX+0),E        ; store new...
0C18: DD7201  	                ld      (IX+1),D        ; ...duration and...
0C1B: B2      	                or      D               ; ...do another check to see if DE=0
0C1C: 2026    	                jr      NZ,CNTCHKSND    ; no, so jump over
              	                                        ; if yes, let's shut down the corresponding channel
              	                                        ; to shut down a tone we disable it into the mixer
              	                                        ; then set 0 into its tone registers
0C1E: 1607    	                ld      D,$07           ; mixer register
0C20: 0E40    	                ld      C,PSG_REG       ; PSG register selector port
0C22: ED51    	                out     (C),D           ; set mixer register
0C24: ED78    	                in      A,(C)           ; load current value
0C26: B4      	                or      H               ; set off the channel into the mixer (remember that 1=OFF)
0C27: ED51    	                out     (C),D           ; select mixer register
0C29: 0E41    	                ld      C,PSG_DAT       ; PSG data port
0C2B: ED79    	                out     (C),A           ; send new value for the mixer
0C2D: 3E03    	                ld      A,$03           ; three channels
0C2F: 90      	                sub     B               ; find current channel (0->A, 1->B, 2->C)
0C30: 87      	                add     A,A             ; and find first register (A=>0, B=>2, C=>4)
0C31: 0E40    	                ld      C,PSG_REG       ; PSG register selector port
0C33: ED79    	                out     (C),A           ; select first tone register of channel
0C35: 2E00    	                ld      L,$00           ; value 0 into L
0C37: 0E41    	                ld      C,PSG_DAT       ; PSG data selector port
0C39: ED69    	                out     (C),L           ; write 0 into register
0C3B: 0E40    	                ld      C,PSG_REG       ; PSG register selector port
0C3D: 3C      	                inc     A               ; next tone register
0C3E: ED79    	                out     (C),A           ; select second tone register of channel
0C40: 0E41    	                ld      C,PSG_DAT       ; PSG data selector port
0C42: ED69    	                out     (C),L           ; write 0 into register
0C44: DD23    	CNTCHKSND:      inc     IX              ; set for...
0C46: DD23    	                inc     IX              ; ...next channel...
0C48: CB24    	                sla     H               ; shift left H 1 bit
0C4A: 10BD    	                djnz    CHKSNDCH        ; repeat for 3 channels
0C4C: DDE1    	                pop     IX              ; restore IX
0C4E: C9      	                ret                     ; return to caller
              	
              	; read a specific row of the keyboard matrix, set by A
              	; return read into A
0C4F: C5      	READKBLN:       push    BC
0C50: 060F    	                ld      B,$0F           ; reg #14
0C52: 0E40    	                ld      C,PSG_REG       ; PSG register port
0C54: ED41    	                out     (C),B           ; select reg #14
0C56: 0E41    	                ld      C,PSG_DAT       ; PSG data port
0C58: ED79    	                out     (C),A           ; activate the row
0C5A: 060E    	                ld      B,$0E           ; register #15 (port B)
0C5C: 0E40    	                ld      C,PSG_REG       ; PSG register port
0C5E: ED41    	                out     (C),B           ; select reg. 15 (port B)
0C60: ED78    	                in      A,(C)           ; read register #15
0C62: C1      	                pop     BC
0C63: C9      	                ret
              	
              	; read the keyboard matrix to look for a key pressure
0C64: 0E40    	KEYBOARD:       ld      C,PSG_REG       ; PSG register port
0C66: 0607    	                ld      B,$07           ; set register #7...
0C68: ED41    	                out     (C),B           ; ...to work with
0C6A: ED78    	                in      A,(C)           ; read register #7
0C6C: CBFF    	                set     7,A             ; port A set to output
0C6E: CBB7    	                res     6,A             ; port B set to input
0C70: ED41    	                out     (C),B           ; set register #7
0C72: 0E41    	                ld      C,PSG_DAT       ; PSG data port
0C74: ED79    	                out     (C),A           ; set I/O ports w/o altering the rest of the mixer
              	                ; check special keys (SHIFT/ALT/CTRL)
0C76: 3EFD    	                ld      A,%11111101     ; select SHIFT row
0C78: CD4F0C  	                call    READKBLN        ; read row
0C7B: CB5F    	                bit     3,A             ; test if SHIFT key is pressed (4th bit is reset)
0C7D: 2005    	                jr      NZ,CHECKALT     ; no, so go on
0C7F: 212D82  	                ld      HL,CONTROLKEYS  ; control key flags
0C82: 3601    	                ld      (HL),%00000001  ; set SHIFT flag, reset CTRL & ALT flags (currently multiply control keys are NOT supported)
0C84: 3EFE    	CHECKALT:       ld      A,%11111110     ; select ALT row
0C86: CD4F0C  	                call    READKBLN        ; read ALT row
0C89: CB6F    	                bit     5,A             ; test if ALT key is pressed (5th bit is reset)
0C8B: 2005    	                jr      NZ,CHECKCTRL    ; no, so go on
0C8D: 212D82  	                ld      HL,CONTROLKEYS  ; control key flags
0C90: 3604    	                ld      (HL),%00000100  ; set ALT flag, reset SHIFT & CTRL flag (currently multiply control keys are NOT supported)
0C92: 3EFE    	CHECKCTRL:      ld      A,%11111110     ; select CTRL row
0C94: CD4F0C  	                call    READKBLN        ; read CTRL row
0C97: CB57    	                bit     2,A             ; test if CTRL key is pressed (3rd bit is reset)
0C99: 2005    	                jr      NZ,CHECKKBD     ; no, so make a normal reading
0C9B: 212D82  	                ld      HL,CONTROLKEYS  ; control key flags
0C9E: 3602    	                ld      (HL),%00000010  ; set CTRL flag, reset SHIFT & ALT flags (currently multiply control keys are NOT supported)
0CA0: 0608    	CHECKKBD:       ld      B,$08           ; 8 lines
0CA2: 3E7F    	                ld      A,%01111111     ; start from the last line of the matrix
0CA4: 160F    	RPTKBDRD:       ld      D,$0F           ; register #14 (port A)
0CA6: 0E40    	                ld      C,PSG_REG       ; PSG register port
0CA8: ED51    	                out     (C),D           ; select reg. #14
0CAA: 0E41    	                ld      C,PSG_DAT       ; PSG data port
0CAC: ED79    	                out     (C),A           ; activate 1 line (active line is grounded, i.e. with a LOW signal)
0CAE: 5F      	                ld      E,A             ; save current line into E
0CAF: 160E    	                ld      D,$0E           ; register #15 (port B)
0CB1: 0E40    	                ld      C,PSG_REG       ; PSG register port
0CB3: ED51    	                out     (C),D           ; select reg. 15 (port B)
0CB5: 00      	                nop
0CB6: ED78    	                in      A,(C)           ; read register #15
0CB8: FEFF    	                cp      $FF             ; is there any line set to 0?
0CBA: 282E    	                jr      Z,NOKEYPRSD     ; no, go to the next row
              	                ; check control keys
0CBC: 322A82  	                ld      (KBTMP),A       ; yes, check if a control key was pressed. First, store current row
0CBF: 78      	                ld      A,B             ; copy current row (B) into A
0CC0: FE02    	                cp      $02             ; is it the row of the SHIFT?
0CC2: 200F    	                jr      NZ,TESTALT      ; no, continue checking the other control keys
0CC4: 3A2A82  	                ld      A,(KBTMP)       ; yes, retrieve current row data
0CC7: CB5F    	                bit     3,A             ; check SHIFT bit line
0CC9: 202E    	                jr      NZ,FINDKEY      ; no SHIFT, continue checking
0CCB: CBDF    	                set     3,A             ; yes, it's the SHIFT. So remove SHIFT bit
0CCD: FEFF    	                cp      $FF             ; after deleting the SHIFT bit, is there any other bit selected?
0CCF: 2028    	                jr      NZ,FINDKEY      ; yes, go to check which one
0CD1: 1817    	                jr      NOKEYPRSD       ; no, go to next row        
0CD3: FE01    	TESTALT:        cp      $01             ; is it the line of ALT & CTRL?
0CD5: 3A2A82  	                ld      A,(KBTMP)       ; retrieve current row data
0CD8: 201F    	                jr      NZ,FINDKEY      ; no, continue
0CDA: CB6F    	                bit     5,A             ; yes, check ALT bit line
0CDC: 2002    	                jr      NZ,TESTCTRL     ; no ALT, continue checking
0CDE: CBEF    	                set     5,A             ; yes, it's the ALT. So remove ALT bit
0CE0: CB57    	TESTCTRL:       bit     2,A             ; check CTRL bit line
0CE2: 2002    	                jr      NZ,ENDCTRLCK    ; no CTRL, continue checking
0CE4: CBD7    	                set     2,A             ; delete CTRL bit flag
0CE6: FEFF    	ENDCTRLCK:      cp      $FF             ; after deleting the ALT & CTRL bits, is there any other bit selected?
0CE8: 200F    	                jr      NZ,FINDKEY      ; yes, go to check which one
0CEA: 7B      	NOKEYPRSD:      ld      A,E             ; no key pressed, load current output port
0CEB: 0F      	                rrca                    ; rotate right by 1
0CEC: 10B6    	                djnz    RPTKBDRD        ; repeat for 8 lines
0CEE: AF      	                xor     A               ; if exit from here, no key has been pressed...
0CEF: 322C82  	                ld      (LASTKEYPRSD),A ; ...so reset the last key cell...
0CF2: 322D82  	                ld      (CONTROLKEYS),A ; ...reset contro key flags...
0CF5: 322982  	                ld      (KBDNPT),A      ; ...no input from keyboard...
0CF8: C9      	                ret                     ; ...and leave
0CF9: 1EFF    	FINDKEY:        ld      E,$FF           ; counter
0CFB: 1C      	CHKLN:          inc     E               ; E goes from 0 to 7
0CFC: CB3F    	                srl     A               ; is the first bit reset? (we're looking for a "0", meaning grounded line)
0CFE: 38FB    	                jr      C,CHKLN         ; no, check next bit
0D00: 3A2D82  	                ld      A,(CONTROLKEYS) ; load control key flags
0D03: 21CC0D  	                ld      HL,KBMAP        ; normal keymap
0D06: FE01    	                cp      $01             ; SHIFT flag?
0D08: 2005    	                jr      NZ,CHKCTRL      ; no, jump over
0D0A: 210C0E  	                ld      HL,KBMAP_SFT    ; SHIFT keymap
0D0D: 1810    	                jr      LOADMAP         ; and load it
0D0F: FE02    	CHKCTRL:        cp      $02             ; CTRL flag?
0D11: 2005    	                jr      NZ,CHKALT       ; no, jump over
0D13: 218C0E  	                ld      HL,KBMAP_CTRL   ; CTRL map
0D16: 1807    	                jr      LOADMAP         ; and load it
0D18: FE04    	CHKALT:         cp      $04             ; ALT flag?
0D1A: 2003    	                jr      NZ,LOADMAP      ; no, check over
0D1C: 214C0E  	                ld      HL,KBMAP_ALT    ; ALT map
0D1F: 05      	LOADMAP:        dec     B               ; decrement row # (rows go from 0 to 7)
0D20: 48      	                ld      C,B             ; move B into C and...
0D21: CB21    	                sla     C               ; ...multiply it...
0D23: CB21    	                sla     C               ; ...by 8 to find...
0D25: CB21    	                sla     C               ; ...the current row into the matrix
0D27: 0600    	                ld      B,$00           ; reset B
0D29: 09      	                add     HL,BC           ; find the address of the current row
0D2A: 50      	                ld      D,B             ; reset D
0D2B: 19      	                add     HL,DE           ; find the current column
0D2C: 3A2C82  	                ld      A,(LASTKEYPRSD) ; load the last key pressed
0D2F: BE      	                cp      (HL)            ; is it the same key?
0D30: 2847    	                jr      Z,LVKBRDCHK     ; yes, so do nothing
0D32: 7E      	                ld      A,(HL)          ; no, load it...
0D33: 322C82  	                ld      (LASTKEYPRSD),A ; ...store it...
0D36: 322B82  	                ld      (TMPKEYBFR),A   ; ...insert it into the INKEY buffer...
0D39: 32EC81  	                ld      (CHR4VID),A     ; ...and store char for video
0D3C: FE03    	                cp      CTRLC           ; is it RUN/STOP?
0D3E: 2005    	                jr      NZ,CNTKBCK      ; no, jump over
0D40: CD3601  	                call    CHARINTOBFR     ; yes, send directly to buffer and...
0D43: 1830    	                jr      LVKBRDCHK2      ; ...leave
0D45: 010008  	CNTKBCK:        ld      BC,$0800        ; 8 FN keys (B), FN key number (C)
0D48: 21C40D  	                ld      HL,FNKEYSORD    ; FN keys codes
0D4B: BE      	CHKFNK:         cp      (HL)            ; is it an FN key?
0D4C: CA7A0D  	                jp      Z,PRNTFNKEY     ; yes, jump over
0D4F: 0C      	                inc     C               ; next FN key
0D50: 23      	                inc     HL              ; next FN key code
0D51: 10F8    	                djnz    CHKFNK          ; continue for 8 FN keys
0D53: 3E01    	SNDKEYTOBFR:    ld      A,$01           ; normal key - set input flag
0D55: 322982  	                ld      (KBDNPT),A      ; to keyboard
0D58: 3AEB81  	                ld      A,(PRNTVIDEO)   ; load status of print-on-video
0D5B: B7      	                or      A               ; is the print-on-video disabled?
0D5C: CA650D  	                jp      Z,PUTCHRBUF     ; yes, so send char to input buffer
0D5F: 3AE981  	                ld      A,(CRSR_STATE)  ; check cursor state
0D62: B7      	                or      A               ; is it 0 (cursor OFF)?
0D63: 200D    	                jr      NZ,PNT2VD       ; no, print on screen
0D65: AF      	PUTCHRBUF:      xor     A
0D66: 322982  	                ld      (KBDNPT),A      ; if send to input buffer, set RETURN as from BASIC
0D69: 3A2B82  	                ld      A,(TMPKEYBFR)   ; retrieve char
0D6C: CD3601  	                call    CHARINTOBFR     ; cursor off, so send char to buffer...
0D6F: C3750D  	                jp      LVKBRDCHK2      ; ...and leave
0D72: CDAC06  	PNT2VD:         call    CHAR2VID        ; send char to video
0D75: AF      	LVKBRDCHK2:     xor     A
0D76: 322D82  	                ld      (CONTROLKEYS),A ; reset control key flags
0D79: C9      	LVKBRDCHK:      ret                     ; return to caller: the current key code is into TMPKEYBFR    
              	                ; manage FN keys          
0D7A: 57      	PRNTFNKEY:      ld      D,A             ; copy A into D
0D7B: 2AAF80  	                ld      HL,(LINEAT)     ; Get current line number
0D7E: 23      	                inc     HL              ; -1 means direct statement
0D7F: 7C      	                ld      A,H
0D80: B5      	                or      L
0D81: 7A      	                ld      A,D             ; retrieve char
0D82: 20CF    	                jr      NZ,SNDKEYTOBFR  ; indirect mode - just send FN key code to buffer
0D84: 79      	                ld      A,C             ; direct mode, so print text - first, get FN key number
0D85: 87      	                add     A,A
0D86: 87      	                add     A,A
0D87: 87      	                add     A,A
0D88: 87      	                add     A,A             ; FN key number * 16
0D89: 4F      	                ld      C,A             ; move it into C
0D8A: 0600    	                ld      B,$00           ; reset B, to get offset
0D8C: 21B380  	                ld      HL,FNKEYS       ; load address of FN keys texts
0D8F: 09      	                add     HL,BC           ; get correct text address
0D90: 0610    	                ld      B,$10           ; 16 chars
0D92: 7E      	LDFNKEYCHR:     ld      A,(HL)          ; load char
0D93: A7      	                and     A               ; null char?
0D94: CA750D  	                jp      Z,LVKBRDCHK2    ; yes, so leave
0D97: 57      	                ld      D,A             ; pass char into D
0D98: 3AEB81  	                ld      A,(PRNTVIDEO)   ; load status of print-on-video
0D9B: B7      	                or      A               ; is the print-on-video disabled?
0D9C: CAAC0D  	                jp      Z,PUTCHRBUF1    ; yes, so send char to input buffer
0D9F: 3AE981  	                ld      A,(CRSR_STATE)  ; check cursor state
0DA2: B7      	                or      A               ; is it 0 (cursor OFF)?
0DA3: C4B70D  	                call    NZ,PRNTFNK      ; no, print on screen
0DA6: 23      	CNTFNK:         inc     HL              ; next char
0DA7: 10E9    	                djnz    LDFNKEYCHR      ; repeat for max. 16 chars
0DA9: C3750D  	                jp      LVKBRDCHK2      ; leave
0DAC: AF      	PUTCHRBUF1:     xor     A
0DAD: 322982  	                ld      (KBDNPT),A      ; if send to input buffer, set RETURN as from BASIC
0DB0: 7A      	                ld      A,D             ; retrieve char
0DB1: CD3601  	                call    CHARINTOBFR     ; cursor off, so send char to buffer...
0DB4: C3A60D  	                jp      CNTFNK          ; jump over
0DB7: 7A      	PRNTFNK:        ld      A,D             ; recover char
0DB8: 32EC81  	                ld      (CHR4VID),A     ; store char for printing
0DBB: 3E01    	                ld      A,$01           ; normal key - set input flag
0DBD: 322982  	                ld      (KBDNPT),A      ; to keyboard
0DC0: CDAC06  	                call    CHAR2VID        ; print on screen
0DC3: C9      	                ret                     ; return to caller
              	
              	
              	;-----------------------------------------------------------------------
0DC4: 01020405	FNKEYSORD:      defb 1,2,4,5,6,22,23,24                 ; order of FN Keys
0DC8: 06161718	
              	;-----------------------------------------------------------------------
              	; key codes
0DCC: 31190E03	KBMAP:          defb '1',25,14,3,' ',16,'q','2'         ; 25=HOME  14=CTRL  3=RUN/STOP 16=C=
0DD0: 20107132	
0DD4: 33776114	                defb '3','w','a',20,'z','s','e','4'     ; 20=SHIFT
0DD8: 7A736534	
0DDC: 35726478	                defb '5','r','d','x','c','f','t','6'
0DE0: 63667436	
0DE4: 37796776	                defb '7','y','g','v','b','h','u','8'
0DE8: 62687538	
0DEC: 39696A6E	                defb '9','i','j','n','m','k','o','0'
0DF0: 6D6B6F30	
0DF4: 1F706C2C	                defb 31,'p','l',',','.',':','-',30      ; 31=CURSOR DOWN  30=CURSOR UP
0DF8: 2E3A2D1E	
0DFC: 1C2A3B2F	                defb 28,'*',';','/',27,'=','+',29       ; 28=CURSOR LEFT  27=ESCAPE  29=CURSOR RIGHT
0E00: 1B3D2B1D	
0E04: 080DFC40	                defb 8,13,252,'@',1,2,4,24              ; 8=DEL(backspace)  13=RETURN  252=  1=F1  2=F2  4=F3  24=HELP
0E08: 01020418	
              	
              	; shifted codes - not all the keys have the shifted version
0E0C: 210C0E03	KBMAP_SFT:      defb '!',12,14,3,' ',16,'Q',34          ; 12=CLEAR  14=CTRL  3=RUN/STOP 16=C=   34="
0E10: 20105122	
0E14: 23574114	                defb '#','W','A',20,'Z','S','E','$'     ; 20=SHIFT
0E18: 5A534524	
0E1C: 25524458	                defb '%','R','D','X','C','F','T','&'
0E20: 43465426	
0E24: 27594756	                defb 39,'Y','G','V','B','H','U','('     ; 39='
0E28: 42485528	
0E2C: 29494A4E	                defb ')','I','J','N','M','K','O',94     ; 94=^
0E30: 4D4B4F5E	
0E34: 1F504C3C	                defb 31,'P','L','<','>','[','_',30      ; 31=CURSOR DOWN  30=CURSOR UP
0E38: 3E5B5F1E	
0E3C: 1C2A5D3F	                defb 28,'*',']','?',27,198,'+',29       ; 28=CURSOR LEFT  27=ESCAPE  29=CURSOR RIGHT
0E40: 1BC62B1D	
0E44: 080DD340	                defb 8,13,211,'@',5,6,22,23             ; 211=  5=F4  6=F5  22=F6  23=F7
0E48: 05061617	
              	
              	; ALT (C=) codes - not all the keys have the alt-ed version
0E4C: 310C0E03	KBMAP_ALT:      defb '1',12,14,3,' ',16,222,196         ; 12=CLEAR  14=CTRL  3=RUN/STOP  16=C=  34="
0E50: 2010DEC4	
0E54: 33DD8514	                defb '3',221,133,20,131,130,165,'4'     ; 20=SHIFT
0E58: 8382A534	
0E5C: 35A2A684	                defb '5',162,166,132,157,163,168,'6'
0E60: 9DA3A836	
0E64: 37ABA9A1	                defb '7',171,169,161,158,172,213,'8'    ;
0E68: 9EACD538	
0E6C: 39D6D89F	                defb '9',214,216,159,160,215,135,195    ;
0E70: A0D787C3	
0E74: 1F888AC1	                defb 31,136,138,193,192,123,144,30      ; 31=CURSOR DOWN  123={  30=CURSOR UP
0E78: C07B901E	
0E7C: 1C8F7DFE	                defb 28,143,125,254,27,209,148,29       ; 28=CURSOR LEFT  125=}  27=ESCAPE  29=CURSOR RIGHT
0E80: 1BD1941D	
0E84: 080DE089	                defb 8,13,224,137,5,6,22,23             ; 8=DEL(backspace)  13=RETURN  252=  5=F4  6=F5  22=F6  23=F7
0E88: 05061617	
              	
              	; CTRL codes - not all the keys have the control-ed version
0E8C: 31190E03	KBMAP_CTRL:     defb '1',25,14,3,' ',16,154,'2'         ; 25=HOME  14=CTRL  3=RUN/STOP  16=C=
0E90: 20109A32	
0E94: 339C9514	                defb '3',156,149,20,152,150,153,'4'     ; 20=SHIFT
0E98: 98969934	
0E9C: 359BB097	                defb '5',155,176,151,177,175,165,'6'
0EA0: B1AFA536	
0EA4: 37A6A8B2	                defb '7',166,168,178,179,169,167,'8'
0EA8: B3A9A738	
0EAC: 39B8AAAC	                defb '9',184,170,172,171,181,164,'0'
0EB0: ABB5A430	
0EB4: 1FA3AD2C	                defb 31,163,173,',','.',':',186,30      ; 31=CURSOR DOWN  30=CURSOR UP
0EB8: 2E3ABA1E	
0EBC: 1CE13B2F	                defb 28,225,';','/',27,212,185,29       ; 28=CURSOR LEFT  27=ESCAPE  212=  29=CURSOR RIGHT
0EC0: 1BD4B91D	
0EC4: 080DBDA2	                defb 8,13,189,162,1,2,4,24              ; 8=DEL(backspace)  13=RETURN  252=  1=F1  2=F2  4=F3  24=HELP; ------------------------------------------------------------------------------
0EC8: 01020418	
              	; LM80C BASIC - R3.13
              	; ------------------------------------------------------------------------------
              	; The following code is intended to be used with LM80C Z80-based computer
              	; designed by Leonardo Miliani. Code and computer schematics are released under
              	; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
              	; kind of warranty: you can use them at your own risk.
              	; You are free to use them for any non-commercial use: you are only asked to
              	; maintain the copyright notices, include this advice and the note to the 
              	; attribution of the original version to Leonardo Miliani, if you intend to
              	; redistribuite them.
              	; https://www.leonardomiliani.com
              	; 
              	; Please support me by visiting the following links:
              	; Main project page: https://www.leonardomiliani.com
              	; Schematics and code: https://github.com/leomil72/LM80C
              	; Videos about the computer: https://www.youtube.com/user/leomil72/videos
              	; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
              	; ------------------------------------------------------------------------------
              	; NASCOM BASIC versions:
              	; 4.7  - original version by NASCOM
              	; 4.7b - modified version by Grant Searle (additional commands & functions)
              	; 4.8  - modified by Leonardo Miliani (new commands/functions)
              	
              	
              	;------------------------------------------------------------------------------
              	;  B A S I C
              	;------------------------------------------------------------------------------
              	
              	; GENERAL EQUATES
              	
0000:         	NLLCR           equ     $00             ; null char (used as space/empty char in video prints)
0003:         	CTRLC           equ     $03             ; Control "C"
0007:         	CTRLG           equ     $07             ; Control "G"
0008:         	BKSP            equ     $08             ; Back space
000A:         	LF              equ     $0A             ; Line feed
000C:         	CS              equ     $0C             ; Clear screen
000D:         	CR              equ     $0D             ; Carriage return
000F:         	CTRLO           equ     $0F             ; Control "O"
0011:         	CTRLQ           equ     $11             ; Control "Q"
0012:         	CTRLR           equ     $12             ; Control "R"
0013:         	CTRLS           equ     $13             ; Control "S"
0015:         	CTRLU           equ     $15             ; Control "U"
0019:         	HOME            equ     $19             ; Home (cursor at 0,0)
001B:         	ESC             equ     $1B             ; Escape
0020:         	SPC             equ     $20             ; Space
007F:         	DEL             equ     $7F             ; Delete
              	; cursor ASCII codes
001C:         	CRSLFT          equ     $1C             ; cursor left
001D:         	CRSRGT          equ     $1D             ; cursor right
001E:         	CRSUP           equ     $1E             ; cursor up
001F:         	CRSDN           equ     $1F             ; cursor down
              	
              	
              	; BASIC WORK SPACE LOCATIONS
              	; BY STARTING FROM $805E THE INTERPRETER ALLOCATES THE FOLLOWING RAM CELLS
              	; TO STORE IMPORTANT VALUES USED FOR SOME SPECIFIC FUNCTIONS:
              	; THEY CAN BE VECTOR (ADDRESSES) FUNCTIONS, SYSTEM DATAS (I.E. VARIABLES)
              	; AND SO ON. THE FIRST CELLS ARE FILLED WITH VALUES STORED INTO ROM AT $(INITAB) ADDRESS
805E:         	WRKSPC          equ     basicStarted+$01; (3) BASIC Work space
8061:         	NMIUSR          equ     WRKSPC+$03      ; (3) NMI exit point routine
8064:         	USR             equ     NMIUSR+$03      ; (3) "USR (x)" jump  <-- in $8065/8066 the user can store the address of a specific machine language routine
8067:         	OUTSUB          equ     USR+$03         ; (1) "out p,n"
8068:         	OTPORT          equ     OUTSUB+$01      ; (2) Port (p)
806A:         	DIVSUP          equ     OTPORT+$02      ; (1) Division support routine
806B:         	DIV1            equ     DIVSUP+$01      ; (4) <- Values
806F:         	DIV2            equ     DIV1+$04        ; (4) <-   to
8073:         	DIV3            equ     DIV2+$04        ; (3) <-   be
8076:         	DIV4            equ     DIV3+$03        ; (2) <-inserted
8078:         	SEED            equ     DIV4+$02        ; (35) Random number seed  <-- starting address of a seed table
809B:         	LSTRND          equ     SEED+$23        ; (4) Last random number
809F:         	INPSUB          equ     LSTRND+$04      ; (1) #INP (x)" Routine
80A0:         	INPORT          equ     INPSUB+$01      ; (2) PORT (x)
80A2:         	LWIDTH          equ     INPORT+$02      ; (1) Terminal width
80A3:         	COMMAN          equ     LWIDTH+$01      ; (1) Width for commas
80A4:         	NULFLG          equ     COMMAN+$01      ; (1) Null after input byte flag
80A5:         	CTLOFG          equ     NULFLG+$01      ; (1) Control "O" flag
80A6:         	CHKSUM          equ     CTLOFG+$01      ; (2) Array load/save check sum
80A8:         	NMIFLG          equ     CHKSUM+$02      ; (1) Flag for NMI break routine
80A9:         	BRKFLG          equ     NMIFLG+$01      ; (1) Break flag
80AA:         	RINPUT          equ     BRKFLG+$01      ; (3) Input reflection
80AD:         	STRSPC          equ     RINPUT+$03      ; (2) Bottom of string space
80AF:         	LINEAT          equ     STRSPC+$02      ; (2) Current line number
80B1:         	HLPLN           equ     LINEAT+$02      ; (2) Current line with errors
80B3:         	FNKEYS          equ     HLPLN+$02       ; (128) text of FN keys
8133:         	BASTXT          equ     FNKEYS+$80      ; (3) Pointer to start of program   <-- actually this is the last value pre-filled by the firmware at startup
8136:         	BUFFER          equ     BASTXT+$03      ; (5) Input buffer
813B:         	STACK           equ     BUFFER+$05      ; (85) Initial stack
8190:         	CURPOS          equ     STACK+$55       ; (1) Character position on line
8191:         	LCRFLG          equ     CURPOS+$01      ; (1) Locate/Create flag
8192:         	TYPE            equ     LCRFLG+$01      ; (1) Data type flag
8193:         	DATFLG          equ     TYPE+$01        ; (1) Literal statement flag
8194:         	LSTRAM          equ     DATFLG+$01      ; (2) Last available RAM
8196:         	TMSTPT          equ     LSTRAM+$02      ; (2) Temporary string pointer
8198:         	TMSTPL          equ     TMSTPT+$02      ; (12) Temporary string pool
81A4:         	TMPSTR          equ     TMSTPL+$0C      ; (4) Temporary string
81A8:         	STRBOT          equ     TMPSTR+$04      ; (2) Bottom of string space
81AA:         	CUROPR          equ     STRBOT+$02      ; (2) Current operator in EVAL
81AC:         	LOOPST          equ     CUROPR+$02      ; (2) First statement of loop
81AE:         	DATLIN          equ     LOOPST+$02      ; (2) Line of current DATA item
81B0:         	FORFLG          equ     DATLIN+$02      ; (1) "FOR" loop flag
81B1:         	LSTBIN          equ     FORFLG+$01      ; (1) Last byte entered
81B2:         	READFG          equ     LSTBIN+$01      ; (1) Read/Input flag
81B3:         	BRKLIN          equ     READFG+$01      ; (2) Line of break
81B5:         	NXTOPR          equ     BRKLIN+$02      ; (2) Next operator in EVAL
81B7:         	ERRLIN          equ     NXTOPR+$02      ; (2) Line of error
81B9:         	CONTAD          equ     ERRLIN+$02      ; (2) Where to CONTinue
81BB:         	PROGND          equ     CONTAD+$02      ; (2) End of program
81BD:         	VAREND          equ     PROGND+$02      ; (2) End of variables
81BF:         	ARREND          equ     VAREND+$02      ; (2) End of arrays
81C1:         	NXTDAT          equ     ARREND+$02      ; (2) Next data item
81C3:         	FNRGNM          equ     NXTDAT+$02      ; (2) Name of FN argument
81C5:         	FNARG           equ     FNRGNM+$02      ; (4) FN argument value
81C9:         	FPREG           equ     FNARG+$04       ; (3) Floating point register
81CC:         	FPEXP           equ     FPREG+$03       ; (1) Floating point exponent
81CD:         	SGNRES          equ     FPEXP+$01       ; (1) Sign of result
81CE:         	TMRCNT          equ     SGNRES+$01      ; (4) TMR counter for 1/100 seconds
81D2:         	CTC0IV          equ     TMRCNT+$04      ; (3) CTC0 interrupt vector
81D5:         	CTC1IV          equ     CTC0IV+$03      ; (3) CTC1 interrupt vector
81D8:         	CTC2IV          equ     CTC1IV+$03      ; (3) CTC2 interrupt vector
81DB:         	CTC3IV          equ     CTC2IV+$03      ; (3) CTC3 interrupt vector
              	; - - - - - - - - - - - - - - - - - - -   VIDEO REGISTERS - FROM HERE...
81DE:         	SCR_SIZE_W      equ     CTC3IV+$03      ; (1) screen width (it can be either 40 chars or 32 chars/bytes)
81DF:         	SCR_SIZE_H      equ     SCR_SIZE_W+$01  ; (1) screen height (it can be 24/48/192: 24 for text, 48 for MC, 192 for graphics)
81E0:         	SCR_MODE        equ     SCR_SIZE_H+$01  ; (1) screen mode (0=text, 1=G1, 2=G2, 3=MC, 4=ExG2)
81E2:         	SCR_NAM_TB      equ     SCR_MODE+$02    ; (2) video name table address
81E4:         	SCR_CURS_X      equ     SCR_NAM_TB+$02  ; (1) cursor X
81E5:         	SCR_CURS_Y      equ     SCR_CURS_X+$01  ; (1) cursor Y
81E6:         	SCR_CUR_NX      equ     SCR_CURS_Y+$01  ; (1) new cursor X position
81E7:         	SCR_CUR_NY      equ     SCR_CUR_NX+$01  ; (1) new cursor Y position
81E8:         	SCR_ORG_CHR     equ     SCR_CUR_NY+$01  ; (1) original char positioned under the cursor
81E9:         	CRSR_STATE      equ     SCR_ORG_CHR+$01 ; (1) state of cursor (1=on, 0=off)
81EA:         	LSTCSRSTA       equ     CRSR_STATE+$01  ; (1) last cursor state
81EB:         	PRNTVIDEO       equ     LSTCSRSTA+$01   ; (1) print on video buffer (1=on / 0=off) set to off on graphic only modes
81EC:         	CHR4VID         equ     PRNTVIDEO+$01   ; (1) char for video buffer
81ED:         	FRGNDCLR        equ     CHR4VID+$01     ; (1) foreground color as set by SCREEN or COLOR commands
81EE:         	BKGNDCLR        equ     FRGNDCLR+$01    ; (1) background color as set by SCREEN or COLOR commands
81EF:         	TMPBFR1         equ     BKGNDCLR+$01    ; (2) word for general purposes use (temp. buffer for 1 or 2 bytes)
81F1:         	TMPBFR2         equ     TMPBFR1+$02     ; (2) word for general purposes use (temp. buffer for 1 or 2 bytes)
81F3:         	TMPBFR3         equ     TMPBFR2+$02     ; (2) word for general purposes use (temp. buffer for 1 or 2 bytes)
81F5:         	TMPBFR4         equ     TMPBFR3+$02     ; (2) word for general purposes use (temp. buffer for 1 or 2 bytes)
81F7:         	VIDEOBUFF       equ     TMPBFR4+$02     ; (40) buffer used for video scrolling and other purposes
821F:         	VIDTMP1         equ     VIDEOBUFF+$28   ; (2) temporary video word
8221:         	VIDTMP2         equ     VIDTMP1+$02     ; (2) temporary video word
              	; - - - - - - - - - - - - - - - - - - -   ...TO HERE. DO NOT ADD ANYTHING RELATED TO VPD OUT OF THIS RANGE,
              	                                        ; OTHERWISE YOU WILL HAVE TO CHECK THE POINTER IN "CLR_RAM_REG" FUNCTION
              	; - - - - - - - - - - - - - - - - - - -   SOUND & KEYBOARD REGISTERS - FROM HERE...
8223:         	CHASNDDTN       equ     VIDTMP2+$02     ; (2) sound Ch.A duration (1/100s)
8225:         	CHBSNDDTN       equ     CHASNDDTN+$02   ; (2) sound Ch.B duration (1/100s)
8227:         	CHCSNDDTN       equ     CHBSNDDTN+$02   ; (2) sound Ch.C duration (1/100s)
8229:         	KBDNPT          equ     CHCSNDDTN+$02   ; (1) temp cell used to flag if input comes from keyboard
822A:         	KBTMP           equ     KBDNPT+$01      ; (1) temp cell used by keyboard scanner
822B:         	TMPKEYBFR       equ     KBTMP+$01       ; (1) temp buffer for last key pressed
822C:         	LASTKEYPRSD     equ     TMPKEYBFR+$01   ; (1) last key code pressed
822D:         	CONTROLKEYS     equ     LASTKEYPRSD+$01 ; (1) flags for control keys (bit#0=SHIFT; bit#1=CTRL; bit#2=C=)
              	; - - - - - - - - - - - - - - - - - - -   ...TO HERE. DO NOT ADD ANYTHING RELATED TO PSG OUT OF THIS RANGE,
              	                                        ; OTHERWISE YOU WILL HAVE TO CHANGE THE POINTER IN "initPSG" FUNCTION
822E:         	SERIALS_EN      equ     CONTROLKEYS+$01 ; (1) serial ports status: bit 0 for Port1(A), bit 1 for Port2(B): 0=OFF, 1=ON
822F:         	SERABITS        equ     SERIALS_EN+$01  ; (1) serial port A data bits
8230:         	PBUFF           equ     SERABITS+$01    ; (13) Number print buffer
823D:         	MULVAL          equ     PBUFF+$0D       ; (3) Multiplier
8240:         	PROGST          equ     MULVAL+$03      ; (100) Start of program text area
82A4:         	STLOOK          equ     PROGST+$64      ; Start of memory test
              	
              	; BASIC ERROR CODE VALUES
              	; These values act as an offset to point to the error message into the error table
              	; must be incremented by 2 because they point to a word address jump
0000:         	NF              equ     $00             ; NEXT without FOR
0002:         	SN              equ     $02             ; Syntax error
0004:         	RG              equ     $04             ; RETURN without GOSUB
0006:         	OD              equ     $06             ; Out of DATA
0008:         	FC              equ     $08             ; Function call error
000A:         	OV              equ     $0A             ; Overflow
000C:         	OM              equ     $0C             ; Out of memory
000E:         	UL              equ     $0E             ; Undefined line number
0010:         	BS              equ     $10             ; Bad subscript
0012:         	DD              equ     $12             ; Re-Dimensioned array
0014:         	DZ              equ     $14             ; Division by zero (/0)
0016:         	ID              equ     $16             ; Illegal direct
0018:         	TM              equ     $18             ; Type mis-match
001A:         	OS              equ     $1A             ; Out of string space
001C:         	LS              equ     $1C             ; String too long
001E:         	ST              equ     $1E             ; String formula too complex
0020:         	CN              equ     $20             ; Can't continue
0022:         	UF              equ     $22             ; Undefined FN function
0024:         	MO              equ     $24             ; Missing operand
0026:         	HX              equ     $26             ; HEX error
0028:         	BN              equ     $28             ; BIN error
002A:         	GM              equ     $2A             ; No Graphics Mode
002C:         	SC              equ     $2C             ; Serial configuration
002E:         	SA              equ     $2E             ; Serial port already open
0030:         	HP              equ     $30             ; HELP call
              	
0ECC: C3D20E  	COLD:   jp      STARTB          ; Jump for cold start
0ECF: C36A0F  	WARM:   jp      WARMST          ; Jump for warm start
              	
0ED2: C3D90E  	STARTB: jp      CSTART          ; Jump to initialise
0ED5: F31A    	        defw    DEINT           ; Get integer -32768 to 32767
0ED7: 9C22    	        defw    ABPASS          ; Return integer in AB
0ED9: 215E80  	CSTART: ld      HL,WRKSPC       ; Start of workspace RAM
0EDC: F9      	        ld      SP,HL           ; Set up a temporary stack
0EDD: C3333C  	        jp      INITST          ; Go to initialise
              	
0EE0: 21D313  	INIT:   ld      HL,INITAB       ; Initialise workspace
0EE3: 01DA00  	        ld      BC,INITBE-INITAB+3; Bytes to copy
0EE6: 115E80  	        ld      DE,WRKSPC       ; Into workspace RAM
0EE9: EDB0    	        ldir                    ; Copy data
0EEB: EB      	        ex      DE,HL           ; Copy DE into HL
0EEC: F9      	        ld      SP,HL           ; Temporary stack
0EED: CD8416  	        call    CLREG           ; Clear registers and stack
0EF0: CDF61C  	        call    PRNTCRLF        ; Output CRLF
0EF3: 328F81  	        ld      (BUFFER+88+1),A ; Mark end of buffer
0EF6: 324082  	        ld      (PROGST),A      ; Initialise program area
0EF9: 1810    	        jr      MNOASK          ; usually, don't ask for memory top (only when there are errors)
0EFB: 21B40F  	MSIZE:  ld      HL,MEMMSG       ; Point to message
0EFE: CDBA23  	        call    PRS             ; Output "Memory size"
0F01: CDA116  	        call    PROMPT          ; Get input with '?'
0F04: CD3D1A  	        call    GETCHR          ; Get next character
0F07: B7      	        or      A               ; Set flags
0F08: C2200F  	        jp      NZ,TSTMEM       ; If number - Test if RAM there
0F0B: 21A482  	MNOASK: ld      HL,STLOOK       ; Point to start of RAM
0F0E: 23      	MLOOP:  inc     HL              ; Next byte
0F0F: 7C      	        ld      A,H             ; Above address FFFF ?
0F10: B5      	        or      L
0F11: CA320F  	        jp      Z,SETTOP        ; Yes - 64K RAM
0F14: 7E      	        ld      A,(HL)          ; Get contents
0F15: 47      	        ld      B,A             ; Save it
0F16: 2F      	        cpl                     ; Flip all bits
0F17: 77      	        ld      (HL),A          ; Put it back
0F18: BE      	        cp      (HL)            ; RAM there if same
0F19: 70      	        ld      (HL),B          ; Restore old contents
0F1A: CA0E0F  	        jp      Z,MLOOP         ; If RAM - test next byte
0F1D: C3320F  	        jp      SETTOP          ; Top of RAM found
              	
0F20: CD0D1B  	TSTMEM: call    ATOH            ; Get high memory into DE
0F23: B7      	        or      A               ; Set flags on last byte
0F24: C23815  	        jp      NZ,SNERR        ; ?SN Error if bad character
0F27: EB      	        ex      DE,HL           ; Address into HL
0F28: 2B      	        dec     HL              ; Back one byte
0F29: 3ED9    	        ld      A,%11011001     ; Test byte
0F2B: 46      	        ld      B,(HL)          ; Get old contents
0F2C: 77      	        ld      (HL),A          ; Load test byte
0F2D: BE      	        cp      (HL)            ; RAM there if same
0F2E: 70      	        ld      (HL),B          ; Restore old contents
0F2F: C2FB0E  	        jp      NZ,MSIZE        ; Ask again if no RAM
              	
0F32: 2B      	SETTOP: dec     HL              ; Back one byte
0F33: 11A382  	        ld      DE,STLOOK-1     ; See if enough RAM
0F36: CD1418  	        call    CPDEHL          ; Compare DE with HL
0F39: DAFB0E  	        jp      C,MSIZE         ; Ask again if not enough RAM
0F3C: 119CFF  	        ld      DE,0-100        ; 100 Bytes string space
0F3F: 229481  	        ld      (LSTRAM),HL     ; Save last available RAM
0F42: 19      	        add     HL,DE           ; Allocate string space
0F43: 22AD80  	        ld      (STRSPC),HL     ; Save string space
0F46: CD5F16  	        call    CLRPTR          ; Clear program area
0F49: 2AAD80  	        ld      HL,(STRSPC)     ; Get end of memory
0F4C: 11EFFF  	        ld      DE,0-17         ; Offset for free bytes
0F4F: 19      	        add     HL,DE           ; Adjust HL
0F50: 114082  	        ld      DE,PROGST       ; Start of program text
0F53: 7D      	        ld      A,L             ; Get LSB
0F54: 93      	        sub     E               ; Adjust it
0F55: 6F      	        ld      L,A             ; Re-save
0F56: 7C      	        ld      A,H             ; Get MSB
0F57: 9A      	        sbc     A,D             ; Adjust it
0F58: 67      	        ld      H,A             ; Re-save
0F59: E5      	        push    HL              ; Save bytes free
0F5A: 21830F  	        ld      HL,SIGNON       ; Sign-on message
0F5D: CDBA23  	        call    PRS             ; Output string
0F60: E1      	        pop     HL              ; Get bytes free back
0F61: CD522E  	        call    PRNTHL          ; Output amount of free memory
0F64: 21760F  	        ld      HL,BFREE        ; " Bytes free" message
0F67: CDBA23  	        call    PRS             ; Output string
              	
0F6A: 313B81  	WARMST: ld      SP,STACK        ; Temporary stack
0F6D: CD8416  	BRKRET: call    CLREG           ; Clear registers and stack
0F70: CD3608  	        call    CURSOR_ON       ; enable cursor
0F73: C39215  	        jp      PRNTOK          ; Go to get command line
              	
0F76: 20427974	BFREE:  defb    " Bytes free",CR,0
0F7A: 65732066	
0F7E: 7265650D	
0F82: 00      	
              	
0F83: 5A383020	SIGNON: defb    "Z80 BASIC Ver 4.8",CR
0F87: 42415349	
0F8B: 43205665	
0F8F: 7220342E	
0F93: 380D    	
0F95: 436F7079	        defb    "Copyright ",251," 1978"
0F99: 72696768	
0F9D: 7420FB20	
0FA1: 31393738	
0FA5: 20627920	        defb    " by Microsoft",CR,0
0FA9: 4D696372	
0FAD: 6F736F66	
0FB1: 740D00  	
              	
0FB4: 4D656D6F	MEMMSG: defb    "Memory top",0
0FB8: 72792074	
0FBC: 6F7000  	
              	
              	; The following list reports all the functions supported by the interpreter.
              	; To add a custom function, the user must first insert the reserved word here,
              	; then into the list of the reserved words below, and finally must increment the
              	; ZSGN token value and all the following ones after ZSGN by 1 for every added
              	; function.
              	
              	; FUNCTION ADDRESS TABLE (this is a sort of offset table)
              	; this list must be coherent with the tokens' functions list. This means that every
              	; entry here must have the corresponding entry in the tokens list.
0FBF: C72C    	FNCTAB: defw    SGN
0FC1: 6422    	        defw    TMR         ; added by Leonardo Miliani
0FC3: 8B2D    	        defw    INT
0FC5: DD2C    	        defw    ABS
0FC7: 6480    	        defw    USR
0FC9: 7A22    	        defw    FRE
0FCB: F526    	        defw    INP
0FCD: A822    	        defw    POS
0FCF: 512F    	        defw    SQR
0FD1: 3030    	        defw    RND
0FD3: 1B2B    	        defw    LOG
0FD5: 9F2F    	        defw    EXP
0FD7: A530    	        defw    COS
0FD9: AB30    	        defw    SIN
0FDB: 0C31    	        defw    TAN
0FDD: 2131    	        defw    ATN
0FDF: D127    	        defw    PEEK
0FE1: 8C31    	        defw    DEEK
0FE3: D827    	        defw    VPEEK       ; added by Leonardo Miliani
0FE5: A229    	        defw    VSTAT       ; added by Leonardo Miliani
0FE7: AD29    	        defw    SSTAT       ; added by Leonardo Miliani
0FE9: BF29    	        defw    INKEY       ; added by Leonardo Miliani
0FEB: E833    	        defw    POINT       ; added by Leonardo Miliani
0FED: 8C25    	        defw    INSTR       ; added by Leonardo Miliani
0FEF: 2C25    	        defw    LEN
0FF1: 4423    	        defw    STR
0FF3: BC26    	        defw    VAL
0FF5: 3B25    	        defw    ASC
0FF7: 4C25    	        defw    CHR
0FF9: 323B    	        defw    HEX         ; added by Grant Searle
0FFB: C33B    	        defw    BIN         ; added by Grant Searle
0FFD: 5C25    	        defw    LEFT
0FFF: 8226    	        defw    RIGHT
1001: 8C26    	        defw    MID
              	
              	; RESERVED WORD LIST
              	; Here are all the reserved words used by the interpreter
              	; To add custom functions/commands, the user must insert the keyword
              	; in this list, following the schematic
1003: C54E44  	WORDS:  defb    'E'+$80,"ND"            ; from here the list contains the COMMANDS
1006: C64F52  	        defb    'F'+$80,"OR"
1009: CE455854	        defb    'N'+$80,"EXT"
100D: C4415441	        defb    'D'+$80,"ATA"
1011: C94E5055	        defb    'I'+$80,"NPUT"
1015: 54      	
1016: C4494D  	        defb    'D'+$80,"IM"
1019: D2454144	        defb    'R'+$80,"EAD"
101D: CC4554  	        defb    'L'+$80,"ET"
1020: C74F544F	        defb    'G'+$80,"OTO"
1024: D2554E  	        defb    'R'+$80,"UN"
1027: C946    	        defb    'I'+$80,"F"
1029: D2455354	        defb    'R'+$80,"ESTORE"
102D: 4F5245  	
1030: C74F5355	        defb    'G'+$80,"OSUB"
1034: 42      	
1035: D2455455	        defb    'R'+$80,"ETURN"
1039: 524E    	
103B: D2454D  	        defb    'R'+$80,"EM"
103E: D3544F50	        defb    'S'+$80,"TOP"
1042: CF5554  	        defb    'O'+$80,"UT"
1045: CF4E    	        defb    'O'+$80,"N"
1047: CE554C4C	        defb    'N'+$80,"ULL"
104B: D7414954	        defb    'W'+$80,"AIT"
104F: C44546  	        defb    'D'+$80,"EF"
1052: D04F4B45	        defb    'P'+$80,"OKE"
1056: C44F4B45	        defb    'D'+$80,"OKE"
105A: D6504F4B	        defb    'V'+$80,"POKE"          ; added by Leonardo Miliani
105E: 45      	
105F: D3524547	        defb    'S'+$80,"REG"           ; added by Leonardo Miliani
1063: D6524547	        defb    'V'+$80,"REG"           ; added by Leonardo Miliani
1067: D3435245	        defb    'S'+$80,"CREEN"         ; changed by Leonardo Miliani
106B: 454E    	
106D: CC4F4341	        defb    'L'+$80,"OCATE"         ; added by Leonardo Miliani
1071: 5445    	
1073: D34F554E	        defb    'S'+$80,"OUND"          ; added by Leonardo Miliani
1077: 44      	
1078: D64F4C55	        defb    'V'+$80,"OLUME"         ; added by Leonardo Miliani
107C: 4D45    	
107E: D0415553	        defb    'P'+$80,"AUSE"          ; added by Leonardo Miliani
1082: 45      	
1083: C34F4C4F	        defb    'C'+$80,"OLOR"          ; added by Leonardo Miliani
1087: 52      	
1088: D04C4F54	        defb    'P'+$80,"LOT"           ; added by Leonardo Miliani
108C: C4524157	        defb    'D'+$80,"RAW"           ; added by Leonardo Miliani
1090: C3495243	        defb    'C'+$80,"IRCLE"         ; added by Leonardo Miliani
1094: 4C45    	
1096: D3455249	        defb    'S'+$80,"ERIAL"         ; added by Leonardo Miliani
109A: 414C    	
109C: C8454C50	        defb    'H'+$80,"ELP"           ; changed by Leonardo Miliani - was LINES
10A0: C34C53  	        defb    'C'+$80,"LS"            ; restored command
10A3: CB4559  	        defb    'K'+$80,"EY"            ; added by Leonardo Miliani
10A6: CE4D49  	        defb    'N'+$80,"MI"            ; added by Leonardo Miliani
10A9: C7505249	        defb    'G'+$80,"PRINT"         ; added by Leonardo Miliani
10AD: 4E54    	
10AF: D7494454	        defb    'W'+$80,"IDTH"
10B3: 48      	
10B4: D35953  	        defb    'S'+$80,"YS"            ; added by Leonardo Miliani
10B7: D2455345	        defb    'R'+$80,"ESET"          ; changed by Leonardo Miliani
10BB: 54      	
10BC: D052494E	        defb    'P'+$80,"RINT"
10C0: 54      	
10C1: C34F4E54	        defb    'C'+$80,"ONT"
10C5: CC495354	        defb    'L'+$80,"IST"
10C9: C34C4541	        defb    'C'+$80,"LEAR"
10CD: 52      	
10CE: C34C4F41	        defb    'C'+$80,"LOAD"
10D2: 44      	
10D3: C3534156	        defb    'C'+$80,"SAVE"
10D7: 45      	
10D8: CE4557  	        defb    'N'+$80,"EW"
10DB: D4414228	        defb    'T'+$80,"AB("
10DF: D44F    	        defb    'T'+$80,"O"
10E1: C64E    	        defb    'F'+$80,"N"
10E3: D3504328	        defb    'S'+$80,"PC("
10E7: D448454E	        defb    'T'+$80,"HEN"
10EB: CE4F54  	        defb    'N'+$80,"OT"
10EE: D3544550	        defb    'S'+$80,"TEP"
              	        ; from here: operators
10F2: AB      	        defb    '+'+$80
10F3: AD      	        defb    '-'+$80
10F4: AA      	        defb    '*'+$80
10F5: AF      	        defb    '/'+$80
10F6: A5      	        defb    '%'+$80
10F7: A3      	        defb    '#'+$80
10F8: DE      	        defb    '^'+$80
10F9: C14E44  	        defb    'A'+$80,"ND"
10FC: D84F52  	        defb    'X'+$80,"OR"
10FF: CF52    	        defb    'O'+$80,"R"
1101: BE      	        defb    '>'+$80
1102: BD      	        defb    '='+$80
1103: BC      	        defb    '<'+$80
              	
              	        ; from here there are the tokens' FUNCTIONS list
              	        ; this list must be coherent with the functions list above
1104: D3474E  	        defb    'S'+$80,"GN"
1107: D44D52  	        defb    'T'+$80,"MR"            ; added by Leonardo Miliani
110A: C94E54  	        defb    'I'+$80,"NT"
110D: C14253  	        defb    'A'+$80,"BS"
1110: D55352  	        defb    'U'+$80,"SR"
1113: C65245  	        defb    'F'+$80,"RE"
1116: C94E50  	        defb    'I'+$80,"NP"
1119: D04F53  	        defb    'P'+$80,"OS"
111C: D35152  	        defb    'S'+$80,"QR"
111F: D24E44  	        defb    'R'+$80,"ND"
1122: CC4F47  	        defb    'L'+$80,"OG"
1125: C55850  	        defb    'E'+$80,"XP"
1128: C34F53  	        defb    'C'+$80,"OS"
112B: D3494E  	        defb    'S'+$80,"IN"
112E: D4414E  	        defb    'T'+$80,"AN"
1131: C1544E  	        defb    'A'+$80,"TN"
1134: D045454B	        defb    'P'+$80,"EEK"
1138: C445454B	        defb    'D'+$80,"EEK"
113C: D6504545	        defb    'V'+$80,"PEEK"          ; added by Leonardo Miliani
1140: 4B      	
1141: D6535441	        defb    'V'+$80,"STAT"          ; added by Leonardo Miliani
1145: 54      	
1146: D3535441	        defb    'S'+$80,"STAT"          ; added by Leonardo Miliani
114A: 54      	
114B: C94E4B45	        defb    'I'+$80,"NKEY"          ; added by Leonardo Miliani
114F: 59      	
1150: D04F494E	        defb    'P'+$80,"OINT"          ; added by Leonardo Miliani
1154: 54      	
1155: C94E5354	        defb    'I'+$80,"NSTR"          ; added by Leonardo Miliani
1159: 52      	
115A: CC454E  	        defb    'L'+$80,"EN"
115D: D3545224	        defb    'S'+$80,"TR$"
1161: D6414C  	        defb    'V'+$80,"AL"
1164: C15343  	        defb    'A'+$80,"SC"
1167: C3485224	        defb    'C'+$80,"HR$"
116B: C8455824	        defb    'H'+$80,"EX$"           ; added by Grant Searle
116F: C2494E24	        defb    'B'+$80,"IN$"           ; added by Grant Searle
1173: CC454654	        defb    'L'+$80,"EFT$"
1177: 24      	
1178: D2494748	        defb    'R'+$80,"IGHT$"
117C: 5424    	
117E: CD494424	        defb    'M'+$80,"ID$"
1182: 80      	        defb    $80                     ; End-of-list marker
              	
              	; KEYWORD ADDRESS TABLE
              	; this list must be coherent with the commands'
              	; tokens list above
1183: 871A    	WORDTB: defw    PEND
1185: 8419    	        defw    FOR
1187: 671E    	        defw    NEXT
1189: E01B    	        defw    DATA
118B: 6C1D    	        defw    INPUT
118D: BC20    	        defw    DIM
118F: 9E1D    	        defw    READ
1191: F71B    	        defw    LET
1193: 9D1B    	        defw    GOTO
1195: 781B    	        defw    RUN
1197: 6F1C    	        defw    IF
1199: 4D1A    	        defw    RESTOR
119B: 8C1B    	        defw    GOSUB
119D: BB1B    	        defw    RETURN
119F: E21B    	        defw    REM
11A1: 851A    	        defw    STOP
11A3: 0127    	        defw    POUT
11A5: 511C    	        defw    ON
11A7: E21B    	        defw    REM         ; removed - was NULL
11A9: 0727    	        defw    WAIT
11AB: B022    	        defw    DEF
11AD: FB27    	        defw    POKE
11AF: 9731    	        defw    DOKE
11B1: 0028    	        defw    VPOKE       ; added by Leonardo Miliani
11B3: 3D28    	        defw    SREG        ; added by Leonardo Miliani
11B5: 8629    	        defw    VREG        ; added by Leonardo Miliani
11B7: CD31    	        defw    SCREEN      ; mod function: now it sets up a graphics mode (Leonardo Miliani)
11B9: 0B28    	        defw    LOCATE      ; added by Leonardo Miliani
11BB: 9528    	        defw    SOUND       ; added by Leonardo Miliani
11BD: 5C28    	        defw    VOLUME      ; added by Leonardo Miliani
11BF: AE31    	        defw    PAUSE       ; added by Leonardo Miliani
11C1: 4832    	        defw    COLOR       ; added by Leonardo Miliani
11C3: 2634    	        defw    PLOT        ; added by Leonardo Miliani
11C5: A534    	        defw    DRAW        ; added by Leonardo Miliani
11C7: CC35    	        defw    CIRCLE      ; added by Leonardo Miliani
11C9: D137    	        defw    SERIAL      ; added by Leonardo Miliani
11CB: CC39    	        defw    HELP        ; changed by Leonardo Miliani - was LINES
11CD: 7031    	        defw    CLS
11CF: E739    	        defw    KEY         ; added by Leonardo Miliani
11D1: 4927    	        defw    NMI         ; added by Leonardo Miliani
11D3: 0233    	        defw    GPRINT      ; added by Leonardo Miliani
11D5: 8431    	        defw    WIDTH
11D7: A327    	        defw    SYS
11D9: 283C    	        defw    RESET       ; new behaviour: now it resets the system
11DB: 931C    	        defw    PRINT
11DD: B91A    	        defw    CONT
11DF: 7918    	        defw    LIST
11E1: 321B    	        defw    CLEAR
11E3: E21B    	        defw    REM         ; not implemented (was CLOAD)
11E5: E21B    	        defw    REM         ; not implemented (was CSAVE)
11E7: 5E16    	        defw    NEW
              	
              	; RESERVED WORD TOKEN VALUES
              	; if you add a function or command you must increment by 1
              	; the values below. Pay attention that you must increment only the
              	; values AFTER the position where you entered the function/command word
              	; in the "Reserver word list" above. I.E.: VPOKE has been added between
              	; DOKE and SCREEN, and since REM is the reserved work listed below
              	; that is before the point where VPOKE has been entered, every entry
              	; after REM has been incremented.
              	; Another example: when TMR has been added, since it's a function, every
              	; entry after & included ZSGN must be checked (read below)
              	
0080:         	ZEND    equ     $80             ; END        <-- from here, there are the commands
0081:         	ZFOR    equ     $81             ; FOR
0083:         	ZDATA   equ     $83             ; DATA
0088:         	ZGOTO   equ     $88             ; GOTO
008C:         	ZGOSUB  equ     $8C             ; GOSUB
008E:         	ZREM    equ     $8E             ; REM
00AC:         	ZPRINT  equ     $AC             ; PRINT
00B2:         	ZNEW    equ     $B2             ; NEW
              	
00B3:         	ZTAB    equ     $B3             ; TAB
00B4:         	ZTO     equ     $B4             ; TO
00B5:         	ZFN     equ     $B5             ; FN
00B6:         	ZSPC    equ     $B6             ; SPC
00B7:         	ZTHEN   equ     $B7             ; THEN
00B8:         	ZNOT    equ     $B8             ; NOT
00B9:         	ZSTEP   equ     $B9             ; STEP
              	
00BA:         	ZPLUS   equ     $BA             ; +         <-- from here, there are the math operators
00BB:         	ZMINUS  equ     $BB             ; -
00BC:         	ZTIMES  equ     $BC             ; *
00BD:         	ZDIV    equ     $BD             ; /
00BE:         	ZMOD    equ     $BE             ; %
00BF:         	ZDINT   equ     $BF             ; #
00C3:         	ZOR     equ     $C3             ; OR
00C4:         	ZGTR    equ     $C4             ; >
00C5:         	ZEQUAL  equ     $C5             ; M
00C6:         	ZLTH    equ     $C6             ; <
              	
00C7:         	ZSGN    equ     $C7             ; SGN       <-- from here, there are the functions
00DD:         	ZPOINT  equ     $DD             ; ZPOINT    <-- if the user enters a custom function, between
              	                                ;               SGN and POINT, he/she must increment this pointer by 1
00DE:         	ZINSTR  equ     $DE             ; ZINSTR    <-- same here
00E6:         	ZLEFT   equ     $E6             ; LEFT$     <-- if the user enters a custom function anywhere,
              	                                ;               he/she must increment this pointer by 1
              	
              	; ARITHMETIC PRECEDENCE TABLE
              	; in the formulas below, <last> is a number stored into the stack that must be retrieved
              	; with POP BC, POP DE; FPREG is a f.p. number store into the RAM register FPREG
11E9: 79      	PRITAB: defb    $79             ; Precedence value
11EA: 392E    	        defw    PADD            ; FPREG = <last> + FPREG
              	
11EC: 79      	        defb    $79             ; Precedence value
11ED: 1C2A    	        defw    PSUB            ; FPREG = <last> - FPREG
              	
11EF: 7C      	        defb    $7C             ; Precedence value
11F0: 5A2B    	        defw    MULT            ; PPREG = <last> * FPREG
              	
11F2: 7C      	        defb    $7C             ; Precedence value
11F3: 0C2C    	        defw    DIV             ; FPREG = <last> / FPREG
              	
11F5: 7C      	        defb    $7C             ; Precedence value
11F6: B72B    	        defw    MOD             ; FPREG = INT(<last>)-(INT(FPREG)*INT(<last>/FPREG))
              	
11F8: 7C      	        defb    $7C             ; precedence value
11F9: AF2B    	        defw    DINT            ; FPREG = INT(<last> / FPREG )
              	
11FB: 7F      	        defb    $7F             ; Precedence value
11FC: 5A2F    	        defw    POWER           ; FPREG = <last> ^ FPREG
              	
11FE: 50      	        defb    $50             ; Precedence value
11FF: 0520    	        defw    PAND            ; FPREG = <last> AND FPREG
              	
1201: 4A      	        defb    $4A             ; Precedence value
1202: 0D20    	        defw    PXOR            ; FPREG = <last> XOR FPREG
              	
1204: 46      	        defb    $46             ; Precedence value
1205: 0820    	        defw    POR             ; FPREG = <last> OR FPREG
              	
              	; BASIC ERROR CODE LIST
              	
1207:         	ERRORS  equ $
1207: 4E455854	NFMSG:  defb    "NEXT Without FOR",0
120B: 20576974	
120F: 686F7574	
1213: 20464F52	
1217: 00      	
1218: 53796E74	SNMSG:  defb    "Syntax",0
121C: 617800  	
121F: 52455455	RGMSG:  defb    "RETURN without GOSUB",0
1223: 524E2077	
1227: 6974686F	
122B: 75742047	
122F: 4F535542	
1233: 00      	
1234: 4F757420	ODMSG:  defb    "Out of DATA",0
1238: 6F662044	
123C: 41544100	
1240: 496C6C65	FCMSG:  defb    "Illegal Function Call",0
1244: 67616C20	
1248: 46756E63	
124C: 74696F6E	
1250: 2043616C	
1254: 6C00    	
1256: 4F766572	OVMSG:  defb    "Overflow",0
125A: 666C6F77	
125E: 00      	
125F: 4F757420	OMMSG:  defb    "Out of Memory",0
1263: 6F66204D	
1267: 656D6F72	
126B: 7900    	
126D: 556E6465	ULMSG:  defb    "Undefined Line",0
1271: 66696E65	
1275: 64204C69	
1279: 6E6500  	
127C: 42616420	BSMSG:  defb    "Bad Subscript",0
1280: 53756273	
1284: 63726970	
1288: 7400    	
128A: 52652D44	DDMSG:  defb    "Re-Dimensioned Array",0
128E: 696D656E	
1292: 73696F6E	
1296: 65642041	
129A: 72726179	
129E: 00      	
129F: 44697669	DZMSG:  defb    "Division by Zero",0
12A3: 73696F6E	
12A7: 20627920	
12AB: 5A65726F	
12AF: 00      	
12B0: 496C6C65	IDMSG:  defb    "Illegal Direct",0
12B4: 67616C20	
12B8: 44697265	
12BC: 637400  	
12BF: 54797065	TMMSG:  defb    "Type Mis-match",0
12C3: 204D6973	
12C7: 2D6D6174	
12CB: 636800  	
12CE: 4F757420	OSMSG:  defb    "Out of String Space",0
12D2: 6F662053	
12D6: 7472696E	
12DA: 67205370	
12DE: 61636500	
12E2: 53747269	LSMSG:  defb    "String Too Long",0
12E6: 6E672054	
12EA: 6F6F204C	
12EE: 6F6E6700	
12F2: 53747269	STMSG:  defb    "String Formula Too Complex",0
12F6: 6E672046	
12FA: 6F726D75	
12FE: 6C612054	
1302: 6F6F2043	
1306: 6F6D706C	
130A: 657800  	
130D: 43616E27	CNMSG:  defb    "Can't Continue",0
1311: 7420436F	
1315: 6E74696E	
1319: 756500  	
131C: 556E6465	UFMSG:  defb    "Undefined FN Function",0
1320: 66696E65	
1324: 6420464E	
1328: 2046756E	
132C: 6374696F	
1330: 6E00    	
1332: 4D697373	MOMSG:  defb    "Missing Operand",0
1336: 696E6720	
133A: 4F706572	
133E: 616E6400	
1342: 48455820	HXMSG:  defb    "HEX Format",0
1346: 466F726D	
134A: 617400  	
134D: 42494E20	BNMSG:  defb    "BIN Format",0
1351: 466F726D	
1355: 617400  	
1358: 4E6F2047	GMMSG:  defb    "No Graphics Mode",0
135C: 72617068	
1360: 69637320	
1364: 4D6F6465	
1368: 00      	
1369: 53657269	SCMSG:  defb    "Serial Configuration",0
136D: 616C2043	
1371: 6F6E6669	
1375: 67757261	
1379: 74696F6E	
137D: 00      	
137E: 53657269	SAMSG:  defb    "Serial Port Already Open",0
1382: 616C2050	
1386: 6F727420	
138A: 416C7265	
138E: 61647920	
1392: 4F70656E	
1396: 00      	
1397: 48454C50	HPMSG:  defb    "HELP Call",0
139B: 2043616C	
139F: 6C00    	
              	
13A1:         	ERRTBL  equ $
13A1: 0712    	NFPTR   defw    NFMSG
13A3: 1812    	SNPTR   defw    SNMSG
13A5: 1F12    	RGPTR   defw    RGMSG
13A7: 3412    	ODPTR   defw    ODMSG
13A9: 4012    	FCPTR   defw    FCMSG
13AB: 5612    	OVPTR   defw    OVMSG
13AD: 5F12    	OMPTR   defw    OMMSG
13AF: 6D12    	ULPTR   defw    ULMSG
13B1: 7C12    	BSPTR   defw    BSMSG
13B3: 8A12    	DDPTR   defw    DDMSG
13B5: 9F12    	DZPTR   defw    DZMSG
13B7: B012    	IDPTR   defw    IDMSG
13B9: BF12    	TMPTR   defw    TMMSG
13BB: CE12    	OSPTR   defw    OSMSG
13BD: E212    	LSPTR   defw    LSMSG
13BF: F212    	STPTR   defw    STMSG
13C1: 0D13    	CNPTR   defw    CNMSG
13C3: 1C13    	UFPTR   defw    UFMSG
13C5: 3213    	MOPTR   defw    MOMSG
13C7: 4213    	HXPTR   defw    HXMSG
13C9: 4D13    	BNPTR   defw    BNMSG
13CB: 5813    	GMPRT   defw    GMMSG
13CD: 6913    	SCPTR   defw    SCMSG
13CF: 7E13    	SAPTR   defw    SAMSG
13D1: 9713    	HPPTR   defw    HPMSG
              	
              	; INITIALISATION TABLE -------------------------------------------------------
              	; these values are copied into RAM at startup
13D3: C36A0F  	INITAB: jp      WARMST          ; Warm start jump
13D6: ED4500  	        defb    $ED,$45,$00     ; RETN + NOP for default NMI service routine
13D9: C3081B  	        jp      FCERR           ; "USR (X)" jump (Set to Error)
13DC: D300    	        out     (0),A           ; "out p,n" skeleton
13DE: C9      	        ret
13DF: D600    	        sub     $00             ; Division support routine
13E1: 6F      	        ld      L,A
13E2: 7C      	        ld      A,H
13E3: DE00    	        sbc     A,$00
13E5: 67      	        ld      H,A
13E6: 78      	        ld      A,B
13E7: DE00    	        sbc     A,$00
13E9: 47      	        ld      B,A
13EA: 3E00    	        ld      A,$00
13EC: C9      	        ret
13ED: 000000  	        defb    $00,$00,$00     ; Random number seed table used by RND
13F0: 354ACA99	        defb    $35,$4A,$CA,$99 ;-2.65145E+07
13F4: 391C7698	        defb    $39,$1C,$76,$98 ; 1.61291E+07
13F8: 2295B398	        defb    $22,$95,$B3,$98 ;-1.17691E+07
13FC: 0ADD4798	        defb    $0A,$DD,$47,$98 ; 1.30983E+07
1400: 53D19999	        defb    $53,$D1,$99,$99 ;-2-01612E+07
1404: 0A1A9F98	        defb    $0A,$1A,$9F,$98 ;-1.04269E+07
1408: 65BCCD98	        defb    $65,$BC,$CD,$98 ;-1.34831E+07
140C: D6773E98	        defb    $D6,$77,$3E,$98 ; 1.24825E+07
1410: 52C74F80	        defb    $52,$C7,$4F,$80 ; Last random number
1414: DB00    	        in      A,($00)         ; INP (x) skeleton
1416: C9      	        ret
1417: FF      	        defb    $FF             ; Terminal width (255 = no auto CRLF)
1418: 1C      	        defb    $1C             ; Width for commas (3 columns)
1419: 00      	        defb    $00             ; No nulls after input bytes
141A: 00      	        defb    $00             ; Output enabled (^O off)
141B: 0000    	        defw    $00             ; Array load/save check sum
141D: 00      	        defb    $00             ; Break not by NMI
141E: 00      	        defb    $00             ; Break flag
141F: C39A17  	        jp      TTYLIN          ; Input reflection (set to TTY)
1422: A482    	        defw    STLOOK          ; Temp string space
1424: FEFF    	        defw    -2              ; Current line number (cold)
1426: FFFF    	        defw    -1              ; Current line with errors (no errors)
1428: 4C495354	DEFFNKS:defm    "LIST",13,0,0,0,0,0,0,0,0,0,0,0     ; KEY 1
142C: 0D000000	
1430: 00000000	
1434: 00000000	
1438: 52554E0D	        defm    "RUN",13,0,0,0,0,0,0,0,0,0,0,0,0    ; KEY 2
143C: 00000000	
1440: 00...   	
1448: 53435245	        defm    "SCREEN1",13,0,0,0,0,0,0,0,0        ; KEY 3
144C: 454E310D	
1450: 00000000	
1454: 00000000	
1458: 434F4C4F	        defm    "COLOR1,15,5",13,0,0,0,0            ; KEY 4
145C: 52312C31	
1460: 352C350D	
1464: 00000000	
1468: 53455249	        defm    "SERIAL1,38400",13,0,0              ; KEY 5
146C: 414C312C	
1470: 33383430	
1474: 300D0000	
1478: 53435245	        defm    "SCREEN2",13,0,0,0,0,0,0,0,0        ; KEY 6
147C: 454E320D	
1480: 00000000	
1484: 00000000	
1488: 434F4E54	        defm    "CONT",13,0,0,0,0,0,0,0,0,0,0,0     ; KEY 7
148C: 0D000000	
1490: 00000000	
1494: 00000000	
1498: 48454C50	        defm    "HELP",13,0,0,0,0,0,0,0,0,0,0,0     ; KEY 8 (HELP KEY)
149C: 0D000000	
14A0: 00000000	
14A4: 00000000	
14A8: 4182    	        defw    PROGST+1        ; Start of program text
14AA:         	INITBE:
              	
              	; END OF INITIALISATION TABLE ---------------------------------------------------
              	
14AA: 20457272	ERRMSG: defb    " Error",0
14AE: 6F7200  	
14B1: 20696E20	INMSG:  defb    " in ",0
14B5: 00      	
14B5:         	ZERBYT  equ     $-1             ; A zero byte
14B6: 4F6B0D00	OKMSG:  defb    "Ok",CR,0,0
14BA: 00      	
14BB: 42726561	BRKMSG: defb    "Break",0
14BF: 6B00    	
              	
14C1: 210400  	BAKSTK: ld      HL,$04          ; Look for "FOR" block with
14C4: 39      	        add     HL,SP           ; same index as specified
14C5: 7E      	LOKFOR: ld      A,(HL)          ; Get block ID
14C6: 23      	        inc     HL              ; Point to index address
14C7: FE81    	        cp      ZFOR            ; Is it a "FOR" token
14C9: C0      	        ret     NZ              ; No - exit
14CA: 4E      	        ld      C,(HL)          ; BC = Address of "FOR" index
14CB: 23      	        inc     HL
14CC: 46      	        ld      B,(HL)
14CD: 23      	        inc     HL              ; Point to sign of STEP
14CE: E5      	        push    HL              ; Save pointer to sign
14CF: 69      	        ld      L,C             ; HL = address of "FOR" index
14D0: 60      	        ld      H,B
14D1: 7A      	        ld      A,D             ; See if an index was specified
14D2: B3      	        or      E               ; DE = 0 if no index specified
14D3: EB      	        ex      DE,HL           ; Specified index into HL
14D4: CADB14  	        jp      Z,INDFND        ; Skip if no index given
14D7: EB      	        ex      DE,HL           ; Index back into DE
14D8: CD1418  	        call    CPDEHL          ; Compare index with one given
14DB: 010D00  	INDFND: ld      BC,16-3         ; Offset to next block
14DE: E1      	        pop     HL              ; Restore pointer to sign
14DF: C8      	        ret     Z               ; Return if block found
14E0: 09      	        add     HL,BC           ; Point to next block
14E1: C3C514  	        jp      LOKFOR          ; Keep on looking
              	
14E4: CDFE14  	MOVUP:  call    ENFMEM          ; See if enough memory
14E7: C5      	MOVSTR: push    BC              ; Save end of source
14E8: E3      	        ex      (SP),HL         ; Swap source and dest" end
14E9: C1      	        pop     BC              ; Get end of destination
14EA: CD1418  	MOVLP:  call    CPDEHL          ; See if list moved
14ED: 7E      	        ld      A,(HL)          ; Get byte
14EE: 02      	        ld      (BC),A          ; Move it
14EF: C8      	        ret     Z               ; Exit if all done
14F0: 0B      	        dec     BC              ; Next byte to move to
14F1: 2B      	        dec     HL              ; Next byte to move
14F2: C3EA14  	        jp      MOVLP           ; Loop until all bytes moved
              	
14F5: E5      	CHKSTK: push    HL              ; Save code string address
14F6: 2ABF81  	        ld      HL,(ARREND)     ; Lowest free memory
14F9: 0600    	        ld      B,$00           ; BC = Number of levels to test
14FB: 09      	        add     HL,BC           ; 2 Bytes for each level
14FC: 09      	        add     HL,BC
14FD: 3E      	        defb    $3E             ; Skip "push HL"
14FE: E5      	ENFMEM: push    HL              ; Save code string address
14FF: 3ED0    	        ld      A,$D0           ; LOW -48 ; 48 Bytes minimum RAM
1501: 95      	        sub     L
1502: 6F      	        ld      L,A
1503: 3EFF    	        ld      A,$FF           ; HIGH (-48) ; 48 Bytes minimum RAM
1505: 9C      	        sbc     A,H
1506: DA0D15  	        jp      C,OMERR         ; Not enough - ?OM Error
1509: 67      	        ld      H,A
150A: 39      	        add     HL,SP           ; Test if stack is overflowed
150B: E1      	        pop     HL              ; Restore code string address
150C: D8      	        ret     C               ; Return if enough memory
150D: 1E0C    	OMERR:  ld      E,OM            ; ?OM Error
150F: C34C15  	        jp      ERROR
              	
              	
              	; if in graphics mode, return to text (called by "NOLIN" and "ERROR")
1512: F5      	EXITGM: push    AF              ; store AF
1513: 3AE081  	        ld      A,(SCR_MODE)    ; check screen mode
1516: FE02    	        cp      $02             ; G2?
1518: CA1F15  	        jp      Z,LDG1          ; yes, back to G1
151B: FE03    	        cp      $03             ; G3?
151D: 2011    	        jr      NZ,LDG1ND       ; no, so return
151F: E5      	LDG1:   push    HL              ; store HL
1520: D5      	        push    DE              ; store DE
1521: 110100  	        ld      DE,$0001        ; sprites set to defaults, G1 mode
1524: F3      	        di                      ; disable INTs
1525: CD7E03  	        call    initVDP         ; initialize VDP with mode pointed by E
1528: FB      	        ei                      ; re-enable INTs
1529: 3E01    	        ld      A,$01           ; activate the...
152B: 32EB81  	        ld      (PRNTVIDEO),A   ; ...video buffer...
152E: D1      	        pop     DE              ; retrieve DE
152F: E1      	        pop     HL              ; retrieve HL
1530: F1      	LDG1ND: pop     AF              ; retrieve AF
1531: C9      	        ret                     ; return to caller
              	
              	
1532: 2AAE81  	DATSNR: ld      HL,(DATLIN)     ; Get line of current DATA item
1535: 22AF80  	        ld      (LINEAT),HL     ; Save as current line
1538: 1E02    	SNERR:  ld      E,SN            ; ?SN Error
153A: 01      	        defb    $01             ; Skip "ld E,DZ"
153B: 1E14    	DZERR:  ld      E,DZ            ; ?/0 Error
153D: 01      	        defb    $01             ; Skip "ld E,NF"
153E: 1E00    	NFERR:  ld      E,NF            ; ?NF Error
1540: 01      	        defb    $01             ; Skip "ld E,DD"
1541: 1E12    	DDERR:  ld      E,DD            ; ?DD Error
1543: 01      	        defb    $01             ; Skip "ld E,UF"
1544: 1E22    	UFERR:  ld      E,UF            ; ?UF Error
1546: 01      	        defb    $01             ; Skip "ld E,OV
1547: 1E0A    	OVERR:  ld      E,OV            ; ?OV Error
1549: 01      	        defb    $01             ; Skip "ld E,TM"
154A: 1E18    	TMERR:  ld      E,TM            ; ?TM Error
              	
154C: CD8416  	ERROR:  call    CLREG           ; Clear registers and stack
154F: CD1215  	        call    EXITGM          ; exit from graphic modes
1552: 32A580  	        ld      (CTLOFG),A      ; Enable output (A is 0)
1555: CD3608  	        call    CURSOR_ON       ; enable cursor
1558: CDE41C  	        call    STTLIN          ; Start new line
155B: 21A113  	        ld      HL,ERRTBL       ; Point to error codes
155E: 57      	        ld      D,A             ; D = 0 (A is 0)
155F: 3E3F    	        ld      A,'?'
1561: CD2518  	        call    OUTC            ; Output '?'
1564: 19      	        add     HL,DE           ; Offset to correct error code
1565: 5E      	        ld      E,(HL)          ; load pointer to error message
1566: 23      	        inc     HL              ; by loading LSB,
1567: 56      	        ld      D,(HL)          ; then MSB
1568: 626B    	        ld      HL,DE           ; load pointer to HL
156A: CDBA23  	        call    PRS             ; Output error message
156D: 21AA14  	        ld      HL,ERRMSG       ; "Error" message
1570: CDBA23  	ERRIN:  call    PRS             ; Output message
1573: 2AAF80  	        ld      HL,(LINEAT)     ; Get line of error
1576: 11FEFF  	        ld      DE,-2           ; Cold start error if -2
1579: CD1418  	        call    CPDEHL          ; See if cold start error
157C: CAD90E  	        jp      Z,CSTART        ; Cold start error - Restart
157F: 7C      	        ld      A,H             ; Was it a direct error?
1580: A5      	        and     L               ; Line = -1 if direct error
1581: 3C      	        inc     A
1582: CA8D15  	        jp      Z,PTLN          ; Yes, jump over
1585: E5      	        push    HL              ; indirect mode - store HL
1586: 2AAF80  	        ld      HL,(LINEAT)     ; copy current line number
1589: 22B180  	        ld      (HLPLN),HL      ; save in HELP line register
158C: E1      	        pop     HL              ; retrieve HL
158D: C44A2E  	PTLN:   call    NZ,LINEIN       ; No - output line of error
              	
1590: 3E      	        defb    $3E             ; Skip "pop BC"
1591: C1      	POPNOK: pop     BC              ; Drop address in input buffer
              	
              	; run into direct mode: print OK and get command
1592: AF      	PRNTOK: xor     A               ; Output "Ok" and get command
1593: 32A580  	        ld      (CTLOFG),A      ; Enable output
1596: CDE41C  	        call    STTLIN          ; Start new line
1599: 21B614  	        ld      HL,OKMSG        ; "Ok" message
159C: CDBA23  	        call    PRS             ; Output "Ok"
159F: CD3608  	GETCMD: call    CURSOR_ON       ; enable cursor
15A2: 21FFFF  	        ld      HL,-1           ; Flag direct mode
15A5: 22AF80  	        ld      (LINEAT),HL     ; Save as current line
15A8: CD9A17  	        call    GETLIN          ; Get an input line
15AB: DA9F15  	        jp      C,GETCMD        ; Get line again if break
15AE: CD3D1A  	        call    GETCHR          ; Get first character
15B1: 17      	        rla                     ; 8th bit is copied into carry and original carry is copied into bit 0)
15B2: DA3815  	        jp      C,SNERR         ; if char >=128 (8th bit set) then raise an error
15B5: 1F      	        rra                     ; recover original char and Carry
15B6: 3C      	        inc     A               ; Test if end of line
15B7: 3D      	        dec     A               ; Without affecting Carry
15B8: CA9F15  	        jp      Z,GETCMD        ; Nothing entered - Get another
15BB: F5      	        push    AF              ; Save Carry status
15BC: CD4C08  	        call    CURSOR_OFF      ; cursor disabled
15BF: CD0D1B  	        call    ATOH            ; Get line number into DE
15C2: D5      	        push    DE              ; Save line number
15C3: CDB116  	        call    CRUNCH          ; Tokenise rest of line
15C6: 47      	        ld      B,A             ; Length of tokenised line
15C7: D1      	        pop     DE              ; Restore line number
15C8: F1      	        pop     AF              ; Restore Carry
15C9: D21D1A  	        jp      NC,EXCUTE       ; No line number - Direct mode
15CC: D5      	        push    DE              ; Save line number
15CD: C5      	        push    BC              ; Save length of tokenised line
15CE: AF      	        xor     A
15CF: 32B181  	        ld      (LSTBIN),A      ; Clear last byte input
15D2: CD3D1A  	        call    GETCHR          ; Get next character
15D5: B7      	        or      A               ; Set flags
15D6: F5      	        push    AF              ; And save them
15D7: CD3E16  	        call    SRCHLN          ; Search for line number in DE
15DA: DAE315  	        jp      C,LINFND        ; Jump if line found
15DD: F1      	        pop     AF              ; Get status
15DE: F5      	        push    AF              ; And re-save
15DF: CAB61B  	        jp      Z,ULERR         ; Nothing after number - Error
15E2: B7      	        or      A               ; Clear Carry
15E3: C5      	LINFND: push    BC              ; Save address of line in prog
15E4: D2FA15  	        jp      NC,INEWLN       ; Line not found - Insert new
15E7: EB      	        ex      DE,HL           ; Next line address in DE
15E8: 2ABB81  	        ld      HL,(PROGND)     ; End of program
15EB: 1A      	SFTPRG: ld      A,(DE)          ; Shift rest of program down
15EC: 02      	        ld      (BC),A
15ED: 03      	        inc     BC              ; Next destination
15EE: 13      	        inc     DE              ; Next source
15EF: CD1418  	        call    CPDEHL          ; All done?
15F2: C2EB15  	        jp      NZ,SFTPRG       ; More to do
15F5: 60      	        ld      H,B             ; HL - New end of program
15F6: 69      	        ld      L,C
15F7: 22BB81  	        ld      (PROGND),HL     ; Update end of program
              	
15FA: D1      	INEWLN: pop     DE              ; Get address of line,
15FB: F1      	        pop     AF              ; Get status
15FC: CA2116  	        jp      Z,SETPTR        ; No text - Set up pointers
15FF: 2ABB81  	        ld      HL,(PROGND)     ; Get end of program
1602: E3      	        ex      (SP),HL         ; Get length of input line
1603: C1      	        pop     BC              ; End of program to BC
1604: 09      	        add     HL,BC           ; Find new end
1605: E5      	        push    HL              ; Save new end
1606: CDE414  	        call    MOVUP           ; Make space for line
1609: E1      	        pop     HL              ; Restore new end
160A: 22BB81  	        ld      (PROGND),HL     ; Update end of program pointer
160D: EB      	        ex      DE,HL           ; Get line to move up in HL
160E: 74      	        ld      (HL),H          ; Save MSB
160F: D1      	        pop     DE              ; Get new line number
1610: 23      	        inc     HL              ; Skip pointer
1611: 23      	        inc     HL
1612: 73      	        ld      (HL),E          ; Save LSB of line number
1613: 23      	        inc     HL
1614: 72      	        ld      (HL),D          ; Save MSB of line number
1615: 23      	        inc     HL              ; To first byte in line
1616: 113681  	        ld      DE,BUFFER       ; Copy buffer to program
1619: 1A      	MOVBUF: ld      A,(DE)          ; Get source
161A: 77      	        ld      (HL),A          ; Save destinations
161B: 23      	        inc     HL              ; Next source
161C: 13      	        inc     DE              ; Next destination
161D: B7      	        or      A               ; Done?
161E: C21916  	        jp      NZ,MOVBUF       ; No - Repeat
1621: CD6A16  	SETPTR: call    RUNFST          ; Set line pointers
1624: 23      	        inc     HL              ; To LSB of pointer
1625: EB      	        ex      DE,HL           ; Address to DE
1626: 62      	PTRLP:  ld      H,D             ; Address to HL
1627: 6B      	        ld      L,E
1628: 7E      	        ld      A,(HL)          ; Get LSB of pointer
1629: 23      	        inc     HL              ; To MSB of pointer
162A: B6      	        or      (HL)            ; Compare with MSB pointer
162B: CA9F15  	        jp      Z,GETCMD        ; Get command line if end
162E: 23      	        inc     HL              ; To LSB of line number
162F: 23      	        inc     HL              ; Skip line number
1630: 23      	        inc     HL              ; Point to first byte in line
1631: AF      	        xor     A               ; Looking for 00 byte
1632: BE      	FNDEND: cp      (HL)            ; Found end of line?
1633: 23      	        inc     HL              ; Move to next byte
1634: C23216  	        jp      NZ,FNDEND       ; No - Keep looking
1637: EB      	        ex      DE,HL           ; Next line address to HL
1638: 73      	        ld      (HL),E          ; Save LSB of pointer
1639: 23      	        inc     HL
163A: 72      	        ld      (HL),D          ; Save MSB of pointer
163B: C32616  	        jp      PTRLP           ; Do next line
              	
163E: 2A3381  	SRCHLN: ld      HL,(BASTXT)     ; Start of program text
1641: 44      	SRCHLP: ld      B,H             ; BC = Address to look at
1642: 4D      	        ld      C,L
1643: 7E      	        ld      A,(HL)          ; Get address of next line
1644: 23      	        inc     HL
1645: B6      	        or      (HL)            ; End of program found?
1646: 2B      	        dec     HL
1647: C8      	        ret     Z               ; Yes - Line not found
1648: 23      	        inc     HL
1649: 23      	        inc     HL
164A: 7E      	        ld      A,(HL)          ; Get LSB of line number
164B: 23      	        inc     HL
164C: 66      	        ld      H,(HL)          ; Get MSB of line number
164D: 6F      	        ld      L,A
164E: CD1418  	        call    CPDEHL          ; Compare with line in DE
1651: 60      	        ld      H,B             ; HL = Start of this line
1652: 69      	        ld      L,C
1653: 7E      	        ld      A,(HL)          ; Get LSB of next line address
1654: 23      	        inc     HL
1655: 66      	        ld      H,(HL)          ; Get MSB of next line address
1656: 6F      	        ld      L,A             ; Next line to HL
1657: 3F      	        ccf
1658: C8      	        ret     Z               ; Lines found - Exit
1659: 3F      	        ccf
165A: D0      	        ret     NC              ; Line not found,at line after
165B: C34116  	        jp      SRCHLP          ; Keep looking
              	
165E: C0      	NEW:    ret     NZ              ; Return if any more on line
165F: 2A3381  	CLRPTR: ld      HL,(BASTXT)     ; Point to start of program
1662: AF      	        xor     A               ; Set program area to empty
1663: 77      	        ld      (HL),A          ; Save LSB = 00
1664: 23      	        inc     HL
1665: 77      	        ld      (HL),A          ; Save MSB = 00
1666: 23      	        inc     HL
1667: 22BB81  	        ld      (PROGND),HL     ; Set program end
              	
166A: 2A3381  	RUNFST: ld      HL,(BASTXT)     ; Clear all variables
166D: 2B      	        dec     HL
              	
166E: 22B381  	INTVAR: ld      (BRKLIN),HL     ; Initialise RUN variables
1671: 2A9481  	        ld      HL,(LSTRAM)     ; Get end of RAM
1674: 22A881  	        ld      (STRBOT),HL     ; Clear string space
1677: AF      	        xor     A
1678: CD4D1A  	        call    RESTOR          ; Reset DATA pointers
167B: 2ABB81  	        ld      HL,(PROGND)     ; Get end of program
167E: 22BD81  	        ld      (VAREND),HL     ; Clear variables
1681: 22BF81  	        ld      (ARREND),HL     ; Clear arrays
              	
1684: C1      	CLREG:  pop     BC              ; Save return address
1685: 2AAD80  	        ld      HL,(STRSPC)     ; Get end of working RAM
1688: F9      	        ld      SP,HL           ; Set stack
1689: 219881  	        ld      HL,TMSTPL       ; Temporary string pool
168C: 229681  	        ld      (TMSTPT),HL     ; Reset temporary string ptr
168F: AF      	        xor     A               ; A = 00
1690: 6F      	        ld      L,A             ; HL = 0000
1691: 67      	        ld      H,A
1692: 22B981  	        ld      (CONTAD),HL     ; No CONTinue
1695: 32B081  	        ld      (FORFLG),A      ; Clear FOR flag
1698: 22C381  	        ld      (FNRGNM),HL     ; Clear FN argument
169B: E5      	        push    HL              ; HL = 0000
169C: C5      	        push    BC              ; Put back return
169D: 2AB381  	DOAGN:  ld      HL,(BRKLIN)     ; Get address of code to RUN
16A0: C9      	        ret                     ; Return to execution driver
              	
16A1: 3E3F    	PROMPT: ld      A,'?'           ; '?'
16A3: CD2518  	        call    OUTC            ; Output character
16A6: 3E00    	        ld      A,NLLCR         ; null char
16A8: CD2518  	        call    OUTC            ; Output character
16AB: CD3608  	        call    CURSOR_ON       ; enable cursor
16AE: C3AA80  	        jp      RINPUT          ; Get input line
              	
16B1: AF      	CRUNCH: xor     A               ; Tokenise line @ HL to BUFFER
16B2: 329381  	        ld      (DATFLG),A      ; Reset literal flag
16B5: 0E05    	        ld      C,2+3           ; 2 byte number and 3 nulls
16B7: 113681  	        ld      DE,BUFFER       ; Start of input buffer
16BA: 7E      	CRNCLP: ld      A,(HL)          ; Get byte
16BB: FE20    	        cp      SPC             ; Is it a space?
16BD: CA3917  	        jp      Z,MOVDIR        ; Yes - Copy direct
16C0: 47      	        ld      B,A             ; Save character
16C1: FE22    	        cp      22H             ; '"'             ; Is it a quote?
16C3: CA5917  	        jp      Z,CPYLIT        ; Yes - Copy literal string
16C6: B7      	        or      A               ; Is it end of buffer?
16C7: CA6017  	        jp      Z,ENDBUF        ; Yes - End buffer
16CA: 3A9381  	        ld      A,(DATFLG)      ; Get data type
16CD: B7      	        or      A               ; Literal?
16CE: 7E      	        ld      A,(HL)          ; Get byte to copy
16CF: C23917  	        jp      NZ,MOVDIR       ; Literal - Copy direct
16D2: FE3F    	        cp      '?'             ; Is it '?' short for PRINT
16D4: 3EAC    	        ld      A,ZPRINT        ; "PRINT" token
16D6: CA3917  	        jp      Z,MOVDIR        ; Yes - replace it
16D9: 7E      	        ld      A,(HL)          ; Get byte again
16DA: FE30    	        cp      '0'             ; Is it less than '0'
16DC: DAE416  	        jp      C,FNDWRD        ; Yes - Look for reserved words
16DF: FE3C    	        cp      $3C  ;60; ";"+1       ; Is it "0123456789:;" ?
16E1: DA3917  	        jp      C,MOVDIR        ; Yes - copy it direct
16E4: D5      	FNDWRD: push    DE              ; Look for reserved words
16E5: 110210  	        ld      DE,WORDS-1      ; Point to table
16E8: C5      	        push    BC              ; Save count
16E9: 013517  	        ld      BC,RETNAD       ; Where to return to
16EC: C5      	        push    BC              ; Save return address
16ED: 067F    	        ld      B,ZEND-1        ; First token value -1
16EF: 7E      	        ld      A,(HL)          ; Get byte
16F0: FE61    	        cp      'a'             ; Less than 'a' ?
16F2: DAFD16  	        jp      C,SEARCH        ; Yes - search for words
16F5: FE7B    	        cp      'z'+1           ; Greater than 'z' ?
16F7: D2FD16  	        jp      NC,SEARCH       ; Yes - search for words
16FA: E65F    	        and     %01011111       ; Force upper case
16FC: 77      	        ld      (HL),A          ; Replace byte
16FD: 4E      	SEARCH: ld      C,(HL)          ; Search for a word
16FE: EB      	        ex      DE,HL
16FF: 23      	GETNXT: inc     HL              ; Get next reserved word
1700: B6      	        or      (HL)            ; Start of word?
1701: F2FF16  	        jp      P,GETNXT        ; No - move on
1704: 04      	        inc     B               ; Increment token value
1705: 7E      	        ld      A,(HL)          ; Get byte from table
1706: E67F    	        and     %01111111       ; Strip bit 7
1708: C8      	        ret     Z               ; Return if end of list
1709: B9      	        cp      C               ; Same character as in buffer?
170A: C2FF16  	        jp      NZ,GETNXT       ; No - get next word
170D: EB      	        ex      DE,HL
170E: E5      	        push    HL              ; Save start of word
              	
170F: 13      	NXTBYT: inc     DE              ; Look through rest of word
1710: 1A      	        ld      A,(DE)          ; Get byte from table
1711: B7      	        or      A               ; End of word ?
1712: FA3117  	        jp      M,MATCH         ; Yes - Match found
1715: 4F      	        ld      C,A             ; Save it
1716: 78      	        ld      A,B             ; Get token value
1717: FE88    	        cp      ZGOTO           ; Is it "GOTO" token ?
1719: C22017  	        jp      NZ,NOSPC        ; No - Don't allow spaces
171C: CD3D1A  	        call    GETCHR          ; Get next character
171F: 2B      	        dec     HL              ; Cancel increment from GETCHR
1720: 23      	NOSPC:  inc     HL              ; Next byte
1721: 7E      	        ld      A,(HL)          ; Get byte
1722: FE61    	        cp      'a'             ; Less than 'a' ?
1724: DA2917  	        jp      C,NOCHNG        ; Yes - don't change
1727: E65F    	        and     %01011111       ; Make upper case
1729: B9      	NOCHNG: cp      C               ; Same as in buffer ?
172A: CA0F17  	        jp      Z,NXTBYT        ; Yes - keep testing
172D: E1      	        pop     HL              ; Get back start of word
172E: C3FD16  	        jp      SEARCH          ; Look at next word
              	
1731: 48      	MATCH:  ld      C,B             ; Word found - Save token value
1732: F1      	        pop     AF              ; Throw away return
1733: EB      	        ex      DE,HL
1734: C9      	        ret                     ; Return to "RETNAD"
1735: EB      	RETNAD: ex      DE,HL           ; Get address in string
1736: 79      	        ld      A,C             ; Get token value
1737: C1      	        pop     BC              ; Restore buffer length
1738: D1      	        pop     DE              ; Get destination address
1739: 23      	MOVDIR: inc     HL              ; Next source in buffer
173A: 12      	        ld      (DE),A          ; Put byte in buffer
173B: 13      	        inc     DE              ; Move up buffer
173C: 0C      	        inc     C               ; Increment length of buffer
173D: D63A    	        sub     ':'             ; End of statement?
173F: CA4717  	        jp      Z,SETLIT        ; Jump if multi-statement line
1742: FE49    	        cp      ZDATA-$3A       ; Is it DATA statement ?
1744: C24A17  	        jp      NZ,TSTREM       ; No - see if REM
1747: 329381  	SETLIT: ld      (DATFLG),A      ; Set literal flag
174A: D654    	TSTREM: sub     ZREM-$3A        ; Is it REM?
174C: C2BA16  	        jp      NZ,CRNCLP       ; No - Leave flag
174F: 47      	        ld      B,A             ; Copy rest of buffer
1750: 7E      	NXTCHR: ld      A,(HL)          ; Get byte
1751: B7      	        or      A               ; End of line ?
1752: CA6017  	        jp      Z,ENDBUF        ; Yes - Terminate buffer
1755: B8      	        cp      B               ; End of statement ?
1756: CA3917  	        jp      Z,MOVDIR        ; Yes - Get next one
1759: 23      	CPYLIT: inc     HL              ; Move up source string
175A: 12      	        ld      (DE),A          ; Save in destination
175B: 0C      	        inc     C               ; Increment length
175C: 13      	        inc     DE              ; Move up destination
175D: C35017  	        jp      NXTCHR          ; Repeat
              	
1760: 213581  	ENDBUF: ld      HL,BUFFER-1     ; Point to start of buffer
1763: 12      	        ld      (DE),A          ; Mark end of buffer (A = 00)
1764: 13      	        inc     DE
1765: 12      	        ld      (DE),A          ; A = 00
1766: 13      	        inc     DE
1767: 12      	        ld      (DE),A          ; A = 00
1768: C9      	        ret
              	
1769: 3AA480  	DODEL:  ld      A,(NULFLG)      ; Get null flag status
176C: B7      	        or      A               ; Is it zero?
176D: 3E00    	        ld      A,$00           ; Zero A - Leave flags
176F: 32A480  	        ld      (NULFLG),A      ; Zero null flag
1772: C27D17  	        jp      NZ,ECHDEL       ; Set - Echo it
1775: 05      	        dec     B               ; Decrement length
1776: CA9A17  	        jp      Z,GETLIN        ; Get line again if empty
1779: CD2518  	        call    OUTC            ; Output null character
177C: 3E      	        defb    $3E             ; Skip "dec B"
177D: 05      	ECHDEL: dec     B               ; Count bytes in buffer
177E: 2B      	        dec     HL              ; Back space buffer
177F: CA9117  	        jp      Z,OTKLN         ; No buffer - Try again
1782: 7E      	        ld      A,(HL)          ; Get deleted byte
1783: CD2518  	        call    OUTC            ; Echo it
1786: C3A317  	        jp      MORINP          ; Get more input
              	
1789: 05      	DELCHR: dec     B               ; Count bytes in buffer
178A: 2B      	        dec     HL              ; Back space buffer
178B: CD2518  	        call    OUTC            ; Output character in A
178E: C2A317  	        jp      NZ,MORINP       ; Not end - Get more
1791: CD2518  	OTKLN:  call    OUTC            ; Output character in A
1794: CDF61C  	KILIN:  call    PRNTCRLF        ; Output CRLF
1797: C39A17  	        jp      TTYLIN          ; Get line again
              	
179A:         	GETLIN:
179A: 213681  	TTYLIN: ld      HL,BUFFER       ; Get a line by character
179D: 0601    	        ld      B,$01           ; Set buffer as empty
179F: AF      	        xor     A
17A0: 32A480  	        ld      (NULFLG),A      ; Clear null flag
17A3: CD6618  	MORINP: call    CLOTST          ; Get character and test ^O
17A6: 4F      	        ld      C,A             ; Save character in C
17A7: FE7F    	        cp      DEL             ; Delete character?
17A9: CA6917  	        jp      Z,DODEL         ; Yes - Process it
17AC: 3AA480  	        ld      A,(NULFLG)      ; Get null flag
17AF: B7      	        or      A               ; Test null flag status
17B0: CABC17  	        jp      Z,PROCES        ; Reset - Process character
17B3: 3E00    	        ld      A,$00           ; Set a null
17B5: CD2518  	        call    OUTC            ; Output null
17B8: AF      	        xor     A               ; Clear A
17B9: 32A480  	        ld      (NULFLG),A      ; Reset null flag
17BC: 79      	PROCES: ld      A,C             ; Get character
17BD: FE07    	        cp      CTRLG           ; Bell?
17BF: CAFC17  	        jp      Z,PUTCTL        ; Yes - Save it
17C2: FE03    	        cp      CTRLC           ; Is it control "C"?
17C4: CCF117  	        call    Z,GMNCR         ; Yes - exit from graphic mode & Output CRLF
17C7: 37      	        scf                     ; Flag break
17C8: C8      	        ret     Z               ; Return if control "C"
17C9: FE0D    	        cp      CR              ; Is it enter?
17CB: CAEC1C  	        jp      Z,ENDINP        ; Yes - Terminate input
17CE: FE15    	        cp      CTRLU           ; Is it control "U"?
17D0: CA9417  	        jp      Z,KILIN         ; Yes - Get another line
17D3: FE08    	        cp      BKSP            ; Is it backspace?
17D5: CA8917  	        jp      Z,DELCHR        ; Yes - Delete character
17D8: FE12    	        cp      CTRLR           ; Is it control "R"?
17DA: C2F717  	        jp      NZ,PUTBUF       ; No - Put in buffer
17DD: C5      	        push    BC              ; Save buffer length
17DE: D5      	        push    DE              ; Save DE
17DF: E5      	        push    HL              ; Save buffer address
17E0: 3600    	        ld      (HL),$00        ; Mark end of buffer
17E2: CD423C  	        call    OUTNCR          ; Output and do CRLF
17E5: 213681  	        ld      HL,BUFFER       ; Point to buffer start
17E8: CDBA23  	        call    PRS             ; Output buffer
17EB: E1      	        pop     HL              ; Restore buffer address
17EC: D1      	        pop     DE              ; Restore DE
17ED: C1      	        pop     BC              ; Restore buffer length
17EE: C3A317  	        jp      MORINP          ; Get another character
17F1: CD1215  	GMNCR:  call    EXITGM          ; exit from graphic mode
17F4: C3F61C  	        jp      PRNTCRLF        ; output CRLF
              	
17F7: FE20    	PUTBUF: cp      SPC             ; Is it a control code?
17F9: DAA317  	        jp      C,MORINP        ; Yes - Ignore
17FC: 78      	PUTCTL: ld      A,B             ; Get number of bytes in buffer
17FD: FE59    	        cp      $58+$01         ; Test for line overflow
17FF: 3E08    	        ld      A,BKSP          ; Set a bell
1801: D20E18  	        jp      NC,OUTNBS       ; Ring bell if buffer full
1804: 79      	        ld      A,C             ; Get character
1805: 71      	        ld      (HL),C          ; Save in buffer
1806: 32B181  	        ld      (LSTBIN),A      ; Save last input byte
1809: 23      	        inc     HL              ; Move up buffer
180A: 04      	        inc     B               ; Increment length
180B: C3A317  	OUTIT:  jp      MORINP          ; Get another character
              	
180E: CD2518  	OUTNBS: call    OUTC            ; Output bell and back over it
              	        ;ld      A,BKSP          ; send back space
              	        ;call    OUTC            ;
1811: C30B18  	        jp      OUTIT           ; get more chars
              	
1814: 7C      	CPDEHL: ld      A,H             ; Get H
1815: 92      	        sub     D               ; Compare with D
1816: C0      	        ret     NZ              ; Different - Exit
1817: 7D      	        ld      A,L             ; Get L
1818: 93      	        sub     E               ; Compare with E
1819: C9      	        ret                     ; Return status
              	
181A: 7E      	CHKSYN: ld      A,(HL)          ; Check syntax of character
181B: E3      	        ex      (SP),HL         ; Address of test byte
181C: BE      	        cp      (HL)            ; Same as in code string?
181D: 23      	        inc     HL              ; Return address
181E: E3      	        ex      (SP),HL         ; Put it back
181F: CA3D1A  	        jp      Z,GETCHR        ; Yes - Get next character
1822: C33815  	        jp      SNERR           ; Different - ?SN Error
              	
1825: F5      	OUTC:   push    AF              ; Save character
1826: 3AA580  	        ld      A,(CTLOFG)      ; Get control "O" flag
1829: B7      	        or      A               ; Is it set?
182A: C2EF23  	        jp      NZ,POPAF        ; Yes - don't output
182D: F1      	        pop     AF              ; Restore character
182E: C5      	        push    BC              ; Save buffer length
182F: F5      	        push    AF              ; Save character
1830: FE20    	        cp      SPC             ; Is it a control code?
1832: DA4918  	        jp      C,DINPOS        ; Yes - Don't inc POS(X)
1835: 3AA280  	        ld      A,(LWIDTH)      ; Get line width
1838: 47      	        ld      B,A             ; To B
1839: 3A9081  	        ld      A,(CURPOS)      ; Get cursor position
183C: 04      	        inc     B               ; Width 255?
183D: CA4518  	        jp      Z,INCLEN        ; Yes - No width limit
1840: 05      	        dec     B               ; Restore width
1841: B8      	        cp      B               ; At end of line?
1842: CCF61C  	        call    Z,PRNTCRLF      ; Yes - output CRLF
1845: 3C      	INCLEN: inc     A               ; Move on one character
1846: 329081  	        ld      (CURPOS),A      ; Save new position
1849: AF      	DINPOS: xor     A
184A: 322982  	        ld      (KBDNPT),A      ; set flag for no char from keyboard
184D: F1      	        pop     AF              ; Restore character
184E: C1      	        pop     BC              ; Restore buffer length
184F: F5      	        push    AF
1850: CD5818  	        call    SND2VID         ; send char to video
1853: F1      	        pop     AF
1854: CD253C  	        call    MONOUT          ; send char to serial if enabled
1857: C9      	        ret
              	
              	; print char to video if cursor is on
1858: 32EC81  	SND2VID:ld      (CHR4VID),A     ; store A
185B: 3AEB81  	        ld      A,(PRNTVIDEO)   ; check print-on-video
185E: B7      	        or      A               ; is it off?
185F: C8      	        ret     Z               ; yes, so return
1860: F3      	        di                      ; disable INTs
1861: CDAC06  	        call    CHAR2VID        ; cursor is on, so print char on screen
1864: FB      	        ei                      ; re-enable INTs
1865: C9      	        ret                     ; return to caller
              	
1866: CD6E31  	CLOTST: call    GETINP          ; Get input character
1869: FE0F    	        cp      CTRLO           ; Is it control "O"?
186B: C0      	        ret     NZ              ; No don't flip flag
186C: 3AA580  	        ld      A,(CTLOFG)      ; Get flag
186F: 2F      	        cpl                     ; Flip it
1870: 32A580  	        ld      (CTLOFG),A      ; Put it back
1873: A7      	        and     A               ; is output enabled?
1874: CC3608  	        call    Z,CURSOR_ON     ; yes, so cursor on
1877: AF      	        xor     A               ; Null character
1878: C9      	        ret
              	
              	; LIST: list the program stored into memory
1879: C1      	LIST:   pop     BC              ; rubbish - not needed (legacy from original call of LIST)
187A: 2B      	        dec     HL              ; dec 'cos GETCHR INCs
187B: CD3D1A  	        call    GETCHR          ; Get next character
187E: CACA18  	        jp      Z,LSTALL        ; list all if nothing follows
1881: FEBB    	        cp      ZMINUS          ; is it '-'?
1883: 2020    	        jr      NZ,LST01        ; no, look for a line number
1885: 110000  	        ld      DE,$0000        ; yes, set search from 0
1888: CD6519  	        call    SRCHLIN         ; find address of line number
188B: ED43EF81	        ld      (TMPBFR1),BC    ; store address of starting line
188F: CD1A18  	        call    CHKSYN          ; skip '-'
1892: BB      	        defb    ZMINUS
1893: CD0D1B  	        call    ATOH            ; now, look for another number (ASCII number to DE)
1896: CD6519  	        call    SRCHLIN         ; find address of line number
1899: ED43F181	        ld      (TMPBFR2),BC    ; store address of ending line
189D: ED4BEF81	        ld      BC,(TMPBFR1)    ; retrieve address of starting line
18A1: C5      	        push    BC              ; store address of line for later use
18A2: C3FC18  	        jp      LISTLP          ; go listing
18A5: CD0D1B  	LST01:  call    ATOH            ; get a line number (ASCII number to DE)
18A8: CD6519  	LST01H: call    SRCHLIN         ; find address of line number
18AB: ED43EF81	        ld      (TMPBFR1),BC    ; store address of starting line
18AF: ED43F181	        ld      (TMPBFR2),BC    ; same address for ending line (we'll change later if needed)
18B3: 2B      	        dec     HL              ; dec 'cos GETCHR INCs
18B4: CD3D1A  	        call    GETCHR          ; Get next character
18B7: CAC618  	        jp      Z,LST06         ; nothing follows, so ending & starting lines are the same
18BA: FEBB    	        cp      ZMINUS          ; is it '-'?
18BC: CAE218  	        jp      Z,LST03         ; yes, read ending line
18BF: CD6519  	LST04:  call    SRCHLIN         ; find address of line number
18C2: ED43F181	        ld      (TMPBFR2),BC    ; set address of ending line
18C6: C5      	LST06:  push    BC              ; store address for later use
18C7: C3FC18  	        jp      LISTLP          ; jump to list
18CA: 11F9FF  	LSTALL  ld      DE,65529        ; set ending line to max. allowed line number
18CD: CD6519  	        call    SRCHLIN         ; get address of last line
18D0: ED43F181	        ld      (TMPBFR2),BC    ; store it
18D4: 110000  	        ld      DE,$0000        ; set start to first line in memory
18D7: CD6519  	        call    SRCHLIN         ; get address of first line
18DA: ED43EF81	        ld      (TMPBFR1),BC    ; store it
18DE: C5      	        push    BC              ; store address of starting line for later use
18DF: C3FC18  	        jp      LISTLP          ; start printing
18E2: CD1A18  	LST03:  call    CHKSYN          ; skip '-'
18E5: BB      	        defb    ZMINUS
18E6: CD0D1B  	        call    ATOH            ; look for another number (return into DE)
18E9: 7A      	        ld      A,D
18EA: B3      	        or      E               ; is line=0?
18EB: 2003    	        jr      NZ,LST05        ; no, jump over
18ED: 11F9FF  	        ld      DE,65529        ; yes set last valid line number
18F0: CD6519  	LST05:  call    SRCHLIN         ; find address of line number
18F3: ED43F181	        ld      (TMPBFR2),BC    ; store address of ending line
18F7: ED4BEF81	        ld      BC,(TMPBFR1)    ; retrieve address of starting line
18FB: C5      	        push    BC              ; store it for later use
18FC: E1      	LISTLP: pop     HL              ; Restore address of line
18FD: 4E      	        ld      C,(HL)          ; Get LSB of next line
18FE: 23      	        inc     HL
18FF: 46      	        ld      B,(HL)          ; Get MSB of next line
1900: 23      	        inc     HL
1901: 78      	        ld      A,B             ; BC = 0 (End of program)?
1902: B1      	        or      C
1903: CA9215  	        jp      Z,PRNTOK        ; Yes - Go to command mode
1906: CD681A  	        call    TSTBRK          ; Test for break key
1909: CD6B19  	        call    TSTSPC          ; test for space
190C: C5      	        push    BC              ; Save address of next line
190D: 3AE481  	        ld      A,(SCR_CURS_X)  ; load current X pos of cursor
1910: A7      	        and     A               ; is it at the beginning of a new line?
1911: 200B    	        jr      NZ,LST08        ; No, jump over
1913: 3E0D    	        ld      A,CR            ; yes, so just send a CR
1915: CD253C  	        call    MONOUT          ; to serial if it's open
1918: AF      	        xor     A               ; then, set cursor
1919: 329081  	        ld      (CURPOS),A      ; to position 0
191C: 1803    	        jr      LST07           ; and continue
191E: CDF61C  	LST08:  call    PRNTCRLF        ; output CRLF
1921: 5E      	LST07:  ld      E,(HL)          ; Get LSB of line number
1922: 23      	        inc     HL
1923: 56      	        ld      D,(HL)          ; Get MSB of line number
1924: 23      	        inc     HL
1925: E5      	        push    HL              ; Save address of line start
1926: EB      	        ex      DE,HL           ; Line number to HL
1927: CD522E  	        call    PRNTHL          ; Output line number in decimal
192A: 3E20    	        ld      A,SPC           ; Space after line number
192C: E1      	        pop     HL              ; Restore start of line address
192D: CD2518  	LSTLP2: call    OUTC            ; Output character in A
1930: 7E      	LSTLP3: ld      A,(HL)          ; Get next byte in line
1931: B7      	        or      A               ; End of line?
1932: 23      	        inc     HL              ; To next byte in line
1933: CA5719  	        jp      Z,NXTLN         ; Yes - check next line
1936: F22D19  	        jp      P,LSTLP2        ; No token - output it
1939: D67F    	        sub     ZEND-1          ; Find and output word
193B: 4F      	        ld      C,A             ; Token offset+1 to C
193C: 110310  	        ld      DE,WORDS        ; Reserved word list
193F: 1A      	FNDTOK: ld      A,(DE)          ; Get character in list
1940: 13      	        inc     DE              ; Move on to next
1941: B7      	        or      A               ; Is it start of word?
1942: F23F19  	        jp      P,FNDTOK        ; No - Keep looking for word
1945: 0D      	        dec     C               ; Count words
1946: C23F19  	        jp      NZ,FNDTOK       ; Not there - keep looking
1949: E67F    	OUTWRD: and     %01111111       ; Strip bit 7
194B: CD2518  	        call    OUTC            ; Output character
194E: 1A      	        ld      A,(DE)          ; Get next character
194F: 13      	        inc     DE              ; Move on to next
1950: B7      	        or      A               ; Is it end of word?
1951: F24919  	        jp      P,OUTWRD        ; No - output the rest
1954: C33019  	        jp      LSTLP3          ; Next byte in line
1957: D1      	NXTLN:  pop     DE              ; recover address of current line
1958: 2AF181  	        ld      HL,(TMPBFR2)    ; address of last line to print
195B: CD483C  	        call    CMP16           ; check if current line is over last printable line
195E: DA9215  	        jp      C,PRNTOK        ; finish - leave & print OK
1961: D5      	        push    DE              ; store address of current line
1962: C3FC18  	        jp      LISTLP          ; continue listing
1965: E5      	SRCHLIN:push    HL              ; store HL (this is needed because HL store the pointer to the input buffer)
1966: CD3E16  	        call    SRCHLN          ; search for line number in DE
1969: E1      	        pop     HL              ; retrieve HL
196A: C9      	        ret                     ; return to caller
              	
              	; during LISTing, check if PAUSE is pressed, then pause listing and
              	; wait for another pressing of PAUSE to continue or CTRL-C/BREAK to exit
196B: 3A2B82  	TSTSPC: ld      A,(TMPKEYBFR)   ; Get input character
196E: FE20    	        cp      SPC             ; Is it SPACE?
1970: C0      	        ret     NZ              ; No, return
1971: CD6E31  	WTSPC   call    GETINP          ; Yes, stop listing and wait for another space or BREAK
1974: FE20    	        cp      SPC             ; is it SPACE?
1976: 2005    	        jr      NZ,CNTWTSP      ; no, continue
1978: AF      	        xor     A
1979: 322B82  	        ld      (TMPKEYBFR),A   ; reset key
197C: C9      	        ret                     ; return to caller
197D: FE03    	CNTWTSP:cp      CTRLC           ; is it CTRL-C/BREAK?
197F: 20F0    	        jr      NZ,WTSPC        ; no, loop
1981: C36D0F  	        jp      BRKRET          ; exit and output "Ok"
              	
              	
1984: 3E64    	FOR:    ld      A,$64           ; Flag "FOR" assignment
1986: 32B081  	        ld      (FORFLG),A      ; Save "FOR" flag
1989: CDF71B  	        call    LET             ; Set up initial index
198C: C1      	        pop     BC              ; Drop RETurn address
198D: E5      	        push    HL              ; Save code string address
198E: CDE01B  	        call    DATA            ; Get next statement address
1991: 22AC81  	        ld      (LOOPST),HL     ; Save it for start of loop
1994: 210200  	        ld      HL,$0002        ; Offset for "FOR" block
1997: 39      	        add     HL,SP           ; Point to it
1998: CDC514  	FORSLP: call    LOKFOR          ; Look for existing "FOR" block
199B: D1      	        pop     DE              ; Get code string address
199C: C2B419  	        jp      NZ,FORFND       ; No nesting found
199F: 09      	        add     HL,BC           ; Move into "FOR" block
19A0: D5      	        push    DE              ; Save code string address
19A1: 2B      	        dec     HL
19A2: 56      	        ld      D,(HL)          ; Get MSB of loop statement
19A3: 2B      	        dec     HL
19A4: 5E      	        ld      E,(HL)          ; Get LSB of loop statement
19A5: 23      	        inc     HL
19A6: 23      	        inc     HL
19A7: E5      	        push    HL              ; Save block address
19A8: 2AAC81  	        ld      HL,(LOOPST)     ; Get address of loop statement
19AB: CD1418  	        call    CPDEHL          ; Compare the FOR loops
19AE: E1      	        pop     HL              ; Restore block address
19AF: C29819  	        jp      NZ,FORSLP       ; Different FORs - Find another
19B2: D1      	        pop     DE              ; Restore code string address
19B3: F9      	        ld      SP,HL           ; Remove all nested loops
              	
19B4: EB      	FORFND: ex      DE,HL           ; Code string address to HL
19B5: 0E08    	        ld      C,$08
19B7: CDF514  	        call    CHKSTK          ; Check for 8 levels of stack
19BA: E5      	        push    HL              ; Save code string address
19BB: 2AAC81  	        ld      HL,(LOOPST)     ; Get first statement of loop
19BE: E3      	        ex      (SP),HL         ; Save and restore code string
19BF: E5      	        push    HL              ; Re-save code string address
19C0: 2AAF80  	        ld      HL,(LINEAT)     ; Get current line number
19C3: E3      	        ex      (SP),HL         ; Save and restore code string
19C4: CDB51E  	        call    TSTNUM          ; Make sure it's a number
19C7: CD1A18  	        call    CHKSYN          ; Make sure "TO" is next
19CA: B4      	        defb    ZTO             ; "TO" token
19CB: CDB21E  	        call    GETNUM          ; Get "TO" expression value
19CE: E5      	        push    HL              ; Save code string address
19CF: CD042D  	        call    BCDEFP          ; Move "TO" value to BCDE
19D2: E1      	        pop     HL              ; Restore code string address
19D3: C5      	        push    BC              ; Save "TO" value in block
19D4: D5      	        push    DE
19D5: 010081  	        ld      BC,$8100        ; BCDE - 1 (default STEP)
19D8: 51      	        ld      D,C             ; C=0
19D9: 5A      	        ld      E,D             ; D=0
19DA: 7E      	        ld      A,(HL)          ; Get next byte in code string
19DB: FEB9    	        cp      ZSTEP           ; See if "STEP" is stated
19DD: 3E01    	        ld      A,$01           ; Sign of step = 1
19DF: C2F019  	        jp      NZ,SAVSTP       ; No STEP given - Default to 1
19E2: CD3D1A  	        call    GETCHR          ; Jump over "STEP" token
19E5: CDB21E  	        call    GETNUM          ; Get step value
19E8: E5      	        push    HL              ; Save code string address
19E9: CD042D  	        call    BCDEFP          ; Move STEP to BCDE
19EC: CDB82C  	        call    TSTSGN          ; Test sign of FPREG
19EF: E1      	        pop     HL              ; Restore code string address
19F0: C5      	SAVSTP: push    BC              ; Save the STEP value in block
19F1: D5      	        push    DE
19F2: F5      	        push    AF              ; Save sign of STEP
19F3: 33      	        inc     SP              ; Don't save flags
19F4: E5      	        push    HL              ; Save code string address
19F5: 2AB381  	        ld      HL,(BRKLIN)     ; Get address of index variable
19F8: E3      	        ex      (SP),HL         ; Save and restore code string
19F9: 0681    	PUTFID: ld      B,ZFOR          ; "FOR" block marker
19FB: C5      	        push    BC              ; Save it
19FC: 33      	        inc     SP              ; Don't save C
              	
19FD: CD681A  	RUNCNT: call    TSTBRK          ; Execution driver - Test break
1A00: 22B381  	        ld      (BRKLIN),HL     ; Save code address for break
1A03: 7E      	        ld      A,(HL)          ; Get next byte in code string
1A04: FE3A    	        cp      ':'             ; Multi statement line?
1A06: CA1D1A  	        jp      Z,EXCUTE        ; Yes - Execute it
1A09: B7      	        or      A               ; End of line?
1A0A: C23815  	        jp      NZ,SNERR        ; No - Syntax error
1A0D: 23      	        inc     HL              ; Point to address of next line
1A0E: 7E      	        ld      A,(HL)          ; Get LSB of line pointer
1A0F: 23      	        inc     HL
1A10: B6      	        or      (HL)            ; Is it zero (End of prog)?
1A11: CA8F1A  	        jp      Z,ENDPRG        ; Yes - Terminate execution
1A14: 23      	        inc     HL              ; Point to line number
1A15: 5E      	        ld      E,(HL)          ; Get LSB of line number
1A16: 23      	        inc     HL
1A17: 56      	        ld      D,(HL)          ; Get MSB of line number
1A18: EB      	        ex      DE,HL           ; Line number to HL
1A19: 22AF80  	        ld      (LINEAT),HL     ; Save as current line number
1A1C: EB      	        ex      DE,HL           ; Line number back to DE
1A1D: CD3D1A  	EXCUTE: call    GETCHR          ; Get key word
1A20: 11FD19  	        ld      DE,RUNCNT       ; Where to RETurn to
1A23: D5      	        push    DE              ; Save for RETurn
1A24: C8      	IFJMP:  ret     Z               ; Go to RUNCNT if end of STMT
              	
1A25: D680    	ONJMP:  sub     ZEND            ; Is it a token?
1A27: DAF71B  	        jp      C,LET           ; No - try to assign it
1A2A: FE33    	        cp      ZNEW+1-ZEND     ; END to NEW ?
1A2C: D23815  	        jp      NC,SNERR        ; Not a key word - ?SN Error
1A2F: 07      	        rlca                    ; Double it
1A30: 4F      	        ld      C,A             ; BC = Offset into table
1A31: 0600    	        ld      B,0
1A33: EB      	        ex      DE,HL           ; Save code string address
1A34: 218311  	        ld      HL,WORDTB       ; Keyword address table
1A37: 09      	        add     HL,BC           ; Point to routine address
1A38: 4E      	        ld      C,(HL)          ; Get LSB of routine address
1A39: 23      	        inc     HL
1A3A: 46      	        ld      B,(HL)          ; Get MSB of routine address
1A3B: C5      	        push    BC              ; Save routine address
1A3C: EB      	        ex      DE,HL           ; Restore code string address
              	
              	; get a char from input buffer: exit with NC if character found is
              	; not a number; exit with Z if nothing found; char is into A
1A3D: 23      	GETCHR: inc     HL              ; Point to next character
1A3E: 7E      	        ld      A,(HL)          ; Get next code string byte
1A3F: FE3A    	        cp      ':'             ; Z if ':'
1A41: D0      	        ret     NC              ; NC if > "9"
1A42: FE20    	        cp      SPC
1A44: CA3D1A  	        jp      Z,GETCHR        ; Skip over spaces
1A47: FE30    	        cp      '0'
1A49: 3F      	        ccf                     ; NC if < '0'
1A4A: 3C      	        inc     A               ; Test for zero - Leave carry
1A4B: 3D      	        dec     A               ; Z if Null
1A4C: C9      	        ret
              	
1A4D: EB      	RESTOR: ex      DE,HL           ; Save code string address
1A4E: 2A3381  	        ld      HL,(BASTXT)     ; Point to start of program
1A51: CA621A  	        jp      Z,RESTNL        ; Just RESTORE - reset pointer
1A54: EB      	        ex      DE,HL           ; Restore code string address
1A55: CD0D1B  	        call    ATOH            ; Get line number to DE
1A58: E5      	        push    HL              ; Save code string address
1A59: CD3E16  	        call    SRCHLN          ; Search for line number in DE
1A5C: 60      	        ld      H,B             ; HL = Address of line
1A5D: 69      	        ld      L,C
1A5E: D1      	        pop     DE              ; Restore code string address
1A5F: D2B61B  	        jp      NC,ULERR        ; ?UL Error if not found
1A62: 2B      	RESTNL: dec     HL              ; Byte before DATA statement
1A63: 22C181  	UPDATA: ld      (NXTDAT),HL     ; Update DATA pointer
1A66: EB      	        ex      DE,HL           ; Restore code string address
1A67: C9      	        ret
              	
              	
1A68: DF      	TSTBRK: rst     $18             ; Check input status
1A69: C8      	        ret     Z               ; No key, go back
1A6A: D7      	        rst     $10             ; Get the key into A
1A6B: FE1B    	        cp      ESC             ; Escape key?
1A6D: 2811    	        jr      Z,BRK           ; Yes, break
1A6F: FE03    	        cp      CTRLC           ; <Ctrl-C>
1A71: 280D    	        jr      Z,BRK           ; Yes, break
1A73: FE13    	        cp      CTRLS           ; Stop scrolling?
1A75: C0      	        ret     NZ              ; Other key, ignore
              	
              	
1A76: D7      	STALL:  rst     $10             ; Wait for key
1A77: FE11    	        cp      CTRLQ           ; Resume scrolling?
1A79: C8      	        ret     Z               ; Release the chokehold
1A7A: FE03    	        cp      CTRLC           ; Second break?
1A7C: 2807    	        jr      Z,STOP          ; Break during hold exits prog
1A7E: 18F6    	        jr      STALL           ; Loop until <Ctrl-Q> or <brk>
              	
1A80: 3EFF    	BRK:    ld      A,$FF           ; Set BRKFLG
1A82: 32A980  	        ld      (BRKFLG),A      ; Store it
              	
1A85: C0      	STOP:   ret     NZ              ; Exit if anything else
1A86: F6      	        defb    $F6             ; Flag "STOP"
1A87: C0      	PEND:   ret     NZ              ; Exit if anything else
1A88: 22B381  	        ld      (BRKLIN),HL     ; Save point of break
1A8B: 21      	        defb    $21             ; Skip "OR 11111111B"
1A8C: F6FF    	INPBRK: or      %11111111       ; Flag "Break" wanted
1A8E: C1      	        pop     BC              ; Return not needed and more
1A8F: 2AAF80  	ENDPRG: ld      HL,(LINEAT)     ; Get current line number
1A92: F5      	        push    AF              ; Save STOP / END status
1A93: 7D      	        ld      A,L             ; Is it direct break?
1A94: A4      	        and     H
1A95: 3C      	        inc     A               ; Line is -1 if direct break
1A96: CAA21A  	        jp      Z,NOLIN         ; Yes - No line number
1A99: 22B781  	        ld      (ERRLIN),HL     ; Save line of break
1A9C: 2AB381  	        ld      HL,(BRKLIN)     ; Get point of break
1A9F: 22B981  	        ld      (CONTAD),HL     ; Save point to CONTinue
1AA2: AF      	NOLIN:  xor     A
1AA3: 32A580  	        ld      (CTLOFG),A      ; Enable output
1AA6: CDE41C  	        call    STTLIN          ; Start a new line
1AA9: F1      	        pop     AF              ; Restore STOP / END status
1AAA: 21BB14  	        ld      HL,BRKMSG       ; "Break" message
1AAD: C2B31A  	        jp      NZ,ERRINT       ; "in line" wanted?
1AB0: C39215  	        jp      PRNTOK          ; Go to command mode
1AB3: CD1215  	ERRINT: call    EXITGM          ; exit from graphics mode
1AB6: C37015  	        jp      ERRIN           ; print message
              	
              	
1AB9: 21FFFF  	CONT:   ld      HL,-1           ; reset...
1ABC: 22B180  	        ld      (HLPLN),HL      ; ...HELP line register
1ABF: 2AB981  	        ld      HL,(CONTAD)     ; Get CONTinue address
1AC2: 7C      	        ld      A,H             ; Is it zero?
1AC3: B5      	        or      L
1AC4: 1E20    	        ld      E,CN            ; ?CN Error
1AC6: CA4C15  	        jp      Z,ERROR         ; Yes - output "?CN Error"
1AC9: EB      	        ex      DE,HL           ; Save code string address
1ACA: 2AB781  	        ld      HL,(ERRLIN)     ; Get line of last break
1ACD: 22AF80  	        ld      (LINEAT),HL     ; Set up current line number
1AD0: EB      	        ex      DE,HL           ; Restore code string address
1AD1: C9      	        ret                     ; CONTinue where left off
              	
1AD2: E5      	ACCSUM: push    HL              ; Save address in array
1AD3: 2AA680  	        ld      HL,(CHKSUM)     ; Get check sum
1AD6: 0600    	        ld      B,$00           ; BC - Value of byte
1AD8: 4F      	        ld      C,A
1AD9: 09      	        add     HL,BC           ; Add byte to check sum
1ADA: 22A680  	        ld      (CHKSUM),HL     ; Re-save check sum
1ADD: E1      	        pop     HL              ; Restore address in array
1ADE: C9      	        ret
              	
1ADF: 7E      	CHKLTR: ld      A,(HL)          ; Get byte
1AE0: FE41    	        cp      'A'             ; < 'a' ?
1AE2: D8      	        ret     C               ; Carry set if not letter
1AE3: FE5B    	        cp      'Z'+1           ; > 'z' ?
1AE5: 3F      	        ccf
1AE6: C9      	        ret                     ; Carry set if not letter
              	
1AE7: CD3D1A  	FPSINT: call    GETCHR          ; Get next character
1AEA: CDB21E  	POSINT: call    GETNUM          ; Get integer 0 to 32767
1AED: CDB82C  	DEPINT: call    TSTSGN          ; Test sign of FPREG
1AF0: FA081B  	        jp      M,FCERR         ; Negative - ?FC Error
1AF3: 3ACC81  	DEINT:  ld      A,(FPEXP)       ; Get integer value to DE
1AF6: FE90    	        cp      $80+$10         ; Exponent in range (16 bits)?
1AF8: DA602D  	        jp      C,FPINT         ; Yes - convert it
1AFB: 018090  	        ld      BC,$9080        ; BCDE = -32768
1AFE: 110000  	        ld      DE,$0000
1B01: E5      	        push    HL              ; Save code string address
1B02: CD332D  	        call    CMPNUM          ; Compare FPREG with BCDE
1B05: E1      	        pop     HL              ; Restore code string address
1B06: 51      	        ld      D,C             ; MSB to D
1B07: C8      	        ret     Z               ; Return if in range
1B08: 1E08    	FCERR:  ld      E,FC            ; ?FC Error
1B0A: C34C15  	        jp      ERROR           ; Output error-
              	
1B0D: 2B      	ATOH:   dec     HL              ; ASCII number to DE binary
1B0E: 110000  	GETLN:  ld      DE,$0000        ; Get number to DE
1B11: CD3D1A  	GTLNLP: call    GETCHR          ; Get next character
1B14: D0      	        ret     NC              ; Exit if not a digit
1B15: E5      	        push    HL              ; Save code string address
1B16: F5      	        push    AF              ; Save digit
1B17: 219819  	        ld      HL,65529/10     ; Largest number 65529
1B1A: CD1418  	        call    CPDEHL          ; Number in range?
1B1D: DA3815  	        jp      C,SNERR         ; No - ?SN Error
1B20: 62      	        ld      H,D             ; HL = Number
1B21: 6B      	        ld      L,E
1B22: 19      	        add     HL,DE           ; Times 2
1B23: 29      	        add     HL,HL           ; Times 4
1B24: 19      	        add     HL,DE           ; Times 5
1B25: 29      	        add     HL,HL           ; Times 10
1B26: F1      	        pop     AF              ; Restore digit
1B27: D630    	        sub     '0'             ; Make it 0 to 9
1B29: 5F      	        ld      E,A             ; DE = Value of digit
1B2A: 1600    	        ld      D,0
1B2C: 19      	        add     HL,DE           ; Add to number
1B2D: EB      	        ex      DE,HL           ; Number to DE
1B2E: E1      	        pop     HL              ; Restore code string address
1B2F: C3111B  	        jp      GTLNLP          ; Go to next character
              	
1B32: CA6E16  	CLEAR:  jp      Z,INTVAR        ; Just "CLEAR" Keep parameters
1B35: CDEA1A  	        call    POSINT          ; Get integer 0 to 32767 to DE
1B38: 2B      	        dec     HL              ; Cancel increment
1B39: CD3D1A  	        call    GETCHR          ; Get next character
1B3C: E5      	        push    HL              ; Save code string address
1B3D: 2A9481  	        ld      HL,(LSTRAM)     ; Get end of RAM
1B40: CA551B  	        jp      Z,STORED        ; No value given - Use stored
1B43: E1      	        pop     HL              ; Restore code string address
1B44: CD1A18  	        call    CHKSYN          ; Check for comma
1B47: 2C      	        defb    ','
1B48: D5      	        push    DE              ; Save number
1B49: CDEA1A  	        call    POSINT          ; Get integer 0 to 32767
1B4C: 2B      	        dec     HL              ; Cancel increment
1B4D: CD3D1A  	        call    GETCHR          ; Get next character
1B50: C23815  	        jp      NZ,SNERR        ; ?SN Error if more on line
1B53: E3      	        ex      (SP),HL         ; Save code string address
1B54: EB      	        ex      DE,HL           ; Number to DE
1B55: 7D      	STORED: ld      A,L             ; Get LSB of new RAM top
1B56: 93      	        sub     E               ; Subtract LSB of string space
1B57: 5F      	        ld      E,A             ; Save LSB
1B58: 7C      	        ld      A,H             ; Get MSB of new RAM top
1B59: 9A      	        sbc     A,D             ; Subtract MSB of string space
1B5A: 57      	        ld      D,A             ; Save MSB
1B5B: DA0D15  	        jp      C,OMERR         ; ?OM Error if not enough mem
1B5E: E5      	        push    HL              ; Save RAM top
1B5F: 2ABB81  	        ld      HL,(PROGND)     ; Get program end
1B62: 012800  	        ld      BC,$28          ; 40 Bytes minimum working RAM
1B65: 09      	        add     HL,BC           ; Get lowest address
1B66: CD1418  	        call    CPDEHL          ; Enough memory?
1B69: D20D15  	        jp      NC,OMERR        ; No - ?OM Error
1B6C: EB      	        ex      DE,HL           ; RAM top to HL
1B6D: 22AD80  	        ld      (STRSPC),HL     ; Set new string space
1B70: E1      	        pop     HL              ; End of memory to use
1B71: 229481  	        ld      (LSTRAM),HL     ; Set new top of RAM
1B74: E1      	        pop     HL              ; Restore code string address
1B75: C36E16  	        jp      INTVAR          ; Initialise variables
              	
1B78: E5      	RUN:    push    HL              ; store HL
1B79: 21FFFF  	        ld      HL,-1           ; reset...
1B7C: 22B180  	        ld      (HLPLN),HL      ; ...HELP line register
1B7F: E1      	        pop     HL              ; retrieve HL
1B80: CA6A16  	        jp      Z,RUNFST        ; RUN from start if just RUN
1B83: CD6E16  	        call    INTVAR          ; Initialise variables
1B86: 01FD19  	        ld      BC,RUNCNT       ; Execution driver loop
1B89: C39C1B  	        jp      RUNLIN          ; RUN from line number
              	
1B8C: 0E03    	GOSUB:  ld      C,$03           ; 3 Levels of stack needed
1B8E: CDF514  	        call    CHKSTK          ; Check for 3 levels of stack
1B91: C1      	        pop     BC              ; Get return address
1B92: E5      	        push    HL              ; Save code string for RETURN
1B93: E5      	        push    HL              ; And for GOSUB routine
1B94: 2AAF80  	        ld      HL,(LINEAT)     ; Get current line
1B97: E3      	        ex      (SP),HL         ; Into stack - Code string out
1B98: 3E8C    	        ld      A,ZGOSUB        ; "GOSUB" token
1B9A: F5      	        push    AF              ; Save token
1B9B: 33      	        inc     SP              ; Don't save flags
              	
1B9C: C5      	RUNLIN: push    BC              ; Save return address
1B9D: CD0D1B  	GOTO:   call    ATOH            ; ASCII number to DE binary
1BA0: CDE21B  	        call    REM             ; Get end of line
1BA3: E5      	        push    HL              ; Save end of line
1BA4: 2AAF80  	        ld      HL,(LINEAT)     ; Get current line
1BA7: CD1418  	        call    CPDEHL          ; Line after current?
1BAA: E1      	        pop     HL              ; Restore end of line
1BAB: 23      	        inc     HL              ; Start of next line
1BAC: DC4116  	        call    C,SRCHLP        ; Line is after current line
1BAF: D43E16  	        call    NC,SRCHLN       ; Line is before current line
1BB2: 60      	        ld      H,B             ; Set up code string address
1BB3: 69      	        ld      L,C
1BB4: 2B      	        dec     HL              ; Incremented after
1BB5: D8      	        ret     C               ; Line found
1BB6: 1E0E    	ULERR:  ld      E,UL            ; ?UL Error
1BB8: C34C15  	        jp      ERROR           ; Output error message
              	
1BBB: C0      	RETURN: ret     NZ              ; Return if not just RETURN
1BBC: 16FF    	        ld      D,-1            ; Flag "GOSUB" search
1BBE: CDC114  	        call    BAKSTK          ; Look "GOSUB" block
1BC1: F9      	        ld      SP,HL           ; Kill all FORs in subroutine
1BC2: FE8C    	        cp      ZGOSUB          ; Test for "GOSUB" token
1BC4: 1E04    	        ld      E,RG            ; ?RG Error
1BC6: C24C15  	        jp      NZ,ERROR        ; Error if no "GOSUB" found
1BC9: E1      	        pop     HL              ; Get RETURN line number
1BCA: 22AF80  	        ld      (LINEAT),HL     ; Save as current
1BCD: 23      	        inc     HL              ; Was it from direct statement?
1BCE: 7C      	        ld      A,H
1BCF: B5      	        or      L               ; Return to line
1BD0: C2DA1B  	        jp      NZ,RETLIN       ; No - Return to line
1BD3: 3AB181  	        ld      A,(LSTBIN)      ; Any INPUT in subroutine?
1BD6: B7      	        or      A               ; If so buffer is corrupted
1BD7: C29115  	        jp      NZ,POPNOK       ; Yes - Go to command mode
1BDA: 21FD19  	RETLIN: ld      HL,RUNCNT       ; Execution driver loop
1BDD: E3      	        ex      (SP),HL         ; Into stack - Code string out
1BDE: 3E      	        defb    $3E             ; Skip "pop HL"
1BDF: E1      	NXTDTA: pop     HL              ; Restore code string address
              	
1BE0: 013A    	DATA:   defb    $01,$3A         ; ':' End of statement
1BE2: 0E00    	REM:    ld      C,$00           ; 00  End of statement
1BE4: 0600    	        ld      B,$00
1BE6: 79      	NXTSTL: ld      A,C             ; Statement and byte
1BE7: 48      	        ld      C,B
1BE8: 47      	        ld      B,A             ; Statement end byte
1BE9: 7E      	NXTSTT: ld      A,(HL)          ; Get byte
1BEA: B7      	        or      A               ; End of line?
1BEB: C8      	        ret     Z               ; Yes - Exit
1BEC: B8      	        cp      B               ; End of statement?
1BED: C8      	        ret     Z               ; Yes - Exit
1BEE: 23      	        inc     HL              ; Next byte
1BEF: FE22    	        cp      $22             ; '"'             ; Literal string?
1BF1: CAE61B  	        jp      Z,NXTSTL        ; Yes - Look for another '"'
1BF4: C3E91B  	        jp      NXTSTT          ; Keep looking
              	
1BF7: CDC120  	LET:    call    GETVAR          ; Get variable name
1BFA: CD1A18  	        call    CHKSYN          ; Make sure "=" follows
1BFD: C5      	        defb    ZEQUAL          ; "=" token
1BFE: D5      	        push    DE              ; Save address of variable
1BFF: 3A9281  	        ld      A,(TYPE)        ; Get data type
1C02: F5      	        push    AF              ; Save type
1C03: CDC41E  	        call    EVAL            ; Evaluate expression
1C06: F1      	        pop     AF              ; Restore type
1C07: E3      	        ex      (SP),HL         ; Save code - Get var addr
1C08: 22B381  	        ld      (BRKLIN),HL     ; Save address of variable
1C0B: 1F      	        rra                     ; Adjust type
1C0C: CDB71E  	        call    CHKTYP          ; Check types are the same
1C0F: CA4A1C  	        jp      Z,LETNUM        ; Numeric - Move value
1C12: E5      	LETSTR: push    HL              ; Save address of string var
1C13: 2AC981  	        ld      HL,(FPREG)      ; Pointer to string entry
1C16: E5      	        push    HL              ; Save it on stack
1C17: 23      	        inc     HL              ; Skip over length
1C18: 23      	        inc     HL
1C19: 5E      	        ld      E,(HL)          ; LSB of string address
1C1A: 23      	        inc     HL
1C1B: 56      	        ld      D,(HL)          ; MSB of string address
1C1C: 2A3381  	        ld      HL,(BASTXT)     ; Point to start of program
1C1F: CD1418  	        call    CPDEHL          ; Is string before program?
1C22: D2391C  	        jp      NC,CRESTR       ; Yes - Create string entry
1C25: 2AAD80  	        ld      HL,(STRSPC)     ; Point to string space
1C28: CD1418  	        call    CPDEHL          ; Is string literal in program?
1C2B: D1      	        pop     DE              ; Restore address of string
1C2C: D2411C  	        jp      NC,MVSTPT       ; Yes - Set up pointer
1C2F: 21A481  	        ld      HL,TMPSTR       ; Temporary string pool
1C32: CD1418  	        call    CPDEHL          ; Is string in temporary pool?
1C35: D2411C  	        jp      NC,MVSTPT       ; No - Set up pointer
1C38: 3E      	        defb    $3E             ; Skip "pop DE"
1C39: D1      	CRESTR: pop     DE              ; Restore address of string
1C3A: CD1B25  	        call    BAKTMP          ; Back to last tmp-str entry
1C3D: EB      	        ex      DE,HL           ; Address of string entry
1C3E: CD5423  	        call    SAVSTR          ; Save string in string area
1C41: CD1B25  	MVSTPT: call    BAKTMP          ; Back to last tmp-str entry
1C44: E1      	        pop     HL              ; Get string pointer
1C45: CD132D  	        call    DETHL4          ; Move string pointer to var
1C48: E1      	        pop     HL              ; Restore code string address
1C49: C9      	        ret
              	
1C4A: E5      	LETNUM: push    HL              ; Save address of variable
1C4B: CD102D  	        call    FPTHL           ; Move value to variable
1C4E: D1      	        pop     DE              ; Restore address of variable
1C4F: E1      	        pop     HL              ; Restore code string address
1C50: C9      	        ret
              	
1C51: CD3827  	ON:     call    GETINT          ; Get integer 0-255
1C54: 7E      	        ld      A,(HL)          ; Get "GOTO" or "GOSUB" token
1C55: 47      	        ld      B,A             ; Save in B
1C56: FE8C    	        cp      ZGOSUB          ; "GOSUB" token?
1C58: CA601C  	        jp      Z,ONGO          ; Yes - Find line number
1C5B: CD1A18  	        call    CHKSYN          ; Make sure it's "GOTO"
1C5E: 88      	        defb    ZGOTO           ; "GOTO" token
1C5F: 2B      	        dec     HL              ; Cancel increment
1C60: 4B      	ONGO:   ld      C,E             ; Integer of branch value
1C61: 0D      	ONGOLP: dec     C               ; Count branches
1C62: 78      	        ld      A,B             ; Get "GOTO" or "GOSUB" token
1C63: CA251A  	        jp      Z,ONJMP         ; Go to that line if right one
1C66: CD0E1B  	        call    GETLN           ; Get line number to DE
1C69: FE2C    	        cp      ','             ; Another line number?
1C6B: C0      	        ret     NZ              ; No - Drop through
1C6C: C3611C  	        jp      ONGOLP          ; Yes - loop
              	
1C6F: CDC41E  	IF:     call    EVAL            ; Evaluate expression
1C72: 7E      	        ld      A,(HL)          ; Get token
1C73: FE88    	        cp      ZGOTO           ; "GOTO" token?
1C75: CA7D1C  	        jp      Z,IFGO          ; Yes - Get line
1C78: CD1A18  	        call    CHKSYN          ; Make sure it's "THEN"
1C7B: B7      	        defb    ZTHEN           ; "THEN" token
1C7C: 2B      	        dec     HL              ; Cancel increment
1C7D: CDB51E  	IFGO:   call    TSTNUM          ; Make sure it's numeric
1C80: CDB82C  	        call    TSTSGN          ; Test state of expression
1C83: CAE21B  	        jp      Z,REM           ; False - Drop through
1C86: CD3D1A  	        call    GETCHR          ; Get next character
1C89: DA9D1B  	        jp      C,GOTO          ; Number - GOTO that line
1C8C: C3241A  	        jp      IFJMP           ; Otherwise do statement
              	
1C8F: 2B      	MRPRNT: dec     HL              ; dec 'cos GETCHR INCs
1C90: CD3D1A  	        call    GETCHR          ; Get next character
1C93: CAF61C  	PRINT:  jp      Z,PRNTCRLF      ; CRLF if just PRINT
1C96: C8      	PRNTLP: ret     Z               ; End of list - Exit
1C97: FEB3    	        cp      ZTAB            ; "TAB(" token?
1C99: CA1E1D  	        jp      Z,DOTAB         ; Yes - Do TAB routine
1C9C: FEB6    	        cp      ZSPC            ; "SPC(" token?
1C9E: CA1E1D  	        jp      Z,DOTAB         ; Yes - Do SPC routine
1CA1: E5      	        push    HL              ; Save code string address
1CA2: FE2C    	        cp      ','             ; Comma?
1CA4: CA051D  	        jp      Z,DOCOM         ; Yes - Move to next zone
1CA7: FE3B    	        cp      ';'             ; Semi-colon?
1CA9: CA421D  	        jp      Z,NEXITM        ; Do semi-colon routine
1CAC: C1      	        pop     BC              ; Code string address to BC
1CAD: CDC41E  	        call    EVAL            ; Evaluate expression
1CB0: E5      	        push    HL              ; Save code string address
1CB1: 3A9281  	        ld      A,(TYPE)        ; Get variable type
1CB4: B7      	        or      A               ; Is it a string variable?
1CB5: C2DD1C  	        jp      NZ,PRNTST       ; Yes - Output string contents
1CB8: CD5D2E  	        call    NUMASC          ; Convert number to text
1CBB: CD7823  	        call    CRTST           ; Create temporary string
1CBE: 3600    	        ld      (HL),NLLCR      ; Followed by a NULL char (was SPC, space)
1CC0: 2AC981  	        ld      HL,(FPREG)      ; Get length of output
1CC3: 34      	        inc     (HL)            ; Plus 1 for the space
1CC4: 2AC981  	        ld      HL,(FPREG)      ; < Not needed >
1CC7: 3AA280  	        ld      A,(LWIDTH)      ; Get width of line
1CCA: 47      	        ld      B,A             ; To B
1CCB: 04      	        inc     B               ; Width 255 (No limit)?
1CCC: CAD91C  	        jp      Z,PRNTNB        ; Yes - Output number string
1CCF: 04      	        inc     B               ; Adjust it
1CD0: 3A9081  	        ld      A,(CURPOS)      ; Get cursor position
1CD3: 86      	        add     A,(HL)          ; Add length of string
1CD4: 3D      	        dec     A               ; Adjust it
1CD5: B8      	        cp      B               ; Will output fit on this line?
1CD6: D4F61C  	        call    NC,PRNTCRLF     ; No - CRLF first
1CD9: CDBD23  	PRNTNB: call    PRS1            ; Output string at (HL)
1CDC: AF      	        xor     A               ; Skip call by setting 'z' flag
1CDD: C4BD23  	PRNTST: call    NZ,PRS1         ; Output string at (HL)
1CE0: E1      	        pop     HL              ; Restore code string address
1CE1: C38F1C  	        jp      MRPRNT          ; See if more to PRINT
              	
1CE4: 3A9081  	STTLIN: ld      A,(CURPOS)      ; Make sure on new line
1CE7: B7      	        or      A               ; Already at start?
1CE8: C8      	        ret     Z               ; Yes - Do nothing
1CE9: C3F61C  	        jp      PRNTCRLF        ; Start a new line
              	
1CEC: AF      	ENDINP: xor     A
1CED: 322982  	        ld      (KBDNPT),A      ; char is not from keyboard
1CF0: 77      	        ld      (HL),A          ; Mark end of buffer
1CF1: 213581  	        ld      HL,BUFFER-1     ; Point to buffer
1CF4: 180A    	        jr      CNTEND
1CF6: 3E0D    	PRNTCRLF:ld     A,CR            ; Load a CR
1CF8: CD2518  	        call    OUTC            ; Output character
1CFB: 3E0A    	        ld      A,LF            ; Load a LF
1CFD: CD2518  	        call    OUTC            ; Output character
1D00: AF      	CNTEND: xor     A               ; Set to position 0
1D01: 329081  	        ld      (CURPOS),A      ; Store it
1D04: C9      	        ret                     ; return to caller
              	
1D05: 3AA380  	DOCOM:  ld      A,(COMMAN)      ; Get comma width
1D08: 47      	        ld      B,A             ; Save in B
1D09: 3A9081  	        ld      A,(CURPOS)      ; Get current position
1D0C: B8      	        cp      B               ; Within the limit?
1D0D: D4F61C  	        call    NC,PRNTCRLF     ; No - output CRLF
1D10: D2421D  	        jp      NC,NEXITM       ; Get next item
1D13: D60E    	ZONELP: sub     $0E             ; Next zone of 14 characters
1D15: D2131D  	        jp      NC,ZONELP       ; Repeat if more zones
1D18: 2F      	        cpl                     ; Number of null chars to output
1D19: 0E00    	        ld      C,NLLCR         ; null char
1D1B: C3381D  	        jp      ASPCS           ; Output them
              	
1D1E: F5      	DOTAB:  push    AF              ; Save token
1D1F: CD3527  	        call    FNDNUM          ; Evaluate expression
1D22: CD1A18  	        call    CHKSYN          ; Make sure ")" follows
1D25: 29      	        defb    ')'
1D26: 2B      	        dec     HL              ; Back space on to ")"
1D27: F1      	        pop     AF              ; Restore token
1D28: 0E00    	        ld      C,NLLCR         ; for SPC we use NULL char (was SPACE)
1D2A: D6B6    	        sub     ZSPC            ; Was it "SPC(" ?
1D2C: E5      	        push    HL              ; Save code string address
1D2D: CA331D  	        jp      Z,DOSPC         ; Yes - Do 'E' spaces
1D30: 3AE481  	        ld      A,(SCR_CURS_X)  ; Get current X position
1D33: 2F      	DOSPC:  cpl                     ; Number of spaces to print to
1D34: 83      	        add     A,E             ; Total number to print
1D35: D2421D  	        jp      NC,NEXITM       ; TAB < Current POS(X)
1D38: 3C      	ASPCS:  inc     A               ; Output A spaces
1D39: 47      	        ld      B,A             ; Save number to print
1D3A: 79      	SPCLP:  ld      A,C             ; char to print
1D3B: CD2518  	        call    OUTC            ; Output character in A
1D3E: 05      	        dec     B               ; Count them
1D3F: C23A1D  	        jp      NZ,SPCLP        ; Repeat if more
1D42: E1      	NEXITM: pop     HL              ; Restore code string address
1D43: CD3D1A  	        call    GETCHR          ; Get next character
1D46: C3961C  	        jp      PRNTLP          ; More to print
              	
1D49: 3F526564	REDO:   defb    "?Redo from start",CR,0
1D4D: 6F206672	
1D51: 6F6D2073	
1D55: 74617274	
1D59: 0D00    	
              	
1D5B: 3AB281  	BADINP: ld      A,(READFG)      ; READ or INPUT?
1D5E: B7      	        or      A
1D5F: C23215  	        jp      NZ,DATSNR       ; READ - ?SN Error
1D62: C1      	        pop     BC              ; Throw away code string addr
1D63: 21491D  	        ld      HL,REDO         ; "Redo from start" message
1D66: CDBA23  	        call    PRS             ; Output string
1D69: C39D16  	        jp      DOAGN           ; Do last INPUT again
              	
1D6C: CD2523  	INPUT:  call    IDTEST          ; Test for illegal direct
1D6F: 7E      	        ld      A,(HL)          ; Get character after "INPUT"
1D70: FE22    	        cp      $22             ; '"' ; Is there a prompt string?
1D72: 3E00    	        ld      A,$00           ; Clear A and leave flags
1D74: 32A580  	        ld      (CTLOFG),A      ; Enable output
1D77: C2861D  	        jp      NZ,NOPMPT       ; No prompt - get input
1D7A: CD7923  	        call    QTSTR           ; Get string terminated by '"'
1D7D: CD1A18  	        call    CHKSYN          ; Check for ';' after prompt
1D80: 3B      	        defb    ";"
1D81: E5      	        push    HL              ; Save code string address
1D82: CDBD23  	        call    PRS1            ; Output prompt string
1D85: 3E      	        defb    $3E             ; Skip "push HL"
1D86: E5      	NOPMPT: push    HL              ; Save code string address
1D87: CDA116  	        call    PROMPT          ; Get input with "? " prompt
1D8A: C1      	        pop     BC              ; Restore code string address
1D8B: DA8C1A  	        jp      C,INPBRK        ; Break pressed - Exit
1D8E: 23      	        inc     HL              ; Next byte
1D8F: 7E      	        ld      A,(HL)          ; Get it
1D90: B7      	        or      A               ; End of line?
1D91: 2B      	        dec     HL              ; Back again
1D92: C5      	        push    BC              ; Re-save code string address
1D93: CD4C08  	        call    CURSOR_OFF      ; disable cursor
1D96: CADF1B  	        jp      Z,NXTDTA        ; Yes - Find next DATA stmt
1D99: 362C    	        ld      (HL),','        ; Store comma as separator
1D9B: C3A31D  	        jp      NXTITM          ; Get next item
              	
1D9E: E5      	READ:   push    HL              ; Save code string address
1D9F: 2AC181  	        ld      HL,(NXTDAT)     ; Next DATA statement
1DA2: F6      	        defb    $F6             ; Flag "READ"
1DA3: AF      	NXTITM: xor     A               ; Flag "INPUT"
1DA4: 32B281  	        ld      (READFG),A      ; Save "READ"/"INPUT" flag
1DA7: E3      	        ex      (SP),HL         ; Get code str' , Save pointer
1DA8: C3AF1D  	        jp      GTVLUS          ; Get values
              	
1DAB: CD1A18  	NEDMOR: call    CHKSYN          ; Check for comma between items
1DAE: 2C      	        defb    ','
1DAF: CDC120  	GTVLUS: call    GETVAR          ; Get variable name
1DB2: E3      	        ex      (SP),HL         ; Save code str" , Get pointer
1DB3: D5      	        push    DE              ; Save variable address
1DB4: 7E      	        ld      A,(HL)          ; Get next "INPUT"/"DATA" byte
1DB5: FE2C    	        cp      ','             ; Comma?
1DB7: CAD71D  	        jp      Z,ANTVLU        ; Yes - Get another value
1DBA: 3AB281  	        ld      A,(READFG)      ; Is it READ?
1DBD: B7      	        or      A
1DBE: C2431E  	        jp      NZ,FDTLP        ; Yes - Find next DATA stmt
1DC1: 3E3F    	        ld      A,'?'           ; More INPUT needed
1DC3: CD2518  	        call    OUTC            ; Output character
1DC6: CDA116  	        call    PROMPT          ; Get INPUT with prompt
1DC9: D1      	        pop     DE              ; Variable address
1DCA: C1      	        pop     BC              ; Code string address
1DCB: DA8C1A  	        jp      C,INPBRK        ; Break pressed
1DCE: 23      	        inc     HL              ; Point to next DATA byte
1DCF: 7E      	        ld      A,(HL)          ; Get byte
1DD0: B7      	        or      A               ; Is it zero (No input) ?
1DD1: 2B      	        dec     HL              ; Back space INPUT pointer
1DD2: C5      	        push    BC              ; Save code string address
1DD3: CADF1B  	        jp      Z,NXTDTA        ; Find end of buffer
1DD6: D5      	        push    DE              ; Save variable address
1DD7: 3A9281  	ANTVLU: ld      A,(TYPE)        ; Check data type
1DDA: B7      	        or      A               ; Is it numeric?
1DDB: CA011E  	        jp      Z,INPBIN        ; Yes - Convert to binary
1DDE: CD3D1A  	        call    GETCHR          ; Get next character
1DE1: 57      	        ld      D,A             ; Save input character
1DE2: 47      	        ld      B,A             ; Again
1DE3: FE22    	        cp      $22             ; '"'     ; Start of literal sting?
1DE5: CAF51D  	        jp      Z,STRENT        ; Yes - Create string entry
1DE8: 3AB281  	        ld      A,(READFG)      ; "READ" or "INPUT" ?
1DEB: B7      	        or      A
1DEC: 57      	        ld      D,A             ; Save 00 if "INPUT"
1DED: CAF21D  	        jp      Z,ITMSEP        ; "INPUT" - End with 00
1DF0: 163A    	        ld      D,':'           ; "DATA" - End with 00 or ':'
1DF2: 062C    	ITMSEP: ld      B,','           ; Item separator
1DF4: 2B      	        dec     HL              ; Back space for DTSTR
1DF5: CD7C23  	STRENT: call    DTSTR           ; Get string terminated by D
1DF8: EB      	        ex      DE,HL           ; String address to DE
1DF9: 210C1E  	        ld      HL,LTSTND       ; Where to go after LETSTR
1DFC: E3      	        ex      (SP),HL         ; Save HL , get input pointer
1DFD: D5      	        push    DE              ; Save address of string
1DFE: C3121C  	        jp      LETSTR          ; Assign string to variable
              	
1E01: CD3D1A  	INPBIN: call    GETCHR          ; Get next character
1E04: CDBF2D  	        call    ASCTFP          ; Convert ASCII to FP number
1E07: E3      	        ex      (SP),HL         ; Save input ptr, Get var addr
1E08: CD102D  	        call    FPTHL           ; Move FPREG to variable
1E0B: E1      	        pop     HL              ; Restore input pointer
1E0C: 2B      	LTSTND: dec     HL              ; dec 'cos GETCHR INCs
1E0D: CD3D1A  	        call    GETCHR          ; Get next character
1E10: CA181E  	        jp      Z,MORDT         ; End of line - More needed?
1E13: FE2C    	        cp      ','             ; Another value?
1E15: C25B1D  	        jp      NZ,BADINP       ; No - Bad input
1E18: E3      	MORDT:  ex      (SP),HL         ; Get code string address
1E19: 2B      	        dec     HL              ; dec 'cos GETCHR INCs
1E1A: CD3D1A  	        call    GETCHR          ; Get next character
1E1D: C2AB1D  	        jp      NZ,NEDMOR       ; More needed - Get it
1E20: D1      	        pop     DE              ; Restore DATA pointer
1E21: 3AB281  	        ld      A,(READFG)      ; "READ" or "INPUT" ?
1E24: B7      	        or      A
1E25: EB      	        ex      DE,HL           ; DATA pointer to HL
1E26: C2631A  	        jp      NZ,UPDATA       ; Update DATA pointer if "READ"
1E29: D5      	        push    DE              ; Save code string address
1E2A: B6      	        or      (HL)            ; More input given?
1E2B: 21331E  	        ld      HL,EXTIG        ; "?Extra ignored" message
1E2E: C4BA23  	        call    NZ,PRS          ; Output string if extra given
1E31: E1      	        pop     HL              ; Restore code string address
1E32: C9      	        ret
              	
1E33: 3F457874	EXTIG:  defb    "?Extra ignored",CR,0
1E37: 72612069	
1E3B: 676E6F72	
1E3F: 65640D00	
              	
1E43: CDE01B  	FDTLP:  call    DATA            ; Get next statement
1E46: B7      	        or      A               ; End of line?
1E47: C25C1E  	        jp      NZ,FANDT        ; No - See if DATA statement
1E4A: 23      	        inc     HL
1E4B: 7E      	        ld      A,(HL)          ; End of program?
1E4C: 23      	        inc     HL
1E4D: B6      	        or      (HL)            ; 00 00 Ends program
1E4E: 1E06    	        ld      E,OD            ; ?OD Error
1E50: CA4C15  	        jp      Z,ERROR         ; Yes - Out of DATA
1E53: 23      	        inc     HL
1E54: 5E      	        ld      E,(HL)          ; LSB of line number
1E55: 23      	        inc     HL
1E56: 56      	        ld      D,(HL)          ; MSB of line number
1E57: EB      	        ex      DE,HL
1E58: 22AE81  	        ld      (DATLIN),HL     ; Set line of current DATA item
1E5B: EB      	        ex      DE,HL
1E5C: CD3D1A  	FANDT:  call    GETCHR          ; Get next character
1E5F: FE83    	        cp      ZDATA           ; "DATA" token
1E61: C2431E  	        jp      NZ,FDTLP        ; No "DATA" - Keep looking
1E64: C3D71D  	        jp      ANTVLU          ; Found - Convert input
              	
1E67: 110000  	NEXT:   ld      DE,$0000        ; In case no index given
1E6A: C4C120  	NEXT1:  call    NZ,GETVAR       ; Get index address
1E6D: 22B381  	        ld      (BRKLIN),HL     ; Save code string address
1E70: CDC114  	        call    BAKSTK          ; Look for "FOR" block
1E73: C23E15  	        jp      NZ,NFERR        ; No "FOR" - ?NF Error
1E76: F9      	        ld      SP,HL           ; Clear nested loops
1E77: D5      	        push    DE              ; Save index address
1E78: 7E      	        ld      A,(HL)          ; Get sign of STEP
1E79: 23      	        inc     HL
1E7A: F5      	        push    AF              ; Save sign of STEP
1E7B: D5      	        push    DE              ; Save index address
1E7C: CDF62C  	        call    PHLTFP          ; Move index value to FPREG
1E7F: E3      	        ex      (SP),HL         ; Save address of TO value
1E80: E5      	        push    HL              ; Save address of index
1E81: CD122A  	        call    ADDPHL          ; Add STEP to index value
1E84: E1      	        pop     HL              ; Restore address of index
1E85: CD102D  	        call    FPTHL           ; Move value to index variable
1E88: E1      	        pop     HL              ; Restore address of TO value
1E89: CD072D  	        call    LOADFP          ; Move TO value to BCDE
1E8C: E5      	        push    HL              ; Save address of line of FOR
1E8D: CD332D  	        call    CMPNUM          ; Compare index with TO value
1E90: E1      	        pop     HL              ; Restore address of line num
1E91: C1      	        pop     BC              ; Address of sign of STEP
1E92: 90      	        sub     B               ; Compare with expected sign
1E93: CD072D  	        call    LOADFP          ; BC = Loop stmt,DE = Line num
1E96: CAA21E  	        jp      Z,KILFOR        ; Loop finished - Terminate it
1E99: EB      	        ex      DE,HL           ; Loop statement line number
1E9A: 22AF80  	        ld      (LINEAT),HL     ; Set loop line number
1E9D: 69      	        ld      L,C             ; Set code string to loop
1E9E: 60      	        ld      H,B
1E9F: C3F919  	        jp      PUTFID          ; Put back "FOR" and continue
              	
1EA2: F9      	KILFOR: ld      SP,HL           ; Remove "FOR" block
1EA3: 2AB381  	        ld      HL,(BRKLIN)     ; Code string after "NEXT"
1EA6: 7E      	        ld      A,(HL)          ; Get next byte in code string
1EA7: FE2C    	        cp      ','             ; More NEXTs ?
1EA9: C2FD19  	        jp      NZ,RUNCNT       ; No - Do next statement
1EAC: CD3D1A  	        call    GETCHR          ; Position to index name
1EAF: CD6A1E  	        call    NEXT1           ; Re-enter NEXT routine
              	; < will not RETurn to here , Exit to RUNCNT or Loop >
              	
1EB2: CDC41E  	GETNUM: call    EVAL            ; Get a numeric expression
1EB5: F6      	TSTNUM: defb    $F6             ; Clear carry (numeric)
1EB6: 37      	TSTSTR: scf                     ; Set carry (string)
1EB7: 3A9281  	CHKTYP: ld      A,(TYPE)        ; Check types match
1EBA: 8F      	        adc     A,A             ; Expected + actual
1EBB: B7      	        or      A               ; Clear carry , set parity
1EBC: E8      	        ret     PE              ; Even parity - Types match
1EBD: C34A15  	        jp      TMERR           ; Different types - Error
              	
1EC0: CD1A18  	OPNPAR: call    CHKSYN          ; Make sure "(" follows
1EC3: 28      	        defb    '('
1EC4: 2B      	EVAL:   dec     HL              ; Evaluate expression & save
1EC5: 1600    	        ld      D,$00           ; Precedence value
1EC7: D5      	EVAL1:  push    DE              ; Save precedence
1EC8: 0E01    	        ld      C,$01
1ECA: CDF514  	        call    CHKSTK          ; Check for 1 level of stack
1ECD: CD3B1F  	        call    OPRND           ; Get next expression value
1ED0: 22B581  	EVAL2:  ld      (NXTOPR),HL     ; Save address of next operator
1ED3: 2AB581  	EVAL3:  ld      HL,(NXTOPR)     ; Restore address of next opr
1ED6: C1      	        pop     BC              ; Precedence value and operator
1ED7: 78      	        ld      A,B             ; Get precedence value
1ED8: FE78    	        cp      $78             ; "AND", "OR", or "XOR" ?
1EDA: D4B51E  	        call    NC,TSTNUM       ; No - Make sure it's a number
1EDD: 7E      	        ld      A,(HL)          ; Get next operator / function
1EDE: 1600    	        ld      D,$00           ; Clear Last relation
1EE0: D6C4    	RLTLP:  sub     ZGTR            ; ">" Token
1EE2: DAFC1E  	        jp      C,FOPRND        ; + - * / ^ AND OR XOR - Test it
1EE5: FE03    	        cp      ZLTH+1-ZGTR     ; < = >
1EE7: D2FC1E  	        jp      NC,FOPRND       ; Function - Call it
1EEA: FE01    	        cp      ZEQUAL-ZGTR     ; "="
1EEC: 17      	        rla                     ; <- Test for legal
1EED: AA      	        xor     D               ; <- combinations of < = >
1EEE: BA      	        cp      D               ; <- by combining last token
1EEF: 57      	        ld      D,A             ; <- with current one
1EF0: DA3815  	        jp      C,SNERR         ; Error if "<<' '==" or ">>"
1EF3: 22AA81  	        ld      (CUROPR),HL     ; Save address of current token
1EF6: CD3D1A  	        call    GETCHR          ; Get next character
1EF9: C3E01E  	        jp      RLTLP           ; Treat the two as one
              	
1EFC: 7A      	FOPRND: ld      A,D             ; < = > found ?
1EFD: B7      	        or      A
1EFE: C23C20  	        jp      NZ,TSTRED       ; Yes - Test for reduction
1F01: 7E      	        ld      A,(HL)          ; Get operator token
1F02: 22AA81  	        ld      (CUROPR),HL     ; Save operator address
1F05: D6BA    	        sub     ZPLUS           ; Operator or function?
1F07: D8      	        ret     C               ; Neither - Exit
1F08: FE0A    	        cp      ZOR+1-ZPLUS     ; Is it + - * / ^ AND XOR OR ?
1F0A: D0      	        ret     NC              ; No - Exit
1F0B: 5F      	        ld      E,A             ; Coded operator
1F0C: 3A9281  	        ld      A,(TYPE)        ; Get data type
1F0F: 3D      	        dec     A               ; FF = numeric , 00 = string
1F10: B3      	        or      E               ; Combine with coded operator
1F11: 7B      	        ld      A,E             ; Get coded operator
1F12: CAB024  	        jp      Z,CONCAT        ; String concatenation
1F15: 07      	        rlca                    ; Times 2
1F16: 83      	        add     A,E             ; Times 3
1F17: 5F      	        ld      E,A             ; To DE (D is 0)
1F18: 21E911  	        ld      HL,PRITAB       ; Precedence table
1F1B: 19      	        add     HL,DE           ; To the operator concerned
1F1C: 78      	        ld      A,B             ; Last operator precedence
1F1D: 56      	        ld      D,(HL)          ; Get evaluation precedence
1F1E: BA      	        cp      D               ; Compare with eval precedence
1F1F: D0      	        ret     NC              ; Exit if higher precedence
1F20: 23      	        inc     HL              ; Point to routine address
1F21: CDB51E  	        call    TSTNUM          ; Make sure it's a number
              	
1F24: C5      	STKTHS: push    BC              ; Save last precedence & token
1F25: 01D31E  	        ld      BC,EVAL3        ; Where to go on prec' break
1F28: C5      	        push    BC              ; Save on stack for return
1F29: 43      	        ld      B,E             ; Save operator
1F2A: 4A      	        ld      C,D             ; Save precedence
1F2B: CDE92C  	        call    STAKFP          ; Move value to stack
1F2E: 58      	        ld      E,B             ; Restore operator
1F2F: 51      	        ld      D,C             ; Restore precedence
1F30: 4E      	        ld      C,(HL)          ; Get LSB of routine address
1F31: 23      	        inc     HL
1F32: 46      	        ld      B,(HL)          ; Get MSB of routine address
1F33: 23      	        inc     HL
1F34: C5      	        push    BC              ; Save routine address
1F35: 2AAA81  	        ld      HL,(CUROPR)     ; Address of current operator
1F38: C3C71E  	        jp      EVAL1           ; Loop until prec' break
              	
1F3B: AF      	OPRND:  xor     A               ; Get operand routine
1F3C: 329281  	        ld      (TYPE),A        ; Set numeric expected
1F3F: CD3D1A  	        call    GETCHR          ; Get next character
1F42: 1E24    	        ld      E,MO            ; ?MO Error
1F44: CA4C15  	        jp      Z,ERROR         ; No operand - Error
1F47: DABF2D  	        jp      C,ASCTFP        ; Number - Get value
1F4A: CDDF1A  	        call    CHKLTR          ; See if a letter
1F4D: D2A21F  	        jp      NC,CONVAR       ; Letter - Find variable
1F50: FE26    	        cp      '&'             ; &H = HEX, &B = BINARY
1F52: 2012    	        jr      NZ,NOTAMP
1F54: CD3D1A  	        call    GETCHR          ; Get next character
1F57: FE48    	        cp      'H'             ; Hex number indicated? [function added]
1F59: CA853B  	        jp      Z,HEXTFP        ; Convert Hex to FPREG
1F5C: FE42    	        cp      'B'             ; Binary number indicated? [function added]
1F5E: CAF53B  	        jp      Z,BINTFP        ; Convert Bin to FPREG
1F61: 1E02    	        ld      E,SN            ; If neither then a ?SN Error
1F63: CA4C15  	        jp      Z,ERROR         ;
1F66: FEBA    	NOTAMP: cp      ZPLUS           ; '+' Token ?
1F68: CA3B1F  	        jp      Z,OPRND         ; Yes - Look for operand
1F6B: FE2E    	        cp      '.'             ; '.' ?
1F6D: CABF2D  	        jp      Z,ASCTFP        ; Yes - Create FP number
1F70: FEBB    	        cp      ZMINUS          ; '-' Token ?
1F72: CA911F  	        jp      Z,MINUS         ; Yes - Do minus
1F75: FE22    	        cp      $22             ; '"'             ; Literal string ?
1F77: CA7923  	        jp      Z,QTSTR         ; Get string terminated by '"'
1F7A: FEB8    	        cp      ZNOT            ; "NOT" Token ?
1F7C: CA9C20  	        jp      Z,EVNOT         ; Yes - Eval NOT expression
1F7F: FEB5    	        cp      ZFN             ; "FN" Token ?
1F81: CADD22  	        jp      Z,DOFN          ; Yes - Do FN routine
1F84: D6C7    	        sub     ZSGN            ; Is it a function?
1F86: D2B31F  	        jp      NC,FNOFST       ; Yes - Evaluate function
1F89: CDC01E  	EVLPAR: call    OPNPAR          ; Evaluate expression in "()"
1F8C: CD1A18  	        call    CHKSYN          ; Make sure ")" follows
1F8F: 29      	        defb    ')'
1F90: C9      	        ret
              	
1F91: 167D    	MINUS:  ld      D,$7D           ; '-' precedence
1F93: CDC71E  	        call    EVAL1           ; Evaluate until prec' break
1F96: 2AB581  	        ld      HL,(NXTOPR)     ; Get next operator address
1F99: E5      	        push    HL              ; Save next operator address
1F9A: CDE12C  	        call    INVSGN          ; Negate value
1F9D: CDB51E  	RETNUM: call    TSTNUM          ; Make sure it's a number
1FA0: E1      	        pop     HL              ; Restore next operator address
1FA1: C9      	        ret
              	
1FA2: CDC120  	CONVAR: call    GETVAR          ; Get variable address to DE
1FA5: E5      	FRMEVL: push    HL              ; Save code string address
1FA6: EB      	        ex      DE,HL           ; Variable address to HL
1FA7: 22C981  	        ld      (FPREG),HL      ; Save address of variable
1FAA: 3A9281  	        ld      A,(TYPE)        ; Get type
1FAD: B7      	        or      A               ; Numeric?
1FAE: CCF62C  	        call    Z,PHLTFP        ; Yes - Move contents to FPREG
1FB1: E1      	        pop     HL              ; Restore code string address
1FB2: C9      	        ret
              	
1FB3: 0600    	FNOFST: ld      B,$00           ; Get address of function
1FB5: 07      	        rlca                    ; Double function offset
1FB6: 4F      	        ld      C,A             ; BC = Offset in function table
1FB7: C5      	        push    BC              ; Save adjusted token value
1FB8: CD3D1A  	        call    GETCHR          ; Get next character
1FBB: 79      	        ld      A,C             ; Get adjusted token value
1FBC: FE2C    	        cp      2*(ZPOINT-ZSGN) ; "POINT" token?
1FBE: CAE833  	        jp      Z,POINT         ; Yes, do "POINT"
1FC1: FE2E    	        cp      2*(ZINSTR-ZSGN) ; "INSTR" token?
1FC3: CA8C25  	        jp      Z,INSTR         ; Yes, do "INSTR"
1FC6: FE3D    	        cp      2*(ZLEFT-ZSGN)-1; Adj' LEFT$,RIGHT$ or MID$ ?
1FC8: DAE41F  	        jp      C,FNVAL         ; No - Do function
1FCB: CDC01E  	        call    OPNPAR          ; Evaluate expression  (X,...
1FCE: CD1A18  	        call    CHKSYN          ; Make sure ',' follows
1FD1: 2C      	        defb    ','
1FD2: CDB61E  	        call    TSTSTR          ; Make sure it's a string
1FD5: EB      	        ex      DE,HL           ; Save code string address
1FD6: 2AC981  	        ld      HL,(FPREG)      ; Get address of string
1FD9: E3      	        ex      (SP),HL         ; Save address of string
1FDA: E5      	        push    HL              ; Save adjusted token value
1FDB: EB      	        ex      DE,HL           ; Restore code string address
1FDC: CD3827  	        call    GETINT          ; Get integer 0-255
1FDF: EB      	        ex      DE,HL           ; Save code string address
1FE0: E3      	        ex      (SP),HL         ; Save integer,HL = adj' token
1FE1: C3EC1F  	        jp      GOFUNC          ; Jump to string function
              	
1FE4: CD891F  	FNVAL:  call    EVLPAR          ; Evaluate expression
1FE7: E3      	        ex      (SP),HL         ; HL = Adjusted token value
1FE8: 119D1F  	        ld      DE,RETNUM       ; Return number from function
1FEB: D5      	        push    DE              ; Save on stack
1FEC: 01BF0F  	GOFUNC: ld      BC,FNCTAB       ; Function routine addresses
1FEF: 09      	        add     HL,BC           ; Point to right address
1FF0: 4E      	        ld      C,(HL)          ; Get LSB of address
1FF1: 23      	        inc     HL              ;
1FF2: 66      	        ld      H,(HL)          ; Get MSB of address
1FF3: 69      	        ld      L,C             ; Address to HL
1FF4: E9      	        jp      (HL)            ; Jump to function
              	
1FF5: 15      	SGNEXP: dec     D               ; Dee to flag negative exponent
1FF6: FEBB    	        cp      ZMINUS          ; '-' token ?
1FF8: C8      	        ret     Z               ; Yes - Return
1FF9: FE2D    	        cp      '-'             ; '-' ASCII ?
1FFB: C8      	        ret     Z               ; Yes - Return
1FFC: 14      	        inc     D               ; Inc to flag positive exponent
1FFD: FE2B    	        cp      '+'             ; '+' ASCII ?
1FFF: C8      	        ret     Z               ; Yes - Return
2000: FEBA    	        cp      ZPLUS           ; '+' token ?
2002: C8      	        ret     Z               ; Yes - Return
2003: 2B      	        dec     HL              ; dec 'cos GETCHR INCs
2004: C9      	        ret                     ; Return "NZ"
              	
              	; execute OR, AND, and XOR operations
2005: AF      	PAND:   xor     A               ; for AND, Z=1
2006: 1807    	        jr      CNTLGC          
2008: AF      	POR     xor     A               ; for OR, Z=0, S=1
2009: D601    	        sub     $01
200B: 1802    	        jr      CNTLGC
200D: AF      	PXOR:   xor     A               ; for XOR, Z=0, S=0
200E: 3C      	        inc     A
200F: F5      	CNTLGC: push    AF              ; store operand's flags
2010: CDB51E  	        call    TSTNUM          ; Make sure it's a number
2013: CDF31A  	        call    DEINT           ; Get integer -32768 to 32767
2016: F1      	        pop     AF              ; retrieve operand's flags
2017: EB      	        ex      DE,HL           ; <- Get last
2018: C1      	        pop     BC              ; <-  value
2019: E3      	        ex      (SP),HL         ; <-  from
201A: EB      	        ex      DE,HL           ; <-  stack
201B: CDF92C  	        call    FPBCDE          ; Move last value to FPREG
201E: F5      	        push    AF              ; store operand's flags
201F: CDF31A  	        call    DEINT           ; Get integer -32768 to 32767
2022: F1      	        pop     AF              ; retrieve operand's flags
2023: C1      	        pop     BC              ; Get value
2024: 79      	        ld      A,C             ; Get LSB
2025: 219B22  	        ld      HL,ACPASS       ; Address of save AC as current
2028: 2005    	        jr      NZ,POR1         ; if X/OR, jump over
202A: A3      	PAND1:  and     E               ; "AND" LSBs
202B: 4F      	        ld      C,A             ; Save LSB
202C: 78      	        ld      A,B             ; Get MSB
202D: A2      	        and     D               ; "AND" MSBs
202E: E9      	        jp      (HL)            ; Save AC as current (ACPASS)
202F: F23720  	POR1:   jp      P,PXOR1         ; if S=0, jump to XOR
2032: B3      	        or      E               ; "OR" LSBs
2033: 4F      	        ld      C,A             ; Save LSB
2034: 78      	        ld      A,B             ; Get MSB
2035: B2      	        or      D               ; "OR" MSBs
2036: E9      	        jp      (HL)            ; Save AC as current (ACPASS)
2037: AB      	PXOR1:  xor     E               ; "XOR" LSBs
2038: 4F      	        ld      C,A             ; Save LSB
2039: 78      	        ld      A,B             ; Get MSB
203A: AA      	        xor     D               ; "XOR" MSBs
203B: E9      	        jp      (HL)            ; Save AC as current (ACPASS) 
              	
203C: 214E20  	TSTRED: ld      HL,CMPLOG       ; Logical compare routine
203F: 3A9281  	        ld      A,(TYPE)        ; Get data type
2042: 1F      	        rra                     ; Carry set = string
2043: 7A      	        ld      A,D             ; Get last precedence value
2044: 17      	        rla                     ; Times 2 plus carry
2045: 5F      	        ld      E,A             ; To E
2046: 1664    	        ld      D,$64           ; Relational precedence
2048: 78      	        ld      A,B             ; Get current precedence
2049: BA      	        cp      D               ; Compare with last
204A: D0      	        ret     NC              ; Eval if last was rel' or log'
204B: C3241F  	        jp      STKTHS          ; Stack this one and get next
              	
204E: 5020    	CMPLOG: defw    CMPLG1          ; Compare two values / strings
2050: 79      	CMPLG1: ld      A,C             ; Get data type
2051: B7      	        or      A
2052: 1F      	        rra
2053: C1      	        pop     BC              ; Get last expression to BCDE
2054: D1      	        pop     DE
2055: F5      	        push    AF              ; Save status
2056: CDB71E  	        call    CHKTYP          ; Check that types match
2059: 219220  	        ld      HL,CMPRES       ; Result to comparison
205C: E5      	        push    HL              ; Save for RETurn
205D: CA332D  	        jp      Z,CMPNUM        ; Compare values if numeric
2060: AF      	        xor     A               ; Compare two strings
2061: 329281  	        ld      (TYPE),A        ; Set type to numeric
2064: D5      	        push    DE              ; Save string name
2065: CDFD24  	        call    GSTRCU          ; Get current string
2068: 7E      	        ld      A,(HL)          ; Get length of string
2069: 23      	        inc     HL
206A: 23      	        inc     HL
206B: 4E      	        ld      C,(HL)          ; Get LSB of address
206C: 23      	        inc     HL
206D: 46      	        ld      B,(HL)          ; Get MSB of address
206E: D1      	        pop     DE              ; Restore string name
206F: C5      	        push    BC              ; Save address of string
2070: F5      	        push    AF              ; Save length of string
2071: CD0125  	        call    GSTRDE          ; Get second string
2074: CD072D  	        call    LOADFP          ; Get address of second string
2077: F1      	        pop     AF              ; Restore length of string 1
2078: 57      	        ld      D,A             ; Length to D
2079: E1      	        pop     HL              ; Restore address of string 1
207A: 7B      	CMPSTR: ld      A,E             ; Bytes of string 2 to do
207B: B2      	        or      D               ; Bytes of string 1 to do
207C: C8      	        ret     Z               ; Exit if all bytes compared
207D: 7A      	        ld      A,D             ; Get bytes of string 1 to do
207E: D601    	        sub     $01
2080: D8      	        ret     C               ; Exit if end of string 1
2081: AF      	        xor     A
2082: BB      	        cp      E               ; Bytes of string 2 to do
2083: 3C      	        inc     A
2084: D0      	        ret     NC              ; Exit if end of string 2
2085: 15      	        dec     D               ; Count bytes in string 1
2086: 1D      	        dec     E               ; Count bytes in string 2
2087: 0A      	        ld      A,(BC)          ; Byte in string 2
2088: BE      	        cp      (HL)            ; Compare to byte in string 1
2089: 23      	        inc     HL              ; Move up string 1
208A: 03      	        inc     BC              ; Move up string 2
208B: CA7A20  	        jp      Z,CMPSTR        ; Same - Try next bytes
208E: 3F      	        ccf                     ; Flag difference (">" or "<")
208F: C3C32C  	        jp      FLGDIF          ; "<" gives -1 , ">" gives +1
              	
2092: 3C      	CMPRES: inc     A               ; Increment current value
2093: 8F      	        adc     A,A             ; Double plus carry
2094: C1      	        pop     BC              ; Get other value
2095: A0      	        and     B               ; Combine them
2096: C6FF    	        add     A,-1            ; Carry set if different
2098: 9F      	        sbc     A,A             ; 00 - Equal , FF - Different
2099: C3CA2C  	        jp      FLGREL          ; Set current value & continue
              	
209C: 165A    	EVNOT:  ld      D,$5A           ; Precedence value for "NOT"
209E: CDC71E  	        call    EVAL1           ; Eval until precedence break
20A1: CDB51E  	        call    TSTNUM          ; Make sure it's a number
20A4: CDF31A  	        call    DEINT           ; Get integer -32768 - 32767
20A7: 7B      	        ld      A,E             ; Get LSB
20A8: 2F      	        cpl                     ; Invert LSB
20A9: 4F      	        ld      C,A             ; Save "NOT" of LSB
20AA: 7A      	        ld      A,D             ; Get MSB
20AB: 2F      	        cpl                     ; Invert MSB
20AC: CD9B22  	        call    ACPASS          ; Save AC as current
20AF: C1      	        pop     BC              ; Clean up stack
20B0: C3D31E  	        jp      EVAL3           ; Continue evaluation
              	
20B3: 2B      	DIMRET: dec     HL              ; dec 'cos GETCHR INCs
20B4: CD3D1A  	        call    GETCHR          ; Get next character
20B7: C8      	        ret     Z               ; End of DIM statement
20B8: CD1A18  	        call    CHKSYN          ; Make sure ',' follows
20BB: 2C      	        defb    ','
20BC: 01B320  	DIM:    ld      BC,DIMRET       ; Return to "DIMRET"
20BF: C5      	        push    BC              ; Save on stack
20C0: F6      	        defb    $F6             ; Flag "Create" variable
20C1: AF      	GETVAR: xor     A               ; Find variable address,to DE
20C2: 329181  	        ld      (LCRFLG),A      ; Set locate / create flag
20C5: 46      	        ld      B,(HL)          ; Get First byte of name
20C6: CDDF1A  	GTFNAM: call    CHKLTR          ; See if a letter
20C9: DA3815  	        jp      C,SNERR         ; ?SN Error if not a letter
20CC: AF      	        xor     A
20CD: 4F      	        ld      C,A             ; Clear second byte of name
20CE: 329281  	        ld      (TYPE),A        ; Set type to numeric
20D1: CD3D1A  	        call    GETCHR          ; Get next character
20D4: DADD20  	        jp      C,SVNAM2        ; Numeric - Save in name
20D7: CDDF1A  	        call    CHKLTR          ; See if a letter
20DA: DAEA20  	        jp      C,CHARTY        ; Not a letter - Check type
20DD: 4F      	SVNAM2: ld      C,A             ; Save second byte of name
20DE: CD3D1A  	ENDNAM: call    GETCHR          ; Get next character
20E1: DADE20  	        jp      C,ENDNAM        ; Numeric - Get another
20E4: CDDF1A  	        call    CHKLTR          ; See if a letter
20E7: D2DE20  	        jp      NC,ENDNAM       ; Letter - Get another
20EA: D624    	CHARTY: sub     '$'             ; String variable?
20EC: C2F920  	        jp      NZ,NOTSTR       ; No - Numeric variable
20EF: 3C      	        inc     A               ; A = 1 (string type)
20F0: 329281  	        ld      (TYPE),A        ; Set type to string
20F3: 0F      	        rrca                    ; A = 80H , Flag for string
20F4: 81      	        add     A,C             ; 2nd byte of name has bit 7 on
20F5: 4F      	        ld      C,A             ; Resave second byte on name
20F6: CD3D1A  	        call    GETCHR          ; Get next character
20F9: 3AB081  	NOTSTR: ld      A,(FORFLG)      ; Array name needed ?
20FC: 3D      	        dec     A
20FD: CAA621  	        jp      Z,ARLDSV        ; Yes - Get array name
2100: F20921  	        jp      P,NSCFOR        ; No array with "FOR" or "FN"
2103: 7E      	        ld      A,(HL)          ; Get byte again
2104: D628    	        sub     '('             ; Subscripted variable?
2106: CA7E21  	        jp      Z,SBSCPT        ; Yes - Sort out subscript
              	
2109: AF      	NSCFOR: xor     A               ; Simple variable
210A: 32B081  	        ld      (FORFLG),A      ; Clear "FOR" flag
210D: E5      	        push    HL              ; Save code string address
210E: 50      	        ld      D,B             ; DE = Variable name to find
210F: 59      	        ld      E,C
2110: 2AC381  	        ld      HL,(FNRGNM)     ; FN argument name
2113: CD1418  	        call    CPDEHL          ; Is it the FN argument?
2116: 11C581  	        ld      DE,FNARG        ; Point to argument value
2119: CAA82B  	        jp      Z,POPHRT        ; Yes - Return FN argument value
211C: 2ABD81  	        ld      HL,(VAREND)     ; End of variables
211F: EB      	        ex      DE,HL           ; Address of end of search
2120: 2ABB81  	        ld      HL,(PROGND)     ; Start of variables address
2123: CD1418  	FNDVAR: call    CPDEHL          ; End of variable list table?
2126: CA3C21  	        jp      Z,CFEVAL        ; Yes - Called from EVAL?
2129: 79      	        ld      A,C             ; Get second byte of name
212A: 96      	        sub     (HL)            ; Compare with name in list
212B: 23      	        inc     HL              ; Move on to first byte
212C: C23121  	        jp      NZ,FNTHR        ; Different - Find another
212F: 78      	        ld      A,B             ; Get first byte of name
2130: 96      	        sub     (HL)            ; Compare with name in list
2131: 23      	FNTHR:  inc     HL              ; Move on to LSB of value
2132: CA7021  	        jp      Z,RETADR        ; Found - Return address
2135: 23      	        inc     HL              ; <- Skip
2136: 23      	        inc     HL              ; <- over
2137: 23      	        inc     HL              ; <- F.P.
2138: 23      	        inc     HL              ; <- value
2139: C32321  	        jp      FNDVAR          ; Keep looking
              	
213C: E1      	CFEVAL: pop     HL              ; Restore code string address
213D: E3      	        ex      (SP),HL         ; Get return address
213E: D5      	        push    DE              ; Save address of variable
213F: 11A51F  	        ld      DE,FRMEVL       ; Return address in EVAL
2142: CD1418  	        call    CPDEHL          ; Called from EVAL ?
2145: D1      	        pop     DE              ; Restore address of variable
2146: CA7321  	        jp      Z,RETNUL        ; Yes - Return null variable
2149: E3      	        ex      (SP),HL         ; Put back return
214A: E5      	        push    HL              ; Save code string address
214B: C5      	        push    BC              ; Save variable name
214C: 010600  	        ld      BC,$0006        ; 2 byte name plus 4 byte data
214F: 2ABF81  	        ld      HL,(ARREND)     ; End of arrays
2152: E5      	        push    HL              ; Save end of arrays
2153: 09      	        add     HL,BC           ; Move up 6 bytes
2154: C1      	        pop     BC              ; Source address in BC
2155: E5      	        push    HL              ; Save new end address
2156: CDE414  	        call    MOVUP           ; Move arrays up
2159: E1      	        pop     HL              ; Restore new end address
215A: 22BF81  	        ld      (ARREND),HL     ; Set new end address
215D: 60      	        ld      H,B             ; End of variables to HL
215E: 69      	        ld      L,C
215F: 22BD81  	        ld      (VAREND),HL     ; Set new end address
              	
2162: 2B      	ZEROLP: dec     HL              ; Back through to zero variable
2163: 3600    	        ld      (HL),$00        ; Zero byte in variable
2165: CD1418  	        call    CPDEHL          ; Done them all?
2168: C26221  	        jp      NZ,ZEROLP       ; No - Keep on going
216B: D1      	        pop     DE              ; Get variable name
216C: 73      	        ld      (HL),E          ; Store second character
216D: 23      	        inc     HL
216E: 72      	        ld      (HL),D          ; Store first character
216F: 23      	        inc     HL
2170: EB      	RETADR: ex      DE,HL           ; Address of variable in DE
2171: E1      	        pop     HL              ; Restore code string address
2172: C9      	        ret
              	
2173: 32CC81  	RETNUL: ld      (FPEXP),A       ; Set result to zero
2176: 21B514  	        ld      HL,ZERBYT       ; Also set a null string
2179: 22C981  	        ld      (FPREG),HL      ; Save for EVAL
217C: E1      	        pop     HL              ; Restore code string address
217D: C9      	        ret
              	
217E: E5      	SBSCPT: push    HL              ; Save code string address
217F: 2A9181  	        ld      HL,(LCRFLG)     ; Locate/Create and Type
2182: E3      	        ex      (SP),HL         ; Save and get code string
2183: 57      	        ld      D,A             ; Zero number of dimensions
2184: D5      	SCPTLP: push    DE              ; Save number of dimensions
2185: C5      	        push    BC              ; Save array name
2186: CDE71A  	        call    FPSINT          ; Get subscript (0-32767)
2189: C1      	        pop     BC              ; Restore array name
218A: F1      	        pop     AF              ; Get number of dimensions
218B: EB      	        ex      DE,HL
218C: E3      	        ex      (SP),HL         ; Save subscript value
218D: E5      	        push    HL              ; Save LCRFLG and TYPE
218E: EB      	        ex      DE,HL
218F: 3C      	        inc     A               ; Count dimensions
2190: 57      	        ld      D,A             ; Save in D
2191: 7E      	        ld      A,(HL)          ; Get next byte in code string
2192: FE2C    	        cp      ','             ; Comma (more to come)?
2194: CA8421  	        jp      Z,SCPTLP        ; Yes - More subscripts
2197: CD1A18  	        call    CHKSYN          ; Make sure ")" follows
219A: 29      	        defb    ')'
219B: 22B581  	        ld      (NXTOPR),HL     ; Save code string address
219E: E1      	        pop     HL              ; Get LCRFLG and TYPE
219F: 229181  	        ld      (LCRFLG),HL     ; Restore Locate/create & type
21A2: 1E00    	        ld      E,$00           ; Flag not CSAVE* or CLOAD*
21A4: D5      	        push    DE              ; Save number of dimensions (D)
21A5: 11      	        defb    $11             ; Skip "push HL" and "push AF'
              	
21A6: E5      	ARLDSV: push    HL              ; Save code string address
21A7: F5      	        push    AF              ; A = 00 , Flags set = Z,N
21A8: 2ABD81  	        ld      HL,(VAREND)     ; Start of arrays
21AB: 3E      	        defb    $3E             ; Skip "add HL,DE"
21AC: 19      	FNDARY: add     HL,DE           ; Move to next array start
21AD: EB      	        ex      DE,HL
21AE: 2ABF81  	        ld      HL,(ARREND)     ; End of arrays
21B1: EB      	        ex      DE,HL           ; Current array pointer
21B2: CD1418  	        call    CPDEHL          ; End of arrays found?
21B5: CADE21  	        jp      Z,CREARY        ; Yes - Create array
21B8: 7E      	        ld      A,(HL)          ; Get second byte of name
21B9: B9      	        cp      C               ; Compare with name given
21BA: 23      	        inc     HL              ; Move on
21BB: C2C021  	        jp      NZ,NXTARY       ; Different - Find next array
21BE: 7E      	        ld      A,(HL)          ; Get first byte of name
21BF: B8      	        cp      B               ; Compare with name given
21C0: 23      	NXTARY: inc     HL              ; Move on
21C1: 5E      	        ld      E,(HL)          ; Get LSB of next array address
21C2: 23      	        inc     HL
21C3: 56      	        ld      D,(HL)          ; Get MSB of next array address
21C4: 23      	        inc     HL
21C5: C2AC21  	        jp      NZ,FNDARY       ; Not found - Keep looking
21C8: 3A9181  	        ld      A,(LCRFLG)      ; Found Locate or Create it?
21CB: B7      	        or      A
21CC: C24115  	        jp      NZ,DDERR        ; Create - ?DD Error
21CF: F1      	        pop     AF              ; Locate - Get number of dim'ns
21D0: 44      	        ld      B,H             ; BC Points to array dim'ns
21D1: 4D      	        ld      C,L
21D2: CAA82B  	        jp      Z,POPHRT        ; Jump if array load/save
21D5: 96      	        sub     (HL)            ; Same number of dimensions?
21D6: CA3C22  	        jp      Z,FINDEL        ; Yes - Find element
21D9: 1E10    	BSERR:  ld      E,BS            ; ?BS Error
21DB: C34C15  	        jp      ERROR           ; Output error
              	
21DE: 110400  	CREARY: ld      DE,$0004        ; 4 Bytes per entry
21E1: F1      	        pop     AF              ; Array to save or 0 dim'ns?
21E2: CA081B  	        jp      Z,FCERR         ; Yes - ?FC Error
21E5: 71      	        ld      (HL),C          ; Save second byte of name
21E6: 23      	        inc     HL
21E7: 70      	        ld      (HL),B          ; Save first byte of name
21E8: 23      	        inc     HL
21E9: 4F      	        ld      C,A             ; Number of dimensions to C
21EA: CDF514  	        call    CHKSTK          ; Check if enough memory
21ED: 23      	        inc     HL              ; Point to number of dimensions
21EE: 23      	        inc     HL
21EF: 22AA81  	        ld      (CUROPR),HL     ; Save address of pointer
21F2: 71      	        ld      (HL),C          ; Set number of dimensions
21F3: 23      	        inc     HL
21F4: 3A9181  	        ld      A,(LCRFLG)      ; Locate of Create?
21F7: 17      	        rla                     ; Carry set = Create
21F8: 79      	        ld      A,C             ; Get number of dimensions
21F9: 010B00  	CRARLP: ld      BC,10+1         ; Default dimension size 10
21FC: D20122  	        jp      NC,DEFSIZ       ; Locate - Set default size
21FF: C1      	        pop     BC              ; Get specified dimension size
2200: 03      	        inc     BC              ; Include zero element
2201: 71      	DEFSIZ: ld      (HL),C          ; Save LSB of dimension size
2202: 23      	        inc     HL
2203: 70      	        ld      (HL),B          ; Save MSB of dimension size
2204: 23      	        inc     HL
2205: F5      	        push    AF              ; Save num' of dim'ns an status
2206: E5      	        push    HL              ; Save address of dim'n size
2207: CDA42D  	        call    MLDEBC          ; Multiply DE by BC to find
220A: EB      	        ex      DE,HL           ; amount of mem needed (to DE)
220B: E1      	        pop     HL              ; Restore address of dimension
220C: F1      	        pop     AF              ; Restore number of dimensions
220D: 3D      	        dec     A               ; Count them
220E: C2F921  	        jp      NZ,CRARLP       ; Do next dimension if more
2211: F5      	        push    AF              ; Save locate/create flag
2212: 42      	        ld      B,D             ; MSB of memory needed
2213: 4B      	        ld      C,E             ; LSB of memory needed
2214: EB      	        ex      DE,HL
2215: 19      	        add     HL,DE           ; Add bytes to array start
2216: DA0D15  	        jp      C,OMERR         ; Too big - Error
2219: CDFE14  	        call    ENFMEM          ; See if enough memory
221C: 22BF81  	        ld      (ARREND),HL     ; Save new end of array
              	
221F: 2B      	ZERARY: dec     HL              ; Back through array data
2220: 3600    	        ld      (HL),$00        ; Set array element to zero
2222: CD1418  	        call    CPDEHL          ; All elements zeroed?
2225: C21F22  	        jp      NZ,ZERARY       ; No - Keep on going
2228: 03      	        inc     BC              ; Number of bytes + 1
2229: 57      	        ld      D,A             ; A=0
222A: 2AAA81  	        ld      HL,(CUROPR)     ; Get address of array
222D: 5E      	        ld      E,(HL)          ; Number of dimensions
222E: EB      	        ex      DE,HL           ; To HL
222F: 29      	        add     HL,HL           ; Two bytes per dimension size
2230: 09      	        add     HL,BC           ; Add number of bytes
2231: EB      	        ex      DE,HL           ; Bytes needed to DE
2232: 2B      	        dec     HL
2233: 2B      	        dec     HL
2234: 73      	        ld      (HL),E          ; Save LSB of bytes needed
2235: 23      	        inc     HL
2236: 72      	        ld      (HL),D          ; Save MSB of bytes needed
2237: 23      	        inc     HL
2238: F1      	        pop     AF              ; Locate / Create?
2239: DA6022  	        jp      C,ENDDIM        ; A is 0 , End if create
223C: 47      	FINDEL: ld      B,A             ; Find array element
223D: 4F      	        ld      C,A
223E: 7E      	        ld      A,(HL)          ; Number of dimensions
223F: 23      	        inc     HL
2240: 16      	        defb    $16             ; Skip "pop HL"
2241: E1      	FNDELP: pop     HL              ; Address of next dim' size
2242: 5E      	        ld      E,(HL)          ; Get LSB of dim'n size
2243: 23      	        inc     HL
2244: 56      	        ld      D,(HL)          ; Get MSB of dim'n size
2245: 23      	        inc     HL
2246: E3      	        ex      (SP),HL         ; Save address - Get index
2247: F5      	        push    AF              ; Save number of dim'ns
2248: CD1418  	        call    CPDEHL          ; Dimension too large?
224B: D2D921  	        jp      NC,BSERR        ; Yes - ?BS Error
224E: E5      	        push    HL              ; Save index
224F: CDA42D  	        call    MLDEBC          ; Multiply previous by size
2252: D1      	        pop     DE              ; Index supplied to DE
2253: 19      	        add     HL,DE           ; Add index to pointer
2254: F1      	        pop     AF              ; Number of dimensions
2255: 3D      	        dec     A               ; Count them
2256: 44      	        ld      B,H             ; MSB of pointer
2257: 4D      	        ld      C,L             ; LSB of pointer
2258: C24122  	        jp      NZ,FNDELP       ; More - Keep going
225B: 29      	        add     HL,HL           ; 4 Bytes per element
225C: 29      	        add     HL,HL
225D: C1      	        pop     BC              ; Start of array
225E: 09      	        add     HL,BC           ; Point to element
225F: EB      	        ex      DE,HL           ; Address of element to DE
2260: 2AB581  	ENDDIM: ld      HL,(NXTOPR)     ; Got code string address
2263: C9      	        ret
              	
              	
              	; returns the value of the 32-bit system tick counter as
              	; two 16-bit words
2264: CDB51E  	TMR:    call    TSTNUM          ; Make sure it's a number
2267: CDF31A  	        call    DEINT           ; Get integer (-32768 to 32767)
226A: 2ACE81  	        ld      HL,(TMRCNT)     ; load the LSBytes of timer
226D: 7B      	        ld      A,E
226E: B2      	        or      D               ; is it 0?
226F: CA7522  	        jp      Z,ENDTMR        ; yes, jump over
2272: 2AD081  	        ld      HL,(TMRCNT+2)   ; load the MSBytes of timer
2275: 45      	ENDTMR: ld      B,L             ; move bytes...
2276: 7C      	        ld      A,H             ; ...into AB
2277: C39C22  	        jp      ABPASS          ; return word into AB
              	
              	
              	; returns the free space for BASIC or into the string pool
227A: 2ABF81  	FRE:    ld      HL,(ARREND)     ; Start of free memory
227D: EB      	        ex      DE,HL           ; To DE
227E: 210000  	        ld      HL,$0000        ; End of free memory
2281: 39      	        add     HL,SP           ; Current stack value
2282: 3A9281  	        ld      A,(TYPE)        ; Dummy argument type
2285: B7      	        or      A
2286: CA9622  	        jp      Z,FRENUM        ; Numeric - Free variable space
2289: CDFD24  	        call    GSTRCU          ; Current string to pool
228C: CDFD23  	        call    GARBGE          ; Garbage collection
228F: 2AAD80  	        ld      HL,(STRSPC)     ; Bottom of string space in use
2292: EB      	        ex      DE,HL           ; To DE
2293: 2AA881  	        ld      HL,(STRBOT)     ; Bottom of string space
2296: 7D      	FRENUM: ld      A,L             ; Get LSB of end
2297: 93      	        sub     E               ; Subtract LSB of beginning
2298: 4F      	        ld      C,A             ; Save difference if C
2299: 7C      	        ld      A,H             ; Get MSB of end
229A: 9A      	        sbc     A,D             ; Subtract MSB of beginning
229B: 41      	ACPASS: ld      B,C             ; Return integer AC
229C: 50      	ABPASS: ld      D,B             ; Return integer AB
229D: 1E00    	        ld      E,$00
229F: 219281  	        ld      HL,TYPE         ; Point to type
22A2: 73      	        ld      (HL),E          ; Set type to numeric
22A3: 0690    	        ld      B,$80+$10       ; 16 bit integer
22A5: C3CF2C  	        jp      RETINT          ; Return the integer
              	
              	; returns the X position of the cursor during a print
22A8: 3A9081  	POS:    ld      A,(CURPOS)      ; Get cursor position
22AB: 47      	PASSA:  ld      B,A             ; Put A into AB
22AC: AF      	        xor     A               ; Zero A
22AD: C39C22  	        jp      ABPASS          ; Return integer AB
              	
22B0: CD3323  	DEF:    call    CHEKFN          ; Get "FN" and name
22B3: CD2523  	        call    IDTEST          ; Test for illegal direct
22B6: 01E01B  	        ld      BC,DATA         ; To get next statement
22B9: C5      	        push    BC              ; Save address for RETurn
22BA: D5      	        push    DE              ; Save address of function ptr
22BB: CD1A18  	        call    CHKSYN          ; Make sure "(" follows
22BE: 28      	        defb    '('
22BF: CDC120  	        call    GETVAR          ; Get argument variable name
22C2: E5      	        push    HL              ; Save code string address
22C3: EB      	        ex      DE,HL           ; Argument address to HL
22C4: 2B      	        dec     HL
22C5: 56      	        ld      D,(HL)          ; Get first byte of arg name
22C6: 2B      	        dec     HL
22C7: 5E      	        ld      E,(HL)          ; Get second byte of arg name
22C8: E1      	        pop     HL              ; Restore code string address
22C9: CDB51E  	        call    TSTNUM          ; Make sure numeric argument
22CC: CD1A18  	        call    CHKSYN          ; Make sure ")" follows
22CF: 29      	        defb    ')'
22D0: CD1A18  	        call    CHKSYN          ; Make sure "=" follows
22D3: C5      	        defb    ZEQUAL          ; "=" token
22D4: 44      	        ld      B,H             ; Code string address to BC
22D5: 4D      	        ld      C,L
22D6: E3      	        ex      (SP),HL         ; Save code str , Get FN ptr
22D7: 71      	        ld      (HL),C          ; Save LSB of FN code string
22D8: 23      	        inc     HL
22D9: 70      	        ld      (HL),B          ; Save MSB of FN code string
22DA: C37223  	        jp      SVSTAD          ; Save address and do function
              	
22DD: CD3323  	DOFN:   call    CHEKFN          ; Make sure FN follows
22E0: D5      	        push    DE              ; Save function pointer address
22E1: CD891F  	        call    EVLPAR          ; Evaluate expression in "()"
22E4: CDB51E  	        call    TSTNUM          ; Make sure numeric result
22E7: E3      	        ex      (SP),HL         ; Save code str , Get FN ptr
22E8: 5E      	        ld      E,(HL)          ; Get LSB of FN code string
22E9: 23      	        inc     HL
22EA: 56      	        ld      D,(HL)          ; Get MSB of FN code string
22EB: 23      	        inc     HL
22EC: 7A      	        ld      A,D             ; And function DEFined?
22ED: B3      	        or      E
22EE: CA4415  	        jp      Z,UFERR         ; No - ?UF Error
22F1: 7E      	        ld      A,(HL)          ; Get LSB of argument address
22F2: 23      	        inc     HL
22F3: 66      	        ld      H,(HL)          ; Get MSB of argument address
22F4: 6F      	        ld      L,A             ; HL = Arg variable address
22F5: E5      	        push    HL              ; Save it
22F6: 2AC381  	        ld      HL,(FNRGNM)     ; Get old argument name
22F9: E3      	        ex      (SP),HL         ; Save old , Get new
22FA: 22C381  	        ld      (FNRGNM),HL     ; Set new argument name
22FD: 2AC781  	        ld      HL,(FNARG+2)    ; Get LSB,NLSB of old arg value
2300: E5      	        push    HL              ; Save it
2301: 2AC581  	        ld      HL,(FNARG)      ; Get MSB,EXP of old arg value
2304: E5      	        push    HL              ; Save it
2305: 21C581  	        ld      HL,FNARG        ; HL = Value of argument
2308: D5      	        push    DE              ; Save FN code string address
2309: CD102D  	        call    FPTHL           ; Move FPREG to argument
230C: E1      	        pop     HL              ; Get FN code string address
230D: CDB21E  	        call    GETNUM          ; Get value from function
2310: 2B      	        dec     HL              ; dec 'cos GETCHR INCs
2311: CD3D1A  	        call    GETCHR          ; Get next character
2314: C23815  	        jp      NZ,SNERR        ; Bad character in FN - Error
2317: E1      	        pop     HL              ; Get MSB,EXP of old arg
2318: 22C581  	        ld      (FNARG),HL      ; Restore it
231B: E1      	        pop     HL              ; Get LSB,NLSB of old arg
231C: 22C781  	        ld      (FNARG+2),HL    ; Restore it
231F: E1      	        pop     HL              ; Get name of old arg
2320: 22C381  	        ld      (FNRGNM),HL     ; Restore it
2323: E1      	        pop     HL              ; Restore code string address
2324: C9      	        ret
              	
2325: E5      	IDTEST: push    HL              ; Save code string address
2326: 2AAF80  	        ld      HL,(LINEAT)     ; Get current line number
2329: 23      	        inc     HL              ; -1 means direct statement
232A: 7C      	        ld      A,H
232B: B5      	        or      L
232C: E1      	        pop     HL              ; Restore code string address
232D: C0      	        ret     NZ              ; Return if in program
232E: 1E16    	        ld      E,ID            ; ?ID Error
2330: C34C15  	        jp      ERROR
              	
2333: CD1A18  	CHEKFN: call    CHKSYN          ; Make sure FN follows
2336: B5      	        defb    ZFN             ; "FN" token
2337: 3E80    	        ld      A,$80
2339: 32B081  	        ld      (FORFLG),A      ; Flag FN name to find
233C: B6      	        or      (HL)            ; FN name has bit 7 set
233D: 47      	        ld      B,A             ; in first byte of name
233E: CDC620  	        call    GTFNAM          ; Get FN name
2341: C3B51E  	        jp      TSTNUM          ; Make sure numeric function
              	
2344: CDB51E  	STR:    call    TSTNUM          ; Make sure it's a number
2347: CD5D2E  	        call    NUMASC          ; Turn number into text
234A: CD7823  	STR1:   call    CRTST           ; Create string entry for it
234D: CDFD24  	        call    GSTRCU          ; Current string to pool
2350: 015825  	        ld      BC,TOPOOL       ; Save in string pool
2353: C5      	        push    BC              ; Save address on stack
              	
2354: 7E      	SAVSTR: ld      A,(HL)          ; Get string length
2355: 23      	        inc     HL
2356: 23      	        inc     HL
2357: E5      	        push    HL              ; Save pointer to string
2358: CDD323  	        call    TESTR           ; See if enough string space
235B: E1      	        pop     HL              ; Restore pointer to string
235C: 4E      	        ld      C,(HL)          ; Get LSB of address
235D: 23      	        inc     HL
235E: 46      	        ld      B,(HL)          ; Get MSB of address
235F: CD6C23  	        call    CRTMST          ; Create string entry
2362: E5      	        push    HL              ; Save pointer to MSB of addr
2363: 6F      	        ld      L,A             ; Length of string
2364: CDF024  	        call    TOSTRA          ; Move to string area
2367: D1      	        pop     DE              ; Restore pointer to MSB
2368: C9      	        ret
              	
2369: CDD323  	MKTMST: call    TESTR           ; See if enough string space
236C: 21A481  	CRTMST: ld      HL,TMPSTR       ; Temporary string
236F: E5      	        push    HL              ; Save it
2370: 77      	        ld      (HL),A          ; Save length of string
2371: 23      	        inc     HL
2372: 23      	SVSTAD: inc     HL
2373: 73      	        ld      (HL),E          ; Save LSB of address
2374: 23      	        inc     HL
2375: 72      	        ld      (HL),D          ; Save MSB of address
2376: E1      	        pop     HL              ; Restore pointer
2377: C9      	        ret
              	
2378: 2B      	CRTST:  dec     HL              ; dec - INCed after
2379: 0622    	QTSTR:  ld      B,$22           ; '"'           ; Terminating quote
237B: 50      	        ld      D,B             ; Quote to D
237C: E5      	DTSTR:  push    HL              ; Save start
237D: 0EFF    	        ld      C,-1            ; Set counter to -1
237F: 23      	QTSTLP: inc     HL              ; Move on
2380: 7E      	        ld      A,(HL)          ; Get byte
2381: 0C      	        inc     C               ; Count bytes
2382: B7      	        or      A               ; End of line?
2383: CA8E23  	        jp      Z,CRTSTE        ; Yes - Create string entry
2386: BA      	        cp      D               ; Terminator D found?
2387: CA8E23  	        jp      Z,CRTSTE        ; Yes - Create string entry
238A: B8      	        cp      B               ; Terminator B found?
238B: C27F23  	        jp      NZ,QTSTLP       ; No - Keep looking
238E: FE22    	CRTSTE: cp      $22             ; '"'             ; End with '"'?
2390: CC3D1A  	        call    Z,GETCHR        ; Yes - Get next character
2393: E3      	        ex      (SP),HL         ; Starting quote
2394: 23      	        inc     HL              ; First byte of string
2395: EB      	        ex      DE,HL           ; To DE
2396: 79      	        ld      A,C             ; Get length
2397: CD6C23  	        call    CRTMST          ; Create string entry
239A: 11A481  	TSTOPL: ld      DE,TMPSTR       ; Temporary string
239D: 2A9681  	        ld      HL,(TMSTPT)     ; Temporary string pool pointer
23A0: 22C981  	        ld      (FPREG),HL      ; Save address of string ptr
23A3: 3E01    	        ld      A,$01
23A5: 329281  	        ld      (TYPE),A        ; Set type to string
23A8: CD132D  	        call    DETHL4          ; Move string to pool
23AB: CD1418  	        call    CPDEHL          ; Out of string pool?
23AE: 229681  	        ld      (TMSTPT),HL     ; Save new pointer
23B1: E1      	        pop     HL              ; Restore code string address
23B2: 7E      	        ld      A,(HL)          ; Get next code byte
23B3: C0      	        ret     NZ              ; Return if pool OK
23B4: 1E1E    	        ld      E,ST            ; ?ST Error
23B6: C34C15  	        jp      ERROR           ; String pool overflow
              	
23B9: 23      	PRNUMS: inc     HL              ; Skip leading space
23BA: CD7823  	PRS:    call    CRTST           ; Create string entry for it
23BD: CDFD24  	PRS1:   call    GSTRCU          ; Current string to pool
23C0: CD072D  	        call    LOADFP          ; Move string block to BCDE
23C3: 1C      	        inc     E               ; Length + 1
23C4: 1D      	PRSLP:  dec     E               ; Count characters
23C5: C8      	        ret     Z               ; End of string
23C6: 0A      	        ld      A,(BC)          ; Get byte to output
23C7: CD2518  	        call    OUTC            ; Output character in A
23CA: FE0D    	        cp      CR              ; Return?
23CC: CC001D  	        call    Z,CNTEND        ; Yes - Position cursor to 0
23CF: 03      	        inc     BC              ; Next byte in string
23D0: C3C423  	        jp      PRSLP           ; More characters to output
              	
23D3: B7      	TESTR:  or      A               ; Test if enough room
23D4: 0E      	        defb    $0E             ; No garbage collection done
23D5: F1      	GRBDON: pop     AF              ; Garbage collection done
23D6: F5      	        push    AF              ; Save status
23D7: 2AAD80  	        ld      HL,(STRSPC)     ; Bottom of string space in use
23DA: EB      	        ex      DE,HL           ; To DE
23DB: 2AA881  	        ld      HL,(STRBOT)     ; Bottom of string area
23DE: 2F      	        cpl                     ; Negate length (Top down)
23DF: 4F      	        ld      C,A             ; -Length to BC
23E0: 06FF    	        ld      B,-1            ; BC = -ve length of string
23E2: 09      	        add     HL,BC           ; Add to bottom of space in use
23E3: 23      	        inc     HL              ; Plus one for 2's complement
23E4: CD1418  	        call    CPDEHL          ; Below string RAM area?
23E7: DAF123  	        jp      C,TESTOS        ; Tidy up if not done else err
23EA: 22A881  	        ld      (STRBOT),HL     ; Save new bottom of area
23ED: 23      	        inc     HL              ; Point to first byte of string
23EE: EB      	        ex      DE,HL           ; Address to DE
23EF: F1      	POPAF:  pop     AF              ; Throw away status push
23F0: C9      	        ret
              	
23F1: F1      	TESTOS: pop     AF              ; Garbage collect been done?
23F2: 1E1A    	        ld      E,OS            ; ?OS Error
23F4: CA4C15  	        jp      Z,ERROR         ; Yes - Not enough string space
23F7: BF      	        cp      A               ; Flag garbage collect done
23F8: F5      	        push    AF              ; Save status
23F9: 01D523  	        ld      BC,GRBDON       ; Garbage collection done
23FC: C5      	        push    BC              ; Save for RETurn
23FD: 2A9481  	GARBGE: ld      HL,(LSTRAM)     ; Get end of RAM pointer
2400: 22A881  	GARBLP: ld      (STRBOT),HL     ; Reset string pointer
2403: 210000  	        ld      HL,$0000
2406: E5      	        push    HL              ; Flag no string found
2407: 2AAD80  	        ld      HL,(STRSPC)     ; Get bottom of string space
240A: E5      	        push    HL              ; Save bottom of string space
240B: 219881  	        ld      HL,TMSTPL       ; Temporary string pool
240E: EB      	GRBLP:  ex      DE,HL
240F: 2A9681  	        ld      HL,(TMSTPT)     ; Temporary string pool pointer
2412: EB      	        ex      DE,HL
2413: CD1418  	        call    CPDEHL          ; Temporary string pool done?
2416: 010E24  	        ld      BC,GRBLP        ; Loop until string pool done
2419: C26224  	        jp      NZ,STPOOL       ; No - See if in string area
241C: 2ABB81  	        ld      HL,(PROGND)     ; Start of simple variables
241F: EB      	SMPVAR: ex      DE,HL
2420: 2ABD81  	        ld      HL,(VAREND)     ; End of simple variables
2423: EB      	        ex      DE,HL
2424: CD1418  	        call    CPDEHL          ; All simple strings done?
2427: CA3524  	        jp      Z,ARRLP         ; Yes - Do string arrays
242A: 7E      	        ld      A,(HL)          ; Get type of variable
242B: 23      	        inc     HL
242C: 23      	        inc     HL
242D: B7      	        or      A               ; "S" flag set if string
242E: CD6524  	        call    STRADD          ; See if string in string area
2431: C31F24  	        jp      SMPVAR          ; Loop until simple ones done
              	
2434: C1      	GNXARY: pop     BC              ; Scrap address of this array
2435: EB      	ARRLP:  ex      DE,HL
2436: 2ABF81  	        ld      HL,(ARREND)     ; End of string arrays
2439: EB      	        ex      DE,HL
243A: CD1418  	        call    CPDEHL          ; All string arrays done?
243D: CA8B24  	        jp      Z,SCNEND        ; Yes - Move string if found
2440: CD072D  	        call    LOADFP          ; Get array name to BCDE
2443: 7B      	        ld      A,E             ; Get type of array
2444: E5      	        push    HL              ; Save address of num of dim'ns
2445: 09      	        add     HL,BC           ; Start of next array
2446: B7      	        or      A               ; Test type of array
2447: F23424  	        jp      P,GNXARY        ; Numeric array - Ignore it
244A: 22AA81  	        ld      (CUROPR),HL     ; Save address of next array
244D: E1      	        pop     HL              ; Get address of num of dim'ns
244E: 4E      	        ld      C,(HL)          ; BC = Number of dimensions
244F: 0600    	        ld      B,$00
2451: 09      	        add     HL,BC           ; Two bytes per dimension size
2452: 09      	        add     HL,BC
2453: 23      	        inc     HL              ; Plus one for number of dim'ns
2454: EB      	GRBARY: ex      DE,HL
2455: 2AAA81  	        ld      HL,(CUROPR)     ; Get address of next array
2458: EB      	        ex      DE,HL
2459: CD1418  	        call    CPDEHL          ; Is this array finished?
245C: CA3524  	        jp      Z,ARRLP         ; Yes - Get next one
245F: 015424  	        ld      BC,GRBARY       ; Loop until array all done
2462: C5      	STPOOL: push    BC              ; Save return address
2463: F680    	        or      $80             ; Flag string type
2465: 7E      	STRADD: ld      A,(HL)          ; Get string length
2466: 23      	        inc     HL
2467: 23      	        inc     HL
2468: 5E      	        ld      E,(HL)          ; Get LSB of string address
2469: 23      	        inc     HL
246A: 56      	        ld      D,(HL)          ; Get MSB of string address
246B: 23      	        inc     HL
246C: F0      	        ret     P               ; Not a string - Return
246D: B7      	        or      A               ; Set flags on string length
246E: C8      	        ret     Z               ; Null string - Return
246F: 44      	        ld      B,H             ; Save variable pointer
2470: 4D      	        ld      C,L
2471: 2AA881  	        ld      HL,(STRBOT)     ; Bottom of new area
2474: CD1418  	        call    CPDEHL          ; String been done?
2477: 60      	        ld      H,B             ; Restore variable pointer
2478: 69      	        ld      L,C
2479: D8      	        ret     C               ; String done - Ignore
247A: E1      	        pop     HL              ; Return address
247B: E3      	        ex      (SP),HL         ; Lowest available string area
247C: CD1418  	        call    CPDEHL          ; String within string area?
247F: E3      	        ex      (SP),HL         ; Lowest available string area
2480: E5      	        push    HL              ; Re-save return address
2481: 60      	        ld      H,B             ; Restore variable pointer
2482: 69      	        ld      L,C
2483: D0      	        ret     NC              ; Outside string area - Ignore
2484: C1      	        pop     BC              ; Get return , Throw 2 away
2485: F1      	        pop     AF              ;
2486: F1      	        pop     AF              ;
2487: E5      	        push    HL              ; Save variable pointer
2488: D5      	        push    DE              ; Save address of current
2489: C5      	        push    BC              ; Put back return address
248A: C9      	        ret                     ; Go to it
              	
248B: D1      	SCNEND: pop     DE              ; Addresses of strings
248C: E1      	        pop     HL              ;
248D: 7D      	        ld      A,L             ; HL = 0 if no more to do
248E: B4      	        or      H
248F: C8      	        ret     Z               ; No more to do - Return
2490: 2B      	        dec     HL
2491: 46      	        ld      B,(HL)          ; MSB of address of string
2492: 2B      	        dec     HL
2493: 4E      	        ld      C,(HL)          ; LSB of address of string
2494: E5      	        push    HL              ; Save variable address
2495: 2B      	        dec     HL
2496: 2B      	        dec     HL
2497: 6E      	        ld      L,(HL)          ; HL = Length of string
2498: 2600    	        ld      H,$00
249A: 09      	        add     HL,BC           ; Address of end of string+1
249B: 50      	        ld      D,B             ; String address to DE
249C: 59      	        ld      E,C
249D: 2B      	        dec     HL              ; Last byte in string
249E: 44      	        ld      B,H             ; Address to BC
249F: 4D      	        ld      C,L
24A0: 2AA881  	        ld      HL,(STRBOT)     ; Current bottom of string area
24A3: CDE714  	        call    MOVSTR          ; Move string to new address
24A6: E1      	        pop     HL              ; Restore variable address
24A7: 71      	        ld      (HL),C          ; Save new LSB of address
24A8: 23      	        inc     HL
24A9: 70      	        ld      (HL),B          ; Save new MSB of address
24AA: 69      	        ld      L,C             ; Next string area+1 to HL
24AB: 60      	        ld      H,B
24AC: 2B      	        dec     HL              ; Next string area address
24AD: C30024  	        jp      GARBLP          ; Look for more strings
              	
24B0: C5      	CONCAT: push    BC              ; Save prec' opr & code string
24B1: E5      	        push    HL              ;
24B2: 2AC981  	        ld      HL,(FPREG)      ; Get first string
24B5: E3      	        ex      (SP),HL         ; Save first string
24B6: CD3B1F  	        call    OPRND           ; Get second string
24B9: E3      	        ex      (SP),HL         ; Restore first string
24BA: CDB61E  	        call    TSTSTR          ; Make sure it's a string
24BD: 7E      	        ld      A,(HL)          ; Get length of second string
24BE: E5      	        push    HL              ; Save first string
24BF: 2AC981  	        ld      HL,(FPREG)      ; Get second string
24C2: E5      	        push    HL              ; Save second string
24C3: 86      	        add     A,(HL)          ; Add length of second string
24C4: 1E1C    	        ld      E,LS            ; ?LS Error
24C6: DA4C15  	        jp      C,ERROR         ; String too long - Error
24C9: CD6923  	        call    MKTMST          ; Make temporary string
24CC: D1      	        pop     DE              ; Get second string to DE
24CD: CD0125  	        call    GSTRDE          ; Move to string pool if needed
24D0: E3      	        ex      (SP),HL         ; Get first string
24D1: CD0025  	        call    GSTRHL          ; Move to string pool if needed
24D4: E5      	        push    HL              ; Save first string
24D5: 2AA681  	        ld      HL,(TMPSTR+2)   ; Temporary string address
24D8: EB      	        ex      DE,HL           ; To DE
24D9: CDE724  	        call    SSTSA           ; First string to string area
24DC: CDE724  	        call    SSTSA           ; Second string to string area
24DF: 21D01E  	        ld      HL,EVAL2        ; Return to evaluation loop
24E2: E3      	        ex      (SP),HL         ; Save return,get code string
24E3: E5      	        push    HL              ; Save code string address
24E4: C39A23  	        jp      TSTOPL          ; To temporary string to pool
              	
24E7: E1      	SSTSA:  pop     HL              ; Return address
24E8: E3      	        ex      (SP),HL         ; Get string block,save return
24E9: 7E      	        ld      A,(HL)          ; Get length of string
24EA: 23      	        inc     HL
24EB: 23      	        inc     HL
24EC: 4E      	        ld      C,(HL)          ; Get LSB of string address
24ED: 23      	        inc     HL
24EE: 46      	        ld      B,(HL)          ; Get MSB of string address
24EF: 6F      	        ld      L,A             ; Length to L
24F0: 2C      	TOSTRA: inc     L               ; inc - DECed after
24F1: 2D      	TSALP:  dec     L               ; Count bytes moved
24F2: C8      	        ret     Z               ; End of string - Return
24F3: 0A      	        ld      A,(BC)          ; Get source
24F4: 12      	        ld      (DE),A          ; Save destination
24F5: 03      	        inc     BC              ; Next source
24F6: 13      	        inc     DE              ; Next destination
24F7: C3F124  	        jp      TSALP           ; Loop until string moved
              	
24FA: CDB61E  	GETSTR: call    TSTSTR          ; Make sure it's a string
24FD: 2AC981  	GSTRCU: ld      HL,(FPREG)      ; Get current string
2500: EB      	GSTRHL: ex      DE,HL           ; Save DE
2501: CD1B25  	GSTRDE: call    BAKTMP          ; Was it last tmp-str?
2504: EB      	        ex      DE,HL           ; Restore DE
2505: C0      	        ret     NZ              ; No - Return
2506: D5      	        push    DE              ; Save string
2507: 50      	        ld      D,B             ; String block address to DE
2508: 59      	        ld      E,C
2509: 1B      	        dec     DE              ; Point to length
250A: 4E      	        ld      C,(HL)          ; Get string length
250B: 2AA881  	        ld      HL,(STRBOT)     ; Current bottom of string area
250E: CD1418  	        call    CPDEHL          ; Last one in string area?
2511: C21925  	        jp      NZ,POPHL        ; No - Return
2514: 47      	        ld      B,A             ; Clear B (A=0)
2515: 09      	        add     HL,BC           ; Remove string from str' area
2516: 22A881  	        ld      (STRBOT),HL     ; Save new bottom of str' area
2519: E1      	POPHL:  pop     HL              ; Restore string
251A: C9      	        ret
              	
251B: 2A9681  	BAKTMP: ld      HL,(TMSTPT)     ; Get temporary string pool top
251E: 2B      	        dec     HL              ; Back
251F: 46      	        ld      B,(HL)          ; Get MSB of address
2520: 2B      	        dec     HL              ; Back
2521: 4E      	        ld      C,(HL)          ; Get LSB of address
2522: 2B      	        dec     HL              ; Back
2523: 2B      	        dec     HL              ; Back
2524: CD1418  	        call    CPDEHL          ; String last in string pool?
2527: C0      	        ret     NZ              ; Yes - Leave it
2528: 229681  	        ld      (TMSTPT),HL     ; Save new string pool top
252B: C9      	        ret
              	
252C: 01AB22  	LEN:    ld      BC,PASSA        ; To return integer A
252F: C5      	        push    BC              ; Save address
2530: CDFA24  	GETLEN: call    GETSTR          ; Get string and its length
2533: AF      	        xor     A
2534: 57      	        ld      D,A             ; Clear D
2535: 329281  	        ld      (TYPE),A        ; Set type to numeric
2538: 7E      	        ld      A,(HL)          ; Get length of string
2539: B7      	        or      A               ; Set status flags
253A: C9      	        ret
              	
253B: 01AB22  	ASC:    ld      BC,PASSA        ; To return integer A
253E: C5      	        push    BC              ; Save address
253F: CD3025  	GTFLNM: call    GETLEN          ; Get length of string
2542: CA081B  	        jp      Z,FCERR         ; Null string - Error
2545: 23      	        inc     HL
2546: 23      	        inc     HL
2547: 5E      	        ld      E,(HL)          ; Get LSB of address
2548: 23      	        inc     HL
2549: 56      	        ld      D,(HL)          ; Get MSB of address
254A: 1A      	        ld      A,(DE)          ; Get first byte of string
254B: C9      	        ret
              	
254C: 3E01    	CHR:    ld      A,$01           ; One character string
254E: CD6923  	        call    MKTMST          ; Make a temporary string
2551: CD3B27  	        call    MAKINT          ; Make it integer A
2554: 2AA681  	        ld      HL,(TMPSTR+2)   ; Get address of string
2557: 73      	        ld      (HL),E          ; Save character
2558: C1      	TOPOOL: pop     BC              ; Clean up stack
2559: C39A23  	        jp      TSTOPL          ; Temporary string to pool
              	
255C: CDEB26  	LEFT:   call    LFRGNM          ; Get number and ending ")"
255F: AF      	        xor     A               ; Start at first byte in string
2560: E3      	RIGHT1: ex      (SP),HL         ; Save code string,Get string
2561: 4F      	        ld      C,A             ; Starting position in string
2562: E5      	MID1:   push    HL              ; Save string block address
2563: 7E      	        ld      A,(HL)          ; Get length of string
2564: B8      	        cp      B               ; Compare with number given
2565: DA6A25  	        jp      C,ALLFOL        ; All following bytes required
2568: 78      	        ld      A,B             ; Get new length
2569: 11      	        defb    $11             ; Skip "ld C,0"
256A: 0E00    	ALLFOL: ld      C,$00           ; First byte of string
256C: C5      	        push    BC              ; Save position in string
256D: CDD323  	        call    TESTR           ; See if enough string space
2570: C1      	        pop     BC              ; Get position in string
2571: E1      	        pop     HL              ; Restore string block address
2572: E5      	        push    HL              ; And re-save it
2573: 23      	        inc     HL
2574: 23      	        inc     HL
2575: 46      	        ld      B,(HL)          ; Get LSB of address
2576: 23      	        inc     HL
2577: 66      	        ld      H,(HL)          ; Get MSB of address
2578: 68      	        ld      L,B             ; HL = address of string
2579: 0600    	        ld      B,$00           ; BC = starting address
257B: 09      	        add     HL,BC           ; Point to that byte
257C: 44      	        ld      B,H             ; BC = source string
257D: 4D      	        ld      C,L
257E: CD6C23  	        call    CRTMST          ; Create a string entry
2581: 6F      	        ld      L,A             ; Length of new string
2582: CDF024  	        call    TOSTRA          ; Move string to string area
2585: D1      	        pop     DE              ; Clear stack
2586: CD0125  	        call    GSTRDE          ; Move to string pool if needed
2589: C39A23  	        jp      TSTOPL          ; Temporary string to pool
              	
              	
              	; INSTR statement - look for a string inside another string
              	; usage: INSTR(A$,B$) -> search for B$ into A$
              	; return 0 if B$ is not contained into A$ or LEN(A$)<LEN(B$)
              	; return 1~255 to indicate the starting position of B$ into A$
              	; ex.: INSTR("HELLO","LO") returns 4
              	;PT=0
              	;DO
              	;  TF=0:TP=0
              	;  IF S1(PT)=S2(0) THEN
              	;    TF=1:TP=PT:PT1=PT:PT2=0
              	;    DO
              	;      IF S1(PT1)<>S2(PT2) THEN TF=0:EXIT
              	;      PT1=PT1+1
              	;      PT2=PT2+1
              	;    LOOP UNTIL PT2=LEN(S2)
              	;  IF TF<>0 THEN EXIT
              	;  PT=PT+1
              	;LOOP UNTIL PT>=LEN(S1)-LEN(S2)
              	;IF TF=0 THEN RETURN 0 ELSE RETURN TP
81EF:         	LNS1    equ     TMPBFR1
81F1:         	ADRS1   equ     TMPBFR2
81F3:         	LNS2    equ     TMPBFR3
81F5:         	ADRS2   equ     TMPBFR4
81F7:         	PT      equ     VIDEOBUFF
81F9:         	PT1     equ     VIDEOBUFF+2
81FB:         	PT2     equ     VIDEOBUFF+4
81FD:         	TP      equ     VIDEOBUFF+6
81FF:         	TF      equ     VIDEOBUFF+8
258C: CD1A18  	INSTR:  call    CHKSYN          ; make sure "(" follows
258F: 28      	        defb    '('
2590: 2B      	        dec     HL
2591: CD3D1A  	        call    GETCHR          ; check if something follows
2594: CA3815  	        jp      Z,SNERR         ; if nothing else, raise a syntax error
2597: CDC41E  	        call    EVAL            ; Evaluate expression
259A: CDB61E  	        call    TSTSTR          ; Make sure it's a string
259D: 22F781  	        ld      (VIDEOBUFF),HL  ; store code string pointer into a temp buffer
25A0: CDFD24  	        call    GSTRCU          ; check that a string follows
25A3: CD072D  	        call    LOADFP          ; Move string block to BCDE (BC=pointer, E=length)
25A6: ED53EF81	        ld      (LNS1),DE       ; store values into
25AA: ED43F181	        ld      (ADRS1),BC      ; temp buffers
25AE: 2AF781  	        ld      HL,(VIDEOBUFF)  ; retrieve code string pointer from temp buffer
25B1: CD1A18  	        call    CHKSYN          ; Make sure ',' follows
25B4: 2C      	        defb    ','
25B5: 2B      	        dec     HL
25B6: CD3D1A  	        call    GETCHR          ; check if something follows
25B9: CA3815  	        jp      Z,SNERR         ; if nothing else, raise a syntax error
25BC: CDC41E  	        call    EVAL            ; Evaluate expression
25BF: CDB61E  	        call    TSTSTR          ; Make sure it's a string
25C2: 22F781  	        ld      (VIDEOBUFF),HL  ; store code string pointer into a temp buffer
25C5: CDFD24  	        call    GSTRCU          ; check that a string follows
25C8: CD072D  	        call    LOADFP          ; Move string block to BCDE (BC=pointer, E=length)
25CB: ED53F381	        ld      (LNS2),DE       ; store values into
25CF: ED43F581	        ld      (ADRS2),BC      ; temp buffers
25D3: 2AF781  	        ld      HL,(VIDEOBUFF)  ; retrieve code string pointer from temp buffer
25D6: CD1A18  	        call    CHKSYN          ; make sure ")" follows
25D9: 29      	        defb    ')'
25DA: E5      	        push    HL              ; store current code string pointer (the point after the ")" ) ...
25DB: FDE1    	        pop     IY              ; ...into IY
25DD: AF      	        xor     A               ; reset 10 RAM cells
25DE: 060A    	        ld      B,$0A           ; (INSTR registers)
25E0: 21F781  	        ld      HL,PT           ; first cell
25E3: 77      	EMPTINS:ld      (HL),A          ; reset cell
25E4: 23      	        inc     HL              ; next cell
25E5: 10FC    	        djnz    EMPTINS         ; repeat
25E7: ED5BF381	        ld      DE,(LNS2)       ; load len(S2) into DE
25EB: 2AEF81  	        ld      HL,(LNS1)       ; load len(S1) into HL
25EE: CD483C  	        call    CMP16           ; check that len(S1)>=len(S2)
25F1: DA6626  	        jp      C,RZINSTR       ; if len(S2)>len(S1) then return 0
25F4: AF      	RPTINST:xor     A               ; reset...
25F5: 32FD81  	        ld      (TP),A          ; ...TP...
25F8: 32FF81  	        ld      (TF),A          ; ...and TF
25FB: ED4BF781	        ld      BC,(PT)         ; pointer to S1
25FF: 2AF181  	        ld      HL,(ADRS1)      ; first cell of S1
2602: 09      	        add     HL,BC           ; get current position into RAM
2603: 7E      	        ld      A,(HL)          ; load S1(PT)
2604: 2AF581  	        ld      HL,(ADRS2)      ; pointer to first char of S2
2607: BE      	        cp      (HL)            ; is S1(PT)=S2(0)?
2608: 203A    	        jr      NZ,CNT1INS      ; no, continue
260A: 3AF781  	        ld      A,(PT)          ; load current PT
260D: 32FD81  	        ld      (TP),A          ; TP=PT
2610: 32F981  	        ld      (PT1),A         ; P1=PT
2613: AF      	        xor     A               ; set...
2614: 32FB81  	        ld      (PT2),A         ; ...PT2=0
2617: 3C      	        inc     A               ;
2618: 32FF81  	        ld      (TF),A          ; set TF=1
261B: ED4BF981	RP2INST:ld      BC,(PT1)        ; load pointer PT1
261F: 2AF181  	        ld      HL,(ADRS1)      ; load address of S1
2622: 09      	        add     HL,BC           ; find char of S1 pointed by PT1
2623: 7E      	        ld      A,(HL)          ; load S1(PT1)
2624: ED4BFB81	        ld      BC,(PT2)        ; load pointer PT2
2628: 2AF581  	        ld      HL,(ADRS2)      ; load char of S2 pointed by PT2
262B: 09      	        add     HL,BC           ; find S2(PT2)
262C: BE      	        cp      (HL)            ; is S1(PT1)=S2(PT2)?
262D: 204C    	        jr      NZ,CNTZIN       ; no, exit inner loop
262F: 21F981  	        ld      HL,PT1
2632: 34      	        inc     (HL)            ; increment PT1
2633: 3AFB81  	        ld      A,(PT2)
2636: 3C      	        inc     A               ; increment PT2
2637: 32FB81  	        ld      (PT2),A
263A: CA4426  	        jp      Z,CNT1INS       ; if PT2>255 then exit
263D: 21F381  	        ld      HL,LNS2         ; len(S2)
2640: BE      	        cp      (HL)            ; PT2=len(S2)?
2641: DA1B26  	        jp      C,RP2INST       ; no (PT2<len(S2) - repeat
2644: 3AFF81  	CNT1INS:ld      A,(TF)          ; check TF
2647: A7      	        and     A               ; TF=0? (clears also Carry for next SBC)
2648: 201C    	        jr      NZ,RZINSTR      ; no, exit
264A: 2AEF81  	        ld      HL,(LNS1)       ; load len(S1)
264D: ED4BF381	        ld      BC,(LNS2)       ; load len(S2)
2651: ED42    	        sbc     HL,BC           ; HL=len(S1)-len(S2)
2653: ED5BF781	        ld      DE,(PT)         ; load pointer
2657: 1C      	        inc     E               ; PT=PT+1
2658: ED53F781	        ld      (PT),DE         ; store new value
265C: EB      	        ex      DE,HL           ; invert registers
265D: CD483C  	        call    CMP16           ; check if PT>len(S1)-len(S2)
2660: DAF425  	        jp      C,RPTINST       ; repeat if <
2663: CAF425  	        jp      Z,RPTINST       ; repeat if =
2666: 3AFF81  	RZINSTR:ld      A,(TF)          ; current value of TF
2669: A7      	        and     A               ; is it 0?
266A: CA7126  	        jp      Z,LVINSTR       ; yes, return 0
266D: 3AFD81  	        ld      A,(TP)          ; return TP...
2670: 3C      	        inc     A               ; ...incremented by 1
2671: E1      	LVINSTR:pop     HL              ; drop original return point
2672: FDE5    	        push    IY              ; load current string address from IY into stack
2674: 119D1F  	        ld      DE,RETNUM       ; Address of Return number from function...
2677: D5      	        push    DE              ; ...saved on stack
2678: C3AB22  	        jp      PASSA           ; return TP
267B: AF      	CNTZIN: xor     A               ; set...
267C: 32FF81  	        ld      (TF),A          ; TF=0
267F: C34426  	        jp      CNT1INS         ; continue
              	
              	
2682: CDEB26  	RIGHT:  call    LFRGNM          ; Get number and ending ")"
2685: D1      	        pop     DE              ; Get string length
2686: D5      	        push    DE              ; And re-save
2687: 1A      	        ld      A,(DE)          ; Get length
2688: 90      	        sub     B               ; Move back N bytes
2689: C36025  	        jp      RIGHT1          ; Go and get sub-string
              	
268C: EB      	MID:    ex      DE,HL           ; Get code string address
268D: 7E      	        ld      A,(HL)          ; Get next byte ',' or ")"
268E: CDF026  	        call    MIDNUM          ; Get number supplied
2691: 04      	        inc     B               ; Is it character zero?
2692: 05      	        dec     B
2693: CA081B  	        jp      Z,FCERR         ; Yes - Error
2696: C5      	        push    BC              ; Save starting position
2697: 1EFF    	        ld      E,$FF           ; All of string
2699: FE29    	        cp      ')'             ; Any length given?
269B: CAA526  	        jp      Z,RSTSTR        ; No - Rest of string
269E: CD1A18  	        call    CHKSYN          ; Make sure ',' follows
26A1: 2C      	        defb    ','
26A2: CD3827  	        call    GETINT          ; Get integer 0-255
26A5: CD1A18  	RSTSTR: call    CHKSYN          ; Make sure ")" follows
26A8: 29      	        defb    ')'
26A9: F1      	        pop     AF              ; Restore starting position
26AA: E3      	        ex      (SP),HL         ; Get string,save code string
26AB: 016225  	        ld      BC,MID1         ; Continuation of MID$ routine
26AE: C5      	        push    BC              ; Save for return
26AF: 3D      	        dec     A               ; Starting position-1
26B0: BE      	        cp      (HL)            ; Compare with length
26B1: 0600    	        ld      B,$00           ; Zero bytes length
26B3: D0      	        ret     NC              ; Null string if start past end
26B4: 4F      	        ld      C,A             ; Save starting position-1
26B5: 7E      	        ld      A,(HL)          ; Get length of string
26B6: 91      	        sub     C               ; Subtract start
26B7: BB      	        cp      E               ; Enough string for it?
26B8: 47      	        ld      B,A             ; Save maximum length available
26B9: D8      	        ret     C               ; Truncate string if needed
26BA: 43      	        ld      B,E             ; Set specified length
26BB: C9      	        ret                     ; Go and create string
              	
26BC: CD3025  	VAL:    call    GETLEN          ; Get length of string
26BF: CA872A  	        jp      Z,RESZER        ; Result zero
26C2: 5F      	        ld      E,A             ; Save length
26C3: 23      	        inc     HL
26C4: 23      	        inc     HL
26C5: 7E      	        ld      A,(HL)          ; Get LSB of address
26C6: 23      	        inc     HL
26C7: 66      	        ld      H,(HL)          ; Get MSB of address
26C8: 6F      	        ld      L,A             ; HL = String address
26C9: E5      	        push    HL              ; Save string address
26CA: 19      	        add     HL,DE
26CB: 46      	        ld      B,(HL)          ; Get end of string+1 byte
26CC: 72      	        ld      (HL),D          ; Zero it to terminate
26CD: E3      	        ex      (SP),HL         ; Save string end,get start
26CE: C5      	        push    BC              ; Save end+1 byte
26CF: 7E      	        ld      A,(HL)          ; Get starting byte
26D0: FE24    	        cp      '$'             ; Hex number indicated? [function added]
26D2: C2DA26  	        jp      NZ,VAL1
26D5: CD853B  	        call    HEXTFP          ; Convert Hex to FPREG
26D8: 180D    	        jr      VAL3
26DA: FE25    	VAL1:   cp      '%'             ; Binary number indicated? [function added]
26DC: C2E426  	        jp      NZ,VAL2
26DF: CDF53B  	        call    BINTFP          ; Convert Bin to FPREG
26E2: 1803    	        jr      VAL3
26E4: CDBF2D  	VAL2:   call    ASCTFP          ; Convert ASCII string to FP
26E7: C1      	VAL3:   pop     BC              ; Restore end+1 byte
26E8: E1      	        pop     HL              ; Restore end+1 address
26E9: 70      	        ld      (HL),B          ; Put back original byte
26EA: C9      	        ret
              	
26EB: EB      	LFRGNM: ex      DE,HL           ; Code string address to HL
26EC: CD1A18  	        call    CHKSYN          ; Make sure ")" follows
26EF: 29      	        defb    ')'
26F0: C1      	MIDNUM: pop     BC              ; Get return address
26F1: D1      	        pop     DE              ; Get number supplied
26F2: C5      	        push    BC              ; Re-save return address
26F3: 43      	        ld      B,E             ; Number to B
26F4: C9      	        ret
              	
26F5: CD3B27  	INP:    call    MAKINT          ; Make it integer A
26F8: 32A080  	        ld      (INPORT),A      ; Set input port
26FB: CD9F80  	        call    INPSUB          ; Get input from port
26FE: C3AB22  	        jp      PASSA           ; Return integer A
              	
2701: CD2527  	POUT:   call    SETIO           ; Set up port number
2704: C36780  	        jp      OUTSUB          ; Output data and return
              	
2707: CD2527  	WAIT:   call    SETIO           ; Set up port number
270A: F5      	        push    AF              ; Save AND mask
270B: 1E00    	        ld      E,$00           ; Assume zero if none given
270D: 2B      	        dec     HL              ; dec 'cos GETCHR INCs
270E: CD3D1A  	        call    GETCHR          ; Get next character
2711: CA1B27  	        jp      Z,NOXOR         ; No XOR byte given
2714: CD1A18  	        call    CHKSYN          ; Make sure ',' follows
2717: 2C      	        defb    ','
2718: CD3827  	        call    GETINT          ; Get integer 0-255 to XOR with
271B: C1      	NOXOR:  pop     BC              ; Restore AND mask
271C: CD9F80  	WAITLP: call    INPSUB          ; Get input
271F: AB      	        xor     E               ; Flip selected bits
2720: A0      	        and     B               ; Result non-zero?
2721: CA1C27  	        jp      Z,WAITLP        ; No = keep waiting
2724: C9      	        ret
              	
2725: CD3827  	SETIO:  call    GETINT          ; Get integer 0-255
2728: 32A080  	        ld      (INPORT),A      ; Set input port
272B: 326880  	        ld      (OTPORT),A      ; Set output port
272E: CD1A18  	        call    CHKSYN          ; Make sure ',' follows
2731: 2C      	        defb    ','
2732: C33827  	        jp      GETINT          ; Get integer 0-255 and return
              	
2735: CD3D1A  	FNDNUM: call    GETCHR          ; Get next character
2738: CDB21E  	GETINT: call    GETNUM          ; Get a number from 0 to 255
273B: CDED1A  	MAKINT: call    DEPINT          ; Make sure value 0 - 255
273E: 7A      	        ld      A,D             ; Get MSB of number
273F: B7      	        or      A               ; Zero?
2740: C2081B  	        jp      NZ,FCERR        ; No - Error
2743: 2B      	        dec     HL              ; dec 'cos GETCHR INCs
2744: CD3D1A  	        call    GETCHR          ; Get next character
2747: 7B      	        ld      A,E             ; Get number to A
2748: C9      	        ret
              	
              	
              	; activate a Non-Maskable Interrupt hooked to VDP interrupt signal
2749: CDB21E  	NMI:    call    GETNUM          ; Get memory address
274C: CDF31A  	        call    DEINT           ; get integer -32768 to 32767
274F: 7B      	        ld      A,E             ; check if address is 0
2750: B2      	        or      D
2751: 2011    	        jr      NZ,NM1          ; no, so jump over
2753: F3      	        di                      ; disable INTs
2754: CD8027  	        call    NMIDINT         ; disable VDP INT
2757: E5      	        push    HL              ; store HL
2758: 21ED45  	        ld      HL,$45ED        ; these are the op-codes for "RETN"
275B: 226180  	        ld      (NMIUSR),HL     ; store RETN
275E: AF      	        xor     A
275F: 326380  	        ld      (NMIUSR+2),A    ; "NOP"
2762: 1811    	        jr      NMI2            ; execute the last part of code
2764: E5      	NM1:    push    HL              ; store current HL
2765: EB      	        ex      DE,HL           ; move address argument into HL
2766: F3      	        di                      ; disable INTs
2767: CD8027  	        call    NMIDINT         ; disable VDP INT, if enabled
276A: 3EC3    	        ld      A,$C3           ; "jp" instruction
276C: 326180  	        ld      (NMIUSR),A      ; store it
276F: 226280  	        ld      (NMIUSR+1),HL   ; store address
2772: CD7927  	        call    NMIEINT         ; re-enable VDP INT
2775: FB      	NMI2:   ei                      ; re-enable INTS
2776: 00      	        nop                     ; wait for INTs
2777: E1      	        pop    HL               ; retrieve HL
2778: C9      	        ret                     ; return to caller
              	; enable VDP INT
2779: CD8F27  	NMIEINT:call    NMIVR1          ; load default VReg #1 setting
277C: F620    	        or      %00100000       ; enable VDP INT
277E: 1803    	        jr      NMIINT          ; rest of code is shared
              	; disable VDP INT
2780: CD8F27  	NMIDINT:call    NMIVR1          ; load default VReg #1 setting
2783: D5      	NMIINT: push    DE              ; store DE
2784: 5F      	        ld      E,A             ; move value into E
2785: 3E01    	        ld      A,$01           ; VREG #1
2787: F3      	        di                      ; disable INTs
2788: CD3406  	        call    WRITE_VREG      ; disable VDP INT
278B: FB      	        ei                      ; re-enable INTs
278C: 00      	        nop                     ; wait for INTs being enabled
278D: D1      	        pop     DE              ; retrieve DE
278E: C9      	        ret                     ; return to caller
              	
              	; load VREG #1 setting for current screen mode and return it into A
278F: E5      	NMIVR1: push    HL              ; store HL
2790: D5      	        push    DE              ; store DE
2791: 3AE081  	        ld      A,(SCR_MODE)    ; check screen mode
2794: 87      	        add     A,A             ; multiply A by 8...
2795: 87      	        add     A,A             ; ...so that reg. A can points..
2796: 87      	        add     A,A             ; to the correct settings
2797: 3C      	        inc     A               ; need to change VREG 1
2798: 5F      	        ld      E,A             ; copy A into E
2799: 1600    	        ld      D,$00           ; reset D
279B: 21350A  	        ld      HL,VDPMODESET   ; pointer to register #1 setting...
279E: 19      	        add     HL,DE           ; ...for current screen mode
279F: 7E      	        ld      A,(HL)          ; load current setting
27A0: D1      	        pop     DE              ; retrieve DE
27A1: E1      	        pop     HL              ; retrieve HL
27A2: C9      	        ret                     ; return to caller
              	
              	; execute a machine language routine, eventually passing a param into A
27A3: CDB21E  	SYS:    call    GETNUM          ; Get memory address
27A6: CDF31A  	        call    DEINT           ; Get integer -32768 to 32767
27A9: ED53F181	        ld      (TMPBFR2),DE    ; store user routine's address
27AD: AF      	        xor     A               ; reset A
27AE: 32EF81  	        ld      (TMPBFR1),A     ; store into temp buffer
27B1: 2B      	        dec     HL              ; dec 'cos GETCHR INCs
27B2: CD3D1A  	        call    GETCHR          ; check next character
27B5: 280A    	        jr      Z,NOSYSPR       ; jump if nothing follows
27B7: CD1A18  	        call    CHKSYN          ; Make sure ',' follows
27BA: 2C      	        defb    ','
27BB: CD3827  	        call    GETINT          ; get byte value (0~255) if something follows
27BE: 32EF81  	        ld      (TMPBFR1),A     ; store into temp buffer
27C1: 3AEF81  	NOSYSPR:ld      A,(TMPBFR1)     ; recover A
27C4: ED5BF181	        ld      DE,(TMPBFR2)    ; recover user routine's address
27C8: E5      	        push    HL              ; save code string address
27C9: EB      	        ex      DE,HL           ; move user routine's address into HL
27CA: 11CF27  	        ld      DE,SYSRET       ; set point of return after the user routine
27CD: D5      	        push    DE              ; store into stack
27CE: E9      	        jp      (HL)            ; call user routine
27CF: E1      	SYSRET: pop     HL              ; retrieve code string address
27D0: C9      	        ret                     ; return to caller
              	
              	
              	; read the contents of a byte from RAM
27D1: CDF31A  	PEEK:   call    DEINT           ; Get memory address into DE
27D4: 1A      	        ld      A,(DE)          ; Read value of memory cell
27D5: C3AB22  	        jp      PASSA           ; Return into A
              	
              	; read the contents of a byte from VRAM
27D8: CDF31A  	VPEEK:  call    DEINT           ; Get VRAM address into DE
27DB: EB      	        ex      DE,HL           ; Copy param into HL
27DC: F3      	        di                      ; Disable interrupts
27DD: CD0A06  	        call    READ_VIDEO_LOC  ; Read data from VRAM at address HL
27E0: FB      	        ei                      ; Re-enable interrupts
27E1: EB      	        ex      DE,HL           ; Restore HL
27E2: C3AB22  	        jp      PASSA           ; Return value into A
              	
              	; recover params for POKE/VPOKE commands
              	; returns address into DE and byte to be written into A
27E5: CDB21E  	PKEPRMS:call    GETNUM          ; Get memory address
27E8: CDF31A  	        call    DEINT           ; Get integer -32768 to 32767
27EB: ED53EF81	        ld      (TMPBFR1),DE    ; Store DE into a temp. buffer
27EF: CD1A18  	        call    CHKSYN          ; Make sure ',' follows
27F2: 2C      	        defb    ','
27F3: CD3827  	        call    GETINT          ; Get integer 0-255
27F6: ED5BEF81	        ld      DE,(TMPBFR1)    ; Restore memory address
27FA: C9      	        ret                     ; Return to caller
              	
              	; write a byte into SRAM
27FB: CDE527  	POKE:   call    PKEPRMS         ; Get params: address and value, return into DE and A, resp.
27FE: 12      	        ld      (DE),A          ; Load it into memory
27FF: C9      	        ret
              	
              	; write a byte into VRAM
2800: CDE527  	VPOKE:  call    PKEPRMS         ; Get params: address and value, return into DE and A, resp.
2803: EB      	        ex      DE,HL           ; Copy address into HL
2804: F3      	        di                      ; Disable interrupts
2805: CD1F06  	        call    WRITE_VIDEO_LOC ; write data into VRAM at address HL
2808: FB      	        ei                      ; Re-enable interrupts
2809: EB      	        ex      DE,HL           ; Restore HL
280A: C9      	        ret                     ; Return to caller
              	
              	; position the cursor at a specific X,Y location onto screen
280B: CD3827  	LOCATE: call    GETINT          ; get the first param into A
280E: E5      	        push    HL              ; store HL
280F: 21DE81  	        ld      HL,SCR_SIZE_W   ; load address of screen width
2812: 5E      	        ld      E,(HL)          ; load screen width into E
2813: E1      	        pop     HL              ; restore HL
2814: BB      	        cp      E               ; compare witdh with param
2815: D2081B  	        jp      NC,FCERR        ; value over the width of the screen, exit with Illegal F.C. error
2818: 32EF81  	        ld      (TMPBFR1),A     ; Store X into a temp. buffer
281B: CD1A18  	        call    CHKSYN          ; Make sure ',' follows
281E: 2C      	        defb    ','
281F: CD3827  	        call    GETINT          ; Get the second param into A
2822: E5      	        push    HL              ; store HL
2823: 21DF81  	        ld      HL,SCR_SIZE_H   ; load address of screen width
2826: 5E      	        ld      E,(HL)          ; load screen width into A
2827: E1      	        pop     HL              ; restore HL
2828: BB      	        cp      E               ; compare witdh with param
2829: D2081B  	        jp      NC,FCERR        ; value over the height of the screen, exit with Illegal F.C. error
282C: 32E781  	        ld      (SCR_CUR_NY),A  ; store new Y
282F: 3AEF81  	        ld      A,(TMPBFR1)     ; recover the new X
2832: 32E681  	        ld      (SCR_CUR_NX),A  ; store new X
2835: E5      	        push    HL              ; store HL
2836: F3      	        di                      ; disable INTs
2837: CD5006  	        call    MOVCRS          ; move cursor to new location
283A: FB      	        ei                      ; re-enable INTs
283B: E1      	        pop     HL              ; restore HL
283C: C9      	        ret                     ; return to caller
              	
              	; write a byte into one of the PSG registers
283D: CD3827  	SREG:   call    GETINT          ; Get register number back into A
2840: FE10    	        cp      $10             ; check if value >= 16 (PSG registers go from 0 to 15)
2842: D2081B  	        jp      NC,FCERR        ; If yes, exit and raise an Illegal function call Error
2845: 32EF81  	        ld      (TMPBFR1),A     ; Store A into a temp. buffer
2848: CD1A18  	        call    CHKSYN          ; Make sure ',' follows
284B: 2C      	        defb    ','
284C: CD3827  	        call    GETINT          ; get second value (0-255), returned into A
284F: 5F      	        ld      E,A             ; store value into E
2850: 3AEF81  	        ld      A,(TMPBFR1)     ; recover VDP register and store into D
2853: 0E40    	        ld      C,PSG_REG       ; output port to access PSG registers
2855: ED79    	        out     (C),A           ; send register # to PSG
2857: 0E41    	        ld      C,PSG_DAT       ; output port to send data to PSG
2859: ED59    	        out     (C),E           ; send byte to write into selected register
285B: C9      	        ret                     ; return to caller
              	
              	; VOLUME ch,vol
              	; set the volume for the audio channels
              	; "ch" is 1~3 for corresponding channel, or 0 for all; "vol" is 0~15 (0=OFF, 15=MAX)
285C: CD3827  	VOLUME: call    GETINT          ; get integer 0-255 (recover channel)
285F: FE04    	        cp      $04             ; check if it's in the range 0~3
2861: D2081B  	        jp      NC,FCERR        ; if not, exit with Illegal function call error
2864: 32EF81  	        ld      (TMPBFR1),A     ; Store A into a temp. buffer
2867: CD1A18  	        call    CHKSYN          ; Make sure ',' follows
286A: 2C      	        defb    ','
286B: CD3827  	        call    GETINT          ; get integer 0-255 (recover channel)
286E: FE10    	        cp      $10             ; check if it's in the range 0~15
2870: D2081B  	        jp      NC,FCERR        ; if not, exit with Illegal funcion call
2873: 57      	        ld      D,A             ; store volume into D
2874: 3AEF81  	        ld      A,(TMPBFR1)     ; retrieve channel
2877: A7      	        and     A               ; is it 0? (0=every channel)
2878: 2010    	        jr      NZ,VOLCH        ; no, jump over
287A: 0603    	        ld      B,$03           ; yes, set every channel
287C: 1E08    	        ld      E,$08           ; register volume of first channel
287E: 0E40    	RPVOLCG:ld      C,PSG_REG       ; PSG register port
2880: ED59    	        out     (C),E           ; set register #
2882: 0E41    	        ld      C,PSG_DAT       ; PSG data port
2884: ED51    	        out     (C),D           ; send volume
2886: 1C      	        inc     E               ; next register
2887: 10F5    	        djnz    RPVOLCG         ; repeat for each channel
2889: C9      	        ret                     ; return to caller
288A: 0E40    	VOLCH:  ld      C,PSG_REG       ; PSG register port
288C: C607    	        add     $07             ; add 7 to A so that we have the correct register (1->8, 2->9, 3->10)
288E: ED79    	        out     (C),A           ; set register
2890: 0E41    	        ld      C,PSG_DAT       ; PSG data port
2892: ED51    	        out     (C),D           ; send volume level
2894: C9      	        ret                     ; return to caller
              	
              	; SOUND ch,tone,dur
              	; play a tone or noise of "tone" frequency from selected channel "ch" for duration "dur"
              	; "ch" is 1~6 (0=means sound OFF,1~3 for tone, 4~6 for noise) / "tone" is 1~4,095 (0=means no tone) /
              	; "dur" is 1~16383 h.o.s.,0.001~163s (0=means non-stop tone)
2895: CD3827  	SOUND:  call    GETINT          ; get integer 0-255 (recover channel)
2898: A7      	        and     A               ; is it zero?
2899: 2006    	        jr      NZ,CTSNDC       ; no, continue with checking of params
289B: E5      	        push    HL              ; store HL
289C: CDA70B  	        call    CLRPSGREGS      ; yes, it's zero, so reset PSG registers to shut down every sound
289F: E1      	        pop     HL              ; retrieve HL
28A0: C9      	        ret                     ; return to caller
28A1: 32EF81  	CTSNDC: ld      (TMPBFR1),A     ; no, continue by storing A into a temp. buffer
28A4: FE04    	        cp      $04             ; is channel >3?
28A6: D22629  	        jp      NC,NOISUP       ; Yes - check to see if it's a noise channel
28A9: CD1A18  	        call    CHKSYN          ; No, continue checking by making sure ',' follows
28AC: 2C      	        defb    ','
28AD: CDB21E  	        call    GETNUM          ; Get tone frequency
28B0: CDF31A  	        call    DEINT           ; Get integer -32768 to 32767
28B3: ED53F181	        ld      (TMPBFR2),DE    ; Store frequency
28B7: CD1A18  	        call    CHKSYN          ; Make sure ',' follows
28BA: 2C      	        defb    ','
28BB: CDB21E  	        call    GETNUM          ; Get duration
28BE: CDF31A  	        call    DEINT           ; Get integer -32768 to 32767
28C1: ED53F381	        ld      (TMPBFR3),DE    ; Store duration
              	                                ; CHECK CHANNEL
28C5: 3AEF81  	        ld      A,(TMPBFR1)     ; recover channel
28C8: FE01    	        cp      $01             ; is channel <1?
28CA: DA081B  	        jp      C,FCERR         ; Yes - Illegal function call error
              	                                ; CHECK FREQUENCY
28CD: ED5BF181	        ld      DE,(TMPBFR2)    ; restore frequency from temp buffer
28D1: 7A      	        ld      A,D             ; move D into A and check if it is in the range 0~4095...
28D2: FE10    	        cp      $10             ; ...so D must not be greater than $0F (15)
28D4: D2081B  	        jp      NC,FCERR        ; if not in the range, exit with an Illegal function call error
              	                                ; CHECK DURATION
28D7: ED5BF381	        ld      DE,(TMPBFR3)    ; restore duration from temp buffer
28DB: 7A      	        ld      A,D             ; check if it is in the range 0~16383...
28DC: E6C0    	        and     $C0             ; ...(15th & 14th bits must not be set)
28DE: C2081B  	        jp      NZ,FCERR        ; if not in the range, exit with an Illegal function call error
              	                                ;
              	                                ; SET TONE:
              	                                ; let's start by setting up the channel
28E1: 3AEF81  	        ld      A,(TMPBFR1)     ; restore channel value
28E4: FE03    	        cp      $03             ; is it 3?
28E6: 2002    	        jr      NZ,SND1         ; no, jump over
28E8: 3E04    	        ld      A,%00000100     ; yes, for ch.3, set 3rd bit only (so A=001, B=010, C=100)
28EA: 2F      	SND1:   cpl                     ; complement of A - this is used later to set on the channel into the mixer
28EB: CD7129  	        call    WRTSND          ; enable line into mixer of channel stored in A
              	                                ; SET FREQUENCY
              	                                ; we simply get frequency and subtract from 4096. The result
              	                                ; is put into register pair of the corresponding freq tone channel
28EE: ED5BF181	        ld      DE,(TMPBFR2)    ; restore frequency from temp buffer
28F2: E5      	        push    HL              ; store HL (it will be used by the subroutine)
28F3: 210010  	        ld      HL,$1000        ; load 4096 into HL
28F6: A7      	        and     A               ; reset C flag
28F7: ED52    	        sbc     HL,DE           ; subtract freq from HL - now the frequency is inverted, so we will send the low as high and vice-versa
28F9: 3AEF81  	        ld      A,(TMPBFR1)     ; restore channel value
28FC: 3D      	        dec     A               ; set A into the range 0~2
28FD: 87      	        add     A,A             ; double A to find the register pair that correspond to the channel (A->0,1 / B->2,3, C->4,5)
28FE: 0E40    	        ld      C,PSG_REG       ; PSG register port
2900: ED79    	        out     (C),A           ; select first register of the pair
2902: 0E41    	        ld      C,PSG_DAT       ; PSG data port
2904: ED69    	        out     (C),L           ; send high byte
2906: 0E40    	        ld      C,PSG_REG       ; PSG register support
2908: 3C      	        inc     A               ; second register of the pair
2909: ED79    	        out     (C),A           ; select register
290B: 0E41    	        ld      C,PSG_DAT       ; PSG data port
290D: ED61    	        out     (C),H           ; send low byte
290F: ED5BF381	        ld      DE,(TMPBFR3)    ; recover duration
2913: 3AEF81  	        ld      A,(TMPBFR1)     ; recover channel value
2916: 3D      	        dec     A               ; set channel into the range 0~2
2917: 87      	        add     A,A             ; double A to find the correct offset
2918: 212382  	        ld      HL,CHASNDDTN    ; set duration into...
291B: 85      	        add     A,L             ; ...the proper...
291C: 3001    	        jr      NC,SNDOVR       ; (is there a rest? no, jump over
291E: 24      	        inc     H               ; yes, increment H)
291F: 6F      	SNDOVR: ld      L,A             ; ...register pair...
2920: 7323722B	        ld      (HL),DE         ; ...and store the value
2924: E1      	        pop     HL              ; retrieve HL
2925: C9      	        ret                     ; Return to caller
2926: FE07    	NOISUP: cp      $07             ; is channel in range 4 to 6 (for a noise)?
2928: D2081B  	        jp      NC,FCERR        ; no, so ILLEGAL FUNCTION CALL
292B: CD1A18  	        call    CHKSYN          ; yes, continue checking by making sure ',' follows
292E: 2C      	        defb    ','
292F: CD3827  	        call    GETINT          ; get integer 0-255 (frequency)
2932: FE20    	        cp      $20             ; make sure it's in range 0~31
2934: D2081B  	        jp      NC,FCERR        ; no, so Illegal function call
2937: 32F181  	        ld      (TMPBFR2),A     ; store freq.
293A: 2B      	        dec     HL              ; dec 'cos GETCHR INCs
293B: CD3D1A  	        call    GETCHR          ; check that nothing follows
293E: C23815  	        jp      NZ,SNERR        ; error if no empty line
2941: 3AF181  	        ld      A,(TMPBFR2)     ; retrieve freq.
2944: 5F      	        ld      E,A             ; store freq into E
2945: 3AEF81  	        ld      A,(TMPBFR1)     ; retrieve channel
2948: D603    	        sub     $03             ; subtract 3 to get channel in range 1~3
294A: FE03    	        cp      $03             ; is it 3?
294C: 2002    	        jr      NZ,NOS1         ; no, jump over
294E: 3E04    	        ld      A,%00000100     ; yes, for ch.3, set 3rd bit only (so A=001, B=010, C=100)
2950: 87      	NOS1:   add     A,A
2951: 87      	        add     A,A
2952: 87      	        add     A,A             ; let's move A 3 bits to left
2953: 47      	        ld      B,A             ; store channel into B
2954: 7B      	        ld      A,E             ; check if
2955: A7      	        and     A               ; freq is 0 (means that noise reproduction must be halted)
2956: 200A    	        jr      NZ,NOS2         ; no, so jump over
2958: 3E07    	        ld      A,$07           ; mixer register
295A: CDF50B  	        call    SETSNDREG       ; set mixer register
295D: ED78    	        in      A,(C)           ; load current mixer value
295F: B0      	        or      B               ; disable noise
2960: 1818    	        jr      NOS3            ; continue over
2962: 78      	NOS2:   ld      A,B             ; recover channel
2963: 2F      	        cpl                     ; complement of A - this is used to set on the channel into the mixer
2964: CD7129  	        call    WRTSND          ; enable line into mixer of channel stored in A
2967: 3E06    	        ld      A,$06           ; write into noise register
2969: CDF50B  	        call    SETSNDREG       ; set register into PSG
296C: 7B      	        ld      A,E             ; load value for noise frequency
296D: CDFA0B  	        call    WRTSNDREG       ; write data into register $06
2970: C9      	        ret
              	        ; enable line into mixer of channel stored in A
2971: 47      	WRTSND: ld      B,A             ; move channel into B
2972: 3E07    	        ld      A,$07           ; mixer register
2974: CDF50B  	        call    SETSNDREG       ; set mixer register
2977: ED78    	        in      A,(C)           ; load current value
2979: A0      	        and     B               ; set on the channel into the mixer (remember that 0=ON)
              	                                ; example: if channel is A (1), complement of 1 is 254 (11111110). So, 255 (in case
              	                                ; the register is still unchanged after reset) is 11111111 and
              	                                ; 11111111 AND 11111110 is equal to 11111110
              	                                ; 11111001 AND 11111110 is equal to 11111000 (in case channels B & C are ON)
297A: 47      	NOS3:   ld      B,A
297B: 3E07    	        ld      A,$07
297D: CDF50B  	        call    SETSNDREG
2980: 78      	        ld      A,B
2981: 00      	        nop
2982: CDFA0B  	        call    WRTSNDREG       ; send new value for the mixer
2985: C9      	        ret                     ; return to caller
              	
              	; write a byte into one of the VDP registers
2986: CD3827  	VREG:   call    GETINT          ; Get register number back into A
2989: FE08    	        cp      $08             ; check if value is equal or greater than 8 (VDP registers are only 8, from 0 to 7)
298B: D2081B  	        jp      NC,FCERR        ; If yes, exit and raise an Illegal function call Error
298E: 32EF81  	        ld      (TMPBFR1),A     ; Store A into a temp. buffer
2991: CD1A18  	        call    CHKSYN          ; Make sure ',' follows
2994: 2C      	        defb    ','
2995: CD3827  	        call    GETINT          ; get value (0-255)
2998: 5F      	        ld      E,A             ; store value into E
2999: 3AEF81  	        ld      A,(TMPBFR1)     ; recover VDP register and store into A
299C: F3      	        di                      ; disable INTs
299D: CD3406  	        call    WRITE_VREG      ; write value into VDP register
29A0: FB      	        ei                      ; re-enable INTs
29A1: C9      	        ret                     ; return to caller
              	
              	; read the VDP status register and return it into A
29A2: CDF31A  	VSTAT:  call    DEINT           ; Get integer -32768 to 32767 (Note: we do NOT use it)
29A5: F3      	        di                      ; disable INTs
29A6: CD3F06  	        call    READ_VSTAT      ; read VDP register status
29A9: FB      	        ei                      ; re-enable INTs
29AA: C3AB22  	        jp      PASSA           ; Return integer A
              	
              	; read from PSG register and return it into A
29AD: CDF31A  	SSTAT:  call    DEINT           ; get integer -32768 to 32767
29B0: 7B      	        ld      A,E             ; consider LSB
29B1: FE10    	        cp      $10             ; check if value >= 16 (PSG registers go from 0 to 15)
29B3: D2081B  	        jp      NC,FCERR        ; If yes, exit and raise an Illegal function call Error
29B6: 0E40    	        ld      C,PSG_REG       ; output port to set PSG register
29B8: ED79    	        out     (C),A           ; send register to read from
29BA: ED78    	        in      A,(C)           ; read register's contents and store into A
29BC: C3AB22  	        jp      PASSA           ; return A
              	
              	; read the temp key buffer and return the value of the current key being pressed
              	; can wait for the number of 100thds of second before to return
29BF: CD2523  	INKEY:  call    IDTEST          ; Test for illegal direct
29C2: CDF31A  	        call    DEINT           ; get number param (100thds of second to wait) into DE
29C5: C5      	        push    BC              ; store BC
29C6: 3ACE81  	        ld      A,(TMRCNT)      ; Load current value of system timer
29C9: 47      	        ld      B,A             ; move it into B
29CA: 3ACE81  	CMP_A:  ld      A,(TMRCNT)      ; make a little delay of 1/100 sec...
29CD: B8      	        cp      B               ; ...to let the sniffer collect...
29CE: 20FA    	        jr      NZ,CMP_A        ; ...at least 1 char before to continue
29D0: 7A      	        ld      A,D             ; check the param
29D1: B3      	        or      E               ; if DE<>0 then...
29D2: 2005    	        jr      NZ,INKEY2       ; ...jump over...
29D4: 3A2B82  	        ld      A,(TMPKEYBFR)   ; ...else read the buffer and...
29D7: 182A    	        jr      ENDINK          ; ...return it
29D9: 7A      	INKEY2: ld      A,D             ; check if param>1023
29DA: FE04    	        cp      $04             ; to do this we check if MSB>3
29DC: D2081B  	        jp      NC,FCERR        ; if MSB >=4 then error
29DF: E5      	        push    HL              ; store HL
29E0: 210900  	        ld      HL,$0009        ; check if value
29E3: CD483C  	        call    CMP16           ; is < 10
29E6: E1      	        pop     HL              ; retrieve HL
29E7: DAED29  	        jp      C,SRTINK        ; if value >= 10 then jump over
29EA: 110A00  	        ld      DE,$000A        ; else, use 10 (no intervals shorter than 10/100s)
29ED: 3ACE81  	SRTINK: ld      A,(TMRCNT)      ; Load the first byte of the system timer
29F0: 47      	        ld      B,A             ; move it into B
29F1: 3A2B82  	CHKINK: ld      A,(TMPKEYBFR)   ; load char code from buffer
29F4: A7      	        and     A               ; is it 0?
29F5: 200C    	        jr      NZ,ENDINK       ; no, so we can return it
29F7: 3ACE81  	        ld      A,(TMRCNT)      ; load the first byte of the system timer
29FA: B8      	        cp      B               ; is it the same value?
29FB: 28F4    	        jr      Z,CHKINK        ; yes, so read again
29FD: 47      	        ld      B,A             ; store new value
29FE: 1B      	        dec     DE              ; no, decrement timer
29FF: 7A      	        ld      A,D             ; check if zero reached
2A00: B3      	        or      E               ; by ORing D and E
2A01: 20EE    	        jr      NZ,CHKINK       ; if not 0, repeat
2A03: C1      	ENDINK: pop     BC              ; restore BC
2A04: F5      	        push    AF              ; store A
2A05: F3      	        di                      ; disable INTs
2A06: AF      	        xor     A               ; clear the...
2A07: 322B82  	        ld      (TMPKEYBFR),A   ; ...TMP KEY buffer for the next read
2A0A: FB      	        ei                      ; re-enable INTs
2A0B: F1      	        pop     AF              ; retrieve A
2A0C: C3AB22  	ENDINK2:jp      PASSA           ; return A as ASCII value
              	
2A0F: 21362F  	ROUND:  ld      HL,HALF         ; Add 0.5 to FPREG
2A12: CD072D  	ADDPHL: call    LOADFP          ; Load FP at (HL) to BCDE
2A15: C3212A  	        jp      FPADD           ; Add BCDE to FPREG
              	
2A18: CD072D  	SUBPHL: call    LOADFP          ; FPREG = -FPREG + number at HL
2A1B: 21      	        defb    $21             ; Skip "pop BC" and "pop DE"
2A1C: C1      	PSUB:   pop     BC              ; Get FP number from stack
2A1D: D1      	        pop     DE
2A1E: CDE12C  	SUBCDE: call    INVSGN          ; Negate FPREG
2A21: 78      	FPADD:  ld      A,B             ; Get FP exponent
2A22: B7      	        or      A               ; Is number zero?
2A23: C8      	        ret     Z               ; Yes - Nothing to add
2A24: 3ACC81  	        ld      A,(FPEXP)       ; Get FPREG exponent
2A27: B7      	        or      A               ; Is this number zero?
2A28: CAF92C  	        jp      Z,FPBCDE        ; Yes - Move BCDE to FPREG
2A2B: 90      	        sub     B               ; BCDE number larger?
2A2C: D23B2A  	        jp      NC,NOSWAP       ; No - Don't swap them
2A2F: 2F      	        cpl                     ; Two's complement
2A30: 3C      	        inc     A               ;  FP exponent
2A31: EB      	        ex      DE,HL
2A32: CDE92C  	        call    STAKFP          ; Put FPREG on stack
2A35: EB      	        ex      DE,HL
2A36: CDF92C  	        call    FPBCDE          ; Move BCDE to FPREG
2A39: C1      	        pop     BC              ; Restore number from stack
2A3A: D1      	        pop     DE
2A3B: FE19    	NOSWAP: cp      24+1            ; Second number insignificant?
2A3D: D0      	        ret     NC              ; Yes - First number is result
2A3E: F5      	        push    AF              ; Save number of bits to scale
2A3F: CD1E2D  	        call    SIGNS           ; Set MSBs & sign of result
2A42: 67      	        ld      H,A             ; Save sign of result
2A43: F1      	        pop     AF              ; Restore scaling factor
2A44: CDE62A  	        call    SCALE           ; Scale BCDE to same exponent
2A47: B4      	        or      H               ; Result to be positive?
2A48: 21C981  	        ld      HL,FPREG        ; Point to FPREG
2A4B: F2612A  	        jp      P,MINCDE        ; No - Subtract FPREG from CDE
2A4E: CDC62A  	        call    PLUCDE          ; Add FPREG to CDE
2A51: D2A72A  	        jp      NC,RONDUP       ; No overflow - Round it up
2A54: 23      	        inc     HL              ; Point to exponent
2A55: 34      	        inc     (HL)            ; Increment it
2A56: CA4715  	        jp      Z,OVERR         ; Number overflowed - Error
2A59: 2E01    	        ld      L,$01           ; 1 bit to shift right
2A5B: CDFC2A  	        call    SHRT1           ; Shift result right
2A5E: C3A72A  	        jp      RONDUP          ; Round it up
              	
2A61: AF      	MINCDE: xor     A               ; Clear A and carry
2A62: 90      	        sub     B               ; Negate exponent
2A63: 47      	        ld      B,A             ; Re-save exponent
2A64: 7E      	        ld      A,(HL)          ; Get LSB of FPREG
2A65: 9B      	        sbc     A, E            ; Subtract LSB of BCDE
2A66: 5F      	        ld      E,A             ; Save LSB of BCDE
2A67: 23      	        inc     HL
2A68: 7E      	        ld      A,(HL)          ; Get NMSB of FPREG
2A69: 9A      	        sbc     A,D             ; Subtract NMSB of BCDE
2A6A: 57      	        ld      D,A             ; Save NMSB of BCDE
2A6B: 23      	        inc     HL
2A6C: 7E      	        ld      A,(HL)          ; Get MSB of FPREG
2A6D: 99      	        sbc     A,C             ; Subtract MSB of BCDE
2A6E: 4F      	        ld      C,A             ; Save MSB of BCDE
2A6F: DCD22A  	CONPOS: call    C,COMPL         ; Overflow - Make it positive
              	
2A72: 68      	BNORM:  ld      L,B             ; L = Exponent
2A73: 63      	        ld      H,E             ; H = LSB
2A74: AF      	        xor     A
2A75: 47      	BNRMLP: ld      B,A             ; Save bit count
2A76: 79      	        ld      A,C             ; Get MSB
2A77: B7      	        or      A               ; Is it zero?
2A78: C2942A  	        jp      NZ,PNORM        ; No - Do it bit at a time
2A7B: 4A      	        ld      C,D             ; MSB = NMSB
2A7C: 54      	        ld      D,H             ; NMSB= LSB
2A7D: 65      	        ld      H,L             ; LSB = VLSB
2A7E: 6F      	        ld      L,A             ; VLSB= 0
2A7F: 78      	        ld      A,B             ; Get exponent
2A80: D608    	        sub     $08             ; Count 8 bits
2A82: FEE0    	        cp      -24-8           ; Was number zero?
2A84: C2752A  	        jp      NZ,BNRMLP       ; No - Keep normalising
2A87: AF      	RESZER: xor     A               ; Result is zero
2A88: 32CC81  	SAVEXP: ld      (FPEXP),A       ; Save result as zero
2A8B: C9      	        ret
              	
2A8C: 05      	NORMAL: dec     B               ; Count bits
2A8D: 29      	        add     HL,HL           ; Shift HL left
2A8E: 7A      	        ld      A,D             ; Get NMSB
2A8F: 17      	        rla                     ; Shift left with last bit
2A90: 57      	        ld      D,A             ; Save NMSB
2A91: 79      	        ld      A,C             ; Get MSB
2A92: 8F      	        adc     A,A             ; Shift left with last bit
2A93: 4F      	        ld      C,A             ; Save MSB
2A94: F28C2A  	PNORM:  jp      P,NORMAL        ; Not done - Keep going
2A97: 78      	        ld      A,B             ; Number of bits shifted
2A98: 5C      	        ld      E,H             ; Save HL in EB
2A99: 45      	        ld      B,L
2A9A: B7      	        or      A               ; Any shifting done?
2A9B: CAA72A  	        jp      Z,RONDUP        ; No - Round it up
2A9E: 21CC81  	        ld      HL,FPEXP        ; Point to exponent
2AA1: 86      	        add     A,(HL)          ; Add shifted bits
2AA2: 77      	        ld      (HL),A          ; Re-save exponent
2AA3: D2872A  	        jp      NC,RESZER       ; Underflow - Result is zero
2AA6: C8      	        ret     Z               ; Result is zero
2AA7: 78      	RONDUP: ld      A,B             ; Get VLSB of number
2AA8: 21CC81  	RONDB:  ld      HL,FPEXP        ; Point to exponent
2AAB: B7      	        or      A               ; Any rounding?
2AAC: FCB92A  	        call    M,FPROND        ; Yes - Round number up
2AAF: 46      	        ld      B,(HL)          ; B = Exponent
2AB0: 23      	        inc     HL
2AB1: 7E      	        ld      A,(HL)          ; Get sign of result
2AB2: E680    	        and     %10000000       ; Only bit 7 needed
2AB4: A9      	        xor     C               ; Set correct sign
2AB5: 4F      	        ld      C,A             ; Save correct sign in number
2AB6: C3F92C  	        jp      FPBCDE          ; Move BCDE to FPREG
              	
2AB9: 1C      	FPROND: inc     E               ; Round LSB
2ABA: C0      	        ret     NZ              ; Return if ok
2ABB: 14      	        inc     D               ; Round NMSB
2ABC: C0      	        ret     NZ              ; Return if ok
2ABD: 0C      	        inc     C               ; Round MSB
2ABE: C0      	        ret     NZ              ; Return if ok
2ABF: 0E80    	        ld      C,$80           ; Set normal value
2AC1: 34      	        inc     (HL)            ; Increment exponent
2AC2: C0      	        ret     NZ              ; Return if ok
2AC3: C34715  	        jp      OVERR           ; Overflow error
              	
2AC6: 7E      	PLUCDE: ld      A,(HL)          ; Get LSB of FPREG
2AC7: 83      	        add     A,E             ; Add LSB of BCDE
2AC8: 5F      	        ld      E,A             ; Save LSB of BCDE
2AC9: 23      	        inc     HL
2ACA: 7E      	        ld      A,(HL)          ; Get NMSB of FPREG
2ACB: 8A      	        adc     A,D             ; Add NMSB of BCDE
2ACC: 57      	        ld      D,A             ; Save NMSB of BCDE
2ACD: 23      	        inc     HL
2ACE: 7E      	        ld      A,(HL)          ; Get MSB of FPREG
2ACF: 89      	        adc     A,C             ; Add MSB of BCDE
2AD0: 4F      	        ld      C,A             ; Save MSB of BCDE
2AD1: C9      	        ret
              	
2AD2: 21CD81  	COMPL:  ld      HL,SGNRES       ; Sign of result
2AD5: 7E      	        ld      A,(HL)          ; Get sign of result
2AD6: 2F      	        cpl                     ; Negate it
2AD7: 77      	        ld      (HL),A          ; Put it back
2AD8: AF      	        xor     A
2AD9: 6F      	        ld      L,A             ; Set L to zero
2ADA: 90      	        sub     B               ; Negate exponent,set carry
2ADB: 47      	        ld      B,A             ; Re-save exponent
2ADC: 7D      	        ld      A,L             ; Load zero
2ADD: 9B      	        sbc     A,E             ; Negate LSB
2ADE: 5F      	        ld      E,A             ; Re-save LSB
2ADF: 7D      	        ld      A,L             ; Load zero
2AE0: 9A      	        sbc     A,D             ; Negate NMSB
2AE1: 57      	        ld      D,A             ; Re-save NMSB
2AE2: 7D      	        ld      A,L             ; Load zero
2AE3: 99      	        sbc     A,C             ; Negate MSB
2AE4: 4F      	        ld      C,A             ; Re-save MSB
2AE5: C9      	        ret
              	
2AE6: 0600    	SCALE:  ld      B,$00           ; Clear underflow
2AE8: D608    	SCALLP: sub     $08             ; 8 bits (a whole byte)?
2AEA: DAF52A  	        jp      C,SHRITE        ; No - Shift right A bits
2AED: 43      	        ld      B,E             ; <- Shift
2AEE: 5A      	        ld      E,D             ; <- right
2AEF: 51      	        ld      D,C             ; <- eight
2AF0: 0E00    	        ld      C,$00           ; <- bits
2AF2: C3E82A  	        jp      SCALLP          ; More bits to shift
              	
2AF5: C609    	SHRITE: add     A,8+1           ; Adjust count
2AF7: 6F      	        ld      L,A             ; Save bits to shift
2AF8: AF      	SHRLP:  xor     A               ; Flag for all done
2AF9: 2D      	        dec     L               ; All shifting done?
2AFA: C8      	        ret     Z               ; Yes - Return
2AFB: 79      	        ld      A,C             ; Get MSB
2AFC: 1F      	SHRT1:  rra                     ; Shift it right
2AFD: 4F      	        ld      C,A             ; Re-save
2AFE: 7A      	        ld      A,D             ; Get NMSB
2AFF: 1F      	        rra                     ; Shift right with last bit
2B00: 57      	        ld      D,A             ; Re-save it
2B01: 7B      	        ld      A,E             ; Get LSB
2B02: 1F      	        rra                     ; Shift right with last bit
2B03: 5F      	        ld      E,A             ; Re-save it
2B04: 78      	        ld      A,B             ; Get underflow
2B05: 1F      	        rra                     ; Shift right with last bit
2B06: 47      	        ld      B,A             ; Re-save underflow
2B07: C3F82A  	        jp      SHRLP           ; More bits to do
              	
2B0A: 00000081	UNITY:  defb    $00,$00,$00,$81 ; 1.00000
              	
2B0E: 03      	LOGTAB: defb    $03             ; Table used by LOG
2B0F: AA561980	        defb    $AA,$56,$19,$80 ; 0.59898
2B13: F1227680	        defb    $F1,$22,$76,$80 ; 0.96147
2B17: 45AA3882	        defb    $45,$AA,$38,$82 ; 2.88539
              	
2B1B: CDB82C  	LOG:    call    TSTSGN          ; Test sign of value
2B1E: B7      	        or      A
2B1F: EA081B  	        jp      PE,FCERR        ; ?FC Error if <= zero
2B22: 21CC81  	        ld      HL,FPEXP        ; Point to exponent
2B25: 7E      	        ld      A,(HL)          ; Get exponent
2B26: 013580  	        ld      BC,$8035        ; BCDE = SQR(1/2)
2B29: 11F304  	        ld      DE,$04F3
2B2C: 90      	        sub     B               ; Scale value to be < 1
2B2D: F5      	        push    AF              ; Save scale factor
2B2E: 70      	        ld      (HL),B          ; Save new exponent
2B2F: D5      	        push    DE              ; Save SQR(1/2)
2B30: C5      	        push    BC
2B31: CD212A  	        call    FPADD           ; Add SQR(1/2) to value
2B34: C1      	        pop     BC              ; Restore SQR(1/2)
2B35: D1      	        pop     DE
2B36: 04      	        inc     B               ; Make it SQR(2)
2B37: CD0E2C  	        call    DVBCDE          ; Divide by SQR(2)
2B3A: 210A2B  	        ld      HL,UNITY        ; Point to 1.
2B3D: CD182A  	        call    SUBPHL          ; Subtract FPREG from 1
2B40: 210E2B  	        ld      HL,LOGTAB       ; Coefficient table
2B43: CD0030  	        call    SUMSER          ; Evaluate sum of series
2B46: 018080  	        ld      BC,$8080        ; BCDE = -0.5
2B49: 110000  	        ld      DE,$0000
2B4C: CD212A  	        call    FPADD           ; Subtract 0.5 from FPREG
2B4F: F1      	        pop     AF              ; Restore scale factor
2B50: CD332E  	        call    RSCALE          ; Re-scale number
2B53: 013180  	MULLN2: ld      BC,$8031        ; BCDE = Ln(2)
2B56: 111872  	        ld      DE,$7218
2B59: 21      	        defb    $21             ; Skip "pop BC" and "pop DE"
              	
2B5A: C1      	MULT:   pop     BC              ; Get number from stack
2B5B: D1      	        pop     DE
2B5C: CDB82C  	FPMULT: call    TSTSGN          ; Test sign of FPREG
2B5F: C8      	        ret     Z               ; Return zero if zero
2B60: 2E00    	        ld      L,$00           ; Flag add exponents
2B62: CD762C  	        call    ADDEXP          ; Add exponents
2B65: 79      	        ld      A,C             ; Get MSB of multiplier
2B66: 323D82  	        ld      (MULVAL),A      ; Save MSB of multiplier
2B69: EB      	        ex      DE,HL
2B6A: 223E82  	        ld      (MULVAL+1),HL   ; Save rest of multiplier
2B6D: 010000  	        ld      BC,$0000        ; Partial product (BCDE) = zero
2B70: 50      	        ld      D,B
2B71: 58      	        ld      E,B
2B72: 21722A  	        ld      HL,BNORM        ; Address of normalise
2B75: E5      	        push    HL              ; Save for return
2B76: 217E2B  	        ld      HL,MULT8        ; Address of 8 bit multiply
2B79: E5      	        push    HL              ; Save for NMSB,MSB
2B7A: E5      	        push    HL              ;
2B7B: 21C981  	        ld      HL,FPREG        ; Point to number
2B7E: 7E      	MULT8:  ld      A,(HL)          ; Get LSB of number
2B7F: 23      	        inc     HL              ; Point to NMSB
2B80: B7      	        or      A               ; Test LSB
2B81: CAAA2B  	        jp      Z,BYTSFT        ; Zero - shift to next byte
2B84: E5      	        push    HL              ; Save address of number
2B85: 2E08    	        ld      L,$08           ; 8 bits to multiply by
2B87: 1F      	MUL8LP: rra                     ; Shift LSB right
2B88: 67      	        ld      H,A             ; Save LSB
2B89: 79      	        ld      A,C             ; Get MSB
2B8A: D2982B  	        jp      NC,NOMADD       ; Bit was zero - Don't add
2B8D: E5      	        push    HL              ; Save LSB and count
2B8E: 2A3E82  	        ld      HL,(MULVAL+1)   ; Get LSB and NMSB
2B91: 19      	        add     HL,DE           ; Add NMSB and LSB
2B92: EB      	        ex      DE,HL           ; Leave sum in DE
2B93: E1      	        pop     HL              ; Restore MSB and count
2B94: 3A3D82  	        ld      A,(MULVAL)      ; Get MSB of multiplier
2B97: 89      	        adc     A,C             ; Add MSB
2B98: 1F      	NOMADD: rra                     ; Shift MSB right
2B99: 4F      	        ld      C,A             ; Re-save MSB
2B9A: 7A      	        ld      A,D             ; Get NMSB
2B9B: 1F      	        rra                     ; Shift NMSB right
2B9C: 57      	        ld      D,A             ; Re-save NMSB
2B9D: 7B      	        ld      A,E             ; Get LSB
2B9E: 1F      	        rra                     ; Shift LSB right
2B9F: 5F      	        ld      E,A             ; Re-save LSB
2BA0: 78      	        ld      A,B             ; Get VLSB
2BA1: 1F      	        rra                     ; Shift VLSB right
2BA2: 47      	        ld      B,A             ; Re-save VLSB
2BA3: 2D      	        dec     L               ; Count bits multiplied
2BA4: 7C      	        ld      A,H             ; Get LSB of multiplier
2BA5: C2872B  	        jp      NZ,MUL8LP       ; More - Do it
2BA8: E1      	POPHRT: pop     HL              ; Restore address of number
2BA9: C9      	        ret
              	
2BAA: 43      	BYTSFT: ld      B,E             ; Shift partial product left
2BAB: 5A      	        ld      E,D
2BAC: 51      	        ld      D,C
2BAD: 4F      	        ld      C,A
2BAE: C9      	        ret
              	
              	
              	; WORKING 
2BAF: C1      	DINT:   pop     BC              ; Get number from stack
2BB0: D1      	        pop     DE
2BB1: CD0E2C  	        call    DVBCDE          ; get BCDE/FPREG and store result into FPREG
2BB4: C38B2D  	        jp      INT             ; return INT(FPREG)
              	
              	
              	; A MODULO B - return remainder of the integer division A/B where:
              	; A is in stack; B is in FPREG
              	; math is:
              	; A=INT(A); B=INT(B); R=A-(B*INT(A/B))
2BB7: CD8B2D  	MOD:    call    INT             ; B=INT(B)
2BBA: CD042D  	        call    BCDEFP          ; copy B (from FPREG) into BCDE
2BBD: ED53F381	        ld      (TMPBFR3),DE    ; store B into...
2BC1: ED43F581	        ld      (TMPBFR4),BC    ; ...a temp buffer
2BC5: C1      	        pop     BC              ; recover A...
2BC6: D1      	        pop     DE              ; ...from stack
2BC7: CDF92C  	        call    FPBCDE          ; store A into FPREG
2BCA: CD8B2D  	        call    INT             ; get integer part: A=INT(A)
2BCD: CD042D  	        call    BCDEFP          ; copy A (from FPREG) into BCDE
2BD0: ED53EF81	        ld      (TMPBFR1),DE    ; store A into...
2BD4: ED43F181	        ld      (TMPBFR2),BC    ; ...a temp buffer
              	                                ; begin calculation
2BD8: 2AF381  	        ld      HL,(TMPBFR3)    ; move B...
2BDB: 22C981  	        ld      (FPREG),HL      ; ...from...
2BDE: 2AF581  	        ld      HL,(TMPBFR4)    ; ...temp buffer...
2BE1: 22CB81  	        ld      (FPREG+2),HL    ; ...into FPREG
2BE4: CD0E2C  	        call    DVBCDE          ; compute A/B and store into FPREG
2BE7: CD8B2D  	        call    INT             ; get integer part of result: now FPREG = INT(A/B)
2BEA: ED5BF381	        ld      DE,(TMPBFR3)    ; load B...
2BEE: ED4BF581	        ld      BC,(TMPBFR4)    ; ...into BCDE
2BF2: CD5C2B  	        call    FPMULT          ; get B*INT(A/B) and store into FPREG
2BF5: ED5BEF81	        ld      DE,(TMPBFR1)    ; retrieve A from...
2BF9: ED4BF181	        ld      BC,(TMPBFR2)    ; ...temp buffer
2BFD: C31E2A  	        jp      SUBCDE          ; return result of A-(B*INT(A/B))
              	
              	
2C00: CDE92C  	DIV10:  call    STAKFP          ; Save FPREG on stack
2C03: 012084  	        ld      BC,$8420        ; BCDE = 10.
2C06: 110000  	        ld      DE,$0000
2C09: CDF92C  	        call    FPBCDE          ; Move 10 to FPREG
              	
2C0C: C1      	DIV:    pop     BC              ; Get number from stack
2C0D: D1      	        pop     DE
2C0E: CDB82C  	DVBCDE: call    TSTSGN          ; Test sign of FPREG
2C11: CA3B15  	        jp      Z,DZERR         ; Error if division by zero
2C14: 2EFF    	        ld      L,-1            ; Flag subtract exponents
2C16: CD762C  	        call    ADDEXP          ; Subtract exponents
2C19: 34      	        inc     (HL)            ; Add 2 to exponent to adjust
2C1A: 34      	        inc     (HL)
2C1B: 2B      	        dec     HL              ; Point to MSB
2C1C: 7E      	        ld      A,(HL)          ; Get MSB of dividend
2C1D: 327380  	        ld      (DIV3),A        ; Save for subtraction
2C20: 2B      	        dec     HL
2C21: 7E      	        ld      A,(HL)          ; Get NMSB of dividend
2C22: 326F80  	        ld      (DIV2),A        ; Save for subtraction
2C25: 2B      	        dec     HL
2C26: 7E      	        ld      A,(HL)          ; Get MSB of dividend
2C27: 326B80  	        ld      (DIV1),A        ; Save for subtraction
2C2A: 41      	        ld      B,C             ; Get MSB
2C2B: EB      	        ex      DE,HL           ; NMSB,LSB to HL
2C2C: AF      	        xor     A
2C2D: 4F      	        ld      C,A             ; Clear MSB of quotient
2C2E: 57      	        ld      D,A             ; Clear NMSB of quotient
2C2F: 5F      	        ld      E,A             ; Clear LSB of quotient
2C30: 327680  	        ld      (DIV4),A        ; Clear overflow count
2C33: E5      	DIVLP:  push    HL              ; Save divisor
2C34: C5      	        push    BC
2C35: 7D      	        ld      A,L             ; Get LSB of number
2C36: CD6A80  	        call    DIVSUP          ; Subt' divisor from dividend
2C39: DE00    	        sbc     A,$00           ; Count for overflows
2C3B: 3F      	        ccf
2C3C: D2462C  	        jp      NC,RESDIV       ; Restore divisor if borrow
2C3F: 327680  	        ld      (DIV4),A        ; Re-save overflow count
2C42: F1      	        pop     AF              ; Scrap divisor
2C43: F1      	        pop     AF
2C44: 37      	        scf                     ; Set carry to
2C45: D2      	        defb    $D2             ; Skip "pop BC" and "pop HL"
              	
2C46: C1      	RESDIV: pop     BC              ; Restore divisor
2C47: E1      	        pop     HL
2C48: 79      	        ld      A,C             ; Get MSB of quotient
2C49: 3C      	        inc     A
2C4A: 3D      	        dec     A
2C4B: 1F      	        rra                     ; Bit 0 to bit 7
2C4C: FAA82A  	        jp      M,RONDB         ; Done - Normalise result
2C4F: 17      	        rla                     ; Restore carry
2C50: 7B      	        ld      A,E             ; Get LSB of quotient
2C51: 17      	        rla                     ; Double it
2C52: 5F      	        ld      E,A             ; Put it back
2C53: 7A      	        ld      A,D             ; Get NMSB of quotient
2C54: 17      	        rla                     ; Double it
2C55: 57      	        ld      D,A             ; Put it back
2C56: 79      	        ld      A,C             ; Get MSB of quotient
2C57: 17      	        rla                     ; Double it
2C58: 4F      	        ld      C,A             ; Put it back
2C59: 29      	        add     HL,HL           ; Double NMSB,LSB of divisor
2C5A: 78      	        ld      A,B             ; Get MSB of divisor
2C5B: 17      	        rla                     ; Double it
2C5C: 47      	        ld      B,A             ; Put it back
2C5D: 3A7680  	        ld      A,(DIV4)        ; Get VLSB of quotient
2C60: 17      	        rla                     ; Double it
2C61: 327680  	        ld      (DIV4),A        ; Put it back
2C64: 79      	        ld      A,C             ; Get MSB of quotient
2C65: B2      	        or      D               ; Merge NMSB
2C66: B3      	        or      E               ; Merge LSB
2C67: C2332C  	        jp      NZ,DIVLP        ; Not done - Keep dividing
2C6A: E5      	        push    HL              ; Save divisor
2C6B: 21CC81  	        ld      HL,FPEXP        ; Point to exponent
2C6E: 35      	        dec     (HL)            ; Divide by 2
2C6F: E1      	        pop     HL              ; Restore divisor
2C70: C2332C  	        jp      NZ,DIVLP        ; Ok - Keep going
2C73: C34715  	        jp      OVERR           ; Overflow error
              	
              	
2C76: 78      	ADDEXP: ld      A,B             ; Get exponent of dividend
2C77: B7      	        or      A               ; Test it
2C78: CA9A2C  	        jp      Z,OVTST3        ; Zero - Result zero
2C7B: 7D      	        ld      A,L             ; Get add/subtract flag
2C7C: 21CC81  	        ld      HL,FPEXP        ; Point to exponent
2C7F: AE      	        xor     (HL)            ; Add or subtract it
2C80: 80      	        add     A,B             ; Add the other exponent
2C81: 47      	        ld      B,A             ; Save new exponent
2C82: 1F      	        rra                     ; Test exponent for overflow
2C83: A8      	        xor     B
2C84: 78      	        ld      A,B             ; Get exponent
2C85: F2992C  	        jp      P,OVTST2        ; Positive - Test for overflow
2C88: C680    	        add     A,$80           ; Add excess 128
2C8A: 77      	        ld      (HL),A          ; Save new exponent
2C8B: CAA82B  	        jp      Z,POPHRT        ; Zero - Result zero
2C8E: CD1E2D  	        call    SIGNS           ; Set MSBs and sign of result
2C91: 77      	        ld      (HL),A          ; Save new exponent
2C92: 2B      	        dec     HL              ; Point to MSB
2C93: C9      	        ret
              	
2C94: CDB82C  	OVTST1: call    TSTSGN          ; Test sign of FPREG
2C97: 2F      	        cpl                     ; Invert sign
2C98: E1      	        pop     HL              ; Clean up stack
2C99: B7      	OVTST2: or      A               ; Test if new exponent zero
2C9A: E1      	OVTST3: pop     HL              ; Clear off return address
2C9B: F2872A  	        jp      P,RESZER        ; Result zero
2C9E: C34715  	        jp      OVERR           ; Overflow error
              	
2CA1: CD042D  	MLSP10: call    BCDEFP          ; Move FPREG to BCDE
2CA4: 78      	        ld      A,B             ; Get exponent
2CA5: B7      	        or      A               ; Is it zero?
2CA6: C8      	        ret     Z               ; Yes - Result is zero
2CA7: C602    	        add     A,$02           ; Multiply by 4
2CA9: DA4715  	        jp      C,OVERR         ; Overflow - ?OV Error
2CAC: 47      	        ld      B,A             ; Re-save exponent
2CAD: CD212A  	        call    FPADD           ; Add BCDE to FPREG (Times 5)
2CB0: 21CC81  	        ld      HL,FPEXP        ; Point to exponent
2CB3: 34      	        inc     (HL)            ; Double number (Times 10)
2CB4: C0      	        ret     NZ              ; Ok - Return
2CB5: C34715  	        jp      OVERR           ; Overflow error
              	
2CB8: 3ACC81  	TSTSGN: ld      A,(FPEXP)       ; Get sign of FPREG
2CBB: B7      	        or      A
2CBC: C8      	        ret     Z               ; RETurn if number is zero
2CBD: 3ACB81  	        ld      A,(FPREG+2)     ; Get MSB of FPREG
2CC0: FE      	        defb    0FEH            ; Test sign
2CC1: 2F      	RETREL: cpl                     ; Invert sign
2CC2: 17      	        rla                     ; Sign bit to carry
2CC3: 9F      	FLGDIF: sbc     A,A             ; Carry to all bits of A
2CC4: C0      	        ret     NZ              ; Return -1 if negative
2CC5: 3C      	        inc     A               ; Bump to +1
2CC6: C9      	        ret                     ; Positive - Return +1
              	
2CC7: CDB82C  	SGN:    call    TSTSGN          ; Test sign of FPREG
2CCA: 0688    	FLGREL: ld      B,$80+8         ; 8 bit integer in exponent
2CCC: 110000  	        ld      DE,0            ; Zero NMSB and LSB
2CCF: 21CC81  	RETINT: ld      HL,FPEXP        ; Point to exponent
2CD2: 4F      	        ld      C,A             ; CDE = MSB,NMSB and LSB
2CD3: 70      	        ld      (HL),B          ; Save exponent
2CD4: 0600    	        ld      B,0             ; CDE = integer to normalise
2CD6: 23      	        inc     HL              ; Point to sign of result
2CD7: 3680    	        ld      (HL),$80        ; Set sign of result
2CD9: 17      	        rla                     ; Carry = sign of integer
2CDA: C36F2A  	        jp      CONPOS          ; Set sign of result
              	
2CDD: CDB82C  	ABS:    call    TSTSGN          ; Test sign of FPREG
2CE0: F0      	        ret     P               ; Return if positive
2CE1: 21CB81  	INVSGN: ld      HL,FPREG+2      ; Point to MSB
2CE4: 7E      	        ld      A,(HL)          ; Get sign of mantissa
2CE5: EE80    	        xor     $80             ; Invert sign of mantissa
2CE7: 77      	        ld      (HL),A          ; Re-save sign of mantissa
2CE8: C9      	        ret
              	
2CE9: EB      	STAKFP: ex      DE,HL           ; Save code string address
2CEA: 2AC981  	        ld      HL,(FPREG)      ; LSB,NLSB of FPREG
2CED: E3      	        ex      (SP),HL         ; Stack them,get return
2CEE: E5      	        push    HL              ; Re-save return
2CEF: 2ACB81  	        ld      HL,(FPREG+2)    ; MSB and exponent of FPREG
2CF2: E3      	        ex      (SP),HL         ; Stack them,get return
2CF3: E5      	        push    HL              ; Re-save return
2CF4: EB      	        ex      DE,HL           ; Restore code string address
2CF5: C9      	        ret
              	
              	; store F.P. number from BCDE into FPREG
2CF6: CD072D  	PHLTFP: call    LOADFP          ; Number at HL to BCDE
2CF9: EB      	FPBCDE: ex      DE,HL           ; Save code string address
2CFA: 22C981  	        ld      (FPREG),HL      ; Save LSB,NLSB of number
2CFD: 60      	        ld      H,B             ; Exponent of number
2CFE: 69      	        ld      L,C             ; MSB of number
2CFF: 22CB81  	        ld      (FPREG+2),HL    ; Save MSB and exponent
2D02: EB      	        ex      DE,HL           ; Restore code string address
2D03: C9      	        ret
              	
              	; load F.P. number from FPREG into BCDE
2D04: 21C981  	BCDEFP: ld      HL,FPREG        ; Point to FPREG
2D07: 5E      	LOADFP: ld      E,(HL)          ; Get LSB of number
2D08: 23      	        inc     HL
2D09: 56      	        ld      D,(HL)          ; Get NMSB of number
2D0A: 23      	        inc     HL
2D0B: 4E      	        ld      C,(HL)          ; Get MSB of number
2D0C: 23      	        inc     HL
2D0D: 46      	        ld      B,(HL)          ; Get exponent of number
2D0E: 23      	INCHL:  inc     HL              ; Used for conditional "inc HL"
2D0F: C9      	        ret
              	
2D10: 11C981  	FPTHL:  ld      DE,FPREG        ; Point to FPREG
2D13: 0604    	DETHL4: ld      B,$04           ; 4 bytes to move
2D15: 1A      	DETHLB: ld      A,(DE)          ; Get source
2D16: 77      	        ld      (HL),A          ; Save destination
2D17: 13      	        inc     DE              ; Next source
2D18: 23      	        inc     HL              ; Next destination
2D19: 05      	        dec     B               ; Count bytes
2D1A: C2152D  	        jp      NZ,DETHLB       ; Loop if more
2D1D: C9      	        ret
              	
2D1E: 21CB81  	SIGNS:  ld      HL,FPREG+2      ; Point to MSB of FPREG
2D21: 7E      	        ld      A,(HL)          ; Get MSB
2D22: 07      	        rlca                    ; Old sign to carry
2D23: 37      	        scf                     ; Set MSBit
2D24: 1F      	        rra                     ; Set MSBit of MSB
2D25: 77      	        ld      (HL),A          ; Save new MSB
2D26: 3F      	        ccf                     ; Complement sign
2D27: 1F      	        rra                     ; Old sign to carry
2D28: 23      	        inc     HL
2D29: 23      	        inc     HL
2D2A: 77      	        ld      (HL),A          ; Set sign of result
2D2B: 79      	        ld      A,C             ; Get MSB
2D2C: 07      	        rlca                    ; Old sign to carry
2D2D: 37      	        scf                     ; Set MSBit
2D2E: 1F      	        rra                     ; Set MSBit of MSB
2D2F: 4F      	        ld      C,A             ; Save MSB
2D30: 1F      	        rra
2D31: AE      	        xor     (HL)            ; New sign of result
2D32: C9      	        ret
              	
2D33: 78      	CMPNUM: ld      A,B             ; Get exponent of number
2D34: B7      	        or      A
2D35: CAB82C  	        jp      Z,TSTSGN        ; Zero - Test sign of FPREG
2D38: 21C12C  	        ld      HL,RETREL       ; Return relation routine
2D3B: E5      	        push    HL              ; Save for return
2D3C: CDB82C  	        call    TSTSGN          ; Test sign of FPREG
2D3F: 79      	        ld      A,C             ; Get MSB of number
2D40: C8      	        ret     Z               ; FPREG zero - Number's MSB
2D41: 21CB81  	        ld      HL,FPREG+2      ; MSB of FPREG
2D44: AE      	        xor     (HL)            ; Combine signs
2D45: 79      	        ld      A,C             ; Get MSB of number
2D46: F8      	        ret     M               ; Exit if signs different
2D47: CD4D2D  	        call    CMPFP           ; Compare FP numbers
2D4A: 1F      	        rra                     ; Get carry to sign
2D4B: A9      	        xor     C               ; Combine with MSB of number
2D4C: C9      	        ret
              	
2D4D: 23      	CMPFP:  inc     HL              ; Point to exponent
2D4E: 78      	        ld      A,B             ; Get exponent
2D4F: BE      	        cp      (HL)            ; Compare exponents
2D50: C0      	        ret     NZ              ; Different
2D51: 2B      	        dec     HL              ; Point to MBS
2D52: 79      	        ld      A,C             ; Get MSB
2D53: BE      	        cp      (HL)            ; Compare MSBs
2D54: C0      	        ret     NZ              ; Different
2D55: 2B      	        dec     HL              ; Point to NMSB
2D56: 7A      	        ld      A,D             ; Get NMSB
2D57: BE      	        cp      (HL)            ; Compare NMSBs
2D58: C0      	        ret     NZ              ; Different
2D59: 2B      	        dec     HL              ; Point to LSB
2D5A: 7B      	        ld      A,E             ; Get LSB
2D5B: 96      	        sub     (HL)            ; Compare LSBs
2D5C: C0      	        ret     NZ              ; Different
2D5D: E1      	        pop     HL              ; Drop RETurn
2D5E: E1      	        pop     HL              ; Drop another RETurn
2D5F: C9      	        ret
              	
2D60: 47      	FPINT:  ld      B,A             ; <- Move
2D61: 4F      	        ld      C,A             ; <- exponent
2D62: 57      	        ld      D,A             ; <- to all
2D63: 5F      	        ld      E,A             ; <- bits
2D64: B7      	        or      A               ; Test exponent
2D65: C8      	        ret     Z               ; Zero - Return zero
2D66: E5      	        push    HL              ; Save pointer to number
2D67: CD042D  	        call    BCDEFP          ; Move FPREG to BCDE
2D6A: CD1E2D  	        call    SIGNS           ; Set MSBs & sign of result
2D6D: AE      	        xor     (HL)            ; Combine with sign of FPREG
2D6E: 67      	        ld      H,A             ; Save combined signs
2D6F: FC842D  	        call    M,DCBCDE        ; Negative - Decrement BCDE
2D72: 3E98    	        ld      A,$80+24        ; 24 bits
2D74: 90      	        sub     B               ; Bits to shift
2D75: CDE62A  	        call    SCALE           ; Shift BCDE
2D78: 7C      	        ld      A,H             ; Get combined sign
2D79: 17      	        rla                     ; Sign to carry
2D7A: DCB92A  	        call    C,FPROND        ; Negative - Round number up
2D7D: 0600    	        ld      B,$00           ; Zero exponent
2D7F: DCD22A  	        call    C,COMPL         ; If negative make positive
2D82: E1      	        pop     HL              ; Restore pointer to number
2D83: C9      	        ret
              	
2D84: 1B      	DCBCDE: dec     DE              ; Decrement BCDE
2D85: 7A      	        ld      A,D             ; Test LSBs
2D86: A3      	        and     E
2D87: 3C      	        inc     A
2D88: C0      	        ret     NZ              ; Exit if LSBs not FFFF
2D89: 0B      	        dec     BC              ; Decrement MSBs
2D8A: C9      	        ret
              	
2D8B: 21CC81  	INT:    ld      HL,FPEXP        ; Point to exponent
2D8E: 7E      	        ld      A,(HL)          ; Get exponent
2D8F: FE98    	        cp      $80+24          ; Integer accuracy only?
2D91: 3AC981  	        ld      A,(FPREG)       ; Get LSB
2D94: D0      	        ret     NC              ; Yes - Already integer
2D95: 7E      	        ld      A,(HL)          ; Get exponent
2D96: CD602D  	        call    FPINT           ; F.P to integer
2D99: 3698    	        ld      (HL),$80+24     ; Save 24 bit integer
2D9B: 7B      	        ld      A,E             ; Get LSB of number
2D9C: F5      	        push    AF              ; Save LSB
2D9D: 79      	        ld      A,C             ; Get MSB of number
2D9E: 17      	        rla                     ; Sign to carry
2D9F: CD6F2A  	        call    CONPOS          ; Set sign of result
2DA2: F1      	        pop     AF              ; Restore LSB of number
2DA3: C9      	        ret
              	
2DA4: 210000  	MLDEBC: ld      HL,$0000        ; Clear partial product
2DA7: 78      	        ld      A,B             ; Test multiplier
2DA8: B1      	        or      C
2DA9: C8      	        ret     Z               ; Return zero if zero
2DAA: 3E10    	        ld      A,$10           ; 16 bits
2DAC: 29      	MLDBLP: add     HL,HL           ; Shift P.P left
2DAD: DAD921  	        jp      C,BSERR         ; ?BS Error if overflow
2DB0: EB      	        ex      DE,HL
2DB1: 29      	        add     HL,HL           ; Shift multiplier left
2DB2: EB      	        ex      DE,HL
2DB3: D2BA2D  	        jp      NC,NOMLAD       ; Bit was zero - No add
2DB6: 09      	        add     HL,BC           ; Add multiplicand
2DB7: DAD921  	        jp      C,BSERR         ; ?BS Error if overflow
2DBA: 3D      	NOMLAD: dec     A               ; Count bits
2DBB: C2AC2D  	        jp      NZ,MLDBLP       ; More
2DBE: C9      	        ret
              	
2DBF: FE2D    	ASCTFP: cp      '-'             ; Negative?
2DC1: F5      	        push    AF              ; Save it and flags
2DC2: CACB2D  	        jp      Z,CNVNUM        ; Yes - Convert number
2DC5: FE2B    	        cp      '+'             ; Positive?
2DC7: CACB2D  	        jp      Z,CNVNUM        ; Yes - Convert number
2DCA: 2B      	        dec     HL              ; dec 'cos GETCHR INCs
2DCB: CD872A  	CNVNUM: call    RESZER          ; Set result to zero
2DCE: 47      	        ld      B,A             ; Digits after point counter
2DCF: 57      	        ld      D,A             ; Sign of exponent
2DD0: 5F      	        ld      E,A             ; Exponent of ten
2DD1: 2F      	        cpl
2DD2: 4F      	        ld      C,A             ; Before or after point flag
2DD3: CD3D1A  	MANLP:  call    GETCHR          ; Get next character
2DD6: DA1C2E  	        jp      C,ADDIG         ; Digit - Add to number
2DD9: FE2E    	        cp      '.'
2DDB: CAF72D  	        jp      Z,DPOINT        ; '.' - Flag point
2DDE: FE45    	        cp      'E'
2DE0: C2FB2D  	        jp      NZ,CONEXP       ; Not 'E' - Scale number
2DE3: CD3D1A  	        call    GETCHR          ; Get next character
2DE6: CDF51F  	        call    SGNEXP          ; Get sign of exponent
2DE9: CD3D1A  	EXPLP:  call    GETCHR          ; Get next character
2DEC: DA3E2E  	        jp      C,EDIGIT        ; Digit - Add to exponent
2DEF: 14      	        inc     D               ; Is sign negative?
2DF0: C2FB2D  	        jp      NZ,CONEXP       ; No - Scale number
2DF3: AF      	        xor     A
2DF4: 93      	        sub     E               ; Negate exponent
2DF5: 5F      	        ld      E,A             ; And re-save it
2DF6: 0C      	        inc     C               ; Flag end of number
2DF7: 0C      	DPOINT: inc     C               ; Flag point passed
2DF8: CAD32D  	        jp      Z,MANLP         ; Zero - Get another digit
2DFB: E5      	CONEXP: push    HL              ; Save code string address
2DFC: 7B      	        ld      A,E             ; Get exponent
2DFD: 90      	        sub     B               ; Subtract digits after point
2DFE: F4142E  	SCALMI: call    P,SCALPL        ; Positive - Multiply number
2E01: F20A2E  	        jp      P,ENDCON        ; Positive - All done
2E04: F5      	        push    AF              ; Save number of times to /10
2E05: CD002C  	        call    DIV10           ; Divide by 10
2E08: F1      	        pop     AF              ; Restore count
2E09: 3C      	        inc     A               ; Count divides
              	
2E0A: C2FE2D  	ENDCON: jp      NZ,SCALMI       ; More to do
2E0D: D1      	        pop     DE              ; Restore code string address
2E0E: F1      	        pop     AF              ; Restore sign of number
2E0F: CCE12C  	        call    Z,INVSGN        ; Negative - Negate number
2E12: EB      	        ex      DE,HL           ; Code string address to HL
2E13: C9      	        ret
              	
2E14: C8      	SCALPL: ret     Z               ; Exit if no scaling needed
2E15: F5      	MULTEN: push    AF              ; Save count
2E16: CDA12C  	        call    MLSP10          ; Multiply number by 10
2E19: F1      	        pop     AF              ; Restore count
2E1A: 3D      	        dec     A               ; Count multiplies
2E1B: C9      	        ret
              	
2E1C: D5      	ADDIG:  push    DE              ; Save sign of exponent
2E1D: 57      	        ld      D,A             ; Save digit
2E1E: 78      	        ld      A,B             ; Get digits after point
2E1F: 89      	        adc     A,C             ; Add one if after point
2E20: 47      	        ld      B,A             ; Re-save counter
2E21: C5      	        push    BC              ; Save point flags
2E22: E5      	        push    HL              ; Save code string address
2E23: D5      	        push    DE              ; Save digit
2E24: CDA12C  	        call    MLSP10          ; Multiply number by 10
2E27: F1      	        pop     AF              ; Restore digit
2E28: D630    	        sub     '0'             ; Make it absolute
2E2A: CD332E  	        call    RSCALE          ; Re-scale number
2E2D: E1      	        pop     HL              ; Restore code string address
2E2E: C1      	        pop     BC              ; Restore point flags
2E2F: D1      	        pop     DE              ; Restore sign of exponent
2E30: C3D32D  	        jp      MANLP           ; Get another digit
              	
2E33: CDE92C  	RSCALE: call    STAKFP          ; Put number on stack
2E36: CDCA2C  	        call    FLGREL          ; Digit to add to FPREG
2E39: C1      	PADD:   pop     BC              ; Restore number
2E3A: D1      	        pop     DE
2E3B: C3212A  	        jp      FPADD           ; Add BCDE to FPREG and return
              	
2E3E: 7B      	EDIGIT: ld      A,E             ; Get digit
2E3F: 07      	        rlca                    ; Times 2
2E40: 07      	        rlca                    ; Times 4
2E41: 83      	        add     A,E             ; Times 5
2E42: 07      	        rlca                    ; Times 10
2E43: 86      	        add     A,(HL)          ; Add next digit
2E44: D630    	        sub     '0'             ; Make it absolute
2E46: 5F      	        ld      E,A             ; Save new digit
2E47: C3E92D  	        jp      EXPLP           ; Look for another digit
              	
2E4A: E5      	LINEIN: push    HL              ; Save code string address
2E4B: 21B114  	        ld      HL,INMSG        ; Output " in "
2E4E: CDBA23  	        call    PRS             ; Output string at HL
2E51: E1      	        pop     HL              ; Restore code string address
2E52: EB      	PRNTHL: ex      DE,HL           ; Code string address to DE
2E53: AF      	        xor     A
2E54: 0698    	        ld      B,$80+24        ; 24 bits
2E56: CDCF2C  	        call    RETINT          ; Return the integer
2E59: 21B923  	        ld      HL,PRNUMS       ; Print number string
2E5C: E5      	        push    HL              ; Save for return
2E5D: 213082  	NUMASC: ld      HL,PBUFF        ; Convert number to ASCII
2E60: E5      	        push    HL              ; Save for return
2E61: CDB82C  	        call    TSTSGN          ; Test sign of FPREG
2E64: 3620    	        ld      (HL),SPC        ; Space at start
2E66: F26B2E  	        jp      P,SPCFST        ; Positive - Space to start
2E69: 362D    	        ld      (HL),'-'        ; '-' sign at start
2E6B: 23      	SPCFST: inc     HL              ; First byte of number
2E6C: 3630    	        ld      (HL),'0'        ; '0' if zero
2E6E: CA212F  	        jp      Z,JSTZER        ; Return '0' if zero
2E71: E5      	        push    HL              ; Save buffer address
2E72: FCE12C  	        call    M,INVSGN        ; Negate FPREG if negative
2E75: AF      	        xor     A               ; Zero A
2E76: F5      	        push    AF              ; Save it
2E77: CD272F  	        call    RNGTST          ; Test number is in range
2E7A: 014391  	SIXDIG: ld      BC,$9143        ; BCDE - 99999.9
2E7D: 11F84F  	        ld      DE,$4FF8
2E80: CD332D  	        call    CMPNUM          ; Compare numbers
2E83: B7      	        or      A
2E84: E2982E  	        jp      PO,INRNG        ; > 99999.9 - Sort it out
2E87: F1      	        pop     AF              ; Restore count
2E88: CD152E  	        call    MULTEN          ; Multiply by ten
2E8B: F5      	        push    AF              ; Re-save count
2E8C: C37A2E  	        jp      SIXDIG          ; Test it again
              	
2E8F: CD002C  	GTSIXD: call    DIV10           ; Divide by 10
2E92: F1      	        pop     AF              ; Get count
2E93: 3C      	        inc     A               ; Count divides
2E94: F5      	        push    AF              ; Re-save count
2E95: CD272F  	        call    RNGTST          ; Test number is in range
2E98: CD0F2A  	INRNG:  call    ROUND           ; Add 0.5 to FPREG
2E9B: 3C      	        inc     A
2E9C: CD602D  	        call    FPINT           ; F.P to integer
2E9F: CDF92C  	        call    FPBCDE          ; Move BCDE to FPREG
2EA2: 010603  	        ld      BC,$0306        ; 1E+06 to 1E-03 range
2EA5: F1      	        pop     AF              ; Restore count
2EA6: 81      	        add     A,C             ; 6 digits before point
2EA7: 3C      	        inc     A               ; Add one
2EA8: FAB42E  	        jp      M,MAKNUM        ; Do it in 'E' form if < 1E-02
2EAB: FE08    	        cp      6+1+1           ; More than 999999 ?
2EAD: D2B42E  	        jp      NC,MAKNUM       ; Yes - Do it in 'E' form
2EB0: 3C      	        inc     A               ; Adjust for exponent
2EB1: 47      	        ld      B,A             ; Exponent of number
2EB2: 3E02    	        ld      A,2             ; Make it zero after
              	
2EB4: 3D      	MAKNUM: dec     A               ; Adjust for digits to do
2EB5: 3D      	        dec     A
2EB6: E1      	        pop     HL              ; Restore buffer address
2EB7: F5      	        push    AF              ; Save count
2EB8: 113A2F  	        ld      DE,POWERS       ; Powers of ten
2EBB: 05      	        dec     B               ; Count digits before point
2EBC: C2C52E  	        jp      NZ,DIGTXT       ; Not zero - Do number
2EBF: 362E    	        ld      (HL),'.'        ; Save point
2EC1: 23      	        inc     HL              ; Move on
2EC2: 3630    	        ld      (HL),'0'        ; Save zero
2EC4: 23      	        inc     HL              ; Move on
2EC5: 05      	DIGTXT: dec     B               ; Count digits before point
2EC6: 362E    	        ld      (HL),'.'        ; Save point in case
2EC8: CC0E2D  	        call    Z,INCHL         ; Last digit - move on
2ECB: C5      	        push    BC              ; Save digits before point
2ECC: E5      	        push    HL              ; Save buffer address
2ECD: D5      	        push    DE              ; Save powers of ten
2ECE: CD042D  	        call    BCDEFP          ; Move FPREG to BCDE
2ED1: E1      	        pop     HL              ; Powers of ten table
2ED2: 062F    	        ld      B,'0'-1         ; ASCII '0' - 1
2ED4: 04      	TRYAGN: inc     B               ; Count subtractions
2ED5: 7B      	        ld      A,E             ; Get LSB
2ED6: 96      	        sub     (HL)            ; Subtract LSB
2ED7: 5F      	        ld      E,A             ; Save LSB
2ED8: 23      	        inc     HL
2ED9: 7A      	        ld      A,D             ; Get NMSB
2EDA: 9E      	        sbc     A,(HL)          ; Subtract NMSB
2EDB: 57      	        ld      D,A             ; Save NMSB
2EDC: 23      	        inc     HL
2EDD: 79      	        ld      A,C             ; Get MSB
2EDE: 9E      	        sbc     A,(HL)          ; Subtract MSB
2EDF: 4F      	        ld      C,A             ; Save MSB
2EE0: 2B      	        dec     HL              ; Point back to start
2EE1: 2B      	        dec     HL
2EE2: D2D42E  	        jp      NC,TRYAGN       ; No overflow - Try again
2EE5: CDC62A  	        call    PLUCDE          ; Restore number
2EE8: 23      	        inc     HL              ; Start of next number
2EE9: CDF92C  	        call    FPBCDE          ; Move BCDE to FPREG
2EEC: EB      	        ex      DE,HL           ; Save point in table
2EED: E1      	        pop     HL              ; Restore buffer address
2EEE: 70      	        ld      (HL),B          ; Save digit in buffer
2EEF: 23      	        inc     HL              ; And move on
2EF0: C1      	        pop     BC              ; Restore digit count
2EF1: 0D      	        dec     C               ; Count digits
2EF2: C2C52E  	        jp      NZ,DIGTXT       ; More - Do them
2EF5: 05      	        dec     B               ; Any decimal part?
2EF6: CA052F  	        jp      Z,DOEBIT        ; No - Do 'E' bit
2EF9: 2B      	SUPTLZ: dec     HL              ; Move back through buffer
2EFA: 7E      	        ld      A,(HL)          ; Get character
2EFB: FE30    	        cp      '0'             ; '0' character?
2EFD: CAF92E  	        jp      Z,SUPTLZ        ; Yes - Look back for more
2F00: FE2E    	        cp      '.'             ; A decimal point?
2F02: C40E2D  	        call    NZ,INCHL        ; Move back over digit
              	
2F05: F1      	DOEBIT: pop     AF              ; Get 'E' flag
2F06: CA242F  	        jp      Z,NOENED        ; No 'E' needed - End buffer
2F09: 3645    	        ld      (HL),'E'        ; Put 'E' in buffer
2F0B: 23      	        inc     HL              ; And move on
2F0C: 362B    	        ld      (HL),'+'        ; Put '+' in buffer
2F0E: F2152F  	        jp      P,OUTEXP        ; Positive - Output exponent
2F11: 362D    	        ld      (HL),'-'        ; Put '-' in buffer
2F13: 2F      	        cpl                     ; Negate exponent
2F14: 3C      	        inc     A
2F15: 062F    	OUTEXP: ld      B,'0'-1         ; ASCII '0' - 1
2F17: 04      	EXPTEN: inc     B               ; Count subtractions
2F18: D60A    	        sub     $0A             ; Tens digit
2F1A: D2172F  	        jp      NC,EXPTEN       ; More to do
2F1D: C63A    	        add     A,'0'+10        ; Restore and make ASCII
2F1F: 23      	        inc     HL              ; Move on
2F20: 70      	        ld      (HL),B          ; Save MSB of exponent
2F21: 23      	JSTZER: inc     HL              ;
2F22: 77      	        ld      (HL),A          ; Save LSB of exponent
2F23: 23      	        inc     HL
2F24: 71      	NOENED: ld      (HL),C          ; Mark end of buffer
2F25: E1      	        pop     HL              ; Restore code string address
2F26: C9      	        ret
              	
2F27: 017494  	RNGTST: ld      BC,$9474        ; BCDE = 999999.
2F2A: 11F723  	        ld      DE,$23F7
2F2D: CD332D  	        call    CMPNUM          ; Compare numbers
2F30: B7      	        or      A
2F31: E1      	        pop     HL              ; Return address to HL
2F32: E28F2E  	        jp      PO,GTSIXD       ; Too big - Divide by ten
2F35: E9      	        jp      (HL)            ; Otherwise return to caller
              	
2F36: 00000080	HALF:   defb    $00,$00,$00,$80 ; 0.5
              	
2F3A: A08601  	POWERS: defb    $A0,$86,$01  ; 100000
2F3D: 102700  	        defb    $10,$27,$00  ;  10000
2F40: E80300  	        defb    $E8,$03,$00  ;   1000
2F43: 640000  	        defb    $64,$00,$00  ;    100
2F46: 0A0000  	        defb    $0A,$00,$00  ;     10
2F49: 010000  	        defb    $01,$00,$00  ;      1
              	
2F4C: 21E12C  	NEGAFT: ld      HL,INVSGN       ; Negate result
2F4F: E3      	        ex      (SP),HL         ; To be done after caller
2F50: E9      	        jp      (HL)            ; Return to caller
              	
2F51: CDE92C  	SQR:    call    STAKFP          ; Put value on stack
2F54: 21362F  	        ld      HL,HALF         ; Set power to 1/2
2F57: CDF62C  	        call    PHLTFP          ; Move 1/2 to FPREG
              	
2F5A: C1      	POWER:  pop     BC              ; Get base
2F5B: D1      	        pop     DE
2F5C: CDB82C  	        call    TSTSGN          ; Test sign of power
2F5F: 78      	        ld      A,B             ; Get exponent of base
2F60: CA9F2F  	        jp      Z,EXP           ; Make result 1 if zero
2F63: F26A2F  	        jp      P,POWER1        ; Positive base - Ok
2F66: B7      	        or      A               ; Zero to negative power?
2F67: CA3B15  	        jp      Z,DZERR         ; Yes - ?/0 Error
2F6A: B7      	POWER1: or      A               ; Base zero?
2F6B: CA882A  	        jp      Z,SAVEXP        ; Yes - Return zero
2F6E: D5      	        push    DE              ; Save base
2F6F: C5      	        push    BC
2F70: 79      	        ld      A,C             ; Get MSB of base
2F71: F67F    	        or      %01111111       ; Get sign status
2F73: CD042D  	        call    BCDEFP          ; Move power to BCDE
2F76: F2872F  	        jp      P,POWER2        ; Positive base - Ok
2F79: D5      	        push    DE              ; Save power
2F7A: C5      	        push    BC
2F7B: CD8B2D  	        call    INT             ; Get integer of power
2F7E: C1      	        pop     BC              ; Restore power
2F7F: D1      	        pop     DE
2F80: F5      	        push    AF              ; MSB of base
2F81: CD332D  	        call    CMPNUM          ; Power an integer?
2F84: E1      	        pop     HL              ; Restore MSB of base
2F85: 7C      	        ld      A,H             ; but don't affect flags
2F86: 1F      	        rra                     ; Exponent odd or even?
2F87: E1      	POWER2: pop     HL              ; Restore MSB and exponent
2F88: 22CB81  	        ld      (FPREG+2),HL    ; Save base in FPREG
2F8B: E1      	        pop     HL              ; LSBs of base
2F8C: 22C981  	        ld      (FPREG),HL      ; Save in FPREG
2F8F: DC4C2F  	        call    C,NEGAFT        ; Odd power - Negate result
2F92: CCE12C  	        call    Z,INVSGN        ; Negative base - Negate it
2F95: D5      	        push    DE              ; Save power
2F96: C5      	        push    BC
2F97: CD1B2B  	        call    LOG             ; Get LOG of base
2F9A: C1      	        pop     BC              ; Restore power
2F9B: D1      	        pop     DE
2F9C: CD5C2B  	        call    FPMULT          ; Multiply LOG by power
              	
2F9F: CDE92C  	EXP:    call    STAKFP          ; Put value on stack
2FA2: 013881  	        ld      BC,$8138        ; BCDE = 1/Ln(2)
2FA5: 113BAA  	        ld      DE,$AA3B
2FA8: CD5C2B  	        call    FPMULT          ; Multiply value by 1/LN(2)
2FAB: 3ACC81  	        ld      A,(FPEXP)       ; Get exponent
2FAE: FE88    	        cp      $80+8           ; Is it in range?
2FB0: D2942C  	        jp      NC,OVTST1       ; No - Test for overflow
2FB3: CD8B2D  	        call    INT             ; Get INT of FPREG
2FB6: C680    	        add     A,$80           ; For excess 128
2FB8: C602    	        add     A,$02           ; Exponent > 126?
2FBA: DA942C  	        jp      C,OVTST1        ; Yes - Test for overflow
2FBD: F5      	        push    AF              ; Save scaling factor
2FBE: 210A2B  	        ld      HL,UNITY        ; Point to 1.
2FC1: CD122A  	        call    ADDPHL          ; Add 1 to FPREG
2FC4: CD532B  	        call    MULLN2          ; Multiply by LN(2)
2FC7: F1      	        pop     AF              ; Restore scaling factor
2FC8: C1      	        pop     BC              ; Restore exponent
2FC9: D1      	        pop     DE
2FCA: F5      	        push    AF              ; Save scaling factor
2FCB: CD1E2A  	        call    SUBCDE          ; Subtract exponent from FPREG
2FCE: CDE12C  	        call    INVSGN          ; Negate result
2FD1: 21DF2F  	        ld      HL,EXPTAB       ; Coefficient table
2FD4: CD0F30  	        call    SMSER1          ; Sum the series
2FD7: 110000  	        ld      DE,$0000        ; Zero LSBs
2FDA: C1      	        pop     BC              ; Scaling factor
2FDB: 4A      	        ld      C,D             ; Zero MSB
2FDC: C35C2B  	        jp      FPMULT          ; Scale result to correct value
              	
2FDF: 08      	EXPTAB: defb    $08             ; Table used by EXP
2FE0: 402E9474	        defb    $40,$2E,$94,$74 ; -1/7! (-1/5040)
2FE4: 704F2E77	        defb    $70,$4F,$2E,$77 ;  1/6! ( 1/720)
2FE8: 6E02887A	        defb    $6E,$02,$88,$7A ; -1/5! (-1/120)
2FEC: E6A02A7C	        defb    $E6,$A0,$2A,$7C ;  1/4! ( 1/24)
2FF0: 50AAAA7E	        defb    $50,$AA,$AA,$7E ; -1/3! (-1/6)
2FF4: FFFF7F7F	        defb    $FF,$FF,$7F,$7F ;  1/2! ( 1/2)
2FF8: 00008081	        defb    $00,$00,$80,$81 ; -1/1! (-1/1)
2FFC: 00000081	        defb    $00,$00,$00,$81 ;  1/0! ( 1/1)
              	
3000: CDE92C  	SUMSER: call    STAKFP          ; Put FPREG on stack
3003: 115A2B  	        ld      DE,MULT         ; Multiply by "X"
3006: D5      	        push    DE              ; To be done after
3007: E5      	        push    HL              ; Save address of table
3008: CD042D  	        call    BCDEFP          ; Move FPREG to BCDE
300B: CD5C2B  	        call    FPMULT          ; Square the value
300E: E1      	        pop     HL              ; Restore address of table
300F: CDE92C  	SMSER1: call    STAKFP          ; Put value on stack
3012: 7E      	        ld      A,(HL)          ; Get number of coefficients
3013: 23      	        inc     HL              ; Point to start of table
3014: CDF62C  	        call    PHLTFP          ; Move coefficient to FPREG
3017: 06      	        defb    06H             ; Skip "pop AF"
3018: F1      	SUMLP:  pop     AF              ; Restore count
3019: C1      	        pop     BC              ; Restore number
301A: D1      	        pop     DE
301B: 3D      	        dec     A               ; Cont coefficients
301C: C8      	        ret     Z               ; All done
301D: D5      	        push    DE              ; Save number
301E: C5      	        push    BC
301F: F5      	        push    AF              ; Save count
3020: E5      	        push    HL              ; Save address in table
3021: CD5C2B  	        call    FPMULT          ; Multiply FPREG by BCDE
3024: E1      	        pop     HL              ; Restore address in table
3025: CD072D  	        call    LOADFP          ; Number at HL to BCDE
3028: E5      	        push    HL              ; Save address in table
3029: CD212A  	        call    FPADD           ; Add coefficient to FPREG
302C: E1      	        pop     HL              ; Restore address in table
302D: C31830  	        jp      SUMLP           ; More coefficients
              	
3030: CDB82C  	RND:    call    TSTSGN          ; Test sign of FPREG
3033: 217A80  	        ld      HL,SEED+2       ; Random number seed
3036: FA9130  	        jp      M,RESEED        ; Negative - Re-seed
3039: 219B80  	        ld      HL,LSTRND       ; Last random number
303C: CDF62C  	        call    PHLTFP          ; Move last RND to FPREG
303F: 217A80  	        ld      HL,SEED+2       ; Random number seed
3042: C8      	        ret     Z               ; Return if RND(0)
3043: 86      	        add     A,(HL)          ; Add (SEED)+2)
3044: E607    	        and     %00000111       ; 0 to 7
3046: 0600    	        ld      B,$00
3048: 77      	        ld      (HL),A          ; Re-save seed
3049: 23      	        inc     HL              ; Move to coefficient table
304A: 87      	        add     A,A             ; 4 bytes
304B: 87      	        add     A,A             ; per entry
304C: 4F      	        ld      C,A             ; BC = Offset into table
304D: 09      	        add     HL,BC           ; Point to coefficient
304E: CD072D  	        call    LOADFP          ; Coefficient to BCDE
3051: CD5C2B  	        call    FPMULT  ;       ; Multiply FPREG by coefficient
3054: 3A7980  	        ld      A,(SEED+1)      ; Get (SEED+1)
3057: 3C      	        inc     A               ; Add 1
3058: E603    	        and     %00000011       ; 0 to 3
305A: 0600    	        ld      B,$00
305C: FE01    	        cp      $01             ; Is it zero?
305E: 88      	        adc     A,B             ; Yes - Make it 1
305F: 327980  	        ld      (SEED+1),A      ; Re-save seed
3062: 219530  	        ld      HL,RNDTAB-4     ; Addition table
3065: 87      	        add     A,A             ; 4 bytes
3066: 87      	        add     A,A             ; per entry
3067: 4F      	        ld      C,A             ; BC = Offset into table
3068: 09      	        add     HL,BC           ; Point to value
3069: CD122A  	        call    ADDPHL          ; Add value to FPREG
306C: CD042D  	RND1:   call    BCDEFP          ; Move FPREG to BCDE
306F: 7B      	        ld      A,E             ; Get LSB
3070: 59      	        ld      E,C             ; LSB = MSB
3071: EE4F    	        xor     %01001111       ; Fiddle around
3073: 4F      	        ld      C,A             ; New MSB
3074: 3680    	        ld      (HL),$80        ; Set exponent
3076: 2B      	        dec     HL              ; Point to MSB
3077: 46      	        ld      B,(HL)          ; Get MSB
3078: 3680    	        ld      (HL),$80        ; Make value -0.5
307A: 217880  	        ld      HL,SEED         ; Random number seed
307D: 34      	        inc     (HL)            ; Count seed
307E: 7E      	        ld      A,(HL)          ; Get seed
307F: D6AB    	        sub     $AB             ; Do it modulo 171
3081: C28830  	        jp      NZ,RND2         ; Non-zero - Ok
3084: 77      	        ld      (HL),A          ; Zero seed
3085: 0C      	        inc     C               ; Fillde about
3086: 15      	        dec     D               ; with the
3087: 1C      	        inc     E               ; number
3088: CD722A  	RND2:   call    BNORM           ; Normalise number
308B: 219B80  	        ld      HL,LSTRND       ; Save random number
308E: C3102D  	        jp      FPTHL           ; Move FPREG to last and return
              	
3091: 77      	RESEED: ld      (HL),A          ; Re-seed random numbers
3092: 2B      	        dec     HL
3093: 77      	        ld      (HL),A
3094: 2B      	        dec     HL
3095: 77      	        ld      (HL),A
3096: C36C30  	        jp      RND1            ; Return RND seed
              	
3099: 68B14668	RNDTAB: defb    $68,$B1,$46,$68 ; Table used by RND
309D: 99E99269	        defb    $99,$E9,$92,$69
30A1: 10D17568	        defb    $10,$D1,$75,$68
              	
30A5: 21EF30  	COS:    ld      HL,HALFPI       ; Point to PI/2
30A8: CD122A  	        call    ADDPHL          ; Add it to PPREG
30AB: CDE92C  	SIN:    call    STAKFP          ; Put angle on stack
30AE: 014983  	        ld      BC,$8349        ; BCDE = 2 PI
30B1: 11DB0F  	        ld      DE,$0FDB
30B4: CDF92C  	        call    FPBCDE          ; Move 2 PI to FPREG
30B7: C1      	        pop     BC              ; Restore angle
30B8: D1      	        pop     DE
30B9: CD0E2C  	        call    DVBCDE          ; Divide angle by 2 PI
30BC: CDE92C  	        call    STAKFP          ; Put it on stack
30BF: CD8B2D  	        call    INT             ; Get INT of result
30C2: C1      	        pop     BC              ; Restore number
30C3: D1      	        pop     DE
30C4: CD1E2A  	        call    SUBCDE          ; Make it 0 <= value < 1
30C7: 21F330  	        ld      HL,QUARTR       ; Point to 0.25
30CA: CD182A  	        call    SUBPHL          ; Subtract value from 0.25
30CD: CDB82C  	        call    TSTSGN          ; Test sign of value
30D0: 37      	        scf                     ; Flag positive
30D1: F2DB30  	        jp      P,SIN1          ; Positive - Ok
30D4: CD0F2A  	        call    ROUND           ; Add 0.5 to value
30D7: CDB82C  	        call    TSTSGN          ; Test sign of value
30DA: B7      	        or      A               ; Flag negative
30DB: F5      	SIN1:   push    AF              ; Save sign
30DC: F4E12C  	        call    P,INVSGN        ; Negate value if positive
30DF: 21F330  	        ld      HL,QUARTR       ; Point to 0.25
30E2: CD122A  	        call    ADDPHL          ; Add 0.25 to value
30E5: F1      	        pop     AF              ; Restore sign
30E6: D4E12C  	        call    NC,INVSGN       ; Negative - Make positive
30E9: 21F730  	        ld      HL,SINTAB       ; Coefficient table
30EC: C30030  	        jp      SUMSER          ; Evaluate sum of series
              	
30EF: DB0F4981	HALFPI: defb    $DB,$0F,$49,$81 ; 1.5708 (PI/2)
              	
30F3: 0000007F	QUARTR: defb    $00,$00,$00,$7F ; 0.25
              	
30F7: 05      	SINTAB: defb    $05             ; Table used by SIN
30F8: BAD71E86	        defb    $BA,$D7,$1E,$86 ; 39.711
30FC: 64269987	        defb    $64,$26,$99,$87 ;-76.575
3100: 58342387	        defb    $58,$34,$23,$87 ; 81.602
3104: E05DA586	        defb    $E0,$5D,$A5,$86 ;-41.342
3108: DA0F4983	        defb    $DA,$0F,$49,$83 ;  6.2832
              	
310C: CDE92C  	TAN:    call    STAKFP          ; Put angle on stack
310F: CDAB30  	        call    SIN             ; Get SIN of angle
3112: C1      	        pop     BC              ; Restore angle
3113: E1      	        pop     HL
3114: CDE92C  	        call    STAKFP          ; Save SIN of angle
3117: EB      	        ex      DE,HL           ; BCDE = Angle
3118: CDF92C  	        call    FPBCDE          ; Angle to FPREG
311B: CDA530  	        call    COS             ; Get COS of angle
311E: C30C2C  	        jp      DIV             ; TAN = SIN / COS
              	
3121: CDB82C  	ATN:    call    TSTSGN          ; Test sign of value
3124: FC4C2F  	        call    M,NEGAFT        ; Negate result after if -ve
3127: FCE12C  	        call    M,INVSGN        ; Negate value if -ve
312A: 3ACC81  	        ld      A,(FPEXP)       ; Get exponent
312D: FE81    	        cp      81H             ; Number less than 1?
312F: DA3E31  	        jp      C,ATN1          ; Yes - Get arc tangnt
3132: 010081  	        ld      BC,$8100        ; BCDE = 1
3135: 51      	        ld      D,C
3136: 59      	        ld      E,C
3137: CD0E2C  	        call    DVBCDE          ; Get reciprocal of number
313A: 21182A  	        ld      HL,SUBPHL       ; Sub angle from PI/2
313D: E5      	        push    HL              ; Save for angle > 1
313E: 214831  	ATN1:   ld      HL,ATNTAB       ; Coefficient table
3141: CD0030  	        call    SUMSER          ; Evaluate sum of series
3144: 21EF30  	        ld      HL,HALFPI       ; PI/2 - angle in case > 1
3147: C9      	        ret                     ; Number > 1 - Sub from PI/2
              	
3148: 09      	ATNTAB: defb    $09             ; Table used by ATN
3149: 4AD73B78	        defb    $4A,$D7,$3B,$78 ; 1/17
314D: 026E847B	        defb    $02,$6E,$84,$7B ;-1/15
3151: FEC12F7C	        defb    $FE,$C1,$2F,$7C ; 1/13
3155: 74319A7D	        defb    $74,$31,$9A,$7D ;-1/11
3159: 843D5A7D	        defb    $84,$3D,$5A,$7D ; 1/9
315D: C87F917E	        defb    $C8,$7F,$91,$7E ;-1/7
3161: E4BB4C7E	        defb    $E4,$BB,$4C,$7E ; 1/5
3165: 6CAAAA7F	        defb    $6C,$AA,$AA,$7F ;-1/3
3169: 00000081	        defb    $00,$00,$00,$81 ; 1/1
              	
              	
316D: C9      	ARET:   ret                     ; A RETurn instruction
              	
316E: D7      	GETINP: rst     $10             ; input a character
316F: C9      	        ret
              	
3170: E5      	CLS:    push    HL
3171: D5      	        push    DE
3172: 3AE081  	        ld      A,(SCR_MODE)    ; check screen mode
3175: FE02    	        cp      $02             ; G2 mode?
3177: CC5805  	        call    Z,EMPTYVIDBUF   ; yes, reset video buffer
317A: D1      	        pop     DE
317B: E1      	        pop     HL
317C: 3E0C    	        ld      A,CS            ; ASCII Clear screen
317E: CD5818  	        call    SND2VID         ; send to screen
3181: C3253C  	        jp      MONOUT          ; Output character
              	
3184: CD3827  	WIDTH:  call    GETINT          ; Get integer 0-255
3187: 7B      	        ld      A,E             ; Width to A
3188: 32A280  	        ld      (LWIDTH),A      ; Set width
318B: C9      	        ret
              	
              	
318C: CDF31A  	DEEK:   call    DEINT           ; Get integer -32768 to 32767
318F: D5      	        push    DE              ; Save number
3190: E1      	        pop     HL              ; Number to HL
3191: 46      	RECWRD: ld      B,(HL)          ; Get LSB of contents
3192: 23      	        inc     HL
3193: 7E      	        ld      A,(HL)          ; Get MSB of contents
3194: C39C22  	        jp      ABPASS          ; Return integer AB
              	
3197: CDB21E  	DOKE:   call    GETNUM          ; Get a number
319A: CDF31A  	        call    DEINT           ; Get integer -32768 to 32767
319D: D5      	        push    DE              ; Save address
319E: CD1A18  	        call    CHKSYN          ; Make sure ',' follows
31A1: 2C      	        defb    ','
31A2: CDB21E  	        call    GETNUM          ; Get a number
31A5: CDF31A  	        call    DEINT           ; Get integer -32768 to 32767
31A8: E3      	        ex      (SP),HL         ; Save value,get address
31A9: 73      	        ld      (HL),E          ; Save LSB of value
31AA: 23      	        inc     HL
31AB: 72      	        ld      (HL),D          ; Save MSB of value
31AC: E1      	        pop     HL              ; Restore code string address
31AD: C9      	        ret
              	
              	; stop the execution of code for a certain bit of time. The pause
              	; is between $0000 and $FFFF 100ths of second (0~655.5 secs)
31AE: CDB21E  	PAUSE:  call    GETNUM          ; Get a number
31B1: CDF31A  	        call    DEINT           ; Get integer -32768 to 32767
31B4: 7A      	        ld      A,D             ; load D into A
31B5: B3      	        or      E               ; are D & E equal to $00?
31B6: C8      	        ret     Z               ; if yes, then return
31B7: C5      	DIR_PAU:push    BC              ; store BC
31B8: 3ACE81  	        ld      A,(TMRCNT)      ; Load current value of system timer
31BB: 47      	        ld      B,A             ; move it into B
31BC: CD681A  	RPTPS:  call    TSTBRK          ; Test for break key
31BF: 3ACE81  	        ld      A,(TMRCNT)      ; Load current value of system timer
31C2: B8      	        cp      B               ; is it the same value?
31C3: 28F7    	        jr      Z,RPTPS         ; yes, so read again
31C5: 47      	        ld      B,A             ; no, so store the new value
31C6: 1B      	        dec     DE              ; decrement interval
31C7: 7A      	        ld      A,D             ; load D into A
31C8: B3      	        or      E               ; check if DE is equal to 0 (if D & e are $00 then result is 0)
31C9: 20F1    	        jr      NZ,RPTPS        ; no, repeat
31CB: C1      	        pop     BC              ; yes, recover BC and continue
31CC: C9      	        ret
              	
              	; change the screen mode. Usage: SCREEN X[,Y][,Z]
              	; where X is: 0=text mode (40x24),
              	; 1=graphic mode 1 (32x24 chars); 2=graphic mode 2 (256x192 pixels);
              	; 3=multicolor mode (64x48 pixels); 4=extended graphic mode 2 (32x24 chars mixed between G1 and G2)
              	; Y is: 0=8x8 sprites, 1=16x16 sprites
              	; Z is: 0=no sprite magnification; 1=sprite magnification x2 (8x8=>16x16, and 16x16=32x32)
              	; (the latters are accepted only in graphic modes G1, G2, G3, and G4)
31CD: AF      	SCREEN: xor     A
31CE: 32F181  	        ld      (TMPBFR2),A     ; sprite size & magnif. byte set to 0
31D1: CD3827  	        call    GETINT          ; Get integer 0-255
31D4: FE05    	        cp      $05             ; is it a valid mode (0~4)?
31D6: D2081B  	        jp      NC,FCERR        ; No - Illegal function call Error
31D9: 32EF81  	        ld      (TMPBFR1),A     ; store graphic mode
31DC: A7      	        and     A               ; is it 0 (text mode)?
31DD: CAF931  	        jp      Z,SCVDP         ; yes, ignore other arguments and set mode immediately
31E0: CD3832  	SETVDP: call    CHKSCAR         ; no, check if sprite size follows
31E3: DAEB31  	        jp      C,CKMAGN        ; no (set to 0 or missing), so jump over
31E6: 3E02    	        ld      A,$02           ; no, so set sprite size
31E8: 32F181  	        ld      (TMPBFR2),A     ; ...to 16x16
31EB: CD3832  	CKMAGN: call    CHKSCAR         ; check if sprite magnification follows
31EE: DAF931  	        jp      C,SCVDP         ; no (set to 0 or missing), so jump over
31F1: 3AF181  	        ld      A,(TMPBFR2)     ; yes, so retrieve sprite attributes...
31F4: F601    	        or      $01             ; ...set sprite magnification to 2x...
31F6: 32F181  	        ld      (TMPBFR2),A     ; ...and save flags again
31F9: F3      	SCVDP:  di                      ; disable INTs
31FA: D5      	        push    DE              ; store DE
31FB: E5      	        push    HL              ; store HL
31FC: 3AEF81  	        ld      A,(TMPBFR1)     ; recover graphic mode
31FF: 5F      	        ld      E,A             ; and store it into E
3200: 3AF181  	        ld      A,(TMPBFR2)     ; recover sprite flags
3203: 57      	        ld      D,A             ; and store them into D
3204: D5      	        push    DE              ; store D & E
3205: CD7E03  	        call    initVDP         ; initialize VDP with mode pointed by E
3208: D1      	        pop     DE              ; retrieve D & E
3209: 7B      	        ld      A,E             ; move graphic mode into A
320A: 87      	        add     A,A
320B: 87      	        add     A,A
320C: 87      	        add     A,A             ; multiply A times 8 to get offset of graphic mode
320D: 5F      	        ld      E,A             ; and pass it into E
320E: D5      	        push    DE              ; store sprite flags in E
320F: 1600    	        ld      D,$00           ; reset D
3211: 21360A  	        ld      HL,VDPMODESET+1 ; load address of VDP settings for reg#1
3214: 19      	        add     HL,DE           ; load correct reg#1 setting
3215: D1      	        pop     DE              ; retrieve sprite flags from E
3216: 7E      	        ld      A,(HL)          ; load reg#1 setting
3217: E6FC    	        and     %11111100       ; reset size & magn. bits
3219: B2      	        or      D               ; set size & magn. bits
321A: 5F      	        ld      E,A             ; value into E
321B: 3E01    	        ld      A,$01           ; reg #1
321D: CD3406  	        call    WRITE_VREG      ; send setting to reg #1
3220: 2AAF80  	        ld      HL,(LINEAT)     ; Get current line number
3223: 23      	        inc     HL              ; -1 means direct statement
3224: 7C      	        ld      A,H
3225: B5      	        or      L
3226: CC3608  	        call    Z,CURSOR_ON     ; enable cursor if not in program mode
3229: FB      	        ei                      ; re-enable interrupts
322A: E1      	        pop     HL              ; restore HL
322B: D1      	        pop     DE              ; restore DE
322C: 3ADF81  	        ld      A,(SCR_SIZE_H)  ; check the screen mode by looking at the screen height
322F: FE30    	        cp      $30             ; is it 48 chars or 192 pixels (MC and G2 modes)?
3231: D0      	        ret     NC              ; yes, so exit (in graphics 2 and multicolor no print-on-video)
3232: 3E01    	        ld      A,$01           ; no (we are in Text, G1 or ExG2), so activate the...
3234: 32EB81  	        ld      (PRNTVIDEO),A   ; ...video buffer...
3237: C9      	        ret                     ; ...and return to caller
              	
              	; check an additional argument for SCREEN
3238: 2B      	CHKSCAR:dec     HL              ; dec 'cos GETCHR INCs
3239: CD3D1A  	        call    GETCHR          ; Get next character
323C: 37      	        scf                     ; set carry flag
323D: C8      	        ret     Z               ; return if nothing follows with Carry=1
323E: CD1A18  	        call    CHKSYN          ; Make sure ',' follows
3241: 2C      	        defb    ','
3242: CD3827  	        call    GETINT          ; get value
3245: 1F      	        rra                     ; Carry=bit #0
3246: 3F      	        ccf                     ; invert Carry, so Carry=0 if arg. is 1, and Carry=1 otherwise (arg<>1)
3247: C9      	        ret                     ; return
              	
              	
              	; change the colors of the screen - Syntax is COLOR a,b,c where:
              	; a=foreground color / b=background color / c=border color
              	; a,b,c must be in a range between 1 and 15 (0 is transparent and it's not supported)
3248: CD3827  	COLOR:  call    GETINT          ; get first value
324B: CDEF32  	        call    CHKCLR          ; check if it's in range 1~15
324E: 32EF81  	        ld      (TMPBFR1),A     ; store it
3251: 3AE081  	        ld      A,(SCR_MODE)    ; check screen mode
3254: FE03    	        cp      $03             ; is it multicolor mode?
3256: 200D    	        jr      NZ,CNTCKCL      ; no, continue
3258: 3E0F    	        ld      A,$0F           ; white for...
325A: 32ED81  	        ld      (FRGNDCLR),A    ; ...foreground (even it's not used in MC)
325D: 3AEF81  	        ld      A,(TMPBFR1)     ; yes, so we stop here because in MC mode we just support border color
3260: 32F381  	        ld      (TMPBFR3),A     ; move color into temp buffer 3
3263: 1834    	        jr      CLRMC           ; jump to set color
3265: CD1A18  	CNTCKCL:call    CHKSYN          ; Make sure ',' follows
3268: 2C      	        defb    ','
3269: CD3827  	        call    GETINT          ; get second value
326C: CDEF32  	        call    CHKCLR          ; check if it's in range 1~15
326F: 32F181  	        ld      (TMPBFR2),A     ; store it
3272: 32EE81  	        ld      (BKGNDCLR),A    ; and set as background color
3275: 3AE081  	        ld      A,(SCR_MODE)    ; check screen mode
3278: A7      	        and     A               ; is it text mode?
3279: 281B    	        jr      Z,CLRTXT        ; yes, stop here because in text mode, background and border colors coincide
327B: CD1A18  	        call    CHKSYN          ; Make sure ',' follows
327E: 2C      	        defb    ','
327F: CD3827  	        call    GETINT          ; get third value
3282: CDEF32  	        call    CHKCLR          ; check if it's in range 1~15
3285: 32F381  	        ld      (TMPBFR3),A     ; store it
3288: D5      	        push    DE              ; store DE
3289: 3AE081  	        ld      A,(SCR_MODE)    ; check screen mode
328C: FE01    	        cp      $01             ; is it G1 mode?
328E: 2810    	        jr      Z,CLRG1         ; yes, jump over
3290: FE02    	        cp      $02             ; is it G2 mode?
3292: 2815    	        jr      Z,CLRG2         ; yes, jump over
3294: 181C    	        jr      CLREX2          ; last case can only be ExG2
3296: CDE232  	CLRTXT: call    MIXCLRS         ; mix foreground and background color nibbles in 1 byte
3299: 32F381  	CLRMC:  ld      (TMPBFR3),A     ; store color settings (for MC mode, we only set border color)
329C: D5      	        push    DE              ; store DE
329D: F3      	        di                      ; disable INTs
329E: 182E    	        jr      SETBRCL         ; set colors and exit
32A0: CDE232  	CLRG1:  call    MIXCLRS         ; mix foreground and background color nibbles in 1 byte
32A3: 1601    	        ld      D,$01           ; repeat 1 time
32A5: 0620    	        ld      B,$20           ; 32 bytes of colors
32A7: 1810    	        jr      LOADCLR         ; load colors
32A9: CDE232  	CLRG2:  call    MIXCLRS         ; mix foreground and background color nibbles in 1 byte
32AC: 1618    	        ld      D,$18           ; 18 pages of...
32AE: 0600    	        ld      B,$00           ; ...256 bytes each
32B0: 1807    	        jr      LOADCLR         ; load colors
32B2: CDE232  	CLREX2: call    MIXCLRS         ; mix foreground and background color nibbles in 1 byte
32B5: 1608    	        ld      D,$08           ; 8 pages of...
32B7: 0600    	        ld      B,$00           ; ...256 bytes each
32B9: E5      	LOADCLR:push    HL              ; store HL
32BA: 210020  	        ld      HL,$2000        ; color table start: $2000
32BD: F3      	        di                      ; disable INTs
32BE: CDEA05  	        call    SETVDPADRS
32C1: 0E30    	        ld      C,VDP_DAT       ; VDP data mode
32C3: ED79    	RPTLDCL:out     (C),A           ; after first byte, the VDP autoincrements VRAM pointer
32C5: 00      	        nop
32C6: 00      	        nop
32C7: 10FA    	        djnz    RPTLDCL         ; repeat for 256 bytes (1 page)
32C9: 15      	        dec     D               ; did we fill up all the pages?
32CA: 20F7    	        jr      NZ,RPTLDCL      ; no, repeat
32CC: FB      	        ei
32CD: E1      	        pop     HL              ; retrieve HL
32CE: 87      	SETBRCL:add     A,A             ; move high nibble
32CF: 87      	        add     A,A             ; to right to get the
32D0: 87      	        add     A,A             ; foreground color
32D1: 87      	        add     A,A             ; into the low nibble
32D2: 32ED81  	        ld      (FRGNDCLR),A    ; store foreground color
32D5: 3AF381  	        ld      A,(TMPBFR3)     ; recover border color
32D8: 5F      	        ld      E,A             ; move A into E
32D9: 3E07    	        ld      A,$07           ; VDP register 7
32DB: F3      	        di
32DC: CD3406  	        call    WRITE_VREG      ; send value to VDP: set border color
32DF: FB      	        ei                      ; re-enable INTs
32E0: D1      	        pop     DE              ; retrieve DE
32E1: C9      	        ret                     ; return to caller
              	
              	
              	; mix 2 color nibbles in 1 byte
32E2: 3AF181  	MIXCLRS:ld      A,(TMPBFR2)     ; retrieve background color
32E5: 47      	        ld      B,A             ; move it into B
32E6: 3AEF81  	        ld      A,(TMPBFR1)     ; retrieve foreground color
32E9: 87      	        add     A,A             ; move foreground color into the high nibble of A
32EA: 87      	        add     A,A
32EB: 87      	        add     A,A
32EC: 87      	        add     A,A
32ED: B0      	        or      B               ; put background color into the low nibble of A
32EE: C9      	        ret                     ; return to caller
              	
              	
              	; check if the color is not 0 and into the range 1~15
32EF: A7      	CHKCLR: and     A               ; is it 0?
32F0: CA3815  	        jp      Z,SNERR         ; yes, raise a SN error
32F3: FE10    	        cp      $10             ; is it in range 1~15?
32F5: D23815  	        jp      NC,SNERR        ; no, raise a SN error
32F8: C9      	        ret                     ; param is OK, can return
              	
              	
              	; check if in graphics 2 mode
32F9: 3AE081  	CHKG2M: ld      A,(SCR_MODE)    ; check screen mode
32FC: FE02    	        cp      $02             ; actually, we can paint only in G2
32FE: C2CC37  	        jp      NZ,GMERR        ; no G2, print a No Graphics Mode Error
3301: C9      	        ret                     ; return to caller
              	
              	
              	; print a text in screen 2
              	; GPRINT text,x,y[,fc[,bc]]
              	; where "text" is an expression that can be converted into a sequence of ASCII chars,
              	; x & y are the coordinates (0<=x<=32, 0<=y<=23), fc & bc are foreground and background
              	; colors (1~15), resp.
              	; (portions of code are from nippur72)
81F3:         	GX      equ     TMPBFR3
81F5:         	GY      equ     TMPBFR4
81EF:         	MIXCOL  equ     TMPBFR1
81F1:         	CHRPNT  equ     TMPBFR2
3302: CDF932  	GPRINT: call    CHKG2M          ; check if in graphic mode 2
3305: 2B      	        dec     HL              ; dec 'cos GETCHR INCs
3306: CD3D1A  	        call    GETCHR          ; check if something follows
3309: CA3815  	        jp      Z,SNERR         ; if nothing else, raise a syntax error
330C: 22F781  	        ld      (VIDEOBUFF),HL  ; save current code string pointer
330F: CDC41E  	        call    EVAL            ; Evaluate expression
3312: CDB61E  	        call    TSTSTR          ; Make sure it's a string
3315: CD1A18  	        call    CHKSYN          ; Make sure ',' follows
3318: 2C      	        defb    ','
3319: CD3827  	        call    GETINT          ; get X coord.
331C: FE20    	        cp      $20             ; is it in rage 0~31?
331E: D2081B  	        jp      NC,FCERR        ; Illegal function call error
3321: 32F381  	        ld      (GX),A          ; store into temp. buffer
3324: CD1A18  	        call    CHKSYN          ; Make sure ',' follows
3327: 2C      	        defb    ','
3328: CD3827  	        call    GETINT          ; get Y coord.
332B: FE18    	        cp      $18             ; is it in range 0~23?
332D: D2081B  	        jp      NC,FCERR        ; Illegal function call error
3330: 32F581  	        ld      (GY),A          ; store into temp. buffer
3333: 11F181  	        ld      DE,TMPBFR2
3336: 3AEE81  	        ld      A,(BKGNDCLR)    ; load background color
3339: 12      	        ld      (DE),A          ; store into temp buff
333A: 3AED81  	        ld      A,(FRGNDCLR)    ; load foreground color
333D: 1B      	        dec     DE
333E: 1B      	        dec     DE
333F: 12      	        ld      (DE),A          ; store into temp buff
3340: CDD533  	        call    CKCOL           ; check color
3343: CA4B33  	        jp      Z,CNTGPT2       ; if anything follows, jump over
3346: 13      	        inc     DE
3347: 13      	        inc     DE
3348: CDD533  	        call    CKCOL           ; check background color
334B: CDE232  	CNTGPT2:call    MIXCLRS         ; mix foreground & background colors
334E: 32EF81  	        ld      (MIXCOL),A      ; store mixed colors
3351: EB      	        ex      DE,HL           ; save code string address into DE
3352: 2AF781  	        ld      HL,(VIDEOBUFF)  ; retrieve pointer to string
3355: D5      	        push    DE              ; store code string address
3356: CDC41E  	        call    EVAL            ; re-evaluate string
3359: CDFD24  	        call    GSTRCU          ; Current string to pool
335C: CD072D  	        call    LOADFP          ; Move string block to BCDE (BC=pointer, E=length)
335F: ED43F181	        ld      (CHRPNT),BC
3363: 1C      	        inc     E               ; Length + 1
3364: CD6933  	        call    GPNT            ; print on G2
3367: E1      	        pop     HL              ; recover HL
3368: C9      	        ret                     ; return to caller
3369: D5      	GPNT:   push    DE              ; store string lenght (E)
              	        ; calculate VRAM address of first char
336A: 3AF381  	        LD      A,(GX)          ; load X
336D: 6F      	        ld      L,A             ;
336E: 2600    	        ld      H,0             ; HL = X
3370: 29      	        add     HL,HL           ;
3371: 29      	        add     HL,HL           ;
3372: 29      	        add     HL,HL           ; HL = X*8
3373: 3AF581  	        ld      A,(GY)          ; load Y
3376: 57      	        ld      D,A             ;
3377: 1E00    	        ld      E,0             ; DE = Y * 256
3379: 19      	        add     HL,DE           ; address = X*8 + Y*256
337A: 22F781  	        ld      (VIDEOBUFF),HL  ; store VRAM address of first VRAM cell
337D: D1      	        pop     DE              ; retrieve # of chars to be printed yet (E)
337E: 1D      	RPGPNT: dec     E               ; Count characters
337F: C8      	        ret     Z               ; End of string - return
3380: D5      	        push    DE              ; store chars counter
              	        ; calculate dest address in color vram
3381: 2AF781  	        ld      HL,(VIDEOBUFF)  ; recover VRAM address 
3384: 110020  	        ld      DE,$2000        ; color map address
3387: 19      	        add     HL,DE           ; HL = $2000 + XY address
3388: F3      	        di                      ; disable INTs
              	        ; send color settings
3389: CDEA05  	GPNTCOL:call    SETVDPADRS      ; set VRAM address for color cell
338C: 3AEF81  	        ld      A,(MIXCOL)      ; load color settings
338F: 0608    	        ld      B,$08           ; repeat for 8 rows
3391: 0E30    	        ld      C,VDP_DAT       ; VDP data mode
3393: ED79    	GPNTCO1:out     (C),A           ; send data (VRAM pointer auto-increments)
3395: 00      	        nop                     ; wait...
3396: 00      	        nop                     ; ...a...
3397: 00      	        nop                     ; ...while
3398: 10F9    	        djnz    GPNTCO1         ; repeat for 8 cells
              	        ; calculate source address
339A: 2AF181  	        ld      HL,(CHRPNT)     ; load char pointer
339D: 7E      	        ld      A,(HL)          ; get char
339E: 23      	        inc     HL              ; increment char pointer
339F: 22F181  	        ld      (CHRPNT),HL     ; store char pointer
33A2: 6F      	        ld      L,A             ;
33A3: 2600    	        ld      H,0             ; char into HL
33A5: 29      	        add     HL,HL           ;
33A6: 29      	        add     HL,HL           ;
33A7: 29      	        add     HL,HL           ; get offset of char into ROM (charcode * 8)
33A8: 119644  	        ld      DE,CHRST88      ; DE = start of 8x8 fonts in ROM
33AB: 19      	        add     HL,DE           ; HL = start of characters in ROM
33AC: EB      	        ex      DE,HL           ; store address into DE
33AD: 2AF781  	GPCPCHR:ld      HL,(VIDEOBUFF)  ; load VRAM address
33B0: CDEA05  	        call    SETVDPADRS      ; send it to VDP
33B3: EB      	        ex      DE,HL           ; restore address into HL
33B4: 0608    	        ld      B,$08           ; repeat for 8 rows
33B6: 0E30    	        ld      C,VDP_DAT       ; VDP data mode
33B8: EDA3    	GPCPCH1:outi                    ; load a byte from ROM and send to VRAM
33BA: 00      	        nop                     ; wait...
33BB: 00      	        nop                     ; ...a...
33BC: 00      	        nop                     ; ...while
33BD: 20F9    	        jr      NZ,GPCPCH1      ; repeat for 8 chars
33BF: FB      	        ei                      ; re-enable INTs
33C0: 110800  	        ld      DE,$0008        ; 8 bytes to go to the next video ell
33C3: 2AF781  	        ld      HL,(VIDEOBUFF)  ; load VRAM address
33C6: 19      	        add     HL,DE           ; get address of next VRAM cell
33C7: 22F781  	        ld      (VIDEOBUFF),HL  ; store new VRAM address
33CA: 110018  	        ld      DE,$1800        ; forbidden address
33CD: CD483C  	        call    CMP16           ; check if the printing has gone out of the screen
33D0: D1      	        pop     DE              ; retrieve number of chars to be printed
33D1: D0      	        ret     NC              ; if HL>=$1800 then leave
33D2: C37E33  	        jp      RPGPNT          ; otherwise, check if more chars to output
              	        
33D5: 2B      	CKCOL:  dec     HL              ; dec 'cos GETCHR INCs
33D6: CD3D1A  	        call    GETCHR          ; Get next character
33D9: C8      	        ret     Z               ; return if nothing follows
33DA: CD1A18  	        call    CHKSYN          ; Make sure ',' follows
33DD: 2C      	        defb    ','
33DE: D5      	        push    DE              ; store DE
33DF: CD3827  	        call    GETINT          ; get value
33E2: CDEF32  	        call    CHKCLR          ; check if color is in range 1~15
33E5: D1      	        pop     DE              ; retrieve DE
33E6: 12      	        ld      (DE),A          ; store color into temp buffer
33E7: C9      	        ret                     ; return to caller
              	        
              	; POINT(x,y): return if a pixel is set (1) or reset (0)
33E8: CDF932  	POINT:  call    CHKG2M          ; check if in graphic mode 2
33EB: CD1A18  	        call    CHKSYN          ; make sure "(" follows
33EE: 28      	        defb    '('
33EF: CD3827  	        call    GETINT          ; get X coords.
33F2: 32EF81  	        ld      (TMPBFR1),A     ; store it into a temp buffer
33F5: CD1A18  	        call    CHKSYN          ; Make sure ',' follows
33F8: 2C      	        defb    ','
33F9: CD3827  	        call    GETINT          ; get Y coords,
33FC: FEC0    	        cp      $C0             ; check if Y is in range 0~191
33FE: D2081B  	        jp      NC,FCERR        ; no, raise an FC error
3401: 32F181  	        ld      (TMPBFR2),A     ; store into a temp buffer
3404: CD1A18  	        call    CHKSYN          ; make sure ")" follows
3407: 29      	        defb    ')'
3408: E5      	        push    HL              ; store current string address - the point after the ")" - ...
3409: FDE1    	        pop     IY              ; ...into IY
340B: CD7A34  	        call    XY2HL           ; find HL address of pixel at X,Y
340E: 57      	        ld      D,A             ; store pixel index
340F: F3      	        di                      ; disable INTs
3410: CD0A06  	        call    READ_VIDEO_LOC  ; read contents of VRAM cell addressed by HL
3413: FB      	        ei                      ; re-enable INTs
3414: A2      	        and     D               ; is the pixel ON or OFF? (will be checked later)
3415: E1      	        pop     HL              ; drop original return point
3416: FDE5    	        push    IY              ; load current string address from IY into stack
3418: 119D1F  	        ld      DE,RETNUM       ; Address of Return number from function...
341B: D5      	        push    DE              ; ...saved on stack
341C: 3E00    	        LD      A,$00           ; A=0 (reset A w/o altering flags)
341E: 47      	        LD      B,A             ; and B=0, so integer AB = 0
341F: CA9C22  	        jp      Z,ABPASS        ; if pixel is off, return AB=0
3422: 04      	        inc     B               ; otherwise, return AB=1
3423: C39C22  	PNTEND: jp      ABPASS          ; return AB
              	
              	
              	; PLOT X,Y[,color]
              	; plot a pixel in graphic mode 2
3426: CDF932  	PLOT:   call    CHKG2M          ; check if in G2 mode
3429: CD3827  	        call    GETINT          ; get X coords.
342C: 32EF81  	        ld      (TMPBFR1),A     ; store it into a temp buffer
342F: CD1A18  	        call    CHKSYN          ; Make sure ',' follows
3432: 2C      	        defb    ','
3433: CD3827  	        call    GETINT          ; get Y coords,
3436: FEC0    	        cp      $C0             ; check if Y is in range 0~191
3438: D2081B  	        jp      NC,FCERR        ; no, raise an FC error
343B: 32F181  	        ld      (TMPBFR2),A     ; store into a temp buffer
343E: CDB337  	        call    CLRPRM          ; check if param "color" has been passed
3441: E5      	CNTPLOT:push    HL              ; store HL
3442: C5      	        push    BC              ; store BC
3443: D5      	        push    DE              ; store DE
3444: CD7A34  	        call    XY2HL           ; find VRAM address of byte containing pixel at X,Y & return into HL
3447: D26E34  	        jp      NC,NOGD         ; if carry is reset, there was an error -> so leave
344A: 57      	        ld      D,A             ; move pixel value into D
344B: 3AF381  	        ld      A,(TMPBFR3)     ; retrieve color
344E: 87      	        add     A,A             ; now we move low nibble
344F: 87      	        add     A,A             ; in the high nibble
3450: 87      	        add     A,A             ; by adding A to itself
3451: 87      	        add     A,A             ; 4 times (this is a shift left 4)
3452: 5F      	        ld      E,A             ; move it into E
3453: F3      	        di                      ; disable INTs
3454: CD0A06  	        call    READ_VIDEO_LOC  ; load original value of VRAM cell pointed by HL
3457: FB      	        ei
3458: B2      	        or      D               ; plot new pixel preserving original pattern
3459: F3      	        di
345A: CD1F06  	        call    WRITE_VIDEO_LOC ; write new value into VRAM cell
345D: FB      	        ei
345E: CBEC    	        set     5,H             ; set to write into color VRAM (it's like adding $2000 to HL)
3460: F3      	        di
3461: CD0A06  	        call    READ_VIDEO_LOC  ; load original colors of pixel
3464: FB      	        ei
3465: E60F    	        and     %00001111       ; reset high nibble (the foreground color)
3467: B3      	        or      E               ; set new foreground color
3468: F3      	        di
3469: CD1F06  	        call    WRITE_VIDEO_LOC ; write new color settings
346C: FB      	        ei                      ; re-enable INTs
346D: 00      	        nop                     ; wait for INTs to be enabled again
346E: D1      	NOGD:   pop     DE              ; retrieve DE
346F: C1      	        pop     BC              ; retrieve BC
3470: E1      	        pop     HL              ; retrieve HL
3471: C9      	        ret                     ; return to caller
3472: 80402010	PXLSET: defb    $80,$40,$20,$10,$08,$04,$02,$01 ; pixel to be set ON
3476: 08040201	
              	        ; where R(X/8)=> 0=80h, 1=40h, 2=20h, 3=10h, 4=08h, 5=04h, 6=02h, 7=$01
              	
              	
              	; compute the VRAM address of the byte containing the pixel
              	; being pointed by X,Y (TMPBFR1,TMPBFR1)
              	; byte address is returned into HL
              	; pixel is returned into A
347A:         	XY2HL:  ; formula is: ADDRESS=(INT(X/8))*8 + (INT(Y/8))*256 + R(Y/8)
              	        ; where R(Y/8) is the remainder of (Y/8)
              	        ; the pixel to be set is given by R(X/8), and data is taken from the array
347A: 3AF181  	        ld      A,(TMPBFR2)     ; retrieve Y
347D: FEC0    	        cp      $C0             ; Y>=192?
347F: D0      	        ret     NC              ; yes, so leave
3480: 1E08    	        ld      E,$08           ; load E with divisor
3482: 57      	        ld      D,A             ; and store into D (dividend)
3483: CD773C  	        call    DIV_8_8         ; get Y/8, D is quotient=INT(Y/8), and A is remainder
3486: 4F      	        ld      C,A             ; store remainder into C
3487: 42      	        ld      B,D             ; B=(INT(Y/8))*256 (we simply copy quotient into B)
3488: 6069    	        ld      HL,BC           ; copy BC into HL: now HL has the VRAM address of the byte being set
348A: 3AEF81  	        ld      A,(TMPBFR1)     ; retrieve X
348D: 57      	        ld      D,A             ; and move it into D (dividend)
348E: CD773C  	        call    DIV_8_8         ; get X/8, D is quotient=INT(X/8), and A is remainder
3491: 4F      	        ld      C,A             ; store remainder into C
3492: 7A      	        ld      A,D             ; move quotient into A
3493: 87      	        add     A,A
3494: 87      	        add     A,A
3495: 87      	        add     A,A             ; multiply quotient by 8
3496: 5F      	        ld      E,A             ; store result into E
3497: 1600    	        ld      D,$00           ; reset D
3499: 19      	        add     HL,DE           ; add DE to HL, getting the final VRAM address
349A: EB      	        ex      DE,HL           ; move VRAM address into DE
349B: 217234  	        ld      HL,PXLSET       ; starting address of table for pixel to draw
349E: 0600    	        ld      B,$00           ; reset B
34A0: 09      	        add     HL,BC           ; add C (remainder of X/8) to get address of pixel to turn on
34A1: 7E      	        ld      A,(HL)          ; load pixel data
34A2: EB      	        ex      DE,HL           ; retrieve VRAM pattern address into HL
34A3: 37      	        scf                     ; set Carry for normal exit
34A4: C9      	        ret                     ; return to caller
              	
              	
              	; DRAW X1,Y1,X2,Y2[,color]
              	; Draw a line using Bresenham's line algorithm from X1,Y1 to X2,Y2
              	; X1,Y1 can be either less than or greater than X2,Y2 (meaning that)
              	; the drawing will be ever done from X1,Y2 to X2,Y2, regardless of
              	; the values. If color is not specified, the foreground color set
              	; with COLOR will be used 
81EF:         	X1      equ     TMPBFR1
81F1:         	Y1      equ     TMPBFR2
81F7:         	X2      equ     VIDEOBUFF
81F9:         	Y2      equ     VIDEOBUFF+$02
81FB:         	ER      equ     VIDEOBUFF+$04
81FD:         	E2      equ     VIDEOBUFF+$06
81FF:         	SX      equ     VIDEOBUFF+$08
8201:         	SY      equ     VIDEOBUFF+$0A
8203:         	DX      equ     VIDEOBUFF+$0C
8205:         	DY      equ     VIDEOBUFF+$0E
34A5: CDF932  	DRAW:   call    CHKG2M          ; check if in G2 mode
34A8: CD9B37  	        call    CLRVDBF         ; clear VIDEOBUFF
34AB: CD3827  	        call    GETINT          ; get X1 coords.
34AE: 32EF81  	        ld      (X1),A          ; store it into a temp buffer
34B1: CD1A18  	        call    CHKSYN          ; Make sure ',' follows
34B4: 2C      	        defb    ','
34B5: CD3827  	        call    GETINT          ; get Y1 coords.
34B8: FEC0    	        cp      $C0             ; check if Y1 is in range 0~191
34BA: D2081B  	        jp      NC,FCERR        ; no, raise an FC error
34BD: 32F181  	        ld      (Y1),A          ; store into a temp buffer
34C0: CD1A18  	        call    CHKSYN          ; Make sure ',' follows
34C3: 2C      	        defb    ','
34C4: CD3827  	        call    GETINT          ; get X2 coords.
34C7: 32F781  	        ld      (X2),A          ; store it into a temp buffer
34CA: CD1A18  	        call    CHKSYN          ; Make sure ',' follows
34CD: 2C      	        defb    ','
34CE: CD3827  	        call    GETINT          ; get Y2 coords
34D1: FEC0    	        cp      $C0             ; check if Y2 is in range 0~191
34D3: D2081B  	        jp      NC,FCERR        ; no, raise an FC error
34D6: 32F981  	        ld      (Y2),A          ; store it into a temp buffer
34D9: CDB337  	        call    CLRPRM          ; check for arg. "color" and store it into TMPBFR3
34DC: E5      	        push    HL              ; store register we'll use
34DD: D5      	        push    DE              
34DE: C5      	        push    BC
34DF: ED5BEF81	        ld      DE,(X1)         ; load X1 and
34E3: 2AF781  	        ld      HL,(X2)         ; X2
34E6: B7      	        or      A               ; clear CARRY
34E7: ED52    	        sbc     HL,DE           ; DX=X2-X1
34E9: CD6D3C  	        call    absHL           ; DX=ABS(DX)
34EC: 220382  	        ld      (DX),HL         ; store DX
34EF: 01FFFF  	        ld      BC,$FFFF        ; SX=-1
34F2: 2AEF81  	        ld      HL,(X1)
34F5: ED5BF781	        ld      DE,(X2)
34F9: CD483C  	        call    CMP16           ; X1<X2?
34FC: F20235  	        jp      P,X1GR          ; no, X1>=X2
34FF: 010100  	        ld      BC,$0001        ; yes, so set SX=1
3502: ED43FF81	X1GR:   ld      (SX),BC         ; store SX
3506: ED5BF181	        ld      DE,(Y1)
350A: 2AF981  	        ld      HL,(Y2)
350D: B7      	        or      A               ; clear Carry
350E: ED52    	        sbc     HL,DE           ; DY=Y2-Y1
3510: CD6D3C  	        call    absHL           ; DY=ABS(DY)
3513: 220582  	        ld      (DY),HL         ; store DY
3516: 01FFFF  	        ld      BC,$FFFF        ; SY=-1
3519: 2AF181  	        ld      HL,(Y1)
351C: ED5BF981	        ld      DE,(Y2)
3520: CD483C  	        call    CMP16           ; is Y1<Y2?
3523: F22935  	        jp      P,Y1GR          ; no, Y1>=Y2
3526: 010100  	        ld      BC,$0001        ; yes, so set SY=1
3529: ED430182	Y1GR:   ld      (SY),BC         ; store SY
352D: 2A0582  	        ld      HL,(DY)         ; ER=DY
3530: CD703C  	        call    negHL           ; ER=-DY
3533: 22FB81  	        ld      (ER),HL         ; store ER
3536: 2A0382  	        ld      HL,(DX)
3539: ED5B0582	        ld      DE,(DY)
353D: CD483C  	        call    CMP16           ; DX>DY?
3540: CA4C35  	        jp      Z,ER2           ; no, DX=DY
3543: FA4C35  	        jp      M,ER2           ; no, DX<DY
3546: 2A0382  	        ld      HL,(DX)         ; reload DX
3549: 22FB81  	        ld      (ER),HL         ; yes: DX>DY, so ER=DX
354C: 2AFB81  	ER2:    ld      HL,(ER)         ; load ER
354F: CB2C    	        sra     H               ; right shift (and preserve sign)...
3551: CB1D    	        rr      L               ; ...of HL, so ER=INT(ER/2)
3553: 22FB81  	STRE2:  ld      (ER),HL         ; store ER
3556: CD4134  	RPTDRW: call    CNTPLOT         ; plot first pixel
3559: 2AEF81  	        ld      HL,(X1)
355C: ED5BF781	        ld      DE,(X2)
3560: CD483C  	        call    CMP16           ; X1=X2?
3563: 200D    	        jr      NZ,CNTDRW       ; no, continue drawing
3565: 2AF181  	        ld      HL,(Y1)         ; yes, so check
3568: ED5BF981	        ld      DE,(Y2)         ; also Y
356C: CD483C  	        call    CMP16           ; Y1=Y2?
356F: CAC835  	        jp      Z,ENDDRAW       ; yes, finished drawing: exit
3572: ED5BFB81	CNTDRW: ld      DE,(ER)
3576: ED53FD81	        ld      (E2),DE         ; E2=ER
357A: 2A0382  	        ld      HL,(DX)
357D: CD703C  	        call    negHL           ; DX=-DX
3580: EB      	        ex      DE,HL           ; invert DE and HL => HL=E2, DE=-DX
3581: CD483C  	        call    CMP16           ; E2>-DX?
3584: CAA235  	        jp      Z,DXGR          ; no, E2=-DX: jump
3587: FAA235  	        jp      M,DXGR          ; no, E2<-DX: jump
358A: 2AFB81  	        ld      HL,(ER)         ; yes
358D: ED5B0582	        ld      DE,(DY)
3591: B7      	        or      A               ; clear CARRY
3592: ED52    	        sbc     HL,DE           ; ER=ER-DY
3594: 22FB81  	        ld      (ER),HL
3597: 2AEF81  	        ld      HL,(X1)
359A: ED5BFF81	        ld      DE,(SX)
359E: 19      	        add     HL,DE           ; X1=X1+SX (increment X1)
359F: 22EF81  	        ld      (X1),HL
35A2: 2AFD81  	DXGR:   ld      HL,(E2)
35A5: ED5B0582	        ld      DE,(DY)
35A9: CD483C  	        call    CMP16           ; E2<DY?
35AC: F25635  	        jp      P,RPTDRW        ; no, E2>=DY: so jump over
35AF: 2AFB81  	        ld      HL,(ER)         ; yes
35B2: ED5B0382	        ld      DE,(DX)
35B6: 19      	        add     HL,DE           ; ER=ER+DX
35B7: 22FB81  	        ld      (ER),HL
35BA: 2AF181  	        ld      HL,(Y1)
35BD: ED5B0182	        ld      DE,(SY)
35C1: 19      	        add     HL,DE           ; Y1=Y1+SY (increment Y1)
35C2: 22F181  	        ld      (Y1),HL
35C5: C35635  	        jp      RPTDRW          ; repeat
35C8: C1      	ENDDRAW:pop     BC              ; retrieve BC
35C9: D1      	        pop     DE              ; retrieve DE
35CA: E1      	        pop     HL              ; retrieve HL
35CB: C9      	        ret                     ; return to caller
              	
              	
              	; CIRCLE X,Y,R[,C]
              	; Draw a circle using Bresenham's circle algorithm with center in X,Y
              	; and radius R, with optional color C. If color is not specified, the
              	; foreground color set with COLOR will be used 
81F7:         	XC      equ     VIDEOBUFF
81F9:         	YC      equ     VIDEOBUFF+$02
81FB:         	RADIUS  equ     VIDEOBUFF+$04
81FD:         	XI      equ     VIDEOBUFF+$06
81FF:         	YI      equ     VIDEOBUFF+$08
8201:         	DC      equ     VIDEOBUFF+$0A
35CC: CDF932  	CIRCLE: call    CHKG2M          ; check if in G2 mode
35CF: CD9B37  	        call    CLRVDBF         ; clear VIDEOBUFF
35D2: CD3827  	        call    GETINT          ; get X coords.
35D5: 32F781  	        ld      (XC),A          ; store it into a temp buffer
35D8: CD1A18  	        call    CHKSYN          ; Make sure ',' follows
35DB: 2C      	        defb    ','
35DC: CD3827  	        call    GETINT          ; get Y coords,
35DF: 32F981  	        ld      (YC),A          ; store it into a temp buffer
35E2: CD1A18  	        call    CHKSYN          ; Make sure ',' follows
35E5: 2C      	        defb    ','
35E6: CD3827  	        call    GETINT          ; get radius
35E9: 32FB81  	        ld      (RADIUS),A      ; store it into a temp buffer
35EC: CDB337  	        call    CLRPRM          ; check if param "color" has been passed
35EF: C5      	        push    BC              ; store BC
35F0: D5      	        push    DE              ; store DE
35F1: E5      	        push    HL              ; store HL
35F2: AF      	        xor     A               ; clear A,
35F3: 47      	        ld      B,A             ; B,
35F4: 4F      	        ld      C,A             ; C,
35F5: 57      	        ld      D,A             ; D,
35F6: 67      	        ld      H,A             ; and H
35F7: ED43FD81	        ld      (XI),BC         ; clear XI
35FB: 3AFB81  	        ld      A,(RADIUS)      ; load RADIUS into A
35FE: 6F      	        ld      L,A             ; HL now contains R
35FF: 22FF81  	        ld      (YI),HL         ; YI=RADIUS
3602: 29      	        add     HL,HL           ; R*2
3603: EB      	        ex      DE,HL           ; put HL into DE
3604: 210300  	        ld      HL,$0003        ; now HL is 3
3607: AF      	        xor     A               ; clear Carry
3608: ED52    	        sbc     HL,DE           ; HL=>D=3-(2*R)
360A: 220182  	        ld      (DC),HL         ; store D
360D: CD6C36  	        call    DRWCRL          ; draw initial point
3610: ED5BFD81	RPTCRL: ld      DE,(XI)         ; load XI
3614: 2AFF81  	        ld      HL,(YI)         ; load YI
3617: CD483C  	        call    CMP16           ; is YI<DI?
361A: CA2336  	        jp      Z,RPTCL1        ; no, YI=XI
361D: F22336  	        jp      P,RPTCL1        ; no, YI>XI
3620: C36836  	        jp      ENDCRL          ; yes, so we've finished
3623: 21FD81  	RPTCL1: ld      HL,XI
3626: 34      	        inc     (HL)            ; XI=XI+1
3627: 2A0182  	        ld      HL,(DC)         ; load D
362A: 7C      	        ld      A,H
362B: B5      	        or      L               ; is D=0? Yes, jump over
362C: CA5036  	        jp      Z,DLSZ
362F: CB7C    	        bit     7,H             ; is D<0?
3631: 201D    	        jr      NZ,DLSZ         ; yes, jump over
3633: ED5BFF81	        ld      DE,(YI)         ; D>0
3637: 1B      	        dec     DE              ; so, YI=YI-1
3638: ED53FF81	        ld      (YI),DE         ; store YI
363C: AF      	        xor     A               ; clear Carry
363D: 2AFD81  	        ld      HL,(XI)
3640: ED52    	        sbc     HL,DE           ; HL=XI-YI
3642: 29      	        add     HL,HL
3643: 29      	        add     HL,HL           ; HL=HL*4
3644: 110A00  	        ld      DE,10
3647: 19      	        add     HL,DE           ; HL=HL+10
3648: ED5B0182	        ld      DE,(DC)         ; load D
364C: EB      	        ex      DE,HL           ; invert DE and HL, so that HL=4*(XI-YI)+10 and DE=D
364D: 19      	        add     HL,DE           ; D=D+4*(XI-YI)+10
364E: 180F    	        jr      PLTCRL          ; plot next pixel
3650: 2AFD81  	DLSZ:   ld      HL,(XI)         ; load XI
3653: 29      	        add     HL,HL
3654: 29      	        add     HL,HL           ; XI=XI*4
3655: 110600  	        ld      DE,$0006
3658: 19      	        add     HL,DE
3659: ED5B0182	        ld      DE,(DC)
365D: EB      	        ex      DE,HL           ; HL=D and DE=4*XI+6
365E: 19      	        add     HL,DE           ; D=D+4*XI+6
365F: 220182  	PLTCRL: ld      (DC),HL         ; store new D
3662: CD6C36  	        call    DRWCRL          ; plot pixel
3665: C31036  	        jp      RPTCRL          ; repeat
3668: E1      	ENDCRL: pop     HL
3669: D1      	        pop     DE
366A: C1      	        pop     BC
366B: C9      	        ret                     ; return to caller
366C: 2AF781  	DRWCRL: ld      HL,(XC)
366F: ED5BFD81	        ld      DE,(XI)
3673: 19      	        add     HL,DE           ; X=XC+XI
3674: 22EF81  	        ld      (X1),HL         ; store X
3677: CD8B37  	        call    VALIDX          ; check if X is valid (0~255)
367A: DA8E36  	        jp      C,CNTCL1        ; if Carry is set, X is not valid
367D: 2AF981  	        ld      HL,(YC)
3680: ED5BFF81	        ld      DE,(YI)
3684: 19      	        add     HL,DE           ; Y=YC+YI
3685: 22F181  	        ld      (Y1),HL         ; store Y
3688: CD9037  	        call    VALIDY          ; check if Y is valid (0~191)
368B: D44134  	        call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
368E: AF      	CNTCL1: xor     A               ; clear Carry
368F: 2AF781  	        ld      HL,(XC)
3692: ED5BFD81	        ld      DE,(XI)
3696: ED52    	        sbc     HL,DE           ; X=XC-XI
3698: 22EF81  	        ld      (X1),HL         ; store X
369B: CD8B37  	        call    VALIDX          ; check if X is valid (0~255)
369E: DAB236  	        jp      C,CNTCL2        ; if Carry is set, X is not valid
36A1: 2AF981  	        ld      HL,(YC)
36A4: ED5BFF81	        ld      DE,(YI)
36A8: 19      	        add     HL,DE           ; Y=YC+YI
36A9: 22F181  	        ld      (Y1),HL         ; store Y
36AC: CD9037  	        call    VALIDY          ; check if Y is valid (0~191)
36AF: D44134  	        call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
36B2: 2AF781  	CNTCL2: ld      HL,(XC)
36B5: ED5BFD81	        ld      DE,(XI)
36B9: 19      	        add     HL,DE           ; X=XC+XI
36BA: 22EF81  	        ld      (X1),HL         ; store X
36BD: CD8B37  	        call    VALIDX          ; check if X is valid (0~255)
36C0: DAD636  	        jp      C,CNTCL3        ; if Carry is set, X is not valid
36C3: AF      	        xor     A               ; clear Carry
36C4: 2AF981  	        ld      HL,(YC)
36C7: ED5BFF81	        ld      DE,(YI)
36CB: ED52    	        sbc     HL,DE           ; Y=YC-YI
36CD: 22F181  	        ld      (Y1),HL         ; store Y
36D0: CD9037  	        call    VALIDY          ; check if Y is valid (0~191)
36D3: D44134  	        call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
36D6: AF      	CNTCL3: xor     A               ; clear Carry
36D7: 2AF781  	        ld      HL,(XC)
36DA: ED5BFD81	        ld      DE,(XI)
36DE: ED52    	        sbc     HL,DE           ; X=XC-XI
36E0: 22EF81  	        ld      (X1),HL         ; store X
36E3: CD8B37  	        call    VALIDX          ; check if X is valid (0~255)
36E6: DAFC36  	        jp      C,CNTCL4        ; if Carry is set, X is not valid
36E9: AF      	        xor     A               ; clear Carry
36EA: 2AF981  	        ld      HL,(YC)
36ED: ED5BFF81	        ld      DE,(YI)
36F1: ED52    	        sbc     HL,DE           ; Y=YC-YI
36F3: 22F181  	        ld      (Y1),HL         ; store Y
36F6: CD9037  	        call    VALIDY          ; check if Y is valid (0~191)
36F9: D44134  	        call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
36FC: 2AF781  	CNTCL4: ld      HL,(XC)
36FF: ED5BFF81	        ld      DE,(YI)
3703: 19      	        add     HL,DE           ; X=XC+YI
3704: 22EF81  	        ld      (X1),HL         ; store X
3707: CD8B37  	        call    VALIDX          ; check if X is valid (0~255)
370A: DA1E37  	        jp      C,CNTCL5        ; if Carry is set, X is not valid
370D: 2AF981  	        ld      HL,(YC)
3710: ED5BFD81	        ld      DE,(XI)
3714: 19      	        add     HL,DE           ; Y=YC+XI
3715: 22F181  	        ld      (Y1),HL         ; store Y
3718: CD9037  	        call    VALIDY          ; check if Y is valid (0~191)
371B: D44134  	        call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
371E: AF      	CNTCL5: xor     A               ; clear Carry
371F: 2AF781  	        ld      HL,(XC)
3722: ED5BFF81	        ld      DE,(YI)
3726: ED52    	        sbc     HL,DE           ; X=XC-YI
3728: 22EF81  	        ld      (X1),HL         ; store X
372B: CD8B37  	        call    VALIDX          ; check if X is valid (0~255)
372E: DA4237  	        jp      C,CNTCL6        ; if Carry is set, X is not valid
3731: 2AF981  	        ld      HL,(YC)
3734: ED5BFD81	        ld      DE,(XI)
3738: 19      	        add     HL,DE           ; Y=YC+XI
3739: 22F181  	        ld      (Y1),HL         ; store Y
373C: CD9037  	        call    VALIDY          ; check if Y is valid (0~191)
373F: D44134  	        call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
3742: 2AF781  	CNTCL6: ld      HL,(XC)
3745: ED5BFF81	        ld      DE,(YI)
3749: 19      	        add     HL,DE           ; X=XC+YI
374A: 22EF81  	        ld      (X1),HL         ; store X
374D: CD8B37  	        call    VALIDX          ; check if X is valid (0~255)
3750: DA6637  	        jp      C,CNTCL7        ; if Carry is set, X is not valid
3753: AF      	        xor     A               ; clear Carry
3754: 2AF981  	        ld      HL,(YC)
3757: ED5BFD81	        ld      DE,(XI)
375B: ED52    	        sbc     HL,DE           ; Y=YC-XI
375D: 22F181  	        ld      (Y1),HL         ; store Y
3760: CD9037  	        call    VALIDY          ; check if Y is valid (0~191)
3763: D44134  	        call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
3766: AF      	CNTCL7: xor     A               ; clear Carry
3767: 2AF781  	        ld      HL,(XC)
376A: ED5BFF81	        ld      DE,(YI)
376E: ED52    	        sbc     HL,DE           ; X=XC-YI
3770: 22EF81  	        ld      (X1),HL         ; store X
3773: CD8B37  	        call    VALIDX          ; check if X is valid (0~255)
3776: D8      	        ret     C               ; if Carry is set, X is not valid
3777: AF      	        xor     A               ; clear Carry
3778: 2AF981  	        ld      HL,(YC)
377B: ED5BFD81	        ld      DE,(XI)
377F: ED52    	        sbc     HL,DE           ; Y=YC-XI
3781: 22F181  	        ld      (Y1),HL         ; store Y
3784: CD9037  	        call    VALIDY          ; check if Y is valid (0~191)
3787: D44134  	        call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
378A: C9      	        ret                     ; return to caller
              	
              	; check if X,Y coordinates are valid: 0<=X<=255 and 0<=Y<=191
              	; input: HL (value to check), can be negative
              	; output: CARRY flag: reset => VALID  //  set => NOT VALID
              	; destroys: A
378B: AF      	VALIDX: xor     A               ; reset A
378C: B4      	        or      H               ; check if H is 0 (this means that X is in range 0~255 and not negative)
378D: C8      	        ret     Z               ; yes, we can return (C is clear)
378E: 37      	        scf                     ; set Carry flag to raise error
378F: C9      	        ret                     ; return to caller
              	
3790: AF      	VALIDY: xor     A               ; reset A
3791: B4      	        or      H               ; check if H is 0 (this means that Y is in range 0~255 and not negative)
3792: 2802    	        jr      Z,CNTVALY       ; yes, continue checking
3794: 37      	        scf                     ; no, raise error by setting Carry flag
3795: C9      	        ret                     ; return to caller
3796: 7D      	CNTVALY:ld      A,L
3797: FEC0    	        cp      $C0             ; is Y<192? Carry is set if Y<192
3799: 3F      	        ccf                     ; invert Carry, so Carry=0 means OK, Carry=1 means ERROR
379A: C9      	        ret                     ; return to caller
              	
              	
              	; clear VIDEOBUFF before using it as temp buffer
379B: AF      	CLRVDBF:xor     A               ; clear A
379C: C5      	        push    BC              ; store BC
379D: E5      	        push    HL              ; store HL
379E: 21EF81  	        ld      HL,TMPBFR1      ; address of 1st cell
37A1: 0606    	        ld      B,$06           ; 6 cells
37A3: 77      	RPTCVB1:ld      (HL),A          ; clear cell
37A4: 23      	        inc     HL              ; next cell
37A5: 10FC    	        djnz    RPTCVB1         ; repeat
37A7: 0628    	        ld      B,$28           ; 40 cells
37A9: 21F781  	        ld      HL,VIDEOBUFF    ; address of 1st cell
37AC: 77      	RPTCVB2:ld      (HL),A          ; clear cell
37AD: 23      	        inc     HL              ; next cell
37AE: 10FC    	        djnz    RPTCVB2         ; repeat
37B0: E1      	        pop     HL              ; retrieve HL
37B1: C1      	        pop     BC              ; retrieve BC
37B2: C9      	        ret                     ; return to caller
              	
              	
              	; check if a color is passed as argument with PLOT, DRAW, and CIRCLE
              	; commands. If not present, the default foreground color will be used
37B3: 3AED81  	CLRPRM: ld      A,(FRGNDCLR)    ; load foreground color
37B6: 32F381  	        ld      (TMPBFR3),A     ; store into temp buffer
37B9: 2B      	        dec     HL              ; dec 'cos GETCHR INCs
37BA: CD3D1A  	        call    GETCHR          ; Get next character
37BD: C8      	        ret     Z               ; return if nothing follows
37BE: CD1A18  	        call    CHKSYN          ; Make sure ',' follows
37C1: 2C      	        defb    ','
37C2: CD3827  	        call    GETINT          ; get value
37C5: CDEF32  	        call    CHKCLR          ; check if color is in range 1~15
37C8: 32F381  	        ld      (TMPBFR3),A     ; store color into temp buffer
37CB: C9      	        ret                     ; return to caller
              	
              	
              	; no graphics mode error: raised when a graphics command is invoked
              	; out of graphic 2 mode.
37CC: 1E2A    	GMERR:  ld      E,GM            ; load Graphics Mode Error flag
37CE: C34C15  	        jp      ERROR           ; print error
              	
              	
              	; set a serial port: params are PORT,BPS,DATA,PARITY,STOP
              	; PORT=1/2; BPS=1,200~57,600 (see below), DATA=5/6/7/8
              	; PARITY: 0=no parity; 1=ODD parity; 2=EVEN parity;
              	; STOP=0/1/2/3: 0=0 bit; 1=1 bit; 2=1.5 bits; 3=2 bits
              	; PORT 1 acts as a char device; PORT 2 acts as a block device
              	; DATA,PARITY, and STOP are optional: if nothing follows BPS,
              	; they are assumed to be 8,0,1 resp.
81F7:         	PRTNUM  equ     VIDEOBUFF
81F8:         	BPS     equ     VIDEOBUFF+$01
81FA:         	DATABT  equ     BPS+$02
81FB:         	PARBT   equ     DATABT+$01
81FC:         	STPBT   equ     PARBT+$01
81FD:         	SIOBFR  equ     STPBT+$01
37D1: CD3827  	SERIAL: call    GETINT          ; get port #
37D4: A7      	        and     A               ; is it zero?
37D5: CA081B  	        jp      Z,FCERR         ; yes, error
37D8: FE03    	        cp      $03             ; is it 1 or 2?
37DA: D2BB39  	        jp      NC,SCERR        ; no, error
37DD: 32F781  	        ld      (PRTNUM),A      ; store port number into a temp buffer
37E0: CD1A18  	        call    CHKSYN          ; Make sure ',' follows
37E3: 2C      	        defb    ','
37E4: CD0D1B  	        call    ATOH            ; get bps (returned into DE)
37E7: 7A      	        ld      A,D             ; move MSB into A
37E8: B3      	        or      E               ; LSB OR MSB, to check if bps=0
37E9: 203A    	        jr      NZ,CNTSER       ; no, continue checking
              	        ; if baud rate is 0, then close the serial comm.
37EB: 3AF781  	RSTSER1:ld      A,(PRTNUM)      ; yes, so reset the channel. First, load port number
37EE: 3D      	        dec     A               ; subtract 1, so that serial channel is 0=>A and 1=>B
37EF: C622    	        add     SIO_CA          ; find correct channel
37F1: 4F      	        ld      C,A             ; store serial channel
37F2: F3      	        di                      ; disable INTs
37F3: AF      	        xor     A               ; reset A
37F4: 1601    	        ld      D,$01           ; start from WR1
37F6: 0605    	        ld      B,$05           ; 5 registers
37F8: ED51    	RPTRSSR:out     (C),D           ; select register
37FA: ED79    	        out     (C),A           ; reset register
37FC: 14      	        inc     D               ; next register
37FD: 10F9    	        djnz    RPTRSSR         ; repeat
37FF: 3E30    	        ld      A,%00110000     ; write into WR0: error reset, select WR0
3801: ED79    	        out     (C),A           ; send command to serial channel
3803: 3E18    	        ld      A,%00011000     ; write into WR0: channel reset
3805: ED79    	        out     (C),A           ; send command to serial channel
3807: FB      	        ei                      ; re-enable INTs
3808: E5      	        push    HL              ; store HL
3809: 212E82  	        ld      HL,SERIALS_EN   ; serials enabled status byte
380C: DB01    	        in      A,(PIO_DB)      ; read status LEDs
380E: CB41    	        bit     0,C             ; check serial port
3810: 2009    	        jr      NZ,SRPT2        ; if bit is set, jump to port 2
3812: CBB7    	        res     6,A             ; it's port 1
3814: CBA7    	        res     4,A             ; remove possible error LED
3816: CB86    	        res     0,(HL)          ; disable port 1
3818: C32138  	        jp      SERLED          ; jump over
381B: CBBF    	SRPT2:  res     7,A             ; it's port 2
381D: CBAF    	        res     5,A             ; remove possible error LED
381F: CB8E    	        res     1,(HL)          ; disable port 2
3821: D301    	SERLED: out     (PIO_DB),A      ; send new configuration
3823: E1      	        pop     HL              ; retrieve HL
3824: C9      	        ret                     ; return to caller
              	        ; check if bps=1, meaning reactivate RX on serial
3825: 7A      	CNTSER: ld      A,D
3826: B2      	        or      D               ; check if bps<>1 by first checking D=0
3827: 203B    	        jr      NZ,CNTSER2      ; if not, jump over
3829: 7B      	        ld      A,E             ; then by checking that
382A: FE01    	        cp      $01             ; E=1
382C: 2036    	        jr      NZ,CNTSER2      ; if not, jump over
382E: 3AF781  	        ld      A,(PRTNUM)      ; load port number
3831: FE01    	        cp      $01             ; is it port 1? (currently do NOT support on port 2)
3833: C2BB39  	        jp      NZ,SCERR        ; no, raise error and exit 
3836: 57      	        ld      D,A             ; store port on D
3837: 3A2E82  	        ld      A,(SERIALS_EN)  ; load address of serial status cell
383A: A2      	        and     D               ; check status
383B: CABB39  	        jp      Z,SCERR         ; port not open, raise error
383E: F3      	        di                      ; disable INTs
383F: 7A      	        ld      A,D             ; move port # into A
3840: 5F      	        ld      E,A             ; store original A into E
3841: 87      	        add     A
3842: 87      	        add     A               ; move A to left times 2
3843: 57      	        ld      D,A             ; move value into D
3844: 3A2E82  	        ld      A,(SERIALS_EN)  ; load serial status byte
3847: B2      	        or      D               ; re-enable RX
3848: 322E82  	        ld      (SERIALS_EN),A  ; store new serial status
384B: 7B      	        ld      A,E             ; recover port #
384C: 3D      	        dec     A               ; check port
384D: 200A    	        jr      NZ,CNTRX2       ; port is #2
384F: CD8D01  	        call    SIO_A_EI        ; re-enable RX on port 1
3852: DB01    	        in      A,(PIO_DB)      ; load status LEDs
3854: CBA7    	        res     4,A             ; remove error LED
3856: C36038  	        jp      RXEND           ; terminate setting
3859: CD8D01  	CNTRX2: call    SIO_A_EI        ; re-enable RX on port 2 -> CURRENTLY only port 1 is supported
385C: DB01    	        in      A,(PIO_DB)      ; load status LEDs
385E: CBAF    	        res     5,A             ; remove error LED
3860: D301    	RXEND:  out     (PIO_DB),A      ; set new status for LEDs
3862: FB      	        ei                      ; re-enable INTs
3863: C9      	        ret                     ; return to caller
              	        ; set serial port comm.
3864: D5      	CNTSER2:push    DE              ; store BPS
3865: 3AF781  	        ld      A,(PRTNUM)      ; load port number
3868: 57      	        ld      D,A             ; move port # into D
3869: 3A2E82  	        ld      A,(SERIALS_EN)  ; check if serial port is already open
386C: A2      	        and     D               ; by ANDing A with D
386D: D1      	        pop     DE              ; retrieve BPS
386E: CA7638  	        jp      Z,CNTSER3       ; not open, continue
3871: 1E2E    	        ld      E,SA            ; already open, so raise a "Serial Port Already Error"
3873: C34C15  	        jp      ERROR           ; and leave
3876: E5      	CNTSER3:push    HL              ; store HL   
3877: 2100E1  	        ld      HL,$E100        ; check bps. start with HL=57,600
387A: CD483C  	        call    CMP16           ; is bps<=57,600?
387D: E1      	        pop     HL              ; but first, recover HL
387E: DABB39  	        jp      C,SCERR         ; no (bps>57,600) then error
3881: ED53F881	        ld      (BPS),DE        ; store bps
3885: 2B      	        dec     HL              ; dec 'cos GETCHR INCs
3886: CD3D1A  	        call    GETCHR          ; Get next character
3889: CAC038  	        jp      Z,DEFSER        ; defaults if nothing follows
388C: CD1A18  	        call    CHKSYN          ; Make sure ',' follows
388F: 2C      	        defb    ','
3890: CD3827  	        call    GETINT          ; get data bits
3893: FE05    	        cp      $05             ; is it <5?
3895: DABB39  	        jp      C,SCERR         ; yes, error
3898: FE09    	        cp      $09             ; is it >=9?
389A: D2081B  	        jp      NC,FCERR        ; no, error
389D: 32FA81  	        ld      (DATABT),A      ; store data bits
38A0: CD1A18  	        call    CHKSYN          ; Make sure ',' follows
38A3: 2C      	        defb    ','
38A4: CD3827  	        call    GETINT          ; get parity bits
38A7: FE03    	        cp      A,$03           ; check if parity is in range 0~2
38A9: D2BB39  	        jp      NC,SCERR        ; no, error
38AC: 32FB81  	        ld      (PARBT),A       ; store parity
38AF: CD1A18  	        call    CHKSYN          ; Make sure ',' follows
38B2: 2C      	        defb    ','
38B3: CD3827  	        call    GETINT          ; get stop bits
38B6: FE03    	        cp      $03             ; is it >=3?
38B8: D2BB39  	        jp      NC,SCERR        ; yes, error
38BB: 32FC81  	        ld      (STPBT),A       ; store stop bits
38BE: 180D    	        jr      SETSER          ; jump to set serial
38C0: 3E08    	DEFSER: ld      A,$08           ; 8 bits for data
38C2: 32FA81  	        ld      (DATABT),A
38C5: AF      	        xor     A               ; no parity bit
38C6: 32FB81  	        ld      (PARBT),A
38C9: 3C      	        inc     A               ; 1 bit for stop
38CA: 32FC81  	        ld      (STPBT),A
              	        ; check if bps are legal
38CD: E5      	SETSER: push    HL              ; store HL 
38CE: D5      	        push    DE              ; store DE
38CF: DDE5    	        push    IX              ; store IX
38D1: DD219639	        ld      IX,SUP_BPS      ; allowed BPSs
38D5: 060B    	        ld      B,$0B           ; 11 items
38D7: 0E00    	        ld      C,$00           ; reset pointer
38D9: 2AF881  	CKBPS:  ld      HL,(BPS)        ; load BPS
38DC: DD5E00  	        ld      E,(IX+0)        ; load LSB of item
38DF: DD5601  	        ld      D,(IX+1)        ; load MSB of item
38E2: CD483C  	        call    CMP16           ; is it equal?
38E5: CAF238  	        jp      Z,FNDBPS        ; yes, found correspondance
38E8: DD23    	        inc     IX
38EA: DD23    	        inc     IX              ; no, go to next entry
38EC: 0C      	        inc     C               ; increment pointer
38ED: 10EA    	        djnz    CKBPS           ; repeat for 10 entries
38EF: C3B739  	        jp      SCERR1          ; if nothing found, raise an error
38F2: 3AF781  	FNDBPS: ld      A,(PRTNUM)      ; check serial port
38F5: 3D      	        dec     A               ; is it port 1?
38F6: CAFC38  	        jp      Z,SET_P1        ; yes, set port 1
38F9: C3B739  	        jp      SCERR1          ; at the moment, only port 1 can be configured
38FC:         	SET_P1: ;init CTC CH0: CH0 provides RX/TX clock to SIO port A
              	        ; TO0 output frequency=INPUT CLK/time constant. Time constant is set to get 16 times
              	        ; the requested baud rate. I.e., if bps is 19,200 then time constast is set to 6 because
              	        ; 1,843,200/6 = 307,200 Hz (that is 19,200 x 16)
38FC: F3      	        di                      ; disable INTs
38FD: 0600    	        ld      B,$00           ; reset B
38FF: 21AC39  	        ld      HL,CTC_CFG      ; address of first CTC divider
3902: 09      	        add     HL,BC           ; adjust for correct CTC divider
3903: 3E47    	        ld      A,%01000111     ; interrupt off, counter mode, prsc=16 (doesn't matter), ext. start,
              	                                ; start upon loading time constant, time constant follows, sw reset, command word
3905: D310    	        out     (CTC_CH0),A     ; configure CTC channel 0
3907: 7E      	        ld      A,(HL)          ; load CTC divider
3908: D310    	        out     (CTC_CH0),A     ; send divider
              	        ; configure SIO
390A: 21FA02  	        ld      HL,SIO_A_SETS   ; load default settings for SIO
390D: 11FD81  	        ld      DE,SIOBFR       ; into a temp buffer
3910: 010A00  	        ld      BC,$000A        ; 10 items to copy
3913: EDB0    	        ldir                    ; copy SIO settings into TEMP buffer
3915: 3A0282  	        ld      A,(SIOBFR+5)    ; load WR5 setting
3918: 47      	        ld      B,A             ; move it into B
3919: 3AFA81  	        ld      A,(DATABT)      ; load DATA bits
391C: FE05    	        cp      $05             ; is it 5 bits?
391E: 2006    	        jr      NZ,BITS6        ; no, jump over
3920: CBB0    	        res     6,B
3922: CBA8    	        res     5,B             ; set D6 & D5 to 0
3924: 1819    	        jr      SETPAR          ; jump to set parity
3926: FE06    	BITS6:  cp      $06             ; is it 6 bits?
3928: 2006    	        jr      NZ,BITS7        ; no, jump over
392A: CBF0    	        set     6,B
392C: CBA8    	        res     5,B             ; set D6 & D5 to 1,0
392E: 180F    	        jr      SETPAR          ; jump to set parity
3930: FE07    	BITS7:  cp      $07             ; is it 7 bits?
3932: 2007    	        jr      NZ,BITS8        ; no, jump over
3934: CBB0    	        res     6,B
3936: CBE8    	        set     5,B             ; set D6 & D5 to 0,1
3938: C33F39  	        jp      SETPAR          ; jump to set parity
393B: CBF0    	BITS8:  set     6,B
393D: CBE8    	        set     5,B             ; set D6 & D5 to 1,1
393F: 78      	SETPAR: ld      A,B
3940: 320282  	        ld      (SIOBFR+5),A    ; save DATA bits
3943: E660    	        and     %01100000       ; filter only D5&D6 bits
3945: 87      	        add     A,A             ; shift left times 1
3946: 322F82  	        ld      (SERABITS),A    ; store for SIO_A_EI & SIO_A_DI functions
3949: 3AFC81  	        ld      A,(STPBT)       ; load STOP bits
394C: 87      	        add     A,A
394D: 87      	        add     A,A             ; 2 left shifts
394E: 47      	        ld      B,A             ; move forming byte into B
394F: 3AFB81  	        ld      A,(PARBT)       ; load PARITY setting
3952: A7      	        and     A               ; is it 0?
3953: CA5E39  	        jp      Z,STRPAR        ; yes, jump over
3956: CBC0    	        set     0,B             ; set PARITY on
3958: 3D      	        dec     A               ; is parity ODD?
3959: CA5E39  	        jp      Z,STRPAR        ; yes, so jump over
395C: CBC8    	        set     1,B             ; no, it's EVEN so set the corresponding bit
395E: 3A0082  	STRPAR: ld      A,(SIOBFR+3)    ; load WR4 setting
3961: E6F0    	        and     %11110000       ; reset STOP & PARITY bits
3963: B0      	        or      B               ; set new STOP & PARITY bits
3964: 320082  	        ld      (SIOBFR+3),A    ; store new value
              	        ;set up TX and RX:
              	        ; the followings are settings for channel A
3967: 21FD81  	        ld      HL,SIOBFR       ; settings for SIO ch. A
396A: 0606    	        ld      B,$06           ; 6 bytes to send
396C: 0E22    	        ld      C,SIO_CA        ; I/O address of SIO ch.A
396E: EDB3    	        otir                    ; send bytes to SIO
              	        ; the following are settings for channel B (don't need to load HL since settings are contigous)
3970: 0604    	        ld      B,$04           ; other 4 bytes to send
3972: 0E23    	        ld      C,SIO_CB        ; I/O address of SIO ch.B
3974: EDB3    	        otir                    ; send bytes to SIO
              	        ; the following are settings for channel A
3976: 3E01    	        ld      A,$01           ; write into WR0: select WR1
3978: D322    	        out     (SIO_CA),A
397A: 3E18    	        ld      A,%00011000     ; interrupts on every RX char; parity is no special condition;
              	                                ; buffer overrun is special condition
397C: D322    	        out     (SIO_CA),A
397E: CD8D01  	        call    SIO_A_EI        ; enable RX on SIO channel A
3981: 212E82  	EXITSER:ld      HL,SERIALS_EN
3984: CBC6    	        set     0,(HL)          ; set serial port 1 status ON
3986: CBD6    	        set     2,(HL)          ; set serial port 1 RX ON
              	        ; back to normal running
3988: FB      	        ei                      ; re-enable INTs
3989: DB01    	        in      A,(PIO_DB)      ; load status LEDs
398B: CBF7    	        set     6,A             ; set status LED on
398D: CBA7    	        res     4,A             ; set error LED off
398F: D301    	        out     (PIO_DB),A      ; send new configuration
3991: DDE1    	        pop     IX              ; retrieve IX
3993: D1      	        pop     DE              ; retrieve DE
3994: E1      	        pop     HL              ; retrieve HL
3995: C9      	        ret                     ; return to caller
              	
              	; allowed bps (Bauds per second)
3996: 00E10096	SUP_BPS:defw    57600,38400,28800,19200,14400,9600,4800,3600,2400,1200,600
399A: 8070004B	
399E: 40388025	
39A2: C012100E	
39A6: 6009B004	
39AA: 5802    	
              	; corresponding CTC divider
39AC: 02030406	CTC_CFG:defb    2,3,4,6,8,12,24,32,48,96,192
39B0: 080C1820	
39B4: 3060C0  	
              	
              	; serial configuration error
39B7: DDE1    	SCERR1: pop     IX              ; retrieve IX
39B9: D1      	        pop     DE              ; retrieve DE
39BA: E1      	        pop     HL              ; retrieve HL
39BB: 1E2C    	SCERR:  ld      E,SC            ; Serial Configuration Error
39BD: C34C15  	        jp      ERROR           ; print error
              	
              	; check for direct mode
39C0: E5      	DIRMOD: push    HL              ; Save code string address
39C1: 2AAF80  	        ld      HL,(LINEAT)     ; Get current line number
39C4: 23      	        inc     HL              ; -1 means direct statement
39C5: 7C      	        ld      A,H
39C6: B5      	        or      L
39C7: E1      	        pop     HL              ; Restore code string address
39C8: C2E239  	        jp      NZ,HLPERR       ; raise error if in indirect mode
39CB: C9      	        ret
              	
              	
              	; HELP lists the line program where an error was found
39CC: CDC039  	HELP:   call    DIRMOD          ; check if in direct mode
39CF: E5      	        push    HL              ; store HL
39D0: 2AB180  	        ld      HL,(HLPLN)      ; load HELP line
39D3: 23      	        inc     HL              ; increment HL
39D4: 7C      	        ld      A,H
39D5: B5      	        or      L               ; check if there is a line into the HELP reg.
39D6: E1      	        pop     HL
39D7: CAE239  	        jp      Z,HLPERR        ; no line found, raise error
39DA: ED5BB180	        ld      DE,(HLPLN)      ; recover line
39DE: C1      	        pop     BC              ; remove BC from stack since it's not needed anymore for LIST
39DF: C3A818  	        jp      LST01H          ; jump to list line
39E2: 1E30    	HLPERR: ld      E,HP            ; HELP call error
39E4: C34C15  	        jp      ERROR           ; raise error
              	
              	
              	; KEY command to list/modify function keys
39E7: 2B      	KEY:    dec     HL              ; dec 'cos GETCHR INCs
39E8: CD3D1A  	        call    GETCHR          ; Get next character
39EB: CA6B3A  	        jp      Z,LSTKEYS       ; jump if nothing follows
              	                                ; change FN keys
39EE: CD3827  	        call    GETINT          ; get a number
39F1: A7      	        and     A               ; is it 0?
39F2: 2010    	        jr      NZ,KEYCH        ; no, jump over         
39F4: E5      	        push    HL              ; yes - reset FN keys to defaults
39F5: D5      	        push    DE              ; store HL & DE
39F6: 212814  	        ld      HL,DEFFNKS      ; pointer to default FN keys texts
39F9: 11B380  	        ld      DE,FNKEYS       ; pointer to destination
39FC: 018000  	        ld      BC,$0080        ; 128 chars to be copied
39FF: EDB0    	        ldir                    ; restore default texts
3A01: D1      	        pop     DE              ; retrieve DE
3A02: E1      	        pop     HL              ; retrieve HL
3A03: C9      	        ret                     ; return to caller
3A04: FE09    	KEYCH:  cp      $09             ; is it >= 9?
3A06: D23815  	        jp      NC,SNERR        ; yes - syntax error
3A09: 3D      	        dec     A               ; FN key in range 0~7
3A0A: 87      	        add     A,A             ; multiply A...
3A0B: 87      	        add     A,A             ; ... times 4...
3A0C: 87      	        add     A,A             ; ... to get the correct...
3A0D: 87      	        add     A,A             ; ... offset fo FN key text
3A0E: 32EF81  	        ld      (TMPBFR1),A     ; store FN key offset...
3A11: AF      	        xor     A               ; ...in a...
3A12: 32F081  	        ld      (TMPBFR1+1),A   ; ...16-bit register
3A15: CD1A18  	        call    CHKSYN          ; Make sure ',' follows
3A18: 2C      	        defb    ','
3A19: 444D    	        ld      BC,HL           ; copy address into BC
3A1B: CDC41E  	        call    EVAL            ; Evaluate expression (in E there is the length)
3A1E: E5      	        push    HL              ; store string pointer
3A1F: 3A9281  	        ld      A,(TYPE)        ; Get variable type
3A22: B7      	        or      A               ; Is it a string variable?
3A23: CA3815  	        jp      Z,SNERR         ; no - syntax error
3A26: CDFD24  	        call    GSTRCU          ; Current string to pool
3A29: CD072D  	        call    LOADFP          ; Move string block data to (BC=pointer, DE=length)
3A2C: 7B      	        ld      A,E             ; copy length into A
3A2D: FE11    	        cp      $11             ; is length > 16?
3A2F: DA343A  	        jp      C,DECLN1        ; no, jump over
3A32: 1E10    	        ld      E,$10           ; yes, so set length to 16
3A34: 3E10    	DECLN1: ld      A,$10           ; calculate how many...
3A36: 93      	        sub     E               ; ...null chars needed to fill up...
3A37: 57      	        ld      D,A             ; ...the FN key text
3A38: C5      	        push    BC              ; store address of string 
3A39: ED4BEF81	        ld      BC,(TMPBFR1)    ; load FN key offset
3A3D: 21B380  	        ld      HL,FNKEYS       ; load address of FN keys texts
3A40: 09      	        add     HL,BC           ; get corrected address
3A41: C1      	        pop     BC              ; retrieve address of string chars
3A42: 0A      	CPKEY:  ld      A,(BC)          ; load char from string
3A43: FE0D    	        cp      CR              ; return?
3A45: CA523A  	        jp      Z,CPKEY2        ; yes, store char
3A48: FE7B    	        cp      $7B             ; if char > "z" ?
3A4A: D23815  	        jp      NC,SNERR        ; yes - syntax error
3A4D: FE20    	        cp      $20             ; is char < space?
3A4F: DA3815  	        jp      C,SNERR         ; yes - syntax error
3A52: FE61    	CPKEY2: cp      $61             ; is it >= 'a'?
3A54: DA593A  	        jp      C,CPKEY3        ; no, continue
3A57: E65F    	        and     %01011111       ; set letters to uppercase
3A59: 77      	CPKEY3: ld      (HL),A          ; store char
3A5A: 23      	        inc     HL              ; next string char
3A5B: 03      	        inc     BC              ; next free cell
3A5C: 1D      	        dec     E               ; decrement E
3A5D: 20E3    	        jr      NZ,CPKEY        ; repeat until 0
3A5F: AF      	        xor     A               ; null char
3A60: 14      	        inc     D               ; +1 to decrement below
3A61: 15      	CPKEY1: dec     D               ; how many null chars to insert?
3A62: CA693A  	        jp      Z,CPKYEND       ; no more nulls, so exit
3A65: 77      	        ld      (HL),A          ; store it
3A66: 23      	        inc     HL              ; next cell
3A67: 18F8    	        jr      CPKEY1          ; repeat
3A69: E1      	CPKYEND:pop     HL              ; retrieve pointer to string
3A6A: C9      	        ret                     ; return to caller
              	                                ; list FN keys
3A6B: E5      	LSTKEYS:push    HL              ; Save code string address
3A6C: 2AAF80  	        ld      HL,(LINEAT)     ; Get current line number
3A6F: 23      	        inc     HL              ; -1 means direct statement
3A70: 7C      	        ld      A,H
3A71: B5      	        or      L
3A72: E1      	        pop     HL              ; Restore code string address
3A73: C23815  	        jp      NZ,SNERR        ; raise error if in indirect mode
3A76: E5      	        push    HL              ; store HL
3A77: D5      	        push    DE              ; store DE
3A78: 21B380  	        ld      HL,FNKEYS       ; load starting address of FN keys text
3A7B: 0E01    	        ld      C,$01           ; 8 function keys
3A7D: 0610    	PRTK4:  ld      B,$10           ; 16 chars each
3A7F: 111E3B  	PRTK2:  ld      DE,CHKEY1       ; message "KEY "
3A82: CD0F3B  	        call    PRTCKEY         ; print it
3A85: 79      	        ld      A,C             ; load FN key
3A86: C630    	        add     $30             ; get number in ASCI code
3A88: CD2518  	        call    OUTC            ; print it
3A8B: 11233B  	        ld      DE,CHKEY2       ; message ": ""
3A8E: CD0F3B  	        call    PRTCKEY         ; print it
3A91: 3E01    	        ld      A,$01           ; " opened
3A93: 32EF81  	        ld      (TMPBFR1),A
3A96: 7E      	LDKEY:  ld      A,(HL)          ; retrieve char
3A97: A7      	        and     A               ; is it zero?
3A98: CAAB3A  	        jp      Z,CNTLTK        ; yes, go next char
3A9B: CDF73A  	        call    OPNQT           ; check if quotes are opened
3A9E: FE22    	        cp      $22             ; check if char is "?
3AA0: CAC03A  	        jp      Z,PRTCHR        ; yes, print "chr$("
3AA3: FE0D    	        cp      CR              ; is it a CR?
3AA5: CAC03A  	        jp      Z,PRTCHR        ; yes, print "chr$("
3AA8: CD2518  	PRTK3:  call    OUTC            ; no, just print it
3AAB: 23      	CNTLTK: inc     HL              ; next char
3AAC: 10E8    	        djnz    LDKEY           ; continue until finished
3AAE: CDE53A  	        call    CLSQT           ; check if quotes are still open
3AB1: 3E0D    	        ld      A,CR            ; go next line
3AB3: CD2518  	        call    OUTC            ; print it
3AB6: 0C      	        inc     C               ; next FN key
3AB7: 79      	        ld      A,C             ; check if...
3AB8: FE09    	        cp      $09             ; finished keys?
3ABA: DA7D3A  	        jp      C,PRTK4         ; no, repeat 1 more time
3ABD: D1      	        pop     DE              ; retrieve DE
3ABE: E1      	        pop     HL              ; retrieve HL
3ABF: C9      	        ret                     ; return to caller
              	
3AC0: E5      	PRTCHR: push    HL              ; store HL
3AC1: CDE53A  	        call    CLSQT           ; check if quotes are closed
3AC4: 3E2B    	        ld      A,'+'           ; '+' char
3AC6: CD2518  	        call    OUTC            ; print it
3AC9: 11263B  	        ld      DE,CHKEY3       ; address of "CHR$("
3ACC: CD0F3B  	        call    PRTCKEY         ; print it
3ACF: E1      	        pop     HL              ; recover HL
3AD0: 23      	        inc     HL              ; next char
3AD1: 05      	        dec     B               ; increment char counter
3AD2: 112C3B  	        ld      DE,CHKEY4       ; load address of RETURN
3AD5: 7E      	        ld      A,(HL)          ; load char
3AD6: FE0D    	        cp      CR              ; is it a RETURN?
3AD8: 2003    	        jr      NZ,PTCHR1       ; no, jump over
3ADA: 112F3B  	        ld      DE,CHKEY5       ; yes, load address of "
3ADD: CD0F3B  	PTCHR1: call    PRTCKEY         ; print it
3AE0: 3E29    	        ld      A,')'           ; char )
3AE2: C3A83A  	        jp      PRTK3           ; continue
              	
3AE5: F5      	CLSQT:  push    AF              ; store A
3AE6: 3AEF81  	        ld      A,(TMPBFR1)     ; quote status
3AE9: A7      	        and     A               ; are they closed?
3AEA: 2809    	        jr      Z,CLSQT1        ; if yes, return
3AEC: 3E22    	        ld      A,$22           ; no, so close them
3AEE: CD2518  	        call    OUTC            ; print "
3AF1: AF      	        xor     A               ; set quotes
3AF2: 32EF81  	        ld      (TMPBFR1),A     ; as closed
3AF5: F1      	CLSQT1: pop     AF              ; retrieve A
3AF6: C9      	        ret                     ; return to caller
              	
3AF7: F5      	OPNQT:  push    AF              ; store A
3AF8: 3AEF81  	        ld      A,(TMPBFR1)     ; quote status
3AFB: A7      	        and     A               ; are they open?
3AFC: 200F    	        jr      NZ,OPNQT1       ; if yes, return
3AFE: 3E2B    	        ld      A,'+'           ; no, so add '+
3B00: CD2518  	        call    OUTC            ; print it
3B03: 3E22    	        ld      A,$22           ; and then open quotes
3B05: CD2518  	        call    OUTC            ; print them
3B08: 3E01    	        ld      A,$01           ; set quotes
3B0A: 32EF81  	        ld      (TMPBFR1),A     ; as opened
3B0D: F1      	OPNQT1: pop     AF              ; retrieve A
3B0E: C9      	        ret                     ; return to caller
              	
3B0F: F5      	PRTCKEY:push    AF              ; store original char
3B10: 1A      	PRTK1:  ld      A,(DE)          ; load char
3B11: A7      	        and     A               ; is it 0?
3B12: CA1C3B  	        jp      Z,PRTEND        ; yes, finished printing
3B15: CD2518  	        call    OUTC            ; no, print char
3B18: 13      	        inc     DE              ; next char
3B19: C3103B  	        jp      PRTK1           ; repeat
3B1C: F1      	PRTEND: pop     AF              ; retrieve AF
3B1D: C9      	        ret                     ; return to caller
              	
3B1E: 4B455920	CHKEY1: defb    "KEY ",0
3B22: 00      	
3B23: 3A2200  	CHKEY2: defb    ":",34,0
3B26: 63687224	CHKEY3: defb    "chr$(",0
3B2A: 2800    	
3B2C: 313300  	CHKEY4: defb    "13",0
3B2F: 333400  	CHKEY5: defb    "34",0
              	
              	
              	; HEX$(nn) Convert 16 bit number to Hexadecimal string
3B32: CDB51E  	HEX: 	call	TSTNUM          ; Verify it's a number
3B35: CDF31A  	        call	DEINT           ; Get integer -32768 to 32767
3B38: C5      	        push	BC              ; Save contents of BC
3B39: 213082  	        ld      HL,PBUFF        ; load address of PBUFF into HL
3B3C: 7A      	        ld      A,D             ; Get MSB into A
3B3D: B7      	        or      A               ; OR with LSB to see if param=0
3B3E: 280C    	        jr      Z,HEX2          ; Skip output if both high digits are zero
3B40: CD683B  	        call    BYT2ASC         ; Convert D to ASCII
3B43: 78      	        ld      A,B             ; cechk if B
3B44: FE30    	        cp      '0'             ; is 0
3B46: 2802    	        jr      Z,HEX1          ; Don't store high digit if zero
3B48: 70      	        ld      (HL),B          ; Store it to PBUFF
3B49: 23      	        inc     HL              ; Next location
3B4A: 71      	HEX1:   ld      (HL),C          ; Store C to PBUFF+1
3B4B: 23      	        inc     HL              ; Next location
3B4C: 7B      	HEX2:   ld      A,E             ; Get lower byte
3B4D: CD683B  	        call    BYT2ASC         ; Convert E to ASCII
3B50: 7A      	        ld      A,D
3B51: B7      	        or      A
3B52: 2005    	        jr      NZ,HEX3         ; If upper byte was not zero then always print lower byte
3B54: 78      	        ld      A,B
3B55: FE30    	        cp      '0'             ; If high digit of lower byte is zero then don't print
3B57: 2802    	        jr      Z,HEX4
3B59: 70      	HEX3:   ld      (HL),B          ; to PBUFF+2
3B5A: 23      	        inc     HL              ; Next location
3B5B: 71      	HEX4:   ld      (HL),C          ; to PBUFF+3
3B5C: 23      	        inc     HL              ; PBUFF+4 to zero
3B5D: AF      	        xor     A               ; Terminating character
3B5E: 77      	        ld      (HL),A          ; Store zero to terminate
3B5F: 23      	        inc     HL              ; Make sure PBUFF is terminated
3B60: 77      	        ld      (HL),A          ; Store the double zero there
3B61: C1      	        pop     BC              ; Get BC back
3B62: 213082  	        ld      HL,PBUFF        ; Reset to start of PBUFF
3B65: C34A23  	        jp      STR1            ; Convert the PBUFF to a string and return it
3B68: 47      	BYT2ASC	ld      B,A             ; Save original value
3B69: E60F    	        and     $0F             ; Strip off upper nybble
3B6B: FE0A    	        cp      $0A             ; 0-9?
3B6D: 3802    	        jr      C,ADD30         ; If A-F, add 7 more
3B6F: C607    	        add     A,$07           ; Bring value up to ASCII A-F
3B71: C630    	ADD30	add     A,$30           ; And make ASCII
3B73: 4F      	        ld      C,A             ; Save converted char to C
3B74: 78      	        ld      A,B             ; Retrieve original value
3B75: 0F      	        rrca                    ; and Rotate it right
3B76: 0F      	        rrca
3B77: 0F      	        rrca
3B78: 0F      	        rrca
3B79: E60F    	        and     $0F             ; Mask off upper nybble
3B7B: FE0A    	        cp      $0A             ; 0-9? < A hex?
3B7D: 3802    	        jr      C,ADD301        ; Skip Add 7
3B7F: C607    	        add     A,$07           ; Bring it up to ASCII A-F
3B81: C630    	ADD301	add     A,$30           ; And make it full ASCII
3B83: 47      	        ld      B,A             ; Store high order byte
3B84: C9      	        ret
              	
              	; Convert "&Hnnnn" to FPREG
              	; Gets a character from (HL) checks for Hexadecimal ASCII numbers "&Hnnnn"
              	; Char is in A, NC if char is ;<=>?@ A-z, CY is set if 0-9
3B85: EB      	HEXTFP  ex      DE,HL           ; Move code string pointer to DE
3B86: 210000  	        ld      HL,$0000        ; Zero out the value
3B89: CD9E3B  	        call    GETHEX          ; Check the number for valid hex
3B8C: DABE3B  	        jp      C,HXERR         ; First value wasn't hex, HX error
3B8F: 1805    	        jr      HEXLP1          ; Convert first character
3B91: CD9E3B  	HEXLP   call    GETHEX          ; Get second and addtional characters
3B94: 381F    	        jr      C,HEXIT         ; Exit if not a hex character
3B96: 29      	HEXLP1  add     HL,HL           ; Rotate 4 bits to the left
3B97: 29      	        add     HL,HL
3B98: 29      	        add     HL,HL
3B99: 29      	        add     HL,HL
3B9A: B5      	        or      L               ; Add in D0-D3 into L
3B9B: 6F      	        ld      L,A             ; Save new value
3B9C: 18F3    	        jr      HEXLP           ; And continue until all hex characters are in
              	
3B9E: 13      	GETHEX  inc     DE              ; Next location
3B9F: 1A      	        ld      A,(DE)          ; Load character at pointer
3BA0: FE20    	        cp      SPC
3BA2: CA9E3B  	        jp      Z,GETHEX        ; Skip spaces
3BA5: D630    	        sub     $30             ; Get absolute value
3BA7: D8      	        ret     C               ; < "0", error
3BA8: FE0A    	        cp      $0A
3BAA: 3805    	        jr      C,NOSUB7        ; Is already in the range 0-9
3BAC: D607    	        sub     $07             ; Reduce to A-F
3BAE: FE0A    	        cp      $0A             ; Value should be $0A-$0F at this point
3BB0: D8      	        ret     C               ; CY set if was :            ; < = > ? @
3BB1: FE10    	NOSUB7  cp      $10             ; > Greater than "F"?
3BB3: 3F      	        ccf
3BB4: C9      	        ret                     ; CY set if it wasn't valid hex
              	
3BB5: EB      	HEXIT   ex      DE,HL           ; Value into DE, Code string into HL
3BB6: 7A      	        ld      A,D             ; Load DE into AC
3BB7: 4B      	        ld      C,E             ; For prep to
3BB8: E5      	        push    HL
3BB9: CD9B22  	        call    ACPASS          ; ACPASS to set AC as integer into FPREG
3BBC: E1      	        pop     HL
3BBD: C9      	        ret
              	
3BBE: 1E26    	HXERR:  ld      E,HX            ; ?HEX Error
3BC0: C34C15  	        jp      ERROR
              	
              	; BIN$(NN) Convert integer to a 1-16 char binary string
3BC3: CDB51E  	BIN:    call    TSTNUM          ; Verify it's a number
3BC6: CDF31A  	        call    DEINT           ; Get integer -32768 to 32767
3BC9: C5      	BIN2:   push    BC              ; Save contents of BC
3BCA: 213082  	        ld      HL,PBUFF
3BCD: 0611    	        ld      B,$11           ; One higher than max char count (16+1)
3BCF:         	ZEROSUP:                        ; Suppress leading zeros
3BCF: 05      	        dec     B               ; Max 16 chars
3BD0: 78      	        ld      A,B
3BD1: FE01    	        cp      $01
3BD3: 2808    	        jr      Z,BITOUT        ; Always output at least one character
3BD5: CB13    	        rl      E
3BD7: CB12    	        rl      D
3BD9: 30F4    	        jr      NC,ZEROSUP
3BDB: 1804    	        jr      BITOUT2
3BDD: CB13    	BITOUT: rl      E
3BDF: CB12    	        rl      D               ; Top bit now in carry
3BE1: 3E30    	BITOUT2:ld      A,'0'           ; Char for '0'
3BE3: CE00    	        adc     A,$00           ; If carry set then '0' --> '1'
3BE5: 77      	        ld      (HL),A
3BE6: 23      	        inc     HL
3BE7: 05      	        dec     B
3BE8: 20F3    	        jr      NZ,BITOUT
3BEA: AF      	        xor     A               ; Terminating character
3BEB: 77      	        ld      (HL),A          ; Store zero to terminate
3BEC: 23      	        inc     HL              ; Make sure PBUFF is terminated
3BED: 77      	        ld      (HL),A          ; Store the double zero there
3BEE: C1      	        pop     BC
3BEF: 213082  	        ld      HL,PBUFF
3BF2: C34A23  	        jp      STR1
              	
              	; Convert "&Bnnnn" to FPREG
              	; Gets a character from (HL) checks for Binary ASCII numbers "&Bnnnn"
3BF5: EB      	BINTFP: ex      DE,HL           ; Move code string pointer to DE
3BF6: 210000  	        ld      HL,$0000        ; Zero out the value
3BF9: CD123C  	        call    CHKBIN          ; Check the number for valid bin
3BFC: DA203C  	        jp      C,BINERR        ; First value wasn't bin, HX error
3BFF: D630    	BINIT:  sub     '0'
3C01: 29      	        add     HL,HL           ; Rotate HL left
3C02: B5      	        or      L
3C03: 6F      	        ld      L,A
3C04: CD123C  	        call    CHKBIN          ; Get second and addtional characters
3C07: 30F6    	        jr      NC,BINIT        ; Process if a bin character
3C09: EB      	        ex      DE,HL           ; Value into DE, Code string into HL
3C0A: 7A      	        ld      A,D             ; Load DE into AC
3C0B: 4B      	        ld      C,E             ; For prep to
3C0C: E5      	        push    HL
3C0D: CD9B22  	        call    ACPASS          ; ACPASS to set AC as integer into FPREG
3C10: E1      	        pop     HL
3C11: C9      	        ret
              	
              	; Char is in A, NC if char is 0 or 1
3C12: 13      	CHKBIN: inc     DE
3C13: 1A      	        ld      A,(DE)
3C14: FE20    	        cp      SPC
3C16: CA123C  	        jp      Z,CHKBIN        ; Skip spaces
3C19: FE30    	        cp      '0'             ; Set C if < '0'
3C1B: D8      	        ret     C
3C1C: FE32    	        cp      '2'
3C1E: 3F      	        ccf                     ; Set C if > '1'
3C1F: C9      	        ret
              	
3C20: 1E28    	BINERR: ld      E,BN            ; ?BIN Error
3C22: C34C15  	        jp      ERROR
              	
              	
3C25: C30800  	MONOUT: jp      $0008           ; output a char
              	
              	
3C28: 3A2E82  	RESET:  ld      A,(SERIALS_EN)
3C2B: E601    	        and     $01             ; is serial port #1 open?
3C2D: C4EB37  	        call    NZ,RSTSER1      ; yes, reset serial 1
3C30: C30000  	        jp      $0000           ; Restart
              	
              	
3C33: 3E00    	INITST: ld      A,$00           ; Clear break flag
3C35: 32A980  	        ld      (BRKFLG),A
3C38: C3E00E  	        jp      INIT
              	
              	
3C3B: F5      	TSTBIT: push    AF              ; Save bit mask
3C3C: A0      	        and     B               ; Get common bits
3C3D: C1      	        pop     BC              ; Restore bit mask
3C3E: B8      	        cp      B               ; Same bit set?
3C3F: 3E00    	        ld      A,$00           ; Return 0 in A
3C41: C9      	        ret
              	
3C42: CD2518  	OUTNCR: call    OUTC            ; Output character in A
3C45: C3F61C  	        jp      PRNTCRLF        ; Output CRLF
              	; ------------------------------------------------------------------------------
              	; LM80C - UTILITY ROUTINES - R1.1
              	; ------------------------------------------------------------------------------
              	; The following code is intended to be used with LM80C Z80-based computer
              	; designed by Leonardo Miliani. More info at
              	; www DOT leonardomiliani DOT com
              	;
              	; *ALS are routines from "Z80 Assembly Language Subroutines" by Lance
              	; A. Leventhal and Winthrop Saville - Ed. Osborne/McGraw-Hill (1983)
              	;
              	; * WKT are routines from WikiTI:
              	; http://wikiti.brandonw.net/index.php?title=WikiTI_Home
              	;
              	; * LAC are routines from Learn@Cemetch
              	; https://learn.cemetech.net/index.php/Main_Page
              	;
              	; ------------------------------------------------------------------------------
              	; Code Revision:
              	; R1.0 - 20200110 - First release: 16-bit comparision/multiplication/negation
              	; R1.1 - 20200413 - Second release: added ABS(HL) 
              	;
              	; ------------------------------------------------------------------------------
              	
              	; compare two 16-bit registers, HL (minuend) and DE (subtrahend)
              	; values can be both signed or unsigned words
              	; inputs: HL, DE
              	; destroys: A,F,HL
              	; returns: if both registers are 2's complement, use Z and S flags;
              	; otherwise:
              	; if HL=DE: Z,P,NC  - Z=1, S=0; C=0
              	; if HL>DE: NZ,P,NC - Z=0, S=0; C=0
              	; if HL<DE: NZ,M,C  - Z=0, S=1; C=1
              	; Source: ALS
              	
3C48: B7      	CMP16:  or      A           ; clear CARRY
3C49: ED52    	        sbc     HL,DE       ; subtract DE from HL
3C4B: E0      	        ret     PO          ; return if no overflow
3C4C: 7C      	        ld      A,H         ; overflow - invert SIGN flag
3C4D: 1F      	        rra                 ; save CARRY flag in bit 7
3C4E: EE40    	        xor     %01000000   ; complement bit 6 (SIGN bit)
3C50: 37      	        scf                 ; ensure a Non-Zero result
3C51: 8F      	        adc     A,A         ; restore CARRY, complemented SIGN
              	                            ; ZERO flag = 0 for sure
3C52: C9      	        ret                 ; return
              	
              	; ----------------------------------------------------------------------
              	
              	; multiply 2 signed/unsigned 16-bit words and return a 16-bit
              	; signed/unsigned product
              	; inputs: HL (multiplicand); DE (multiplier)
              	; destroys: A,F
              	; returns: HL (product)
              	; Source: ALS
              	
              	; initialize partial product, bit count
3C53: C5      	MUL16:  push    BC
3C54: 4D      	        ld      C,L         ; BC = multiplier
3C55: 44      	        ld      B,H
3C56: 210000  	        ld      HL,0        ; product = 0
3C59: 3E0F    	        ld      A,$0F       ; count = bit lenght - 1 (16-1)
              	        ; shift-and-add algorithm
              	        ; if MSB of multiplier is 1, add multiplicand to partial product
              	        ; shift partial product, multiplier left 1 bit
3C5B: CB23    	MLP:    sla     E           ; shift multiplier left 1 bit
3C5D: CB12    	        rl      D
3C5F: 3001    	        jr      NC,MLP1     ; jump if MSB of multiplier = 0
3C61: 09      	        add     HL,BC       ; add multiplicand to partial product
3C62: 29      	MLP1:   add     HL,HL       ; shift partial product left
3C63: 3D      	        dec     A
3C64: 20F5    	        jr      NZ,MLP      ; continue until count = 0
              	        ; add multiplicand one last time if MSB of multiplier is 1
3C66: B2      	        or      D           ; sign flag = MSB of multiplier
3C67: F26B3C  	        jp      P,EXMUL16   ; exit if MSB of multiplier is 0
3C6A: 09      	        add     HL,BC       ; add multiplicand to product
3C6B: C1      	EXMUL16:pop     BC
3C6C: C9      	        ret
              	
              	; ----------------------------------------------------------------------
              	; absolute value of HL (same applies to other 16-bit register pairs)
              	; also, invert value of HL (or any other 16-bit register, just adjust the code)
              	;
              	; inputs: HL
              	; destroys: A
              	; operation: ABS(HL)
              	; returns: HL with no sign or negated
              	; Source: WKT
              	
3C6D: CB7C    	absHL:  bit     7,H
3C6F: C8      	        ret     Z
3C70: AF      	negHL:  xor     A
3C71: 95      	        sub     L
3C72: 6F      	        ld      L,A
3C73: 9F      	        sbc     A,A
3C74: 94      	        sub     H
3C75: 67      	        ld      H,A
3C76: C9      	        ret
              	
              	; ------------------------------------------------------------------------------
              	
              	; 8/8 division
              	; INPUT: D (dividend), E (divisor)
              	; OPERATION: D/E
              	; OUTPUT: D (quotient), A (remainder)
3C77: AF      	DIV_8_8:    xor     A
3C78: C5      	            push    BC
3C79: 0608    	            ld      B,08h
3C7B: CB22    	DIV_8_8LOOP:sla     D
3C7D: 17      	            rla
3C7E: BB      	            cp      E
3C7F: 3802    	            jr      C,$+4
3C81: 93      	            sub     E
3C82: 14      	            inc     D
3C83: 10F6    	            djnz    DIV_8_8LOOP
3C85: C1      	            pop     BC
3C86: C9      	            ret
              	
              	; ----------------------------------------------------------------------
              	; divide a 16-bit number by an 8-bit number
              	; (16/8 division)
              	;
              	; inputs: HL (Dividend), C (divisor)
              	; destroys: A
              	; OPERATION: HL/C
              	; returns: HL (quotient), A (remainder)
              	; source: WKT
              	
3C87: AF      	DIV_16_8:   xor     A
3C88: 0610    	            ld      B,16
3C8A: 29      	DIV_16_8LP: add     HL,HL
3C8B: 17      	            rla
3C8C: 3803    	            jr      C,$+5
3C8E: B9      	            cp      C
3C8F: 3802    	            jr      C,$+4
3C91: 91      	            sub     C
3C92: 2C      	            inc     L
3C93: 10F5    	            djnz    DIV_16_8LP
3C95: C9      	            ret; ------------------------------------------------------------------------------
              	; LM80C - 6x8 CHARSET - R1.4
              	; ------------------------------------------------------------------------------
              	; The following code is intended to be used with LM80C Z80-based computer
              	; designed by Leonardo Miliani. More info at
              	; www DOT leonardomiliani DOT com
              	; ------------------------------------------------------------------------------
              	; Code Revision:
              	; R1.0 - 20190511 - First revision: ASCII chars (from 0 to 127)
              	; R1.1 - 20190521 - Expanded to 255 chars
              	; R1.2 - 20191209 - Start adding graphic chars to be coherent with 8x8 fonts
              	; R1.3 - 20191226 - Added extended char codes (128-255)
              	; R1.4 - 20200228 - adopted more usual hexadecimal & binary prefixes
              	; ------------------------------------------------------------------------------
              	;
              	;-------------------------------------------------------------------------------
              	;
              	;               6 x 8    C  H  A  R  S  E  T
              	;
              	;-------------------------------------------------------------------------------
              	;
              	;       6X8 CHARS, DESIGNED FOR TEXT BUT USABLE IN GRAPHICS 1 MODE TOO
              	;       UPDATE: NOW GRAPHICS 1 MODE HAS ITS OWN CHAR SET
              	
3C96:         	CHRST68 equ $
3C96: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 0 (null char)
3C9A: 00000000	
3C9E: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 1 F1
3CA2: 00000000	
3CA6: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 2 F2
3CAA: 00000000	
3CAE: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 3 CTRL-C
3CB2: 00000000	
3CB6: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 4 F3
3CBA: 00000000	
3CBE: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 5 F4
3CC2: 00000000	
3CC6: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 6 F5
3CCA: 00000000	
3CCE: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 7 (bell)
3CD2: 00000000	
3CD6: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 8 (backspace)
3CDA: 00000000	
3CDE: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 9 (H. tab)
3CE2: 00000000	
3CE6: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 10 (line feed)
3CEA: 00000000	
3CEE: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 11 
3CF2: 00000000	
3CF6: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 12 Form feed (clear screen)
3CFA: 00000000	
3CFE: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 13 (carriage return)
3D02: 00000000	
3D06: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 14 CTRL
3D0A: 00000000	
3D0E: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 15 CTRL-O
3D12: 00000000	
3D16: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 16 C=/Graphic key
3D1A: 00000000	
3D1E: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 17 CTRL-Q
3D22: 00000000	
3D26: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 18 CTRL-R
3D2A: 00000000	
3D2E: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 19 CTRL-S
3D32: 00000000	
3D36: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 20 SHIFT
3D3A: 00000000	
3D3E: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 21 CTRL-U
3D42: 00000000	
3D46: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 22 F6
3D4A: 00000000	
3D4E: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 23 F7
3D52: 00000000	
3D56: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 24 HELP
3D5A: 00000000	
3D5E: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 25 (home)
3D62: 00000000	
3D66: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 26
3D6A: 00000000	
3D6E: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 27 (escape)
3D72: 00000000	
3D76: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 28 (cursor left)
3D7A: 00000000	
3D7E: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 29 (cursor right)
3D82: 00000000	
3D86: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 30 (cursor up)
3D8A: 00000000	
3D8E: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 31 (cursor down)
3D92: 00000000	
3D96: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 32: space
3D9A: 00000000	
3D9E: 20202020	        defb $20,$20,$20,$20,$20,$00,$20,$00 ; char 33: !
3DA2: 20002000	
3DA6: 50500000	        defb $50,$50,$00,$00,$00,$00,$00,$00 ; char 34: "
3DAA: 00000000	
3DAE: 5050F850	        defb $50,$50,$f8,$50,$f8,$50,$50,$00 ; char 35: #
3DB2: F8505000	
3DB6: 2078A070	        defb $20,$78,$a0,$70,$28,$f0,$20,$00 ; char 36: $
3DBA: 28F02000	
3DBE: C0C81020	        defb $c0,$c8,$10,$20,$40,$98,$18,$00 ; char 37: %
3DC2: 40981800	
3DC6: 6090A040	        defb $60,$90,$a0,$40,$a8,$90,$68,$00 ; char 38: &
3DCA: A8906800	
3DCE: 60204000	        defb $60,$20,$40,$00,$00,$00,$00,$00 ; char 39: '
3DD2: 00000000	
3DD6: 10204040	        defb $10,$20,$40,$40,$40,$20,$10,$00 ; char 40: (
3DDA: 40201000	
3DDE: 40201010	        defb $40,$20,$10,$10,$10,$20,$40,$00 ; char 41: )
3DE2: 10204000	
3DE6: 0020A870	        defb $00,$20,$a8,$70,$a8,$20,$00,$00 ; char 42: *
3DEA: A8200000	
3DEE: 002020F8	        defb $00,$20,$20,$f8,$20,$20,$00,$00 ; char 43: +
3DF2: 20200000	
3DF6: 00000000	        defb $00,$00,$00,$00,$60,$20,$40,$00 ; char 44: ,
3DFA: 60204000	
3DFE: 000000F8	        defb $00,$00,$00,$f8,$00,$00,$00,$00 ; char 45: -
3E02: 00000000	
3E06: 00000000	        defb $00,$00,$00,$00,$00,$60,$60,$00 ; char 46: .
3E0A: 00606000	
3E0E: 00081020	        defb $00,$08,$10,$20,$40,$80,$00,$00 ; char 47: /
3E12: 40800000	
3E16: 708898A8	        defb $70,$88,$98,$a8,$c8,$88,$70,$00 ; char 48: 0
3E1A: C8887000	
3E1E: 20602020	        defb $20,$60,$20,$20,$20,$20,$70,$00 ; char 49: 1
3E22: 20207000	
3E26: 70880810	        defb $70,$88,$08,$10,$20,$40,$f8,$00 ; char 50: 2
3E2A: 2040F800	
3E2E: F8102010	        defb $f8,$10,$20,$10,$08,$88,$70,$00 ; char 51: 3
3E32: 08887000	
3E36: 10305090	        defb $10,$30,$50,$90,$f8,$10,$10,$00 ; char 52: 4
3E3A: F8101000	
3E3E: F880F008	        defb $f8,$80,$f0,$08,$08,$88,$70,$00 ; char 53: 5
3E42: 08887000	
3E46: 304080F8	        defb $30,$40,$80,$f8,$88,$88,$70,$00 ; char 54: 6
3E4A: 88887000	
3E4E: F8081020	        defb $f8,$08,$10,$20,$40,$40,$40,$00 ; char 55: 7
3E52: 40404000	
3E56: 70888870	        defb $70,$88,$88,$70,$88,$88,$70,$00 ; char 56: 8
3E5A: 88887000	
3E5E: 70888878	        defb $70,$88,$88,$78,$08,$10,$60,$00 ; char 57: 9
3E62: 08106000	
3E66: 00303000	        defb $00,$30,$30,$00,$30,$30,$00,$00 ; char 58: :
3E6A: 30300000	
3E6E: 00303000	        defb $00,$30,$30,$00,$30,$10,$20,$00 ; char 59: ;
3E72: 30102000	
3E76: 10204080	        defb $10,$20,$40,$80,$40,$20,$10,$00 ; char 60: <
3E7A: 40201000	
3E7E: 0000F800	        defb $00,$00,$f8,$00,$f8,$00,$00,$00 ; char 61: =
3E82: F8000000	
3E86: 40201008	        defb $40,$20,$10,$08,$10,$20,$40,$00 ; char 62: >
3E8A: 10204000	
3E8E: 70880810	        defb $70,$88,$08,$10,$20,$00,$20,$00 ; char 63: ?
3E92: 20002000	
3E96: 70880868	        defb $70,$88,$08,$68,$a8,$a8,$70,$00 ; char 64: @
3E9A: A8A87000	
3E9E: 70888888	        defb $70,$88,$88,$88,$f8,$88,$88,$00 ; char 65: A
3EA2: F8888800	
3EA6: F08888F0	        defb $f0,$88,$88,$f0,$88,$88,$f0,$00 ; char 66: B
3EAA: 8888F000	
3EAE: 70888080	        defb $70,$88,$80,$80,$80,$88,$70,$00 ; char 67: C
3EB2: 80887000	
3EB6: E0908888	        defb $e0,$90,$88,$88,$88,$90,$e0,$00 ; char 68: D
3EBA: 8890E000	
3EBE: F88080F0	        defb $f8,$80,$80,$f0,$80,$80,$f8,$00 ; char 69: E
3EC2: 8080F800	
3EC6: F88080F0	        defb $f8,$80,$80,$f0,$80,$80,$80,$00 ; char 70: F
3ECA: 80808000	
3ECE: 708880B8	        defb $70,$88,$80,$b8,$88,$88,$78,$00 ; char 71: G
3ED2: 88887800	
3ED6: 888888F8	        defb $88,$88,$88,$f8,$88,$88,$88,$00 ; char 72: H
3EDA: 88888800	
3EDE: 70202020	        defb $70,$20,$20,$20,$20,$20,$70,$00 ; char 73: I
3EE2: 20207000	
3EE6: 38101010	        defb $38,$10,$10,$10,$10,$90,$60,$00 ; char 74: J
3EEA: 10906000	
3EEE: 8890A0C0	        defb $88,$90,$a0,$c0,$a0,$90,$88,$00 ; char 75: K
3EF2: A0908800	
3EF6: 80808080	        defb $80,$80,$80,$80,$80,$80,$f8,$00 ; char 76: L
3EFA: 8080F800	
3EFE: 88D8A8A8	        defb $88,$d8,$a8,$a8,$88,$88,$88,$00 ; char 77: M
3F02: 88888800	
3F06: 88C8A898	        defb $88,$c8,$a8,$98,$88,$88,$88,$00 ; char 78: N
3F0A: 88888800	
3F0E: 70888888	        defb $70,$88,$88,$88,$88,$88,$70,$00 ; char 79: O
3F12: 88887000	
3F16: F08888F0	        defb $f0,$88,$88,$f0,$80,$80,$80,$00 ; char 80: P
3F1A: 80808000	
3F1E: 70888888	        defb $70,$88,$88,$88,$a8,$90,$68,$00 ; char 81: Q
3F22: A8906800	
3F26: F08888F0	        defb $f0,$88,$88,$f0,$a0,$90,$88,$00 ; char 82: R
3F2A: A0908800	
3F2E: 78808070	        defb $78,$80,$80,$70,$08,$08,$f0,$00 ; char 83: S
3F32: 0808F000	
3F36: F8202020	        defb $f8,$20,$20,$20,$20,$20,$20,$00 ; char 84: T
3F3A: 20202000	
3F3E: 88888888	        defb $88,$88,$88,$88,$88,$88,$70,$00 ; char 85: U
3F42: 88887000	
3F46: 88888888	        defb $88,$88,$88,$88,$88,$50,$20,$00 ; char 86: V
3F4A: 88502000	
3F4E: 88888888	        defb $88,$88,$88,$88,$a8,$a8,$50,$00 ; char 87: W
3F52: A8A85000	
3F56: 88885020	        defb $88,$88,$50,$20,$50,$88,$88,$00 ; char 88: X
3F5A: 50888800	
3F5E: 88888850	        defb $88,$88,$88,$50,$20,$20,$20,$00 ; char 89: Y
3F62: 20202000	
3F66: F8081020	        defb $f8,$08,$10,$20,$40,$80,$f8,$00 ; char 90: Z
3F6A: 4080F800	
3F6E: 70404040	        defb $70,$40,$40,$40,$40,$40,$70,$00 ; char 91: [
3F72: 40407000	
3F76: 00804020	        defb $00,$80,$40,$20,$10,$08,$00,$00 ; char 92: \
3F7A: 10080000	
3F7E: 70101010	        defb $70,$10,$10,$10,$10,$10,$70,$00 ; char 93: ]
3F82: 10107000	
3F86: 20508800	        defb $20,$50,$88,$00,$00,$00,$00,$00 ; char 94: ^
3F8A: 00000000	
3F8E: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$FC ; char 95: _ (underscore)
3F92: 000000FC	
3F96: 40201000	        defb $40,$20,$10,$00,$00,$00,$00,$00 ; char 96: `
3F9A: 00000000	
3F9E: 00007008	        defb $00,$00,$70,$08,$78,$88,$78,$00 ; char 97: a
3FA2: 78887800	
3FA6: 808080B0	        defb $80,$80,$80,$b0,$c8,$88,$f0,$00 ; char 98: b
3FAA: C888F000	
3FAE: 00007080	        defb $00,$00,$70,$80,$80,$88,$70,$00 ; char 99: c
3FB2: 80887000	
3FB6: 08080868	        defb $08,$08,$08,$68,$98,$88,$78,$00 ; char 100: d
3FBA: 98887800	
3FBE: 00007088	        defb $00,$00,$70,$88,$f8,$80,$70,$00 ; char 101: e
3FC2: F8807000	
3FC6: 304840E0	        defb $30,$48,$40,$e0,$40,$40,$40,$00 ; char 102: f
3FCA: 40404000	
3FCE: 00007888	        defb $00,$00,$78,$88,$78,$08,$70,$00 ; char 103: g
3FD2: 78087000	
3FD6: 8080B0C8	        defb $80,$80,$b0,$c8,$88,$88,$88,$00 ; char 104: h
3FDA: 88888800	
3FDE: 00200020	        defb $00,$20,$00,$20,$20,$20,$20,$00 ; char 105: i
3FE2: 20202000	
3FE6: 00100030	        defb $00,$10,$00,$30,$10,$90,$60,$00 ; char 106: j
3FEA: 10906000	
3FEE: 808090A0	        defb $80,$80,$90,$a0,$c0,$a0,$90,$00 ; char 107: k
3FF2: C0A09000	
3FF6: 60202020	        defb $60,$20,$20,$20,$20,$20,$70,$00 ; char 108: l
3FFA: 20207000	
3FFE: 0000D0A8	        defb $00,$00,$d0,$a8,$a8,$88,$88,$00 ; char 109: m
4002: A8888800	
4006: 0000B0C8	        defb $00,$00,$b0,$c8,$88,$88,$88,$00 ; char 110: n
400A: 88888800	
400E: 00007088	        defb $00,$00,$70,$88,$88,$88,$70,$00 ; char 111: o
4012: 88887000	
4016: 0000F088	        defb $00,$00,$f0,$88,$f0,$80,$80,$00 ; char 112: p
401A: F0808000	
401E: 00007888	        defb $00,$00,$78,$88,$78,$08,$08,$00 ; char 113: q
4022: 78080800	
4026: 0000B0C8	        defb $00,$00,$b0,$c8,$80,$80,$80,$00 ; char 114: r
402A: 80808000	
402E: 00007080	        defb $00,$00,$70,$80,$70,$08,$f0,$00 ; char 115: s
4032: 7008F000	
4036: 4040E040	        defb $40,$40,$e0,$40,$40,$48,$30,$00 ; char 116: t
403A: 40483000	
403E: 00008888	        defb $00,$00,$88,$88,$88,$98,$68,$00 ; char 117: u
4042: 88986800	
4046: 00008888	        defb $00,$00,$88,$88,$88,$50,$20,$00 ; char 118: v
404A: 88502000	
404E: 00008888	        defb $00,$00,$88,$88,$a8,$a8,$50,$00 ; char 119: w
4052: A8A85000	
4056: 00008850	        defb $00,$00,$88,$50,$20,$50,$88,$00 ; char 120: x
405A: 20508800	
405E: 00008898	        defb $00,$00,$88,$98,$68,$08,$70,$00 ; char 121: y
4062: 68087000	
4066: 0000F810	        defb $00,$00,$f8,$10,$20,$40,$f8,$00 ; char 122: z
406A: 2040F800	
406E: 10202040	        defb $10,$20,$20,$40,$20,$20,$10,$00 ; char 123: {
4072: 20201000	
4076: 20202020	        defb $20,$20,$20,$20,$20,$20,$20,$00 ; char 124: |
407A: 20202000	
407E: 20101008	        defb $20,$10,$10,$08,$10,$10,$20,$00 ; char 125: }
4082: 10102000	
4086: 00285000	        defb $00,$28,$50,$00,$00,$00,$00,$00 ; char 126: ~
408A: 00000000	
408E: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 127: (delete) - here end the standard ASCII (0-127)
4092: 00000000	
4096: 7884CC84	        defb %01111000,%10000100,%11001100,%10000100,%10110100,%10000100,%01111000,%00000000 ; char 128 (open face)
409A: B4847800	
409E: 78FCB4FC	        defb %01111000,%11111100,%10110100,%11111100,%10110100,%11001100,%01111000,%00000000 ; char 129 (full face)
40A2: B4CC7800	
40A6: 48FCFCFC	        defb %01001000,%11111100,%11111100,%11111100,%11111100,%01111000,%00110000,%00000000 ; char 130 (hearts)
40AA: FC783000	
40AE: 002070F8	        defb %00000000,%00100000,%01110000,%11111000,%11111000,%01110000,%00100000,%00000000 ; char 131 (diamonds)
40B2: F8702000	
40B6: 7020A8F8	        defb %01110000,%00100000,%10101000,%11111000,%10101000,%00100000,%01110000,%00000000 ; char 132 (clubs)
40BA: A8207000	
40BE: 2070F8F8	        defb %00100000,%01110000,%11111000,%11111000,%10101000,%00100000,%01110000,%00000000 ; char 133 (spades)
40C2: A8207000	
40C6: 303030FC	        defb %00110000,%00110000,%00110000,%11111100,%11111100,%00110000,%00110000,%00110000 ; char 134 
40CA: FC303030	
40CE: 0000003C	        defb %00000000,%00000000,%00000000,%00111100,%00111100,%00110000,%00110000,%00110000 ; char 135 
40D2: 3C303030	
40D6: 000000F0	        defb %00000000,%00000000,%00000000,%11110000,%11110000,%00110000,%00110000,%00110000 ; char 136 
40DA: F0303030	
40DE: 303030F0	        defb %00110000,%00110000,%00110000,%11110000,%11110000,%00000000,%00000000,%00000000 ; char 137 
40E2: F0000000	
40E6: 3030303C	        defb %00110000,%00110000,%00110000,%00111100,%00111100,%00000000,%00000000,%00000000 ; char 138 
40EA: 3C000000	
40EE: 303030FC	        defb %00110000,%00110000,%00110000,%11111100,%11111100,%00000000,%00000000,%00000000 ; char 139 
40F2: FC000000	
40F6: 3030303C	        defb %00110000,%00110000,%00110000,%00111100,%00111100,%00110000,%00110000,%00110000 ; char 140 
40FA: 3C303030	
40FE: 000000FC	        defb %00000000,%00000000,%00000000,%11111100,%11111100,%00110000,%00110000,%00110000 ; char 141 
4102: FC303030	
4106: 303030F0	        defb %00110000,%00110000,%00110000,%11110000,%11110000,%00110000,%00110000,%00110000 ; char 142 
410A: F0303030	
410E: 000000FC	        defb %00000000,%00000000,%00000000,%11111100,%11111100,%00000000,%00000000,%00000000 ; char 143 
4112: FC000000	
4116: 30303030	        defb %00110000,%00110000,%00110000,%00110000,%00110000,%00110000,%00110000,%00110000 ; char 144 
411A: 30303030	
411E: 0C1C1838	        defb %00001100,%00011100,%00011000,%00111000,%01110000,%01100000,%11100000,%11000000 ; char 145 
4122: 7060E0C0	
4126: C0E06070	        defb %11000000,%11100000,%01100000,%01110000,%00111000,%00011000,%00011100,%00001100 ; char 146 
412A: 38181C0C	
412E: CCCC7830	        defb %11001100,%11001100,%01111000,%00110000,%00110000,%01111000,%11001100,%11001100 ; char 147 
4132: 3078CCCC	
4136: 202020FC	        defb %00100000,%00100000,%00100000,%11111100,%00100000,%00100000,%00100000,%00100000 ; char 148 
413A: 20202020	
413E: 0000003C	        defb %00000000,%00000000,%00000000,%00111100,%00100000,%00100000,%00100000,%00100000 ; char 149 
4142: 20202020	
4146: 000000E0	        defb %00000000,%00000000,%00000000,%11100000,%00100000,%00100000,%00100000,%00100000 ; char 150 
414A: 20202020	
414E: 202020E0	        defb %00100000,%00100000,%00100000,%11100000,%00000000,%00000000,%00000000,%00000000 ; char 151 
4152: 00000000	
4156: 2020203C	        defb %00100000,%00100000,%00100000,%00111100,%00000000,%00000000,%00000000,%00000000 ; char 152 
415A: 00000000	
415E: 202020FC	        defb %00100000,%00100000,%00100000,%11111100,%00000000,%00000000,%00000000,%00000000 ; char 153 
4162: 00000000	
4166: 2020203C	        defb %00100000,%00100000,%00100000,%00111100,%00100000,%00100000,%00100000,%00100000 ; char 154 
416A: 20202020	
416E: 000000FC	        defb %00000000,%00000000,%00000000,%11111100,%00100000,%00100000,%00100000,%00100000 ; char 155 
4172: 20202020	
4176: 202020E0	        defb %00100000,%00100000,%00100000,%11100000,%00100000,%00100000,%00100000,%00100000 ; char 156 
417A: 20202020	
417E: 000000FC	        defb %00000000,%00000000,%00000000,%11111100,%00000000,%00000000,%00000000,%00000000 ; char 157 
4182: 00000000	
4186: 20202020	        defb %00100000,%00100000,%00100000,%00100000,%00100000,%00100000,%00100000,%00100000 ; char 158 
418A: 20202020	
418E: 04080810	        defb %00000100,%00001000,%00001000,%00010000,%00100000,%01000000,%01000000,%10000000 ; char 159 
4192: 20404080	
4196: 80404020	        defb %10000000,%01000000,%01000000,%00100000,%00010000,%00001000,%00001000,%00000100 ; char 160 
419A: 10080804	
419E: 84484830	        defb %10000100,%01001000,%01001000,%00110000,%00110000,%01001000,%01001000,%10000100 ; char 161 
41A2: 30484884	
41A6: 00000000	        defb %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%11111100,%11111100 ; char 162 
41AA: 0000FCFC	
41AE: 00000000	        defb %00000000,%00000000,%00000000,%00000000,%11111100,%11111100,%11111100,%11111100 ; char 163 
41B2: FCFCFCFC	
41B6: 0000FCFC	        defb %00000000,%00000000,%11111100,%11111100,%11111100,%11111100,%11111100,%11111100 ; char 164 
41BA: FCFCFCFC	
41BE: FCFC0000	        defb %11111100,%11111100,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 165 
41C2: 00000000	
41C6: FCFCFCFC	        defb %11111100,%11111100,%11111100,%11111100,%00000000,%00000000,%00000000,%00000000 ; char 166 
41CA: 00000000	
41CE: FCFCFCFC	        defb %11111100,%11111100,%11111100,%11111100,%11111100,%11111100,%00000000,%00000000 ; char 167 
41D2: FCFC0000	
41D6: 80808080	        defb %10000000,%10000000,%10000000,%10000000,%10000000,%10000000,%10000000,%10000000 ; char 168 
41DA: 80808080	
41DE: E0E0E0E0	        defb %11100000,%11100000,%11100000,%11100000,%11100000,%11100000,%11100000,%11100000 ; char 169 
41E2: E0E0E0E0	
41E6: F8F8F8F8	        defb %11111000,%11111000,%11111000,%11111000,%11111000,%11111000,%11111000,%11111000 ; char 170 
41EA: F8F8F8F8	
41EE: 04040404	        defb %00000100,%00000100,%00000100,%00000100,%00000100,%00000100,%00000100,%00000100 ; char 171 
41F2: 04040404	
41F6: 1C1C1C1C	        defb %00011100,%00011100,%00011100,%00011100,%00011100,%00011100,%00011100,%00011100 ; char 172 
41FA: 1C1C1C1C	
41FE: 7C7C7C7C	        defb %01111100,%01111100,%01111100,%01111100,%01111100,%01111100,%01111100,%01111100 ; char 173 
4202: 7C7C7C7C	
4206: FC848484	        defb %11111100,%10000100,%10000100,%10000100,%10000100,%10000100,%10000100,%11111100 ; char 174 
420A: 848484FC	
420E: 00000000	        defb %00000000,%00000000,%00000000,%00000000,%11100000,%11100000,%11100000,%11100000 ; char 175 
4212: E0E0E0E0	
4216: 00000000	        defb %00000000,%00000000,%00000000,%00000000,%00011100,%00011100,%00011100,%00011100 ; char 176 
421A: 1C1C1C1C	
421E: 1C1C1C1C	        defb %00011100,%00011100,%00011100,%00011100,%00000000,%00000000,%00000000,%00000000 ; char 177 
4222: 00000000	
4226: E0E0E0E0	        defb %11100000,%11100000,%11100000,%11100000,%00000000,%00000000,%00000000,%00000000 ; char 178 
422A: 00000000	
422E: E0E0E0E0	        defb %11100000,%11100000,%11100000,%11100000,%00011100,%00011100,%00011100,%00011100 ; char 179 
4232: 1C1C1C1C	
4236: 1C1C1C1C	        defb %00011100,%00011100,%00011100,%00011100,%11100000,%11100000,%11100000,%11100000 ; char 180 
423A: E0E0E0E0	
423E: 78787878	        defb %01111000,%01111000,%01111000,%01111000,%01111000,%01111000,%01111000,%01111000 ; char 181 
4242: 78787878	
4246: CCCCCCCC	        defb %11001100,%11001100,%11001100,%11001100,%11001100,%11001100,%11001100,%11001100 ; char 182 
424A: CCCCCCCC	
424E: FCFC0000	        defb %11111100,%11111100,%00000000,%00000000,%00000000,%00000000,%11111100,%11111100 ; char 183 
4252: 0000FCFC	
4256: 0000FCFC	        defb %00000000,%00000000,%11111100,%11111100,%11111100,%11111100,%00000000,%00000000 ; char 184 
425A: FCFC0000	
425E: 3030CCCC	        defb %00110000,%00110000,%11001100,%11001100,%00110000,%00110000,%11001100,%11001100 ; char 185 
4262: 3030CCCC	
4266: 54A854A8	        defb %01010100,%10101000,%01010100,%10101000,%01010100,%10101000,%01010100,%10101000 ; char 186 
426A: 54A854A8	
426E: 643098CC	        defb %01100100,%00110000,%10011000,%11001100,%01100100,%00110000,%10011000,%11001100 ; char 187 
4272: 643098CC	
4276: CC643098	        defb %11001100,%01100100,%00110000,%10011000,%11001100,%01100100,%00110000,%10011000 ; char 188 
427A: CC643098	
427E: 3098CC64	        defb %00110000,%10011000,%11001100,%01100100,%00110000,%10011000,%11001100,%01100100 ; char 189 
4282: 3098CC64	
4286: 64CC9830	        defb %01100100,%11001100,%10011000,%00110000,%01100100,%11001100,%10011000,%00110000 ; char 190 
428A: 64CC9830	
428E: 2020F820	        defb %00100000,%00100000,%11111000,%00100000,%00100000,%00000000,%11111000,%00000000 ; char 191 ()
4292: 2000F800	
4296: C0300830	        defb %11000000,%00110000,%00001000,%00110000,%11000000,%00000000,%11111000,%00000000 ; char 192 ()
429A: C000F800	
429E: 18608060	        defb %00011000,%01100000,%10000000,%01100000,%00011000,%00000000,%11111000,%00000000 ; char 193 ()
42A2: 1800F800	
42A6: 3C202020	        defb %00111100,%00100000,%00100000,%00100000,%10100000,%01100000,%00100000,%00000000 ; char 194 (square root)
42AA: A0602000	
42AE: 30484830	        defb %00110000,%01001000,%01001000,%00110000,%00000000,%00000000,%00000000,%00000000 ; char 195 ()
42B2: 00000000	
42B6: 60103040	        defb %01100000,%00010000,%00110000,%01000000,%01110000,%00000000,%00000000,%00000000 ; char 196 ()
42BA: 70000000	
42BE: 000054A8	        defb %00000000,%00000000,%01010100,%10101000,%00000000,%11111100,%00000000,%00000000 ; char 197
42C2: 00FC0000	
42C6: 0054A800	        defb %00000000,%01010100,%10101000,%00000000,%01010100,%10101000,%00000000,%00000000 ; char 198 ()
42CA: 54A80000	
42CE: 0080C0E0	        defb %00000000,%10000000,%11000000,%11100000,%11100000,%11000000,%10000000,%00000000 ; char 199
42D2: E0C08000	
42D6: FC783000	        defb %11111100,%01111000,%00110000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 200
42DA: 00000000	
42DE: 00040C1C	        defb %00000000,%00000100,%00001100,%00011100,%00011100,%00001100,%00000100,%00000000 ; char 201
42E2: 1C0C0400	
42E6: 00000000	        defb %00000000,%00000000,%00000000,%00000000,%00000000,%00110000,%01111000,%11111100 ; char 202 
42EA: 003078FC	
42EE: 2070F820	        defb %00100000,%01110000,%11111000,%00100000,%00100000,%00100000,%00100000,%00000000 ; char 203 (up arrow)
42F2: 20202000	
42F6: 3C1C1C24	        defb %00111100,%00011100,%00011100,%00100100,%01000000,%10000000,%00000000,%00000000 ; char 204 (up right arrow)
42FA: 40800000	
42FE: 001018FC	        defb %00000000,%00010000,%00011000,%11111100,%00011000,%00010000,%00000000,%00000000 ; char 205 (right arrow)
4302: 18100000	
4306: 00008040	        defb %00000000,%00000000,%10000000,%01000000,%00100100,%00011100,%00011100,%00111100 ; char 206 (down right arrow)
430A: 241C1C3C	
430E: 00202020	        defb %00000000,%00100000,%00100000,%00100000,%00100000,%11111000,%01110000,%00100000 ; char 207 (down arrow)
4312: 20F87020	
4316: 00000408	        defb %00000000,%00000000,%00000100,%00001000,%10010000,%11100000,%11100000,%11110000 ; char 208 (down left arrow)
431A: 90E0E0F0	
431E: 002060FC	        defb %00000000,%00100000,%01100000,%11111100,%01100000,%00100000,%00000000,%00000000 ; char 209 (left arrow)
4322: 60200000	
4326: F0E0E090	        defb %11110000,%11100000,%11100000,%10010000,%00001000,%00000100,%00000000,%00000000 ; char 210 (up left arrow)
432A: 08040000	
432E: 3844F040	        defb %00111000,%01000100,%11110000,%01000000,%11110000,%01000100,%00111000,%00000000 ; char 211 (euro)
4332: F0443800	
4336: 000478A8	        defb %00000000,%00000100,%01111000,%10101000,%00101000,%00101000,%00101000,%00000000 ; char 212 (greek pi)
433A: 28282800	
433E: 00000000	        defb %00000000,%00000000,%00000000,%00000000,%00011100,%00100000,%00100000,%00100000 ; char 213
4342: 1C202020	
4346: 00000000	        defb %00000000,%00000000,%00000000,%00000000,%11100000,%00010000,%00010000,%00010000 ; char 214
434A: E0101010	
434E: 101010E0	        defb %00010000,%00010000,%00010000,%11100000,%00000000,%00000000,%00000000,%00000000 ; char 215
4352: 00000000	
4356: 2020201C	        defb %00100000,%00100000,%00100000,%00011100,%00000000,%00000000,%00000000,%00000000 ; char 216
435A: 00000000	
435E: 0000001C	        defb %00000000,%00000000,%00000000,%00011100,%00111100,%00110000,%00110000,%00110000 ; char 217
4362: 3C303030	
4366: 000000E0	        defb %00000000,%00000000,%00000000,%11100000,%11110000,%00110000,%00110000,%00110000 ; char 218
436A: F0303030	
436E: 303030F0	        defb %00110000,%00110000,%00110000,%11110000,%11100000,%00000000,%00000000,%00000000 ; char 219
4372: E0000000	
4376: 3030303C	        defb %00110000,%00110000,%00110000,%00111100,%00011100,%00000000,%00000000,%00000000 ; char 220
437A: 1C000000	
437E: 00304848	        defb %00000000,%00110000,%01001000,%01001000,%01001000,%00110000,%00000000,%00000000 ; char 221
4382: 48300000	
4386: 00307878	        defb %00000000,%00110000,%01111000,%01111000,%01111000,%00110000,%00000000,%00000000 ; char 222
438A: 78300000	
438E: 003078FC	        defb %00000000,%00110000,%01111000,%11111100,%11111100,%01111000,%00110000,%00000000 ; char 223
4392: FC783000	
4396: FCF8F0E0	        defb %11111100,%11111000,%11110000,%11100000,%11100000,%11000000,%10000000,%10000000 ; char 224
439A: E0C08080	
439E: FC7C3C1C	        defb %11111100,%01111100,%00111100,%00011100,%00011100,%00001100,%00000100,%00000100 ; char 225
43A2: 1C0C0404	
43A6: 04040C1C	        defb %00000100,%00000100,%00001100,%00011100,%00011100,%00111100,%01111100,%11111100 ; char 226
43AA: 1C3C7CFC	
43AE: 8080C0E0	        defb %10000000,%10000000,%11000000,%11100000,%11100000,%11110000,%11111000,%11111100 ; char 227
43B2: E0F0F8FC	
43B6: 00040CD8	        defb %00000000,%00000100,%00001100,%11011000,%11110000,%11100000,%11000000,%00000000 ; char 228 (checkmark)
43BA: F0E0C000	
43BE: 00CC7830	        defb %00000000,%11001100,%01111000,%00110000,%01111000,%11001100,%00000000,%00000000 ; char 229 (x)
43C2: 78CC0000	
43C6: 70888888	        defb %01110000,%10001000,%10001000,%10001000,%01110000,%00100000,%01110000,%00100000 ; char 230 (female)
43CA: 70207020	
43CE: 001C0C74	        defb %00000000,%00011100,%00001100,%01110100,%10010000,%10010000,%01100000,%00000000 ; char 231 (male)
43D2: 90906000	
43D6: F8848484	        defb %11111000,%10000100,%10000100,%10000100,%10000100,%10000100,%10000100,%11111100 ; char 232 (new doc)
43DA: 848484FC	
43DE: 00F0FC84	        defb %00000000,%11110000,%11111100,%10000100,%10000100,%10000100,%10000100,%11111100 ; char 233 (folder)
43E2: 848484FC	
43E6: 3078FC48	        defb %00110000,%01111000,%11111100,%01001000,%01001000,%01001000,%01001000,%01111000 ; char 234 (trash bin)
43EA: 48484878	
43EE: FC848484	        defb %11111100,%10000100,%10000100,%10000100,%11111100,%10110100,%10110100,%11111100 ; char 235 (floppy disk)
43F2: FCB4B4FC	
43F6: 0000D4D8	        defb %00000000,%00000000,%11010100,%11011000,%11010100,%11010100,%00000000,%00000000 ; char 236 (OK)
43FA: D4D40000	
43FE: 3078FC78	        defb %00110000,%01111000,%11111100,%01111000,%01111000,%01001000,%01001000,%01001000 ; char 237 (home)
4402: 78484848	
4406: 7884A4A4	        defb %01111000,%10000100,%10100100,%10100100,%10110100,%10000100,%01111000,%00000000 ; char 238 (clock)
440A: B4847800	
440E: 000008F4	        defb %00000000,%00000000,%00001000,%11110100,%10101000,%10000000,%00000000,%00000000 ; char 239 (key)
4412: A8800000	
4416: 203078B0	        defb %00100000,%00110000,%01111000,%10110000,%10100000,%10001000,%01110000,%00000000 ; char 240 (undo)
441A: A0887000	
441E: 00FCCCB4	        defb %00000000,%11111100,%11001100,%10110100,%10000100,%10000100,%11111100,%00000000 ; char 241 (letter)
4422: 8484FC00	
4426: 609090F0	        defb %01100000,%10010000,%10010000,%11110000,%11110000,%11110000,%11110000,%00000000 ; char 242 (lock)
442A: F0F0F000	
442E: 081414F0	        defb %00001000,%00010100,%00010100,%11110000,%11110000,%11110000,%11110000,%00000000 ; char 243 (unlock)
4432: F0F0F000	
4436: FCFC84B4	        defb %11111100,%11111100,%10000100,%10110100,%10010100,%10010100,%10000100,%11111100 ; char 244 (calendar)
443A: 949484FC	
443E: 00043858	        defb %00000000,%00000100,%00111000,%01011000,%01101000,%01110000,%10000000,%00000000 ; char 245 (diameter)
4442: 68708000	
4446: 78848484	        defb %01111000,%10000100,%10000100,%10000100,%01101100,%00011000,%00001000,%00000000 ; char 246 (baloon)
444A: 6C180800	
444E: 30282828	        defb %00110000,%00101000,%00101000,%00101000,%00100000,%01100000,%11100000,%01000000 ; char 247 (note)
4452: 2060E040	
4456: 2068E4E4	        defb %00100000,%01101000,%11100100,%11100100,%11100100,%01101000,%00100000,%00000000 ; char 248 (audio on)
445A: E4682000	
445E: 2060E0E0	        defb %00100000,%01100000,%11100000,%11100000,%11100000,%01100000,%00100000,%00000000 ; char 249 (audio off)
4462: E0602000	
4466: 80C0E0F0	        defb %10000000,%11000000,%11100000,%11110000,%11111000,%11111100,%11110000,%10010000 ; char 250 (pointer)
446A: F8FCF090	
446E: 7884B4A4	        defb %01111000,%10000100,%10110100,%10100100,%10110100,%10000100,%01111000,%00000000 ; char 251 ()
4472: B4847800	
4476: 30484040	        defb %00110000,%01001000,%01000000,%01000000,%11100000,%01000000,%01000100,%10111000 ; char 252 ()
447A: E04044B8	
447E: 7884F048	        defb %01111000,%10000100,%11110000,%01001000,%01001000,%00111100,%10000100,%01111000 ; char 253 ()
4482: 483C8478	
4486: 00002000	        defb %00000000,%00000000,%00100000,%00000000,%11111000,%00000000,%00100000,%00000000 ; char 254 ()
448A: F8002000	
448E: FCFCFCFC	        defb %11111100,%11111100,%11111100,%11111100,%11111100,%11111100,%11111100,%11111100 ; char 255 (cursor)
4492: FCFCFCFC	
              	        ; here ends the ASCII table
              	; ------------------------------------------------------------------------------
              	; LM80C - 8x8 CHARSET - R1.7
              	; ------------------------------------------------------------------------------
              	; The following code is intended to be used with LM80C Z80-based computer
              	; designed by Leonardo Miliani. More info at
              	; www DOT leonardomiliani DOT com
              	; ------------------------------------------------------------------------------
              	; Code Revision:
              	; R1.0 - 20190615 - First revision: ASCII chars (from 0 to 255) - actually, they are 6x8 pixels
              	; R1.1 - 20190616 - Converted to 8x8 pixels
              	; R1.2 - 20191013 - Added new graphic chars and reorganized previous ones
              	; R1.3 - 20191015 - More graphic chars
              	; R1.4 - 20191202 - Fixed char 11/12, added new special chars
              	; R1.5 - 20191210 - Changed several graphic chars
              	; R1.6 - 20200125 - Removed double chars, changed with new ones
              	; R1.7 - 20200228 - adopted more usual hexadecimal & binary prefixes
              	; ------------------------------------------------------------------------------
              	;
              	;-------------------------------------------------------------------------------
              	;
              	;               8 x 8    C  H  A  R  S  E  T
              	;
              	;-------------------------------------------------------------------------------
              	;
              	;       8X8 CHARS, DESIGNED FOR GRAPHICS 1 MODE
              	
4496:         	CHRST88 equ $
4496: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 0 (null char)
449A: 00000000	
449E: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 1 F1
44A2: 00000000	
44A6: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 2 F2
44AA: 00000000	
44AE: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 3 CTRL-C
44B2: 00000000	
44B6: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 4 F3
44BA: 00000000	
44BE: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 5 F4
44C2: 00000000	
44C6: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 6 F5
44CA: 00000000	
44CE: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 7 (bell)
44D2: 00000000	
44D6: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 8 (backspace)
44DA: 00000000	
44DE: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 9 (H. tab)
44E2: 00000000	
44E6: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 10 (line feed)
44EA: 00000000	
44EE: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 11 
44F2: 00000000	
44F6: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 12 Form feed (clear screen)
44FA: 00000000	
44FE: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 13 (carriage return)
4502: 00000000	
4506: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 14 CTRL
450A: 00000000	
450E: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 15 CTRL-O
4512: 00000000	
4516: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 16 C=/Graphic key
451A: 00000000	
451E: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 17 CTRL-Q
4522: 00000000	
4526: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 18 CTRL-R
452A: 00000000	
452E: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 19 CTRL-S
4532: 00000000	
4536: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 20 SHIFT
453A: 00000000	
453E: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 21 CTRL-U
4542: 00000000	
4546: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 22 F6
454A: 00000000	
454E: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 23 F7
4552: 00000000	
4556: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 24 HELP
455A: 00000000	
455E: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 25 (home)
4562: 00000000	
4566: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 26
456A: 00000000	
456E: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 27 (escape)
4572: 00000000	
4576: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 28 (cursor left)
457A: 00000000	
457E: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 29 (cursor right)
4582: 00000000	
4586: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 30 (cursor up)
458A: 00000000	
458E: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 31 (cursor down)
4592: 00000000	
4596: 00000000	        defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 32 - space
459A: 00000000	
459E: 10101010	        defb %00010000,%00010000,%00010000,%00010000,%00010000,%00000000,%00010000,%00000000 ; char 33 - !
45A2: 10001000	
45A6: 28282800	        defb %00101000,%00101000,%00101000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 34 - "
45AA: 00000000	
45AE: 2828FE28	        defb %00101000,%00101000,%11111110,%00101000,%11111110,%00101000,%00101000,%00000000 ; char 35 - #
45B2: FE282800	
45B6: 103C5038	        defb %00010000,%00111100,%01010000,%00111000,%00010100,%01111000,%00010000,%00000000 ; char 36 - $
45BA: 14781000	
45BE: 00626408	        defb %00000000,%01100010,%01100100,%00001000,%00010000,%00100110,%01000110,%00000000 ; char 37 - %
45C2: 10264600	
45C6: 00304830	        defb %00000000,%00110000,%01001000,%00110000,%01001010,%01000100,%00111010,%00000000 ; char 38 - &
45CA: 4A443A00	
45CE: 08102000	        defb %00001000,%00010000,%00100000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 39 - '
45D2: 00000000	
45D6: 08102020	        defb %00001000,%00010000,%00100000,%00100000,%00100000,%00010000,%00001000,%00000000 ; char 40 - (
45DA: 20100800	
45DE: 20100808	        defb %00100000,%00010000,%00001000,%00001000,%00001000,%00010000,%00100000,%00000000 ; char 41 - )
45E2: 08102000	
45E6: 00105438	        defb %00000000,%00010000,%01010100,%00111000,%00111000,%01010100,%00010000,%00000000 ; char 42 - *
45EA: 38541000	
45EE: 0010107C	        defb %00000000,%00010000,%00010000,%01111100,%00010000,%00010000,%00000000,%00000000 ; char 43 - +
45F2: 10100000	
45F6: 00000000	        defb %00000000,%00000000,%00000000,%00000000,%00000000,%00011000,%00001000,%00010000 ; char 44 - ,
45FA: 00180810	
45FE: 0000007C	        defb %00000000,%00000000,%00000000,%01111100,%00000000,%00000000,%00000000,%00000000 ; char 45 - -
4602: 00000000	
4606: 00000000	        defb %00000000,%00000000,%00000000,%00000000,%00000000,%00011000,%00011000,%00000000 ; char 46 - .
460A: 00181800	
460E: 00020408	        defb %00000000,%00000010,%00000100,%00001000,%00010000,%00100000,%01000000,%00000000 ; char 47 - /
4612: 10204000	
4616: 38444C54	        defb %00111000,%01000100,%01001100,%01010100,%01100100,%01000100,%00111000,%00000000 ; char 48 - 0
461A: 64443800	
461E: 10305010	        defb %00010000,%00110000,%01010000,%00010000,%00010000,%00010000,%01111100,%00000000 ; char 49 - 1
4622: 10107C00	
4626: 38440408	        defb %00111000,%01000100,%00000100,%00001000,%00010000,%00100000,%01111100,%00000000 ; char 50 - 2
462A: 10207C00	
462E: 7C081008	        defb %01111100,%00001000,%00010000,%00001000,%00000100,%01000100,%00111000,%00000000 ; char 51 - 3
4632: 04443800	
4636: 08182848	        defb %00001000,%00011000,%00101000,%01001000,%01111100,%00001000,%00001000,%00000000 ; char 52 - 4
463A: 7C080800	
463E: 7C407804	        defb %01111100,%01000000,%01111000,%00000100,%00000100,%01000100,%00111000,%00000000 ; char 53 - 5
4642: 04443800	
4646: 38444078	        defb %00111000,%01000100,%01000000,%01111000,%01000100,%01000100,%00111000,%00000000 ; char 54 - 6
464A: 44443800	
464E: 7C040810	        defb %01111100,%00000100,%00001000,%00010000,%00100000,%00100000,%00100000,%00000000 ; char 55 - 7
4652: 20202000	
4656: 38444438	        defb %00111000,%01000100,%01000100,%00111000,%01000100,%01000100,%00111000,%00000000 ; char 56 - 8
465A: 44443800	
465E: 3844443C	        defb %00111000,%01000100,%01000100,%00111100,%00000100,%01000100,%00111000,%00000000 ; char 57 - 9
4662: 04443800	
4666: 00181800	        defb %00000000,%00011000,%00011000,%00000000,%00011000,%00011000,%00000000,%00000000 ; char 58 - :
466A: 18180000	
466E: 00181800	        defb %00000000,%00011000,%00011000,%00000000,%00011000,%00001000,%00010000,%00000000 ; char 59 - ;
4672: 18081000	
4676: 04081020	        defb %00000100,%00001000,%00010000,%00100000,%00010000,%00001000,%00000100,%00000000 ; char 60 - <
467A: 10080400	
467E: 00007E00	        defb %00000000,%00000000,%01111110,%00000000,%01111110,%00000000,%00000000,%00000000 ; char 61 - =
4682: 7E000000	
4686: 20100804	        defb %00100000,%00010000,%00001000,%00000100,%00001000,%00010000,%00100000,%00000000 ; char 62 - >
468A: 08102000	
468E: 38440408	        defb %00111000,%01000100,%00000100,%00001000,%00010000,%00000000,%00010000,%00000000 ; char 63 - ?
4692: 10001000	
4696: 7884BCAC	        defb %01111000,%10000100,%10111100,%10101100,%10111000,%10000000,%10000100,%01111000 ; char 64 - @
469A: B8808478	
469E: 38444444	        defb %00111000,%01000100,%01000100,%01000100,%01111100,%01000100,%01000100,%00000000 ; char 65 - A
46A2: 7C444400	
46A6: 78444478	        defb %01111000,%01000100,%01000100,%01111000,%01000100,%01000100,%01111000,%00000000 ; char 66 - B
46AA: 44447800	
46AE: 38444040	        defb %00111000,%01000100,%01000000,%01000000,%01000000,%01000100,%00111000,%00000000 ; char 67 - C
46B2: 40443800	
46B6: 78444444	        defb %01111000,%01000100,%01000100,%01000100,%01000100,%01000100,%01111000,%00000000 ; char 68 - D
46BA: 44447800	
46BE: 7C404070	        defb %01111100,%01000000,%01000000,%01110000,%01000000,%01000000,%01111100,%00000000 ; char 69 - E
46C2: 40407C00	
46C6: 7C404070	        defb %01111100,%01000000,%01000000,%01110000,%01000000,%01000000,%01000000,%00000000 ; char 70 - F
46CA: 40404000	
46CE: 38444040	        defb %00111000,%01000100,%01000000,%01000000,%01011100,%01000100,%00111000,%00000000 ; char 71 - G
46D2: 5C443800	
46D6: 4444447C	        defb %01000100,%01000100,%01000100,%01111100,%01000100,%01000100,%01000100,%00000000 ; char 72 - H
46DA: 44444400	
46DE: 38101010	        defb %00111000,%00010000,%00010000,%00010000,%00010000,%00010000,%00111000,%00000000 ; char 73 - I
46E2: 10103800	
46E6: 3C040404	        defb %00111100,%00000100,%00000100,%00000100,%00000100,%01000100,%00111000,%00000000 ; char 74 - J
46EA: 04443800	
46EE: 44444870	        defb %01000100,%01000100,%01001000,%01110000,%01001000,%01000100,%01000100,%00000000 ; char 75 - K
46F2: 48444400	
46F6: 40404040	        defb %01000000,%01000000,%01000000,%01000000,%01000000,%01000000,%01111100,%00000000 ; char 76 - L
46FA: 40407C00	
46FE: 42665A42	        defb %01000010,%01100110,%01011010,%01000010,%01000010,%01000010,%01000010,%00000000 ; char 77 - M
4702: 42424200	
4706: 4464544C	        defb %01000100,%01100100,%01010100,%01001100,%01000100,%01000100,%01000100,%00000000 ; char 78 - N
470A: 44444400	
470E: 38444444	        defb %00111000,%01000100,%01000100,%01000100,%01000100,%01000100,%00111000,%00000000 ; char 79 - O
4712: 44443800	
4716: 78444444	        defb %01111000,%01000100,%01000100,%01000100,%01111000,%01000000,%01000000,%00000000 ; char 80 - P
471A: 78404000	
471E: 38444444	        defb %00111000,%01000100,%01000100,%01000100,%01010100,%01001000,%00110100,%00000000 ; char 81 - Q
4722: 54483400	
4726: 78444444	        defb %01111000,%01000100,%01000100,%01000100,%01111000,%01001000,%01000100,%00000000 ; char 82 - R
472A: 78484400	
472E: 3C404038	        defb %00111100,%01000000,%01000000,%00111000,%00000100,%00000100,%01111000,%00000000 ; char 83 - S
4732: 04047800	
4736: 7C101010	        defb %01111100,%00010000,%00010000,%00010000,%00010000,%00010000,%00010000,%00000000 ; char 84 - T
473A: 10101000	
473E: 44444444	        defb %01000100,%01000100,%01000100,%01000100,%01000100,%01000100,%00111000,%00000000 ; char 85 - U
4742: 44443800	
4746: 44444444	        defb %01000100,%01000100,%01000100,%01000100,%01000100,%00101000,%00010000,%00000000 ; char 86 - V
474A: 44281000	
474E: 42424242	        defb %01000010,%01000010,%01000010,%01000010,%01011010,%01011010,%00100100,%00000000 ; char 87 - W
4752: 5A5A2400	
4756: 44442810	        defb %01000100,%01000100,%00101000,%00010000,%00101000,%01000100,%01000100,%00000000 ; char 88 - X
475A: 28444400	
475E: 44444428	        defb %01000100,%01000100,%01000100,%00101000,%00010000,%00010000,%00010000,%00000000 ; char 89 - Y
4762: 10101000	
4766: 7C040810	        defb %01111100,%00000100,%00001000,%00010000,%00100000,%01000000,%01111100,%00000000 ; char 90 - Z
476A: 20407C00	
476E: 38202020	        defb %00111000,%00100000,%00100000,%00100000,%00100000,%00100000,%00111000,%00000000 ; char 91 - [
4772: 20203800	
4776: 00402010	        defb %00000000,%01000000,%00100000,%00010000,%00001000,%00000100,%00000010,%00000000 ; char 92 - \
477A: 08040200	
477E: 38080808	        defb %00111000,%00001000,%00001000,%00001000,%00001000,%00001000,%00111000,%00000000 ; char 93 - ]
4782: 08083800	
4786: 10284400	        defb %00010000,%00101000,%01000100,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 94 - ^
478A: 00000000	
478E: 00000000	        defb %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%01111110,%00000000 ; char 95 _ (underscore)
4792: 00007E00	
4796: 20100800	        defb %00100000,%00010000,%00001000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 96 - `
479A: 00000000	
479E: 00003804	        defb %00000000,%00000000,%00111000,%00000100,%00111100,%01000100,%00111100,%00000000 ; char 97 - a
47A2: 3C443C00	
47A6: 40404078	        defb %01000000,%01000000,%01000000,%01111000,%01000100,%01000100,%01111000,%00000000 ; char 98 - b
47AA: 44447800	
47AE: 00003840	        defb %00000000,%00000000,%00111000,%01000000,%01000000,%01000100,%00111000,%00000000 ; char 99 - c
47B2: 40443800	
47B6: 0404043C	        defb %00000100,%00000100,%00000100,%00111100,%01000100,%01000100,%00111100,%00000000 ; char 100 - d
47BA: 44443C00	
47BE: 00003844	        defb %00000000,%00000000,%00111000,%01000100,%01111100,%01000000,%00111000,%00000000 ; char 101 - e
47C2: 7C403800	
47C6: 18242070	        defb %00011000,%00100100,%00100000,%01110000,%00100000,%00100000,%00100000,%00000000 ; char 102 - f
47CA: 20202000	
47CE: 00003C44	        defb %00000000,%00000000,%00111100,%01000100,%01000100,%00111100,%00000100,%00111000 ; char 103 - g
47D2: 443C0438	
47D6: 40405864	        defb %01000000,%01000000,%01011000,%01100100,%01000100,%01000100,%01000100,%00000000 ; char 104 - h
47DA: 44444400	
47DE: 00100010	        defb %00000000,%00010000,%00000000,%00010000,%00010000,%00010000,%00010000,%00000000 ; char 105 - i
47E2: 10101000	
47E6: 08001808	        defb %00001000,%00000000,%00011000,%00001000,%00001000,%00001000,%01001000,%00110000 ; char 106 - j
47EA: 08084830	
47EE: 40404850	        defb %01000000,%01000000,%01001000,%01010000,%01100000,%01010000,%01001000,%00000000 ; char 107 - k
47F2: 60504800	
47F6: 30101010	        defb %00110000,%00010000,%00010000,%00010000,%00010000,%00010000,%00111000,%00000000 ; char 108 - l
47FA: 10103800	
47FE: 0000546A	        defb %00000000,%00000000,%01010100,%01101010,%01001010,%01000010,%01000010,%00000000 ; char 109 - m
4802: 4A424200	
4806: 00005864	        defb %00000000,%00000000,%01011000,%01100100,%01000100,%01000100,%01000100,%00000000 ; char 110 - n
480A: 44444400	
480E: 00003844	        defb %00000000,%00000000,%00111000,%01000100,%01000100,%01000100,%00111000,%00000000 ; char 111: o
4812: 44443800	
4816: 00007844	        defb %00000000,%00000000,%01111000,%01000100,%01000100,%01111000,%01000000,%01000000 ; char 112: p
481A: 44784040	
481E: 00003C44	        defb %00000000,%00000000,%00111100,%01000100,%01000100,%00111100,%00000100,%00000100 ; char 113: q
4822: 443C0404	
4826: 00005864	        defb %00000000,%00000000,%01011000,%01100100,%01000000,%01000000,%01000000,%00000000 ; char 114: r
482A: 40404000	
482E: 00003840	        defb %00000000,%00000000,%00111000,%01000000,%00111000,%00000100,%01111000,%00000000 ; char 115: s
4832: 38047800	
4836: 20207020	        defb %00100000,%00100000,%01110000,%00100000,%00100000,%00100100,%00011000,%00000000 ; char 116: t
483A: 20241800	
483E: 00004444	        defb %00000000,%00000000,%01000100,%01000100,%01000100,%01001100,%00110100,%00000000 ; char 117: u
4842: 444C3400	
4846: 00004444	        defb %00000000,%00000000,%01000100,%01000100,%01000100,%00101000,%00010000,%00000000 ; char 118: v
484A: 44281000	
484E: 00004444	        defb %00000000,%00000000,%01000100,%01000100,%01010100,%01010100,%00101000,%00000000 ; char 119: w
4852: 54542800	
4856: 00004428	        defb %00000000,%00000000,%01000100,%00101000,%00010000,%00101000,%01000100,%00000000 ; char 120: x
485A: 10284400	
485E: 00004444	        defb %00000000,%00000000,%01000100,%01000100,%01001100,%00110100,%00000100,%00111000 ; char 121: y
4862: 4C340438	
4866: 00007C08	        defb %00000000,%00000000,%01111100,%00001000,%00010000,%00100000,%01111100,%00000000 ; char 122: z
486A: 10207C00	
486E: 18202040	        defb %00011000,%00100000,%00100000,%01000000,%00100000,%00100000,%00011000,%00000000 ; char 123: {
4872: 20201800	
4876: 10101010	        defb %00010000,%00010000,%00010000,%00010000,%00010000,%00010000,%00010000,%00000000 ; char 124: |
487A: 10101000	
487E: 30080804	        defb %00110000,%00001000,%00001000,%00000100,%00001000,%00001000,%00110000,%00000000 ; char 125: }
4882: 08083000	
4886: 20540800	        defb %00100000,%01010100,%00001000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 126: ~
488A: 00000000	
488E: 00000000	        defb %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 127 (delete) - end the standard ASCII (0-127)
4892: 00000000	
4896: 3C42A581	        defb %00111100,%01000010,%10100101,%10000001,%10100101,%10011001,%01000010,%00111100 ; char 128 (open face)
489A: A599423C	
489E: 3C7EDBFF	        defb %00111100,%01111110,%11011011,%11111111,%11011011,%11100111,%01111110,%00111100 ; char 129 (full face)
48A2: DBE77E3C	
48A6: 6CFEFEFE	        defb %01101100,%11111110,%11111110,%11111110,%01111100,%00111000,%00010000,%00000000 ; char 130 (hearts)
48AA: 7C381000	
48AE: 10387CFE	        defb %00010000,%00111000,%01111100,%11111110,%01111100,%00111000,%00010000,%00000000 ; char 131 (diamonds)
48B2: 7C381000	
48B6: 103854FE	        defb %00010000,%00111000,%01010100,%11111110,%01010100,%00010000,%01111100,%00000000 ; char 132 (clus)
48BA: 54107C00	
48BE: 10387CFE	        defb %00010000,%00111000,%01111100,%11111110,%11010110,%00010000,%01111100,%00000000 ; char 133 (spades)
48C2: D6107C00	
48C6: 181818FF	        defb %00011000,%00011000,%00011000,%11111111,%11111111,%00011000,%00011000,%00011000 ; char 134
48CA: FF181818	
48CE: 0000001F	        defb %00000000,%00000000,%00000000,%00011111,%00011111,%00011000,%00011000,%00011000 ; char 135
48D2: 1F181818	
48D6: 000000F8	        defb %00000000,%00000000,%00000000,%11111000,%11111000,%00011000,%00011000,%00011000 ; char 136
48DA: F8181818	
48DE: 181818F8	        defb %00011000,%00011000,%00011000,%11111000,%11111000,%00000000,%00000000,%00000000 ; char 137
48E2: F8000000	
48E6: 1818181F	        defb %00011000,%00011000,%00011000,%00011111,%00011111,%00000000,%00000000,%00000000 ; char 138
48EA: 1F000000	
48EE: 181818FF	        defb %00011000,%00011000,%00011000,%11111111,%11111111,%00000000,%00000000,%00000000 ; char 139
48F2: FF000000	
48F6: 1818181F	        defb %00011000,%00011000,%00011000,%00011111,%00011111,%00011000,%00011000,%00011000 ; char 140
48FA: 1F181818	
48FE: 000000FF	        defb %00000000,%00000000,%00000000,%11111111,%11111111,%00011000,%00011000,%00011000 ; char 141
4902: FF181818	
4906: 181818F8	        defb %00011000,%00011000,%00011000,%11111000,%11111000,%00011000,%00011000,%00011000 ; char 142
490A: F8181818	
490E: 000000FF	        defb %00000000,%00000000,%00000000,%11111111,%11111111,%00000000,%00000000,%00000000 ; char 143
4912: FF000000	
4916: 18181818	        defb %00011000,%00011000,%00011000,%00011000,%00011000,%00011000,%00011000,%00011000 ; char 144
491A: 18181818	
491E: 03070E1C	        defb %00000011,%00000111,%00001110,%00011100,%00111000,%01110000,%11100000,%11000000 ; char 145
4922: 3870E0C0	
4926: C0E07038	        defb %11000000,%11100000,%01110000,%00111000,%00011100,%00001110,%00000111,%00000011 ; char 146
492A: 1C0E0703	
492E: C3E77E3C	        defb %11000011,%11100111,%01111110,%00111100,%00111100,%01111110,%11100111,%11000011 ; char 147
4932: 3C7EE7C3	
4936: 101010FF	        defb %00010000,%00010000,%00010000,%11111111,%00010000,%00010000,%00010000,%00010000 ; char 148
493A: 10101010	
493E: 0000001F	        defb %00000000,%00000000,%00000000,%00011111,%00010000,%00010000,%00010000,%00010000 ; char 149
4942: 10101010	
4946: 000000F0	        defb %00000000,%00000000,%00000000,%11110000,%00010000,%00010000,%00010000,%00010000 ; char 150
494A: 10101010	
494E: 101010F0	        defb %00010000,%00010000,%00010000,%11110000,%00000000,%00000000,%00000000,%00000000 ; char 151
4952: 00000000	
4956: 1010101F	        defb %00010000,%00010000,%00010000,%00011111,%00000000,%00000000,%00000000,%00000000 ; char 152
495A: 00000000	
495E: 101010FF	        defb %00010000,%00010000,%00010000,%11111111,%00000000,%00000000,%00000000,%00000000 ; char 153
4962: 00000000	
4966: 1010101F	        defb %00010000,%00010000,%00010000,%00011111,%00010000,%00010000,%00010000,%00010000 ; char 154
496A: 10101010	
496E: 000000FF	        defb %00000000,%00000000,%00000000,%11111111,%00010000,%00010000,%00010000,%00010000 ; char 155
4972: 10101010	
4976: 101010F0	        defb %00010000,%00010000,%00010000,%11110000,%00010000,%00010000,%00010000,%00010000 ; char 156
497A: 10101010	
497E: 000000FF	        defb %00000000,%00000000,%00000000,%11111111,%00000000,%00000000,%00000000,%00000000 ; char 157
4982: 00000000	
4986: 10101010	        defb %00010000,%00010000,%00010000,%00010000,%00010000,%00010000,%00010000,%00010000 ; char 158
498A: 10101010	
498E: 01020408	        defb %00000001,%00000010,%00000100,%00001000,%00010000,%00100000,%01000000,%10000000 ; char 159
4992: 10204080	
4996: 80402010	        defb %10000000,%01000000,%00100000,%00010000,%00001000,%00000100,%00000010,%00000001 ; char 160
499A: 08040201	
499E: 81422418	        defb %10000001,%01000010,%00100100,%00011000,%00011000,%00100100,%01000010,%10000001 ; char 161
49A2: 18244281	
49A6: 00000000	        defb %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%11111111,%11111111 ; char 162
49AA: 0000FFFF	
49AE: 00000000	        defb %00000000,%00000000,%00000000,%00000000,%11111111,%11111111,%11111111,%11111111 ; char 163
49B2: FFFFFFFF	
49B6: 0000FFFF	        defb %00000000,%00000000,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111 ; char 164
49BA: FFFFFFFF	
49BE: FFFF0000	        defb %11111111,%11111111,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 165
49C2: 00000000	
49C6: FFFFFFFF	        defb %11111111,%11111111,%11111111,%11111111,%00000000,%00000000,%00000000,%00000000 ; char 166
49CA: 00000000	
49CE: FFFFFFFF	        defb %11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%00000000,%00000000 ; char 167
49D2: FFFF0000	
49D6: C0C0C0C0	        defb %11000000,%11000000,%11000000,%11000000,%11000000,%11000000,%11000000,%11000000 ; char 168
49DA: C0C0C0C0	
49DE: F0F0F0F0	        defb %11110000,%11110000,%11110000,%11110000,%11110000,%11110000,%11110000,%11110000 ; char 169
49E2: F0F0F0F0	
49E6: FCFCFCFC	        defb %11111100,%11111100,%11111100,%11111100,%11111100,%11111100,%11111100,%11111100 ; char 170
49EA: FCFCFCFC	
49EE: 03030303	        defb %00000011,%00000011,%00000011,%00000011,%00000011,%00000011,%00000011,%00000011 ; char 171
49F2: 03030303	
49F6: 0F0F0F0F	        defb %00001111,%00001111,%00001111,%00001111,%00001111,%00001111,%00001111,%00001111 ; char 172
49FA: 0F0F0F0F	
49FE: 3F3F3F3F	        defb %00111111,%00111111,%00111111,%00111111,%00111111,%00111111,%00111111,%00111111 ; char 173
4A02: 3F3F3F3F	
4A06: FF818181	        defb %11111111,%10000001,%10000001,%10000001,%10000001,%10000001,%10000001,%11111111 ; char 174
4A0A: 818181FF	
4A0E: 00000000	        defb %00000000,%00000000,%00000000,%00000000,%11110000,%11110000,%11110000,%11110000 ; char 175
4A12: F0F0F0F0	
4A16: 00000000	        defb %00000000,%00000000,%00000000,%00000000,%00001111,%00001111,%00001111,%00001111 ; char 176
4A1A: 0F0F0F0F	
4A1E: 0F0F0F0F	        defb %00001111,%00001111,%00001111,%00001111,%00000000,%00000000,%00000000,%00000000 ; char 177
4A22: 00000000	
4A26: F0F0F0F0	        defb %11110000,%11110000,%11110000,%11110000,%00000000,%00000000,%00000000,%00000000 ; char 178
4A2A: 00000000	
4A2E: F0F0F0F0	        defb %11110000,%11110000,%11110000,%11110000,%00001111,%00001111,%00001111,%00001111 ; char 179
4A32: 0F0F0F0F	
4A36: 0F0F0F0F	        defb %00001111,%00001111,%00001111,%00001111,%11110000,%11110000,%11110000,%11110000 ; char 180
4A3A: F0F0F0F0	
4A3E: 3C3C3C3C	        defb %00111100,%00111100,%00111100,%00111100,%00111100,%00111100,%00111100,%00111100 ; char 181
4A42: 3C3C3C3C	
4A46: C3C3C3C3	        defb %11000011,%11000011,%11000011,%11000011,%11000011,%11000011,%11000011,%11000011 ; char 182
4A4A: C3C3C3C3	
4A4E: FFFF0000	        defb %11111111,%11111111,%00000000,%00000000,%00000000,%00000000,%11111111,%11111111 ; char 183
4A52: 0000FFFF	
4A56: 0000FFFF	        defb %00000000,%00000000,%11111111,%11111111,%11111111,%11111111,%00000000,%00000000 ; char 184
4A5A: FFFF0000	
4A5E: 3333CCCC	        defb %00110011,%00110011,%11001100,%11001100,%00110011,%00110011,%11001100,%11001100 ; char 185
4A62: 3333CCCC	
4A66: 55AA55AA	        defb %01010101,%10101010,%01010101,%10101010,%01010101,%10101010,%01010101,%10101010 ; char 186
4A6A: 55AA55AA	
4A6E: 663399CC	        defb %01100110,%00110011,%10011001,%11001100,%01100110,%00110011,%10011001,%11001100 ; char 187
4A72: 663399CC	
4A76: CC993366	        defb %11001100,%10011001,%00110011,%01100110,%11001100,%10011001,%00110011,%01100110 ; char 188
4A7A: CC993366	
4A7E: 3399CC66	        defb %00110011,%10011001,%11001100,%01100110,%00110011,%10011001,%11001100,%01100110 ; char 189
4A82: 3399CC66	
4A86: 66CC9933	        defb %01100110,%11001100,%10011001,%00110011,%01100110,%11001100,%10011001,%00110011 ; char 190
4A8A: 66CC9933	
4A8E: 10107C10	        defb %00010000,%00010000,%01111100,%00010000,%00010000,%00000000,%01111100,%00000000 ; char 191 ()
4A92: 10007C00	
4A96: 60180618	        defb %01100000,%00011000,%00000110,%00011000,%01100000,%00000000,%01111110,%00000000 ; char 192 ()
4A9A: 60007E00	
4A9E: 06186018	        defb %00000110,%00011000,%01100000,%00011000,%00000110,%00000000,%01111110,%00000000 ; char 193 ()
4AA2: 06007E00	
4AA6: 3E202020	        defb %00111110,%00100000,%00100000,%00100000,%10100000,%01100000,%00100000,%00000000 ; char 194 (square root)
4AAA: A0602000	
4AAE: 30484830	        defb %00110000,%01001000,%01001000,%00110000,%00000000,%00000000,%00000000,%00000000 ; char 195 ()
4AB2: 00000000	
4AB6: 60103040	        defb %01100000,%00010000,%00110000,%01000000,%01110000,%00000000,%00000000,%00000000 ; char 196 ()
4ABA: 70000000	
4ABE: 00002A54	        defb %00000000,%00000000,%00101010,%01010100,%00000000,%01111110,%00000000,%00000000 ; char 197 
4AC2: 007E0000	
4AC6: 0054A800	        defb %00000000,%01010100,%10101000,%00000000,%01010100,%10101000,%00000000,%00000000 ; char 198 ()
4ACA: 54A80000	
4ACE: 80C0E0F0	        defb %10000000,%11000000,%11100000,%11110000,%11100000,%11000000,%10000000,%00000000 ; char 199
4AD2: E0C08000	
4AD6: FE7C3810	        defb %11111110,%01111100,%00111000,%00010000,%00000000,%00000000,%00000000,%00000000 ; char 200
4ADA: 00000000	
4ADE: 0103070F	        defb %00000001,%00000011,%00000111,%00001111,%00000111,%00000011,%00000001,%00000000 ; char 201
4AE2: 07030100	
4AE6: 00000000	        defb %00000000,%00000000,%00000000,%00000000,%00010000,%00111000,%01111100,%11111110 ; char 202
4AEA: 10387CFE	
4AEE: 10387C10	        defb %00010000,%00111000,%01111100,%00010000,%00010000,%00010000,%00010000,%00000000 ; char 203 (up arrow)
4AF2: 10101000	
4AF6: 1E0E0E12	        defb %00011110,%00001110,%00001110,%00010010,%00100000,%01000000,%00000000,%00000000 ; char 204 (up right arrow)
4AFA: 20400000	
4AFE: 00080CFE	        defb %00000000,%00001000,%00001100,%11111110,%00001100,%00001000,%00000000,%00000000 ; char 205 (right arrow)
4B02: 0C080000	
4B06: 00402012	        defb %00000000,%01000000,%00100000,%00010010,%00001110,%00001110,%00011110,%00000000 ; char 206 (down right arrow)
4B0A: 0E0E1E00	
4B0E: 10101010	        defb %00010000,%00010000,%00010000,%00010000,%01111100,%00111000,%00010000,%00000000 ; char 207 (down arrow)
4B12: 7C381000	
4B16: 00040890	        defb %00000000,%00000100,%00001000,%10010000,%11100000,%11100000,%11110000,%00000000 ; char 208 (down left arrow)
4B1A: E0E0F000	
4B1E: 002060FE	        defb %00000000,%00100000,%01100000,%11111110,%01100000,%00100000,%00000000,%00000000 ; char 209 (left arrow)
4B22: 60200000	
4B26: F0E0E090	        defb %11110000,%11100000,%11100000,%10010000,%00001000,%00000100,%00000000,%00000000 ; char 210 (up left arrow)
4B2A: 08040000	
4B2E: 3844F040	        defb %00111000,%01000100,%11110000,%01000000,%11110000,%01000100,%00111000,%00000000 ; char 211 (euro)
4B32: F0443800	
4B36: 00027CA8	        defb %00000000,%00000010,%01111100,%10101000,%00101000,%00101000,%00101000,%00000000 ; char 212 (greek pi)
4B3A: 28282800	
4B3E: 00000007	        defb %00000000,%00000000,%00000000,%00000111,%00001000,%00010000,%00010000,%00010000 ; char 213
4B42: 08101010	
4B46: 000000C0	        defb %00000000,%00000000,%00000000,%11000000,%00100000,%00010000,%00010000,%00010000 ; char 214
4B4A: 20101010	
4B4E: 101020C0	        defb %00010000,%00010000,%00100000,%11000000,%00000000,%00000000,%00000000,%00000000 ; char 215
4B52: 00000000	
4B56: 10100807	        defb %00010000,%00010000,%00001000,%00000111,%00000000,%00000000,%00000000,%00000000 ; char 216
4B5A: 00000000	
4B5E: 00000007	        defb %00000000,%00000000,%00000000,%00000111,%00001111,%00011100,%00011000,%00011000 ; char 217
4B62: 0F1C1818	
4B66: 000000E0	        defb %00000000,%00000000,%00000000,%11100000,%11110000,%00111000,%00011000,%00011000 ; char 218
4B6A: F0381818	
4B6E: 181838F0	        defb %00011000,%00011000,%00111000,%11110000,%11100000,%00000000,%00000000,%00000000 ; char 219
4B72: E0000000	
4B76: 18181C0F	        defb %00011000,%00011000,%00011100,%00001111,%00000111,%00000000,%00000000,%00000000 ; char 220
4B7A: 07000000	
4B7E: 003C4242	        defb %00000000,%00111100,%01000010,%01000010,%01000010,%01000010,%00111100,%00000000 ; char 221
4B82: 42423C00	
4B86: 003C7E7E	        defb %00000000,%00111100,%01111110,%01111110,%01111110,%01111110,%00111100,%00000000 ; char 222
4B8A: 7E7E3C00	
4B8E: 00183C7E	        defb %00000000,%00011000,%00111100,%01111110,%01111110,%00111100,%00011000,%00000000 ; char 223
4B92: 7E3C1800	
4B96: FFFEFCF8	        defb %11111111,%11111110,%11111100,%11111000,%11110000,%11100000,%11000000,%10000000 ; char 224
4B9A: F0E0C080	
4B9E: FF7F3F1F	        defb %11111111,%01111111,%00111111,%00011111,%00001111,%00000111,%00000011,%00000001 ; char 225
4BA2: 0F070301	
4BA6: 0103070F	        defb %00000001,%00000011,%00000111,%00001111,%00011111,%00111111,%01111111,%11111111 ; char 226
4BAA: 1F3F7FFF	
4BAE: 80C0E0F0	        defb %10000000,%11000000,%11100000,%11110000,%11111000,%11111100,%11111110,%11111111 ; char 227
4BB2: F8FCFEFF	
4BB6: 0002066C	        defb %00000000,%00000010,%00000110,%01101100,%01111000,%01110000,%01100000,%00000000 ; char 228 (checkmark)
4BBA: 78706000	
4BBE: 00663C18	        defb %00000000,%01100110,%00111100,%00011000,%00111100,%01100110,%00000000,%00000000 ; char 229 (x)
4BC2: 3C660000	
4BC6: 38444444	        defb %00111000,%01000100,%01000100,%01000100,%00111000,%00010000,%00111000,%00010000 ; char 230 (female)
4BCA: 38103810	
4BCE: 07033D44	        defb %00000111,%00000011,%00111101,%01000100,%01000100,%01000100,%00111000,%00000000 ; char 231 (male)
4BD2: 44443800	
4BD6: 78444242	        defb %01111000,%01000100,%01000010,%01000010,%01000010,%01000010,%01000010,%01111110 ; char 232 (new doc)
4BDA: 4242427E	
4BDE: 00F8FF81	        defb %00000000,%11111000,%11111111,%10000001,%10000001,%10000001,%10000001,%11111111 ; char 233 (folder)
4BE2: 818181FF	
4BE6: 107CFE54	        defb %00010000,%01111100,%11111110,%01010100,%01010100,%01010100,%01010100,%01111100 ; char 234 (trash bin)
4BEA: 5454547C	
4BEE: FF818181	        defb %11111111,%10000001,%10000001,%10000001,%10111101,%10101101,%10101101,%11111111 ; char 235 (floppy disk)
4BF2: BDADADFF	
4BF6: 00EAAAAC	        defb %00000000,%11101010,%10101010,%10101100,%10101100,%10101010,%11101010,%00000000 ; char 236 (OK)
4BFA: ACAAEA00	
4BFE: 187EFF7E	        defb %00011000,%01111110,%11111111,%01111110,%01111110,%01100110,%01100110,%01100110 ; char 237 (home)
4C02: 7E666666	
4C06: 3C429191	        defb %00111100,%01000010,%10010001,%10010001,%10011101,%10000001,%01000010,%00111100 ; char 238 (clock)
4C0A: 9D81423C	
4C0E: 000205FD	        defb %00000000,%00000010,%00000101,%11111101,%10100101,%10100010,%00000000,%00000000 ; char 239 (key)
4C12: A5A20000	
4C16: 080C3E4C	        defb %00001000,%00001100,%00111110,%01001100,%01001000,%01000010,%01000010,%00111100 ; char 240 (undo)
4C1A: 4842423C	
4C1E: 00FFC3A5	        defb %00000000,%11111111,%11000011,%10100101,%10011001,%10000001,%11111111,%00000000 ; char 241 (letter)
4C22: 9981FF00	
4C26: 3844447C	        defb %00111000,%01000100,%01000100,%01111100,%01111100,%01111100,%01111100,%00000000 ; char 242 (lock)
4C2A: 7C7C7C00	
4C2E: 060909F8	        defb %00000110,%00001001,%00001001,%11111000,%11111000,%11111000,%11111000,%00000000 ; char 243 (unlock)
4C32: F8F8F800	
4C36: FFFF81AD	        defb %11111111,%11111111,%10000001,%10101101,%10100101,%10100101,%10000001,%11111111 ; char 244 (calendar)
4C3A: A5A581FF	
4C3E: 011A244A	        defb %00000001,%00011010,%00100100,%01001010,%01010010,%00100100,%01011000,%10000000 ; char 245 (diameter)
4C42: 52245880	
4C46: 7E818181	        defb %01111110,%10000001,%10000001,%10000001,%10000001,%01110110,%00001100,%00000100 ; char 246 (baloon)
4C4A: 81760C04	
4C4E: 0C0A0A0A	        defb %00001100,%00001010,%00001010,%00001010,%00001000,%00011000,%00111000,%00010000 ; char 247 (note)
4C52: 08183810	
4C56: 1231F5F5	        defb %00010010,%00110001,%11110101,%11110101,%11110101,%11110101,%00110001,%00010010 ; char 248 (audio on)
4C5A: F5F53112	
4C5E: 1030F0F0	        defb %00010000,%00110000,%11110000,%11110000,%11110000,%11110000,%00110000,%00010000 ; char 249 (audio off)
4C62: F0F03010	
4C66: 40607078	        defb %01000000,%01100000,%01110000,%01111000,%01111100,%01111110,%01111000,%01001000 ; char 250 (pointer)
4C6A: 7C7E7848	
4C6E: 3C4299A1	        defb %00111100,%01000010,%10011001,%10100001,%10100001,%10011001,%01000010,%00111100 ; char 251 ()
4C72: A199423C	
4C76: 30484040	        defb %00110000,%01001000,%01000000,%01000000,%11110000,%01000000,%01000010,%10111100 ; char 252 ()
4C7A: F04042BC	
4C7E: 3C427824	        defb %00111100,%01000010,%01111000,%00100100,%00100100,%00011110,%01000010,%00111100 ; char 253 ()
4C82: 241E423C	
4C86: 00001000	        defb %00000000,%00000000,%00010000,%00000000,%01111100,%00000000,%00010000,%00000000 ; char 254 ()
4C8A: 7C001000	
4C8E: FFFFFFFF	        defb %11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111 ; char 255 (cursor)
4C92: FFFFFFFF	
              	
              	; ------------------------------------------------------------------------------
              	; LM80C - LOGO CHARSET - R1.1
              	; ------------------------------------------------------------------------------
              	; The following code is intended to be used with LM80C Z80-based computer
              	; designed by Leonardo Miliani. More info at
              	; www DOT leonardomiliani DOT com
              	; ------------------------------------------------------------------------------
              	; Code Revision:
              	; R1.0 - 20200124 - First revision: logo chars
              	; R1.1 - 20200229 - Adopted usual hexadecimal & binary prefixes
              	; ------------------------------------------------------------------------------
              	
4C96:         	LOGOFONT:   equ $
4C96: 00000000	            defb %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000 ; 0
4C9A: 00000000	
4C9E: FFFFFFFF	            defb %11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111 ; 1
4CA2: FFFFFFFF	
4CA6: FFFFFFFF	            defb %11111111,%11111111,%11111111,%11111111,%00000000,%00000000,%00000000,%00000000 ; 2
4CAA: 00000000	
4CAE: 0F0F0F0F	            defb %00001111,%00001111,%00001111,%00001111,%00001111,%00001111,%00001111,%00001111 ; 3
4CB2: 0F0F0F0F	
4CB6: 00000000	            defb %00000000,%00000000,%00000000,%00000000,%11111111,%11111111,%11111111,%11111111 ; 4
4CBA: FFFFFFFF	
4CBE: F0F0F0F0	            defb %11110000,%11110000,%11110000,%11110000,%11110000,%11110000,%11110000,%11110000 ; 5
4CC2: F0F0F0F0	
4CC6: 00000000	            defb %00000000,%00000000,%00000000,%00000000,%00001111,%00001111,%00001111,%00001111 ; 6
4CCA: 0F0F0F0F	
4CCE: 00000000	            defb %00000000,%00000000,%00000000,%00000000,%11110000,%11110000,%11110000,%11110000 ; 7
4CD2: F0F0F0F0	
4CD6: F0F0F0F0	            defb %11110000,%11110000,%11110000,%11110000,%00000000,%00000000,%00000000,%00000000 ; 8
4CDA: 00000000	
4CDE: 0F0F0F0F	            defb %00001111,%00001111,%00001111,%00001111,%00000000,%00000000,%00000000,%00000000 ; 9
4CE2: 00000000	
4CE6: 000000FC	            defb %00000000,%00000000,%00000000,%11111100,%11111111,%00000111,%00000011,%00000000 ; 10
4CEA: FF070300	
4CEE: 0000003F	            defb %00000000,%00000000,%00000000,%00111111,%11111111,%11100000,%11000000,%00000000 ; 11
4CF2: FFE0C000	
4CF6: 18181F19	            defb %00011000,%00011000,%00011111,%00011001,%00011001,%00011111,%00011000,%00011000 ; 12
4CFA: 191F1818	
4CFE: 1818F898	            defb %00011000,%00011000,%11111000,%10011000,%10011000,%11111000,%00011000,%00011000 ; 13
4D02: 98F81818	
4D06: 18181C1F	            defb %00011000,%00011000,%00011100,%00011111,%00001111,%00000000,%00000000,%00000000 ; 14
4D0A: 0F000000	
4D0E: 0000000F	            defb %00000000,%00000000,%00000000,%00001111,%00011111,%00011100,%00011000,%00011000 ; 15
4D12: 1F1C1818	
4D16: 000000F0	            defb %00000000,%00000000,%00000000,%11110000,%11111000,%00111000,%00011000,%00011000 ; 16
4D1A: F8381818	
4D1E: 181838F8	            defb %00011000,%00011000,%00111000,%11111000,%11110000,%00000000,%00000000,%00000000 ; 17
4D22: F0000000	
4D26: 000000FF	            defb %00000000,%00000000,%00000000,%11111111,%11111111,%00000000,%00000000,%00000000 ; 18
4D2A: FF000000	
4D2E: 0F0F0F0F	            defb %00001111,%00001111,%00001111,%00001111,%11111111,%11111111,%11111111,%11111111 ; 19
4D32: FFFFFFFF	
4D36: F0F0F0F0	            defb %11110000,%11110000,%11110000,%11110000,%11111111,%11111111,%11111111,%11111111 ; 20
4D3A: FFFFFFFF	
4D3E: FFFFFFFF	            defb %11111111,%11111111,%11111111,%11111111,%11110000,%11110000,%11110000,%11110000 ; 21
4D42: F0F0F0F0	
4D46: FFFFFFFF	            defb %11111111,%11111111,%11111111,%11111111,%00001111,%00001111,%00001111,%00001111 ; 22
4D4A: 0F0F0F0F	
4D4E: 00307878	            defb %00000000,%00110000,%01111000,%01111000,%00110000,%00000000,%00000000,%00000000 ; 23
4D52: 30000000	
              	            ; ------------------------------------------------------------------------------
              	; LM80C - FIRMWARE - R3.13
              	; ------------------------------------------------------------------------------
              	; The following code is intended to be used with LM80C Z80-based computer
              	; designed by Leonardo Miliani. More info at
              	; www DOT leonardomiliani DOT com
              	; ------------------------------------------------------------------------------
              	; Coding/Editing/Compiling:
              	; Original init code for MC68B05 by Grant Searle
              	; Original SIO/CTC/PIO init code by Mario Blunk
              	; NASCOM BASIC originally modified by Gran Searle
              	; Code modified and adapted for LM80C by Leonardo Miliani
              	;
              	; Edited with Atom Editor
              	;
              	; Compiled with ZASM assembler 4.2.4
              	; https://k1.spdns.de/Develop/Projects/zasm-4.0/Distributions/
              	; ------------------------------------------------------------------------------
              	; Copyright notes:
              	; Parts of the code (c) Grant Searle - free for non commercial use
              	; Please include this advice and the note to the attribution of the original
              	; version to Grant Searle if you intend to redistribuite it
              	; http://searle.hostei.com/grant/index.html
              	; eMail: home.micros01@btinternet.com
              	;
              	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
              	; Parts of the code (c) Mario Blunk
              	; http://www.trainz.de
              	;
              	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
              	; NASCOM ROM BASIC Ver 4.7, (C) 1978 Microsoft
              	; Scanned from source published in 80-BUS NEWS from Vol 2, Issue 3
              	; (May-June 1983) to Vol 3, Issue 3 (May-June 1984)
              	; Adapted for the freeware Zilog Macro Assembler 2.10 to produce
              	; the original ROM code (checksum A934H). PA
              	;
              	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
              	; The following code is intended to be used with LM80C Z80-based computer
              	; designed by Leonardo Miliani. Code and computer schematics are released under
              	; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
              	; kind of warranty: you can use them at your own risk.
              	; You are free to use them for any non-commercial use: you are only asked to
              	; maintain the copyright notices, include this advice and the note to the 
              	; attribution of the original version to Leonardo Miliani, if you intend to
              	; redistribuite them.
              	; https://www.leonardomiliani.com
              	; 
              	; Please support me by visiting the following links:
              	; Main project page: https://www.leonardomiliani.com
              	; Schematics and code: https://github.com/leomil72/LM80C
              	; Videos about the computer: https://www.youtube.com/user/leomil72/videos
              	; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
              	; ------------------------------------------------------------------------------
              	
              	
              	; ------------------------------------------------------------------------------
              	; this line instructs the assembler to prepare a file for a ROM target
              	; meaning that blank cells will be filled up with $FF
              	#target rom
              	
              	; this line instructs the assembler to compile taking account that code
              	; starts at $0000 (the address reached by Z80 upon reset)
0000:         	#code BOOT, $0000
              	
              	; END OF ASSEMBLY SOURCE
              	#end
              	
              	;-------------------------------------------------------------------------------


; +++ segments +++

#CODE          = $0000 =     0,  size = $4D56 = 19798
#CODE BOOT     = $0000 =     0,  size = $0000 =     0

; +++ global symbols +++

ABPASS           = $229C =  8860          rom.asm:4645
ABS              = $2CDD = 11485          rom.asm:6238
ACCSUM           = $1AD2 =  6866          rom.asm:3513 (unused)
ACPASS           = $229B =  8859          rom.asm:4644
ADD30            = $3B71 = 15217          rom.asm:8286
ADD301           = $3B81 = 15233          rom.asm:8297
ADDEXP           = $2C76 = 11382          rom.asm:6173
ADDIG            = $2E1C = 11804          rom.asm:6463
ADDNEWLINE       = $096C =  2412          rom.asm:1410
ADDPHL           = $2A12 = 10770          rom.asm:5781
ADRS1            = $81F1 = 33265          rom.asm:5137
ADRS2            = $81F5 = 33269          rom.asm:5139
ALLFOL           = $256A =  9578          rom.asm:5093
ANTVLU           = $1DD7 =  7639          rom.asm:3923
ARET             = $316D = 12653          rom.asm:6903 (unused)
ARLDSV           = $21A6 =  8614          rom.asm:4484
ARREND           = $81BF = 33215          rom.asm:2033
ARRLP            = $2435 =  9269          rom.asm:4884
ASC              = $253B =  9531          rom.asm:5063
ASCTFP           = $2DBF = 11711          rom.asm:6409
ASPCS            = $1D38 =  7480          rom.asm:3845
ATHOME           = $0600 =  1536          rom.asm:900
ATN              = $3121 = 12577          rom.asm:6874
ATN1             = $313E = 12606          rom.asm:6886
ATNTAB           = $3148 = 12616          rom.asm:6891
ATOH             = $1B0D =  6925          rom.asm:3546
A_RTS_OFF        = $0165 =   357          rom.asm:198
A_RTS_ON         = $0173 =   371          rom.asm:209
BACKSPACE        = $0769 =  1897          rom.asm:1121
BADINP           = $1D5B =  7515          rom.asm:3857
BAKSTK           = $14C1 =  5313          rom.asm:2618
BAKTMP           = $251B =  9499          rom.asm:5041
BASTXT           = $8133 = 33075          rom.asm:2009
BCDEFP           = $2D04 = 11524          rom.asm:6267
BEEPOFF          = $052A =  1322          rom.asm:767
BFREE            = $0F76 =  3958          rom.asm:2202
BIN              = $3BC3 = 15299          rom.asm:8346
BIN2             = $3BC9 = 15305          rom.asm:8348 (unused)
BINERR           = $3C20 = 15392          rom.asm:8407
BINIT            = $3BFF = 15359          rom.asm:8382
BINTFP           = $3BF5 = 15349          rom.asm:8378
BITOUT           = $3BDD = 15325          rom.asm:8360
BITOUT2          = $3BE1 = 15329          rom.asm:8362
BITS6            = $3926 = 14630          rom.asm:7968
BITS7            = $3930 = 14640          rom.asm:7973
BITS8            = $393B = 14651          rom.asm:7978
BKGNDCLR         = $81EE = 33262          rom.asm:2060
BKSP             = $0008 =     8          rom.asm:1958
BN               = $0028 =    40          rom.asm:2111
BNMSG            = $134D =  4941          rom.asm:2526
BNORM            = $2A72 = 10866          rom.asm:5840
BNPTR            = $13C9 =  5065          rom.asm:2553 (unused)
BNRMLP           = $2A75 = 10869          rom.asm:5843
BOOT             = $0000 =     0  BOOT    rom.asm:9234 (unused)
BOOT_end         = $0000 =     0  BOOT    rom.asm:9234 (unused)
BOOT_size        = $0000 =     0  BOOT    rom.asm:9234 (unused)
BPS              = $81F8 = 33272          rom.asm:7789
BRK              = $1A80 =  6784          rom.asm:3470
BRKFLG           = $80A9 = 32937          rom.asm:2003
BRKLIN           = $81B3 = 33203          rom.asm:2027
BRKMSG           = $14BB =  5307          rom.asm:2616
BRKRET           = $0F6D =  3949          rom.asm:2198
BS               = $0010 =    16          rom.asm:2099
BSERR            = $21D9 =  8665          rom.asm:4515
BSMSG            = $127C =  4732          rom.asm:2514
BSPTR            = $13B1 =  5041          rom.asm:2541 (unused)
BUFFER           = $8136 = 33078          rom.asm:2010
BYT2ASC          = $3B68 = 15208          rom.asm:8281
BYTSFT           = $2BAA = 11178          rom.asm:6051
CFEVAL           = $213C =  8508          rom.asm:4415
CH3_TIMER        = $0237 =   567          rom.asm:349
CHABFREMPTY      = $01C8 =   456          rom.asm:263
CHAR2VID         = $06AC =  1708          rom.asm:1019
CHARINTOBFR      = $0136 =   310          rom.asm:167
CHARTY           = $20EA =  8426          rom.asm:4371
CHASNDDTN        = $8223 = 33315          rom.asm:2071
CHBSNDDTN        = $8225 = 33317          rom.asm:2072
CHCKYPOS         = $078F =  1935          rom.asm:1140
CHCKYPOS2        = $07FA =  2042          rom.asm:1200
CHCSNDDTN        = $8227 = 33319          rom.asm:2073
CHECKALT         = $0C84 =  3204          rom.asm:1720
CHECKCTRL        = $0C92 =  3218          rom.asm:1726
CHECKKBD         = $0CA0 =  3232          rom.asm:1732
CHECKWARM        = $02BB =   699          rom.asm:417
CHEKFN           = $2333 =  9011          rom.asm:4737
CHKALT           = $0D18 =  3352          rom.asm:1792
CHKBIN           = $3C12 = 15378          rom.asm:8397
CHKBKSP          = $06D6 =  1750          rom.asm:1039
CHKCLR           = $32EF = 13039          rom.asm:7139
CHKCR            = $06CD =  1741          rom.asm:1035
CHKCRSDWN        = $06FA =  1786          rom.asm:1055
CHKCRSLFT        = $06DF =  1759          rom.asm:1043
CHKCRSR          = $0246 =   582          rom.asm:359
CHKCRSRGT        = $06F1 =  1777          rom.asm:1051
CHKCRSUP         = $06E8 =  1768          rom.asm:1047
CHKCS            = $06C4 =  1732          rom.asm:1031
CHKCTRL          = $0D0F =  3343          rom.asm:1788
CHKEY1           = $3B1E = 15134          rom.asm:8239
CHKEY2           = $3B23 = 15139          rom.asm:8240
CHKEY3           = $3B26 = 15142          rom.asm:8241
CHKEY4           = $3B2C = 15148          rom.asm:8242
CHKEY5           = $3B2F = 15151          rom.asm:8243
CHKFNK           = $0D4B =  3403          rom.asm:1817
CHKG2M           = $32F9 = 13049          rom.asm:7147
CHKINK           = $29F1 = 10737          rom.asm:5760
CHKLF            = $0703 =  1795          rom.asm:1059
CHKLN            = $0CFB =  3323          rom.asm:1779
CHKLTR           = $1ADF =  6879          rom.asm:3522
CHKSCAR          = $3238 = 12856          rom.asm:7035
CHKSNDCH         = $0C09 =  3081          rom.asm:1646
CHKSTK           = $14F5 =  5365          rom.asm:2655
CHKSUM           = $80A6 = 32934          rom.asm:2001
CHKSYN           = $181A =  6170          rom.asm:3125
CHKTYP           = $1EB7 =  7863          rom.asm:4038
CHKYPOS          = $07B6 =  1974          rom.asm:1161
CHR              = $254C =  9548          rom.asm:5075
CHR4VID          = $81EC = 33260          rom.asm:2058
CHRPNT           = $81F1 = 33265          rom.asm:7162
CHRST68          = $3C96 = 15510          rom.asm:8594
CHRST88          = $4496 = 17558          rom.asm:8878
CIRCLE           = $35CC = 13772          rom.asm:7539
CKBPS            = $38D9 = 14553          rom.asm:7928
CKCOL            = $33D5 = 13269          rom.asm:7273
CKINCHAR         = $0224 =   548          rom.asm:330
CKMAGN           = $31EB = 12779          rom.asm:6988
CLEAR            = $1B32 =  6962          rom.asm:3570
CLEARVIDBUF      = $05F3 =  1523          rom.asm:893
CLOTST           = $1866 =  6246          rom.asm:3172
CLREG            = $1684 =  5764          rom.asm:2898
CLREX2           = $32B2 = 12978          rom.asm:7095
CLRG1            = $32A0 = 12960          rom.asm:7087
CLRG2            = $32A9 = 12969          rom.asm:7091
CLRG2PTNTBL      = $0593 =  1427          rom.asm:831
CLRMC            = $3299 = 12953          rom.asm:7083
CLRPRM           = $37B3 = 14259          rom.asm:7762
CLRPSGREGS       = $0BA7 =  2983          rom.asm:1591
CLRPTR           = $165F =  5727          rom.asm:2878
CLRTABLE         = $0553 =  1363          rom.asm:798
CLRTXT           = $3296 = 12950          rom.asm:7082
CLRVDBF          = $379B = 14235          rom.asm:7742
CLR_RAM_REG      = $09ED =  2541          rom.asm:1447
CLS              = $3170 = 12656          rom.asm:6908
CLSQT            = $3AE5 = 15077          rom.asm:8205
CLSQT1           = $3AF5 = 15093          rom.asm:8213
CMP16            = $3C48 = 15432          rom.asm:8468
CMPFP            = $2D4D = 11597          rom.asm:6325
CMPLG1           = $2050 =  8272          rom.asm:4277
CMPLOG           = $204E =  8270          rom.asm:4276
CMPNUM           = $2D33 = 11571          rom.asm:6308
CMPRES           = $2092 =  8338          rom.asm:4325
CMPSTR           = $207A =  8314          rom.asm:4305
CMP_A            = $29CA = 10698          rom.asm:5741
CN               = $0020 =    32          rom.asm:2107
CNMSG            = $130D =  4877          rom.asm:2522
CNPTR            = $13C1 =  5057          rom.asm:2549 (unused)
CNT1INS          = $2644 =  9796          rom.asm:5220
CNTCHKSND        = $0C44 =  3140          rom.asm:1681
CNTCKCL          = $3265 = 12901          rom.asm:7061
CNTCL1           = $368E = 13966          rom.asm:7626
CNTCL2           = $36B2 = 14002          rom.asm:7639
CNTCL3           = $36D6 = 14038          rom.asm:7652
CNTCL4           = $36FC = 14076          rom.asm:7666
CNTCL5           = $371E = 14110          rom.asm:7678
CNTCL6           = $3742 = 14146          rom.asm:7691
CNTCL7           = $3766 = 14182          rom.asm:7704
CNTDRW           = $3572 = 13682          rom.asm:7493
CNTEND           = $1D00 =  7424          rom.asm:3815
CNTFNK           = $0DA6 =  3494          rom.asm:1867
CNTGPT2          = $334B = 13131          rom.asm:7194
CNTKBCK          = $0D45 =  3397          rom.asm:1815
CNTLGC           = $200F =  8207          rom.asm:4231
CNTLTK           = $3AAB = 15019          rom.asm:8174
CNTNULL          = $08FC =  2300          rom.asm:1353
CNTNULL2         = $0926 =  2342          rom.asm:1375
CNTPLOT          = $3441 = 13377          rom.asm:7330
CNTRX2           = $3859 = 14425          rom.asm:7869
CNTRXCHA         = $0120 =   288          rom.asm:151
CNTSER           = $3825 = 14373          rom.asm:7840
CNTSER2          = $3864 = 14436          rom.asm:7876
CNTSER3          = $3876 = 14454          rom.asm:7885
CNTTXA           = $0201 =   513          rom.asm:302
CNTVALY          = $3796 = 14230          rom.asm:7735
CNTWTSP          = $197D =  6525          rom.asm:3306
CNTZIN           = $267B =  9851          rom.asm:5243
CNVNUM           = $2DCB = 11723          rom.asm:6415
COLD             = $0ECC =  3788          rom.asm:2117
COLDSTART        = $02B3 =   691          rom.asm:414
COLOR            = $3248 = 12872          rom.asm:7050
COMMAN           = $80A3 = 32931          rom.asm:1998
COMPL            = $2AD2 = 10962          rom.asm:5914
CONCAT           = $24B0 =  9392          rom.asm:4974
CONEXP           = $2DFB = 11771          rom.asm:6439
CONPOS           = $2A6F = 10863          rom.asm:5838
CONT             = $1AB9 =  6841          rom.asm:3500
CONTAD           = $81B9 = 33209          rom.asm:2030
CONTCRSLFT       = $07A0 =  1952          rom.asm:1148
CONTCRSRGT       = $080D =  2061          rom.asm:1210
CONTROLKEYS      = $822D = 33325          rom.asm:2078
CONT_POS_CURS    = $068C =  1676          rom.asm:996
CONVAR           = $1FA2 =  8098          rom.asm:4162
CORW             = $02A7 =   679          rom.asm:409
COS              = $30A5 = 12453          rom.asm:6822
COUNTER          = $02EF =   751          rom.asm:447
CPDEHL           = $1814 =  6164          rom.asm:3118
CPKEY            = $3A42 = 14914          rom.asm:8119
CPKEY1           = $3A61 = 14945          rom.asm:8136
CPKEY2           = $3A52 = 14930          rom.asm:8126
CPKEY3           = $3A59 = 14937          rom.asm:8129
CPKYEND          = $3A69 = 14953          rom.asm:8141
CPYLIT           = $1759 =  5977          rom.asm:3017
CR               = $000D =    13          rom.asm:1961
CRARLP           = $21F9 =  8697          rom.asm:4535
CREARY           = $21DE =  8670          rom.asm:4518
CRESTR           = $1C39 =  7225          rom.asm:3713
CRGRETURN        = $08CE =  2254          rom.asm:1329
CRNCLP           = $16BA =  5818          rom.asm:2925
CRSDN            = $001F =    31          rom.asm:1975
CRSLFT           = $001C =    28          rom.asm:1972
CRSRGT           = $001D =    29          rom.asm:1973
CRSR_STATE       = $81E9 = 33257          rom.asm:2055
CRSUP            = $001E =    30          rom.asm:1974
CRTMST           = $236C =  9068          rom.asm:4770
CRTST            = $2378 =  9080          rom.asm:4781
CRTSTE           = $238E =  9102          rom.asm:4795
CRUNCH           = $16B1 =  5809          rom.asm:2921
CS               = $000C =    12          rom.asm:1960
CSTART           = $0ED9 =  3801          rom.asm:2123
CTC0IV           = $81D2 = 33234          rom.asm:2041
CTC1IV           = $81D5 = 33237          rom.asm:2042
CTC2IV           = $81D8 = 33240          rom.asm:2043
CTC3IV           = $81DB = 33243          rom.asm:2044
CTCCONF          = $032E =   814          rom.asm:505
CTC_CFG          = $39AC = 14764          rom.asm:8034
CTC_CH0          = $0010 =    16          rom.asm:36
CTC_CH1          = $0011 =    17          rom.asm:37
CTC_CH2          = $0012 =    18          rom.asm:38
CTC_CH3          = $0013 =    19          rom.asm:39
CTLOFG           = $80A5 = 32933          rom.asm:2000
CTRLC            = $0003 =     3          rom.asm:1956
CTRLG            = $0007 =     7          rom.asm:1957
CTRLO            = $000F =    15          rom.asm:1962
CTRLQ            = $0011 =    17          rom.asm:1963
CTRLR            = $0012 =    18          rom.asm:1964
CTRLS            = $0013 =    19          rom.asm:1965
CTRLU            = $0015 =    21          rom.asm:1966
CTSNDC           = $28A1 = 10401          rom.asm:5578
CUROPR           = $81AA = 33194          rom.asm:2021
CURPOS           = $8190 = 33168          rom.asm:2012
CURSORDOWN       = $0816 =  2070          rom.asm:1218
CURSORLEFT       = $077C =  1916          rom.asm:1131
CURSORRIGHT      = $07E1 =  2017          rom.asm:1187
CURSORUP         = $07C8 =  1992          rom.asm:1172
CURSOR_OFF       = $084C =  2124          rom.asm:1251
CURSOR_ON        = $0836 =  2102          rom.asm:1238
CUR_POS          = $81EF = 33263          rom.asm:1326
DATA             = $1BE0 =  7136          rom.asm:3665
DATABT           = $81FA = 33274          rom.asm:7790
DATFLG           = $8193 = 33171          rom.asm:2015
DATLIN           = $81AE = 33198          rom.asm:2023
DATSNR           = $1532 =  5426          rom.asm:2697
DC               = $8201 = 33281          rom.asm:7538
DCBCDE           = $2D84 = 11652          rom.asm:6368
DD               = $0012 =    18          rom.asm:2100
DDERR            = $1541 =  5441          rom.asm:2705
DDMSG            = $128A =  4746          rom.asm:2515
DDPTR            = $13B3 =  5043          rom.asm:2542 (unused)
DECLN1           = $3A34 = 14900          rom.asm:8111
DEC_D            = $04EA =  1258          rom.asm:726
DEC_E            = $02ED =   749          rom.asm:446
DEEK             = $318C = 12684          rom.asm:6925
DEF              = $22B0 =  8880          rom.asm:4658
DEFFNKS          = $1428 =  5160          rom.asm:2599
DEFSER           = $38C0 = 14528          rom.asm:7915
DEFSIZ           = $2201 =  8705          rom.asm:4539
DEINT            = $1AF3 =  6899          rom.asm:3533
DEL              = $007F =   127          rom.asm:1970
DELCHR           = $1789 =  6025          rom.asm:3047
DEPINT           = $1AED =  6893          rom.asm:3531
DETHL4           = $2D13 = 11539          rom.asm:6279
DETHLB           = $2D15 = 11541          rom.asm:6280
DIGTXT           = $2EC5 = 11973          rom.asm:6561
DIM              = $20BC =  8380          rom.asm:4351
DIMRET           = $20B3 =  8371          rom.asm:4346
DINPOS           = $1849 =  6217          rom.asm:3152
DINT             = $2BAF = 11183          rom.asm:6059
DIRMOD           = $39C0 = 14784          rom.asm:8044
DIR_PAU          = $31B7 = 12727          rom.asm:6954 (unused)
DIV              = $2C0C = 11276          rom.asm:6100
DIV1             = $806B = 32875          rom.asm:1989
DIV10            = $2C00 = 11264          rom.asm:6095
DIV2             = $806F = 32879          rom.asm:1990
DIV3             = $8073 = 32883          rom.asm:1991
DIV4             = $8076 = 32886          rom.asm:1992
DIVLP            = $2C33 = 11315          rom.asm:6124
DIVSUP           = $806A = 32874          rom.asm:1988
DIV_16_8         = $3C87 = 15495          rom.asm:8560
DIV_16_8LP       = $3C8A = 15498          rom.asm:8562
DIV_8_8          = $3C77 = 15479          rom.asm:8537
DIV_8_8LOOP      = $3C7B = 15483          rom.asm:8540
DLSZ             = $3650 = 13904          rom.asm:7599
DOAGN            = $169D =  5789          rom.asm:2911
DOCOM            = $1D05 =  7429          rom.asm:3819
DODEL            = $1769 =  5993          rom.asm:3031
DOEBIT           = $2F05 = 12037          rom.asm:6604
DOFN             = $22DD =  8925          rom.asm:4686
DOKE             = $3197 = 12695          rom.asm:6933
DOSPC            = $1D33 =  7475          rom.asm:3842
DOTAB            = $1D1E =  7454          rom.asm:3831
DPOINT           = $2DF7 = 11767          rom.asm:6437
DRAW             = $34A5 = 13477          rom.asm:7420
DRWCRL           = $366C = 13932          rom.asm:7614
DTSTR            = $237C =  9084          rom.asm:4784
DVBCDE           = $2C0E = 11278          rom.asm:6102
DX               = $8203 = 33283          rom.asm:7418
DXGR             = $35A2 = 13730          rom.asm:7510
DY               = $8205 = 33285          rom.asm:7419
DZ               = $0014 =    20          rom.asm:2101
DZERR            = $153B =  5435          rom.asm:2701
DZMSG            = $129F =  4767          rom.asm:2516
DZPTR            = $13B5 =  5045          rom.asm:2543 (unused)
E2               = $81FD = 33277          rom.asm:7415
ECHDEL           = $177D =  6013          rom.asm:3040
ECHO_CHAR        = $02C5 =   709          rom.asm:423
EDIGIT           = $2E3E = 11838          rom.asm:6486
EMPTINS          = $25E3 =  9699          rom.asm:5178
EMPTSNDBFR       = $0BA3 =  2979          rom.asm:1588
EMPTVRM          = $09E4 =  2532          rom.asm:1439
EMPTYCHABFR      = $01BA =   442          rom.asm:256
EMPTYG2          = $0581 =  1409          rom.asm:823
EMPTYMC          = $05B2 =  1458          rom.asm:849
EMPTYVIDBUF      = $0558 =  1368          rom.asm:802
EMPTY_VRAM       = $09D9 =  2521          rom.asm:1432
ENDBUF           = $1760 =  5984          rom.asm:3023
ENDCON           = $2E0A = 11786          rom.asm:6449
ENDCRL           = $3668 = 13928          rom.asm:7610
ENDCTRLCK        = $0CE6 =  3302          rom.asm:1768
ENDDIM           = $2260 =  8800          rom.asm:4608
ENDDRAW          = $35C8 = 13768          rom.asm:7523
ENDINK           = $2A03 = 10755          rom.asm:5771
ENDINK2          = $2A0C = 10764          rom.asm:5778 (unused)
ENDINP           = $1CEC =  7404          rom.asm:3806
ENDNAM           = $20DE =  8414          rom.asm:4367
ENDPRG           = $1A8F =  6799          rom.asm:3480
ENDTMR           = $2275 =  8821          rom.asm:4621
ENDTXT           = $81F3 = 33267          rom.asm:1328
ENDVDPSET        = $0487 =  1159          rom.asm:671
ENFMEM           = $14FE =  5374          rom.asm:2661
ER               = $81FB = 33275          rom.asm:7414
ER2              = $354C = 13644          rom.asm:7480
ERASECLRTBL      = $0506 =  1286          rom.asm:743
ERRIN            = $1570 =  5488          rom.asm:2729
ERRINT           = $1AB3 =  6835          rom.asm:3496
ERRLIN           = $81B7 = 33207          rom.asm:2029
ERRMSG           = $14AA =  5290          rom.asm:2612
ERROR            = $154C =  5452          rom.asm:2713
ERRORS           = $1207 =  4615          rom.asm:2505 (unused)
ERRTBL           = $13A1 =  5025          rom.asm:2532
ESC              = $001B =    27          rom.asm:1968
EVAL             = $1EC4 =  7876          rom.asm:4046
EVAL1            = $1EC7 =  7879          rom.asm:4048
EVAL2            = $1ED0 =  7888          rom.asm:4052
EVAL3            = $1ED3 =  7891          rom.asm:4053
EVLPAR           = $1F89 =  8073          rom.asm:4148
EVNOT            = $209C =  8348          rom.asm:4333
EXCUTE           = $1A1D =  6685          rom.asm:3400
EXG2MD           = $0449 =  1097          rom.asm:639
EXITCHAR2VID     = $0737 =  1847          rom.asm:1085
EXITCURSORDOWN   = $0833 =  2099          rom.asm:1232
EXITCURSORLEFT   = $07A3 =  1955          rom.asm:1149
EXITCURSORRGHT   = $0813 =  2067          rom.asm:1212
EXITCURSORUP     = $07DF =  2015          rom.asm:1182
EXITCURSOR_ON    = $084A =  2122          rom.asm:1247
EXITGM           = $1512 =  5394          rom.asm:2677
EXITSER          = $3981 = 14721          rom.asm:8017 (unused)
EXMUL16          = $3C6B = 15467          rom.asm:8508
EXP              = $2F9F = 12191          rom.asm:6691
EXPLP            = $2DE9 = 11753          rom.asm:6429
EXPTAB           = $2FDF = 12255          rom.asm:6719
EXPTEN           = $2F17 = 12055          rom.asm:6614
EXTIG            = $1E33 =  7731          rom.asm:3971
EXTXA            = $0215 =   533          rom.asm:313
FANDT            = $1E5C =  7772          rom.asm:3989
FC               = $0008 =     8          rom.asm:2095
FCERR            = $1B08 =  6920          rom.asm:3543
FCMSG            = $1240 =  4672          rom.asm:2510
FCPTR            = $13A9 =  5033          rom.asm:2537 (unused)
FDTLP            = $1E43 =  7747          rom.asm:3973
FINDEL           = $223C =  8764          rom.asm:4580
FINDKEY          = $0CF9 =  3321          rom.asm:1778
FLASHCURSOR      = $0745 =  1861          rom.asm:1098
FLGDIF           = $2CC3 = 11459          rom.asm:6221
FLGREL           = $2CCA = 11466          rom.asm:6227
FNARG            = $81C5 = 33221          rom.asm:2036
FNCTAB           = $0FBF =  4031          rom.asm:2219
FNDARY           = $21AC =  8620          rom.asm:4488
FNDBPS           = $38F2 = 14578          rom.asm:7938
FNDELP           = $2241 =  8769          rom.asm:4585
FNDEND           = $1632 =  5682          rom.asm:2841
FNDNUM           = $2735 = 10037          rom.asm:5357
FNDTOK           = $193F =  6463          rom.asm:3271
FNDVAR           = $2123 =  8483          rom.asm:4399
FNDWRD           = $16E4 =  5860          rom.asm:2945
FNKEYS           = $80B3 = 32947          rom.asm:2008
FNKEYSORD        = $0DC4 =  3524          rom.asm:1884
FNOFST           = $1FB3 =  8115          rom.asm:4172
FNRGNM           = $81C3 = 33219          rom.asm:2035
FNTHR            = $2131 =  8497          rom.asm:4407
FNVAL            = $1FE4 =  8164          rom.asm:4198
FOPRND           = $1EFC =  7932          rom.asm:4074
FOR              = $1984 =  6532          rom.asm:3311
FORFLG           = $81B0 = 33200          rom.asm:2024
FORFND           = $19B4 =  6580          rom.asm:3339
FORSLP           = $1998 =  6552          rom.asm:3320
FPADD            = $2A21 = 10785          rom.asm:5789
FPBCDE           = $2CF9 = 11513          rom.asm:6258
FPEXP            = $81CC = 33228          rom.asm:2038
FPINT            = $2D60 = 11616          rom.asm:6345
FPMULT           = $2B5C = 11100          rom.asm:6000
FPREG            = $81C9 = 33225          rom.asm:2037
FPROND           = $2AB9 = 10937          rom.asm:5890
FPSINT           = $1AE7 =  6887          rom.asm:3529
FPTHL            = $2D10 = 11536          rom.asm:6278
FRE              = $227A =  8826          rom.asm:4627
FRENUM           = $2296 =  8854          rom.asm:4639
FRGNDCLR         = $81ED = 33261          rom.asm:2059
FRMEVL           = $1FA5 =  8101          rom.asm:4163
FWVER            = $00E0 =   224          rom.asm:134 (unused)
G1MD             = $03C8 =   968          rom.asm:578
G2MD             = $0404 =  1028          rom.asm:609
GARBGE           = $23FD =  9213          rom.asm:4857
GARBLP           = $2400 =  9216          rom.asm:4858
GETCHR           = $1A3D =  6717          rom.asm:3423
GETCMD           = $159F =  5535          rom.asm:2753
GETHEX           = $3B9E = 15262          rom.asm:8319
GETINP           = $316E = 12654          rom.asm:6905
GETINT           = $2738 = 10040          rom.asm:5358
GETLEN           = $2530 =  9520          rom.asm:5055
GETLIN           = $179A =  6042          rom.asm:3055
GETLN            = $1B0E =  6926          rom.asm:3547
GETNUM           = $1EB2 =  7858          rom.asm:4035
GETNXT           = $16FF =  5887          rom.asm:2960
GETSTR           = $24FA =  9466          rom.asm:5021
GETVAR           = $20C1 =  8385          rom.asm:4354
GM               = $002A =    42          rom.asm:2112
GMERR            = $37CC = 14284          rom.asm:7777
GMMSG            = $1358 =  4952          rom.asm:2527
GMNCR            = $17F1 =  6129          rom.asm:3097
GMPRT            = $13CB =  5067          rom.asm:2554 (unused)
GNXARY           = $2434 =  9268          rom.asm:4883
GOFUNC           = $1FEC =  8172          rom.asm:4202
GOSUB            = $1B8C =  7052          rom.asm:3616
GOTO             = $1B9D =  7069          rom.asm:3628
GPCPCH1          = $33B8 = 13240          rom.asm:7257
GPCPCHR          = $33AD = 13229          rom.asm:7252 (unused)
GPNT             = $3369 = 13161          rom.asm:7207
GPNTCO1          = $3393 = 13203          rom.asm:7234
GPNTCOL          = $3389 = 13193          rom.asm:7230 (unused)
GPRINT           = $3302 = 13058          rom.asm:7163
GRBARY           = $2454 =  9300          rom.asm:4902
GRBDON           = $23D5 =  9173          rom.asm:4832
GRBLP            = $240E =  9230          rom.asm:4864
GSTRCU           = $24FD =  9469          rom.asm:5022
GSTRDE           = $2501 =  9473          rom.asm:5024
GSTRHL           = $2500 =  9472          rom.asm:5023
GTFLNM           = $253F =  9535          rom.asm:5065 (unused)
GTFNAM           = $20C6 =  8390          rom.asm:4357
GTLNLP           = $1B11 =  6929          rom.asm:3548
GTSIXD           = $2E8F = 11919          rom.asm:6530
GTVLUS           = $1DAF =  7599          rom.asm:3901
GX               = $81F3 = 33267          rom.asm:7159
GY               = $81F5 = 33269          rom.asm:7160
HALF             = $2F36 = 12086          rom.asm:6635
HALFPI           = $30EF = 12527          rom.asm:6853
HELLOWRLD        = $02DF =   735          rom.asm:438
HELP             = $39CC = 14796          rom.asm:8055
HEX              = $3B32 = 15154          rom.asm:8247
HEX1             = $3B4A = 15178          rom.asm:8260
HEX2             = $3B4C = 15180          rom.asm:8262
HEX3             = $3B59 = 15193          rom.asm:8270
HEX4             = $3B5B = 15195          rom.asm:8272
HEXIT            = $3BB5 = 15285          rom.asm:8334
HEXLP            = $3B91 = 15249          rom.asm:8309
HEXLP1           = $3B96 = 15254          rom.asm:8311
HEXTFP           = $3B85 = 15237          rom.asm:8304
HL2XY            = $069B =  1691          rom.asm:1007
HLPERR           = $39E2 = 14818          rom.asm:8066
HLPLN            = $80B1 = 32945          rom.asm:2007
HOME             = $0019 =    25          rom.asm:1967
HP               = $0030 =    48          rom.asm:2115
HPMSG            = $1397 =  5015          rom.asm:2530
HPPTR            = $13D1 =  5073          rom.asm:2557 (unused)
HX               = $0026 =    38          rom.asm:2110
HXERR            = $3BBE = 15294          rom.asm:8342
HXMSG            = $1342 =  4930          rom.asm:2525
HXPTR            = $13C7 =  5063          rom.asm:2552 (unused)
ID               = $0016 =    22          rom.asm:2102
IDMSG            = $12B0 =  4784          rom.asm:2517
IDPTR            = $13B7 =  5047          rom.asm:2544 (unused)
IDTEST           = $2325 =  8997          rom.asm:4727
IF               = $1C6F =  7279          rom.asm:3746
IFGO             = $1C7D =  7293          rom.asm:3753
IFJMP            = $1A24 =  6692          rom.asm:3403
INCHL            = $2D0E = 11534          rom.asm:6275
INCLEN           = $1845 =  6213          rom.asm:3150
INCTMR3          = $0240 =   576          rom.asm:355
INDFND           = $14DB =  5339          rom.asm:2637
INEWLN           = $15FA =  5626          rom.asm:2801
INIT             = $0EE0 =  3808          rom.asm:2127
INITAB           = $13D3 =  5075          rom.asm:2561
INITBE           = $14AA =  5290          rom.asm:2608
INITST           = $3C33 = 15411          rom.asm:8420
INIT_HW          = $025A =   602          rom.asm:376
INKEY            = $29BF = 10687          rom.asm:5736
INKEY2           = $29D9 = 10713          rom.asm:5749
INMSG            = $14B1 =  5297          rom.asm:2613
INP              = $26F5 =  9973          rom.asm:5326
INPBIN           = $1E01 =  7681          rom.asm:3945
INPBRK           = $1A8C =  6796          rom.asm:3478
INPORT           = $80A0 = 32928          rom.asm:1996
INPSUB           = $809F = 32927          rom.asm:1995
INPUT            = $1D6C =  7532          rom.asm:3865
INRNG            = $2E98 = 11928          rom.asm:6535
INSTR            = $258C =  9612          rom.asm:5145
INT              = $2D8B = 11659          rom.asm:6376
INTVAR           = $166E =  5742          rom.asm:2889
INVSGN           = $2CE1 = 11489          rom.asm:6240
ITMSEP           = $1DF2 =  7666          rom.asm:3936
JSTZER           = $2F21 = 12065          rom.asm:6620
KBDNPT           = $8229 = 33321          rom.asm:2074
KBMAP            = $0DCC =  3532          rom.asm:1887
KBMAP_ALT        = $0E4C =  3660          rom.asm:1907
KBMAP_CTRL       = $0E8C =  3724          rom.asm:1917
KBMAP_SFT        = $0E0C =  3596          rom.asm:1897
KBTMP            = $822A = 33322          rom.asm:2075
KEY              = $39E7 = 14823          rom.asm:8071
KEYBOARD         = $0C64 =  3172          rom.asm:1704
KEYCH            = $3A04 = 14852          rom.asm:8087
KILFOR           = $1EA2 =  7842          rom.asm:4026
KILIN            = $1794 =  6036          rom.asm:3052
LASTKEYPRSD      = $822C = 33324          rom.asm:2077
LCRFLG           = $8191 = 33169          rom.asm:2013
LDCLRTBEX2       = $047E =  1150          rom.asm:664
LDCLRTBMD1       = $03FB =  1019          rom.asm:602
LDCOLSTOEMPTY    = $0572 =  1394          rom.asm:813
LDFNKEYCHR       = $0D92 =  3474          rom.asm:1857
LDG1             = $151F =  5407          rom.asm:2683
LDG1ND           = $1530 =  5424          rom.asm:2693
LDKEY            = $3A96 = 14998          rom.asm:8165
LDREGVLS         = $0A0A =  2570          rom.asm:1466
LEDLIGHT         = $02E9 =   745          rom.asm:444
LEFT             = $255C =  9564          rom.asm:5083
LEN              = $252C =  9516          rom.asm:5053
LET              = $1BF7 =  7159          rom.asm:3681
LETNUM           = $1C4A =  7242          rom.asm:3723
LETSTR           = $1C12 =  7186          rom.asm:3694
LF               = $000A =    10          rom.asm:1959
LFRGNM           = $26EB =  9963          rom.asm:5317
LINEAT           = $80AF = 32943          rom.asm:2006
LINEIN           = $2E4A = 11850          rom.asm:6496
LINFND           = $15E3 =  5603          rom.asm:2787
LIST             = $1879 =  6265          rom.asm:3184
LISTLP           = $18FC =  6396          rom.asm:3233
LM80CLOGO        = $0A5D =  2653          rom.asm:1551
LNS1             = $81EF = 33263          rom.asm:5136
LNS2             = $81F3 = 33267          rom.asm:5138
LOADCHARSET      = $0A14 =  2580          rom.asm:1475
LOADCLR          = $32B9 = 12985          rom.asm:7098
LOADFP           = $2D07 = 11527          rom.asm:6268
LOADLOGOCHRS     = $0532 =  1330          rom.asm:773
LOADMAP          = $0D1F =  3359          rom.asm:1795
LOADNEXTCOL      = $087E =  2174          rom.asm:1278
LOAD_CRSR_POS    = $0677 =  1655          rom.asm:985
LOCATE           = $280B = 10251          rom.asm:5492
LOG              = $2B1B = 11035          rom.asm:5968
LOGOFONT         = $4C96 = 19606          rom.asm:9148
LOGTAB           = $2B0E = 11022          rom.asm:5963
LOKFOR           = $14C5 =  5317          rom.asm:2620
LOOPST           = $81AC = 33196          rom.asm:2022
LS               = $001C =    28          rom.asm:2105
LSMSG            = $12E2 =  4834          rom.asm:2520
LSPTR            = $13BD =  5053          rom.asm:2547 (unused)
LST01            = $18A5 =  6309          rom.asm:3201
LST01H           = $18A8 =  6312          rom.asm:3202
LST03            = $18E2 =  6370          rom.asm:3222
LST04            = $18BF =  6335          rom.asm:3210 (unused)
LST05            = $18F0 =  6384          rom.asm:3229
LST06            = $18C6 =  6342          rom.asm:3212
LST07            = $1921 =  6433          rom.asm:3253
LST08            = $191E =  6430          rom.asm:3252
LSTALL           = $18CA =  6346          rom.asm:3214
LSTBIN           = $81B1 = 33201          rom.asm:2025
LSTCSRSTA        = $81EA = 33258          rom.asm:2056
LSTKEYS          = $3A6B = 14955          rom.asm:8144
LSTLP2           = $192D =  6445          rom.asm:3262
LSTLP3           = $1930 =  6448          rom.asm:3263
LSTRAM           = $8194 = 33172          rom.asm:2016
LSTRND           = $809B = 32923          rom.asm:1994
LTSTND           = $1E0C =  7692          rom.asm:3950
LVINSTR          = $2671 =  9841          rom.asm:5238
LVKBRDCHK        = $0D79 =  3449          rom.asm:1838
LVKBRDCHK2       = $0D75 =  3445          rom.asm:1836
LVRXCHA          = $0131 =   305          rom.asm:159
LWIDTH           = $80A2 = 32930          rom.asm:1997
MAKINT           = $273B = 10043          rom.asm:5359
MAKNUM           = $2EB4 = 11956          rom.asm:6550
MANLP            = $2DD3 = 11731          rom.asm:6421
MATCH            = $1731 =  5937          rom.asm:2992
MCMD             = $0426 =  1062          rom.asm:624
MEMMSG           = $0FB4 =  4020          rom.asm:2208
MID              = $268C =  9868          rom.asm:5255
MID1             = $2562 =  9570          rom.asm:5087
MIDNUM           = $26F0 =  9968          rom.asm:5320
MINCDE           = $2A61 = 10849          rom.asm:5824
MINUS            = $1F91 =  8081          rom.asm:4153
MIXCLRS          = $32E2 = 13026          rom.asm:7127
MIXCOL           = $81EF = 33263          rom.asm:7161
MKTMST           = $2369 =  9065          rom.asm:4769
MLDBLP           = $2DAC = 11692          rom.asm:6397
MLDEBC           = $2DA4 = 11684          rom.asm:6392
MLOOP            = $0F0E =  3854          rom.asm:2145
MLP              = $3C5B = 15451          rom.asm:8497
MLP1             = $3C62 = 15458          rom.asm:8501
MLSP10           = $2CA1 = 11425          rom.asm:6201
MNGSNDS          = $0BFF =  3071          rom.asm:1642
MNOASK           = $0F0B =  3851          rom.asm:2144
MO               = $0024 =    36          rom.asm:2109
MOD              = $2BB7 = 11191          rom.asm:6069
MOMSG            = $1332 =  4914          rom.asm:2524
MONOUT           = $3C25 = 15397          rom.asm:8411
MOPTR            = $13C5 =  5061          rom.asm:2551 (unused)
MORDT            = $1E18 =  7704          rom.asm:3955
MORINP           = $17A3 =  6051          rom.asm:3060
MOVBUF           = $1619 =  5657          rom.asm:2822
MOVCRS           = $0650 =  1616          rom.asm:963
MOVDIR           = $1739 =  5945          rom.asm:3000
MOVLP            = $14EA =  5354          rom.asm:2647
MOVSTR           = $14E7 =  5351          rom.asm:2644
MOVUP            = $14E4 =  5348          rom.asm:2643
MRPRNT           = $1C8F =  7311          rom.asm:3760
MSGTXT1          = $033A =   826          rom.asm:510
MSGTXT2          = $0364 =   868          rom.asm:512
MSIZE            = $0EFB =  3835          rom.asm:2138
MUL16            = $3C53 = 15443          rom.asm:8489
MUL8LP           = $2B87 = 11143          rom.asm:6023
MULLN2           = $2B53 = 11091          rom.asm:5994
MULT             = $2B5A = 11098          rom.asm:5998
MULT8            = $2B7E = 11134          rom.asm:6017
MULTEN           = $2E15 = 11797          rom.asm:6457
MULVAL           = $823D = 33341          rom.asm:2084
MVCRS2LFT        = $07A5 =  1957          rom.asm:1153
MVSTPT           = $1C41 =  7233          rom.asm:3717
NEDMOR           = $1DAB =  7595          rom.asm:3899
NEGAFT           = $2F4C = 12108          rom.asm:6644
NEW              = $165E =  5726          rom.asm:2877
NEWCRSRCOORD     = $0659 =  1625          rom.asm:969
NEXITM           = $1D42 =  7490          rom.asm:3851
NEXT             = $1E67 =  7783          rom.asm:3994
NEXT1            = $1E6A =  7786          rom.asm:3995
NF               = $0000 =     0          rom.asm:2091
NFERR            = $153E =  5438          rom.asm:2703
NFMSG            = $1207 =  4615          rom.asm:2506
NFPTR            = $13A1 =  5025          rom.asm:2533 (unused)
NLLCR            = $0000 =     0          rom.asm:1955
NM1              = $2764 = 10084          rom.asm:5383
NMI              = $2749 = 10057          rom.asm:5370
NMI2             = $2775 = 10101          rom.asm:5391
NMIDINT          = $2780 = 10112          rom.asm:5400
NMIEINT          = $2779 = 10105          rom.asm:5396
NMIFLG           = $80A8 = 32936          rom.asm:2002
NMIINT           = $2783 = 10115          rom.asm:5401
NMIUSR           = $8061 = 32865          rom.asm:1984
NMIVR1           = $278F = 10127          rom.asm:5412
NOBEEP           = $0BD1 =  3025          rom.asm:1611
NOBPDAT          = $0BED =  3053          rom.asm:1625
NOCHNG           = $1729 =  5929          rom.asm:2987
NOENED           = $2F24 = 12068          rom.asm:6623
NOGD             = $346E = 13422          rom.asm:7359
NOISUP           = $2926 = 10534          rom.asm:5646
NOKEYPRSD        = $0CEA =  3306          rom.asm:1770
NOLIN            = $1AA2 =  6818          rom.asm:3489
NOMADD           = $2B98 = 11160          rom.asm:6034
NOMLAD           = $2DBA = 11706          rom.asm:6405
NOPMPT           = $1D86 =  7558          rom.asm:3877
NORMAL           = $2A8C = 10892          rom.asm:5859
NOS1             = $2950 = 10576          rom.asm:5664
NOS2             = $2962 = 10594          rom.asm:5676
NOS3             = $297A = 10618          rom.asm:5694
NOSPC            = $1720 =  5920          rom.asm:2982
NOSUB7           = $3BB1 = 15281          rom.asm:8330
NOSWAP           = $2A3B = 10811          rom.asm:5805
NOSYSPR          = $27C1 = 10177          rom.asm:5441
NOTAMP           = $1F66 =  8038          rom.asm:4134
NOTFULL          = $0141 =   321          rom.asm:173
NOTRDWRAP        = $01E2 =   482          rom.asm:281
NOTSTR           = $20F9 =  8441          rom.asm:4379
NOTWRAP          = $014D =   333          rom.asm:179
NOXOR            = $271B = 10011          rom.asm:5343
NSCFOR           = $2109 =  8457          rom.asm:4387
NULFLG           = $80A4 = 32932          rom.asm:1999
NUMASC           = $2E5D = 11869          rom.asm:6506
NXTARY           = $21C0 =  8640          rom.asm:4500
NXTBYT           = $170F =  5903          rom.asm:2972
NXTCHAR          = $0A27 =  2599          rom.asm:1486
NXTCHR           = $1750 =  5968          rom.asm:3012
NXTDAT           = $81C1 = 33217          rom.asm:2034
NXTDTA           = $1BDF =  7135          rom.asm:3663
NXTITM           = $1DA3 =  7587          rom.asm:3894
NXTLN            = $1957 =  6487          rom.asm:3284
NXTOPR           = $81B5 = 33205          rom.asm:2028
NXTSTL           = $1BE6 =  7142          rom.asm:3668
NXTSTT           = $1BE9 =  7145          rom.asm:3671
OD               = $0006 =     6          rom.asm:2094
ODMSG            = $1234 =  4660          rom.asm:2509
ODPTR            = $13A7 =  5031          rom.asm:2536 (unused)
OKMSG            = $14B6 =  5302          rom.asm:2615
OM               = $000C =    12          rom.asm:2097
OMERR            = $150D =  5389          rom.asm:2672
OMMSG            = $125F =  4703          rom.asm:2512
OMPTR            = $13AD =  5037          rom.asm:2539 (unused)
ON               = $1C51 =  7249          rom.asm:3729
ONGO             = $1C60 =  7264          rom.asm:3737
ONGOLP           = $1C61 =  7265          rom.asm:3738
ONJMP            = $1A25 =  6693          rom.asm:3405
OPNPAR           = $1EC0 =  7872          rom.asm:4044
OPNQT            = $3AF7 = 15095          rom.asm:8216
OPNQT1           = $3B0D = 15117          rom.asm:8226
OPRND            = $1F3B =  7995          rom.asm:4117
OS               = $001A =    26          rom.asm:2104
OSMSG            = $12CE =  4814          rom.asm:2519
OSPTR            = $13BB =  5051          rom.asm:2546 (unused)
OTKLN            = $1791 =  6033          rom.asm:3051
OTPORT           = $8068 = 32872          rom.asm:1987
OUTC             = $1825 =  6181          rom.asm:3133
OUTEXP           = $2F15 = 12053          rom.asm:6613
OUTIT            = $180B =  6155          rom.asm:3111
OUTNBS           = $180E =  6158          rom.asm:3113
OUTNCR           = $3C42 = 15426          rom.asm:8432
OUTSUB           = $8067 = 32871          rom.asm:1986
OUTWRD           = $1949 =  6473          rom.asm:3277
OV               = $000A =    10          rom.asm:2096
OVERR            = $1547 =  5447          rom.asm:2709
OVMSG            = $1256 =  4694          rom.asm:2511
OVPTR            = $13AB =  5035          rom.asm:2538 (unused)
OVTST1           = $2C94 = 11412          rom.asm:6193
OVTST2           = $2C99 = 11417          rom.asm:6196
OVTST3           = $2C9A = 11418          rom.asm:6197
PADD             = $2E39 = 11833          rom.asm:6482
PAND             = $2005 =  8197          rom.asm:4224
PAND1            = $202A =  8234          rom.asm:4247 (unused)
PARBT            = $81FB = 33275          rom.asm:7791
PASSA            = $22AB =  8875          rom.asm:4654
PAUSE            = $31AE = 12718          rom.asm:6949
PBUFF            = $8230 = 33328          rom.asm:2083
PEEK             = $27D1 = 10193          rom.asm:5453
PEND             = $1A87 =  6791          rom.asm:3475
PHLTFP           = $2CF6 = 11510          rom.asm:6257
PIO_CA           = $0002 =     2          rom.asm:32 (unused)
PIO_CB           = $0003 =     3          rom.asm:33
PIO_DA           = $0000 =     0          rom.asm:30 (unused)
PIO_DB           = $0001 =     1          rom.asm:31
PKEPRMS          = $27E5 = 10213          rom.asm:5468
PLOT             = $3426 = 13350          rom.asm:7320
PLTCRL           = $365F = 13919          rom.asm:7607
PLUCDE           = $2AC6 = 10950          rom.asm:5901
PNORM            = $2A94 = 10900          rom.asm:5867
PNT2VD           = $0D72 =  3442          rom.asm:1835
PNTEND           = $3423 = 13347          rom.asm:7315 (unused)
POINT            = $33E8 = 13288          rom.asm:7286
POKE             = $27FB = 10235          rom.asm:5478
POPAF            = $23EF =  9199          rom.asm:4847
POPHL            = $2519 =  9497          rom.asm:5038
POPHRT           = $2BA8 = 11176          rom.asm:6048
POPNOK           = $1591 =  5521          rom.asm:2745
POR              = $2008 =  8200          rom.asm:4226
POR1             = $202F =  8239          rom.asm:4252
POS              = $22A8 =  8872          rom.asm:4653
POSINT           = $1AEA =  6890          rom.asm:3530
POS_CURSOR       = $0646 =  1606          rom.asm:957
POS_TB_CRS_32    = $0979 =  2425          rom.asm:1422
POS_TB_CRS_40    = $09A9 =  2473          rom.asm:1426
POUT             = $2701 =  9985          rom.asm:5331
POWER            = $2F5A = 12122          rom.asm:6652
POWER1           = $2F6A = 12138          rom.asm:6660
POWER2           = $2F87 = 12167          rom.asm:6678
POWERS           = $2F3A = 12090          rom.asm:6637
PRINT            = $1C93 =  7315          rom.asm:3762
PRITAB           = $11E9 =  4585          rom.asm:2473
PRNTCRLF         = $1CF6 =  7414          rom.asm:3811
PRNTFNK          = $0DB7 =  3511          rom.asm:1875
PRNTFNKEY        = $0D7A =  3450          rom.asm:1840
PRNTHL           = $2E52 = 11858          rom.asm:6500
PRNTLP           = $1C96 =  7318          rom.asm:3763
PRNTNB           = $1CD9 =  7385          rom.asm:3795
PRNTOK           = $1592 =  5522          rom.asm:2748
PRNTRETURN       = $0958 =  2392          rom.asm:1399
PRNTST           = $1CDD =  7389          rom.asm:3797
PRNTVIDEO        = $81EB = 33259          rom.asm:2057
PRNUMS           = $23B9 =  9145          rom.asm:4816
PROCES           = $17BC =  6076          rom.asm:3071
PROGND           = $81BB = 33211          rom.asm:2031
PROGST           = $8240 = 33344          rom.asm:2085
PROMPT           = $16A1 =  5793          rom.asm:2914
PRS              = $23BA =  9146          rom.asm:4817
PRS1             = $23BD =  9149          rom.asm:4818
PRSLP            = $23C4 =  9156          rom.asm:4821
PRTCHR           = $3AC0 = 15040          rom.asm:8187
PRTCKEY          = $3B0F = 15119          rom.asm:8229
PRTEND           = $3B1C = 15132          rom.asm:8236
PRTK1            = $3B10 = 15120          rom.asm:8230
PRTK2            = $3A7F = 14975          rom.asm:8156 (unused)
PRTK3            = $3AA8 = 15016          rom.asm:8173
PRTK4            = $3A7D = 14973          rom.asm:8155
PRTNUM           = $81F7 = 33271          rom.asm:7788
PSG_DAT          = $0041 =    65          rom.asm:53
PSG_REG          = $0040 =    64          rom.asm:52
PSUB             = $2A1C = 10780          rom.asm:5786
PT               = $81F7 = 33271          rom.asm:5140
PT1              = $81F9 = 33273          rom.asm:5141
PT2              = $81FB = 33275          rom.asm:5142
PTCHR1           = $3ADD = 15069          rom.asm:8201
PTLN             = $158D =  5517          rom.asm:2742
PTRLP            = $1626 =  5670          rom.asm:2831
PUTBUF           = $17F7 =  6135          rom.asm:3100
PUTCHRBUF        = $0D65 =  3429          rom.asm:1830
PUTCHRBUF1       = $0DAC =  3500          rom.asm:1870
PUTCRSCHR        = $0765 =  1893          rom.asm:1116
PUTCTL           = $17FC =  6140          rom.asm:3102
PUTFID           = $19F9 =  6649          rom.asm:3377
PXLSET           = $3472 = 13426          rom.asm:7363
PXOR             = $200D =  8205          rom.asm:4229
PXOR1            = $2037 =  8247          rom.asm:4258
QTSTLP           = $237F =  9087          rom.asm:4786
QTSTR            = $2379 =  9081          rom.asm:4782
QUARTR           = $30F3 = 12531          rom.asm:6855
RADIUS           = $81FB = 33275          rom.asm:7535
RAWPRINT         = $0229 =   553          rom.asm:336
READ             = $1D9E =  7582          rom.asm:3891
READFG           = $81B2 = 33202          rom.asm:2026
READKBLN         = $0C4F =  3151          rom.asm:1690
READ_VIDEO_LOC   = $060A =  1546          rom.asm:907
READ_VSTAT       = $063F =  1599          rom.asm:950
RECWRD           = $3191 = 12689          rom.asm:6928 (unused)
REDO             = $1D49 =  7497          rom.asm:3855
REM              = $1BE2 =  7138          rom.asm:3666
RESDIV           = $2C46 = 11334          rom.asm:6137
RESEED           = $3091 = 12433          rom.asm:6811
RESET            = $3C28 = 15400          rom.asm:8414
RESTMR           = $0329 =   809          rom.asm:500
RESTNL           = $1A62 =  6754          rom.asm:3446
RESTOR           = $1A4D =  6733          rom.asm:3435
RESZER           = $2A87 = 10887          rom.asm:5855
RETADR           = $2170 =  8560          rom.asm:4447
RETINT           = $2CCF = 11471          rom.asm:6229
RETLIN           = $1BDA =  7130          rom.asm:3660
RETNAD           = $1735 =  5941          rom.asm:2996
RETNUL           = $2173 =  8563          rom.asm:4451
RETNUM           = $1F9D =  8093          rom.asm:4158
RETREL           = $2CC1 = 11457          rom.asm:6219
RETURN           = $1BBB =  7099          rom.asm:3644
RG               = $0004 =     4          rom.asm:2093
RGMSG            = $121F =  4639          rom.asm:2508
RGPTR            = $13A5 =  5029          rom.asm:2535 (unused)
RIGHT            = $2682 =  9858          rom.asm:5248
RIGHT1           = $2560 =  9568          rom.asm:5085
RINPUT           = $80AA = 32938          rom.asm:2004
RLTLP            = $1EE0 =  7904          rom.asm:4060
RND              = $3030 = 12336          rom.asm:6758
RND1             = $306C = 12396          rom.asm:6789
RND2             = $3088 = 12424          rom.asm:6807
RNDTAB           = $3099 = 12441          rom.asm:6818
RNGTST           = $2F27 = 12071          rom.asm:6627
RONDB            = $2AA8 = 10920          rom.asm:5879
RONDUP           = $2AA7 = 10919          rom.asm:5878
ROUND            = $2A0F = 10767          rom.asm:5780
RP2INST          = $261B =  9755          rom.asm:5202
RPGPNT           = $337E = 13182          rom.asm:7221
RPT100           = $0514 =  1300          rom.asm:750
RPT101           = $04BB =  1211          rom.asm:698
RPT102           = $04BE =  1214          rom.asm:700
RPT103           = $04D4 =  1236          rom.asm:713
RPT104           = $04DC =  1244          rom.asm:717
RPTCL1           = $3623 = 13859          rom.asm:7577
RPTCRL           = $3610 = 13840          rom.asm:7571
RPTCVB1          = $37A3 = 14243          rom.asm:7747
RPTCVB2          = $37AC = 14252          rom.asm:7752
RPTDRW           = $3556 = 13654          rom.asm:7484
RPTEMPTYBUF      = $0578 =  1400          rom.asm:817
RPTEMPTYROW      = $08C2 =  2242          rom.asm:1314
RPTFLL1          = $05E0 =  1504          rom.asm:877
RPTINST          = $25F4 =  9716          rom.asm:5185
RPTKBDRD         = $0CA4 =  3236          rom.asm:1734
RPTLDCL          = $32C3 = 12995          rom.asm:7103
RPTNLLSRC        = $08EC =  2284          rom.asm:1343
RPTNLLSRC2       = $0917 =  2327          rom.asm:1367
RPTPS            = $31BC = 12732          rom.asm:6957
RPTRSSR          = $37F8 = 14328          rom.asm:7815
RPTWLCMBP        = $0BD7 =  3031          rom.asm:1614
RPVOLCG          = $287E = 10366          rom.asm:5553
RSCALE           = $2E33 = 11827          rom.asm:6480
RST00            = $0000 =     0          rom.asm:75 (unused)
RST08            = $0008 =     8          rom.asm:81 (unused)
RST10            = $0010 =    16          rom.asm:96 (unused)
RST18            = $0018 =    24          rom.asm:102 (unused)
RSTCHRCRS        = $066E =  1646          rom.asm:979
RSTPSG           = $0BAE =  2990          rom.asm:1594
RSTSER1          = $37EB = 14315          rom.asm:7807
RSTSTR           = $26A5 =  9893          rom.asm:5268
RSTVDPRAMREG     = $09F3 =  2547          rom.asm:1450
RUN              = $1B78 =  7032          rom.asm:3607
RUNCNT           = $19FD =  6653          rom.asm:3381
RUNFST           = $166A =  5738          rom.asm:2886
RUNLIN           = $1B9C =  7068          rom.asm:3627
RXA              = $01CD =   461          rom.asm:270
RXA_EXIT         = $01F3 =   499          rom.asm:288
RXEND            = $3860 = 14432          rom.asm:7872
RX_CHA_AVAIL     = $0100 =   256          rom.asm:138
RZINSTR          = $2666 =  9830          rom.asm:5233
SA               = $002E =    46          rom.asm:2114
SAMSG            = $137E =  4990          rom.asm:2529
SAPTR            = $13CF =  5071          rom.asm:2556 (unused)
SAVEXP           = $2A88 = 10888          rom.asm:5856
SAVSTP           = $19F0 =  6640          rom.asm:3370
SAVSTR           = $2354 =  9044          rom.asm:4753
SBSCPT           = $217E =  8574          rom.asm:4457
SC               = $002C =    44          rom.asm:2113
SCALE            = $2AE6 = 10982          rom.asm:5933
SCALLP           = $2AE8 = 10984          rom.asm:5934
SCALMI           = $2DFE = 11774          rom.asm:6442
SCALPL           = $2E14 = 11796          rom.asm:6456
SCERR            = $39BB = 14779          rom.asm:8040
SCERR1           = $39B7 = 14775          rom.asm:8037
SCMSG            = $1369 =  4969          rom.asm:2528
SCNEND           = $248B =  9355          rom.asm:4943
SCPTLP           = $2184 =  8580          rom.asm:4461
SCPTR            = $13CD =  5069          rom.asm:2555 (unused)
SCREEN           = $31CD = 12749          rom.asm:6976
SCROLLNXTRW      = $086C =  2156          rom.asm:1270
SCROLLUP         = $0853 =  2131          rom.asm:1258
SCR_CURS_X       = $81E4 = 33252          rom.asm:2050
SCR_CURS_Y       = $81E5 = 33253          rom.asm:2051
SCR_CUR_NX       = $81E6 = 33254          rom.asm:2052
SCR_CUR_NY       = $81E7 = 33255          rom.asm:2053
SCR_MODE         = $81E0 = 33248          rom.asm:2048
SCR_NAM_TB       = $81E2 = 33250          rom.asm:2049
SCR_ORG_CHR      = $81E8 = 33256          rom.asm:2054
SCR_SIZE_H       = $81DF = 33247          rom.asm:2047
SCR_SIZE_W       = $81DE = 33246          rom.asm:2046
SCVDP            = $31F9 = 12793          rom.asm:6993
SEARCH           = $16FD =  5885          rom.asm:2958
SEED             = $8078 = 32888          rom.asm:1993
SENDCHRPTRNS     = $0A2B =  2603          rom.asm:1488
SENDSND          = $0BD4 =  3028          rom.asm:1612
SERABITS         = $822F = 33327          rom.asm:2082
SERBUF_START     = $8000 = 32768          rom.asm:63
SERIAL           = $37D1 = 14289          rom.asm:7794
SERIALS_EN       = $822E = 33326          rom.asm:2081
SERLED           = $3821 = 14369          rom.asm:7836
SER_BUFSIZE      = $0058 =    88          rom.asm:59
SER_EMPTYSIZE    = $0005 =     5          rom.asm:61
SER_FULLSIZE     = $0050 =    80          rom.asm:60
SETBEEP          = $051E =  1310          rom.asm:759
SETBRCL          = $32CE = 13006          rom.asm:7111
SETCRSRY         = $072C =  1836          rom.asm:1080
SETCSRCOORDS     = $072D =  1837          rom.asm:1081
SETIO            = $2725 = 10021          rom.asm:5350
SETLIT           = $1747 =  5959          rom.asm:3008
SETNAMETABLE     = $05D7 =  1495          rom.asm:872
SETPAR           = $393F = 14655          rom.asm:7980
SETPTR           = $1621 =  5665          rom.asm:2828
SETSER           = $38CD = 14541          rom.asm:7922
SETSNDREG        = $0BF5 =  3061          rom.asm:1629
SETTOP           = $0F32 =  3890          rom.asm:2170
SETVDP           = $31E0 = 12768          rom.asm:6984 (unused)
SETVDPADRS       = $05EA =  1514          rom.asm:886
SET_GFX_MODE     = $09F8 =  2552          rom.asm:1457
SET_GFX_MODE2    = $0A00 =  2560          rom.asm:1461
SET_P1           = $38FC = 14588          rom.asm:7942
SFTPRG           = $15EB =  5611          rom.asm:2791
SGN              = $2CC7 = 11463          rom.asm:6226
SGNEXP           = $1FF5 =  8181          rom.asm:4210
SGNRES           = $81CD = 33229          rom.asm:2039
SHOW_LOGO        = $0492 =  1170          rom.asm:679
SHRITE           = $2AF5 = 10997          rom.asm:5942
SHRLP            = $2AF8 = 11000          rom.asm:5944
SHRT1            = $2AFC = 11004          rom.asm:5948
SIGNON           = $0F83 =  3971          rom.asm:2204
SIGNS            = $2D1E = 11550          rom.asm:6288
SIN              = $30AB = 12459          rom.asm:6824
SIN1             = $30DB = 12507          rom.asm:6844
SINTAB           = $30F7 = 12535          rom.asm:6857
SIOBFR           = $81FD = 33277          rom.asm:7793
SIO_A_DI         = $0181 =   385          rom.asm:219
SIO_A_EI         = $018D =   397          rom.asm:228
SIO_A_SETS       = $02FA =   762          rom.asm:457
SIO_B_SETS       = $0300 =   768          rom.asm:463 (unused)
SIO_CA           = $0022 =    34          rom.asm:42
SIO_CB           = $0023 =    35          rom.asm:43
SIO_DA           = $0020 =    32          rom.asm:44
SIO_DB           = $0021 =    33          rom.asm:45 (unused)
SIXDIG           = $2E7A = 11898          rom.asm:6520
SMPVAR           = $241F =  9247          rom.asm:4871
SMSER1           = $300F = 12303          rom.asm:6736
SN               = $0002 =     2          rom.asm:2092
SND1             = $28EA = 10474          rom.asm:5612
SND2VID          = $1858 =  6232          rom.asm:3163
SNDCHRTOBFR      = $0939 =  2361          rom.asm:1383
SNDCLRSET        = $05CD =  1485          rom.asm:863
SNDKEYTOBFR      = $0D53 =  3411          rom.asm:1822
SNDLOGPT         = $0549 =  1353          rom.asm:789
SNDOVR           = $291F = 10527          rom.asm:5642
SNDREGCFG        = $0BBB =  3003          rom.asm:1603
SNERR            = $1538 =  5432          rom.asm:2699
SNMSG            = $1218 =  4632          rom.asm:2507
SNPTR            = $13A3 =  5027          rom.asm:2534 (unused)
SOUND            = $2895 = 10389          rom.asm:5571
SPC              = $0020 =    32          rom.asm:1969
SPCFST           = $2E6B = 11883          rom.asm:6512
SPCLP            = $1D3A =  7482          rom.asm:3847
SPEC_RX_CONDITON = $019B =   411          rom.asm:241
SQR              = $2F51 = 12113          rom.asm:6648
SRCHLIN          = $1965 =  6501          rom.asm:3290
SRCHLN           = $163E =  5694          rom.asm:2850
SRCHLP           = $1641 =  5697          rom.asm:2851
SREG             = $283D = 10301          rom.asm:5520
SRPT2            = $381B = 14363          rom.asm:7833
SRTINK           = $29ED = 10733          rom.asm:5758
SRTTXT           = $81F1 = 33265          rom.asm:1327
SSTAT            = $29AD = 10669          rom.asm:5725
SSTSA            = $24E7 =  9447          rom.asm:5003
ST               = $001E =    30          rom.asm:2106
STACK            = $813B = 33083          rom.asm:2011
STAKFP           = $2CE9 = 11497          rom.asm:6246
STALL            = $1A76 =  6774          rom.asm:3463
STARTB           = $0ED2 =  3794          rom.asm:2120
STARTEMPTY       = $05C9 =  1481          rom.asm:861
STKTHS           = $1F24 =  7972          rom.asm:4101
STLOOK           = $82A4 = 33444          rom.asm:2086
STMSG            = $12F2 =  4850          rom.asm:2521
STOP             = $1A85 =  6789          rom.asm:3473
STORED           = $1B55 =  6997          rom.asm:3587
STPBT            = $81FC = 33276          rom.asm:7792
STPOOL           = $2462 =  9314          rom.asm:4908
STPTR            = $13BF =  5055          rom.asm:2548 (unused)
STR              = $2344 =  9028          rom.asm:4746
STR1             = $234A =  9034          rom.asm:4748
STRADD           = $2465 =  9317          rom.asm:4910
STRBOT           = $81A8 = 33192          rom.asm:2020
STRE2            = $3553 = 13651          rom.asm:7483 (unused)
STRENT           = $1DF5 =  7669          rom.asm:3938
STRPAR           = $395E = 14686          rom.asm:7996
STRSPC           = $80AD = 32941          rom.asm:2005
STTLIN           = $1CE4 =  7396          rom.asm:3801
SUBCDE           = $2A1E = 10782          rom.asm:5788
SUBPHL           = $2A18 = 10776          rom.asm:5784
SUMLP            = $3018 = 12312          rom.asm:6741
SUMSER           = $3000 = 12288          rom.asm:6729
SUPTLZ           = $2EF9 = 12025          rom.asm:6597
SUP_BPS          = $3996 = 14742          rom.asm:8032
SVNAM2           = $20DD =  8413          rom.asm:4366
SVSTAD           = $2372 =  9074          rom.asm:4774
SX               = $81FF = 33279          rom.asm:7416
SY               = $8201 = 33281          rom.asm:7417
SYS              = $27A3 = 10147          rom.asm:5429
SYSRET           = $27CF = 10191          rom.asm:5448
TAN              = $310C = 12556          rom.asm:6864
TEMPSTACK        = $818D = 33165          rom.asm:69
TESTALT          = $0CD3 =  3283          rom.asm:1759
TESTCTRL         = $0CE0 =  3296          rom.asm:1765
TESTOS           = $23F1 =  9201          rom.asm:4850
TESTR            = $23D3 =  9171          rom.asm:4830
TF               = $81FF = 33279          rom.asm:5144
TM               = $0018 =    24          rom.asm:2103
TMERR            = $154A =  5450          rom.asm:2711
TMMSG            = $12BF =  4799          rom.asm:2518
TMPBFR1          = $81EF = 33263          rom.asm:2061
TMPBFR2          = $81F1 = 33265          rom.asm:2062
TMPBFR3          = $81F3 = 33267          rom.asm:2063
TMPBFR4          = $81F5 = 33269          rom.asm:2064
TMPKEYBFR        = $822B = 33323          rom.asm:2076
TMPSTR           = $81A4 = 33188          rom.asm:2019
TMPTR            = $13B9 =  5049          rom.asm:2545 (unused)
TMR              = $2264 =  8804          rom.asm:4614
TMRCNT           = $81CE = 33230          rom.asm:2040
TMSTPL           = $8198 = 33176          rom.asm:2018
TMSTPT           = $8196 = 33174          rom.asm:2017
TOPOOL           = $2558 =  9560          rom.asm:5080
TOSTRA           = $24F0 =  9456          rom.asm:5012
TP               = $81FD = 33277          rom.asm:5143
TRYAGN           = $2ED4 = 11988          rom.asm:6570
TSALP            = $24F1 =  9457          rom.asm:5013
TSTBIT           = $3C3B = 15419          rom.asm:8425 (unused)
TSTBRK           = $1A68 =  6760          rom.asm:3452
TSTMEM           = $0F20 =  3872          rom.asm:2158
TSTNUM           = $1EB5 =  7861          rom.asm:4036
TSTOPL           = $239A =  9114          rom.asm:4802
TSTRED           = $203C =  8252          rom.asm:4264
TSTREM           = $174A =  5962          rom.asm:3009
TSTSGN           = $2CB8 = 11448          rom.asm:6214
TSTSPC           = $196B =  6507          rom.asm:3297
TSTSTR           = $1EB6 =  7862          rom.asm:4037
TTYLIN           = $179A =  6042          rom.asm:3056
TXA              = $01F7 =   503          rom.asm:296
TXA_EXIT         = $0210 =   528          rom.asm:310
TXTMD            = $03A3 =   931          rom.asm:559 (unused)
TX_EMP           = $0218 =   536          rom.asm:319
TYPE             = $8192 = 33170          rom.asm:2014
UF               = $0022 =    34          rom.asm:2108
UFERR            = $1544 =  5444          rom.asm:2707
UFMSG            = $131C =  4892          rom.asm:2523
UFPTR            = $13C3 =  5059          rom.asm:2550 (unused)
UL               = $000E =    14          rom.asm:2098
ULERR            = $1BB6 =  7094          rom.asm:3641
ULMSG            = $126D =  4717          rom.asm:2513
ULPTR            = $13AF =  5039          rom.asm:2540 (unused)
UNITY            = $2B0A = 11018          rom.asm:5961
UPDATA           = $1A63 =  6755          rom.asm:3447
USR              = $8064 = 32868          rom.asm:1985
VAL              = $26BC =  9916          rom.asm:5287
VAL1             = $26DA =  9946          rom.asm:5307
VAL2             = $26E4 =  9956          rom.asm:5311
VAL3             = $26E7 =  9959          rom.asm:5312
VALIDX           = $378B = 14219          rom.asm:7724
VALIDY           = $3790 = 14224          rom.asm:7730
VAREND           = $81BD = 33213          rom.asm:2032
VDPMODESET       = $0A35 =  2613          rom.asm:1502
VDPMODESET1      = $0A3D =  2621          rom.asm:1511 (unused)
VDPMODESET2      = $0A45 =  2629          rom.asm:1521 (unused)
VDPMODESETEX2    = $0A55 =  2645          rom.asm:1541 (unused)
VDPMODESETMC     = $0A4D =  2637          rom.asm:1531 (unused)
VDP_DAT          = $0030 =    48          rom.asm:48
VDP_SET          = $0032 =    50          rom.asm:49
VIDEOBUFF        = $81F7 = 33271          rom.asm:2065
VIDTMP1          = $821F = 33311          rom.asm:2066
VIDTMP2          = $8221 = 33313          rom.asm:2067
VOLCH            = $288A = 10378          rom.asm:5560
VOLUME           = $285C = 10332          rom.asm:5538
VPEEK            = $27D8 = 10200          rom.asm:5458
VPOKE            = $2800 = 10240          rom.asm:5483
VREG             = $2986 = 10630          rom.asm:5703
VSTAT            = $29A2 = 10658          rom.asm:5718
WAIT             = $2707 =  9991          rom.asm:5334
WAITLP           = $271C = 10012          rom.asm:5344
WARM             = $0ECF =  3791          rom.asm:2118
WARMST           = $0F6A =  3946          rom.asm:2197
WIDTH            = $3184 = 12676          rom.asm:6919
WLCBPDAT         = $0BE5 =  3045          rom.asm:1624
WLCMBEEP         = $0BCB =  3019          rom.asm:1609
WORDS            = $1003 =  4099          rom.asm:2258
WORDTB           = $1183 =  4483          rom.asm:2372
WRITEBUF         = $08A7 =  2215          rom.asm:1299
WRITE_VIDEO_LOC  = $061F =  1567          rom.asm:924
WRITE_VREG       = $0634 =  1588          rom.asm:941
WRKSPC           = $805E = 32862          rom.asm:1983
WRTSND           = $2971 = 10609          rom.asm:5685
WRTSNDREG        = $0BFA =  3066          rom.asm:1634
WTSPC            = $1971 =  6513          rom.asm:3300
X1               = $81EF = 33263          rom.asm:7410
X1GR             = $3502 = 13570          rom.asm:7456
X2               = $81F7 = 33271          rom.asm:7412
XC               = $81F7 = 33271          rom.asm:7533
XI               = $81FD = 33277          rom.asm:7536
XY2HL            = $347A = 13434          rom.asm:7371
Y1               = $81F1 = 33265          rom.asm:7411
Y1GR             = $3529 = 13609          rom.asm:7469
Y2               = $81F9 = 33273          rom.asm:7413
YC               = $81F9 = 33273          rom.asm:7534
YI               = $81FF = 33279          rom.asm:7537
ZDATA            = $0083 =   131          rom.asm:2437
ZDINT            = $00BF =   191          rom.asm:2457 (unused)
ZDIV             = $00BD =   189          rom.asm:2455 (unused)
ZEND             = $0080 =   128          rom.asm:2435
ZEQUAL           = $00C5 =   197          rom.asm:2460
ZERARY           = $221F =  8735          rom.asm:4560
ZERBYT           = $14B5 =  5301          rom.asm:2614
ZEROLP           = $2162 =  8546          rom.asm:4438
ZEROSUP          = $3BCF = 15311          rom.asm:8351
ZFN              = $00B5 =   181          rom.asm:2446
ZFOR             = $0081 =   129          rom.asm:2436
ZGOSUB           = $008C =   140          rom.asm:2439
ZGOTO            = $0088 =   136          rom.asm:2438
ZGTR             = $00C4 =   196          rom.asm:2459
ZINSTR           = $00DE =   222          rom.asm:2466
ZLEFT            = $00E6 =   230          rom.asm:2467
ZLTH             = $00C6 =   198          rom.asm:2461
ZMINUS           = $00BB =   187          rom.asm:2453
ZMOD             = $00BE =   190          rom.asm:2456 (unused)
ZNEW             = $00B2 =   178          rom.asm:2442
ZNOT             = $00B8 =   184          rom.asm:2449
ZONELP           = $1D13 =  7443          rom.asm:3825
ZOR              = $00C3 =   195          rom.asm:2458
ZPLUS            = $00BA =   186          rom.asm:2452
ZPOINT           = $00DD =   221          rom.asm:2464
ZPRINT           = $00AC =   172          rom.asm:2441
ZREM             = $008E =   142          rom.asm:2440
ZSGN             = $00C7 =   199          rom.asm:2463
ZSPC             = $00B6 =   182          rom.asm:2447
ZSTEP            = $00B9 =   185          rom.asm:2450
ZTAB             = $00B3 =   179          rom.asm:2444
ZTHEN            = $00B7 =   183          rom.asm:2448
ZTIMES           = $00BC =   188          rom.asm:2454 (unused)
ZTO              = $00B4 =   180          rom.asm:2445
_end             = $4D56 = 19798          rom.asm:73 (unused)
_size            = $4D56 = 19798          rom.asm:73 (unused)
absHL            = $3C6D = 15469          rom.asm:8521
basicStarted     = $805D = 32861          rom.asm:67
bufWrap          = $0058 =    88          rom.asm:68
initCTC          = $0304 =   772          rom.asm:472
initPSG          = $0B9D =  2973          rom.asm:1585
initVDP          = $037E =   894          rom.asm:539
negHL            = $3C70 = 15472          rom.asm:8523
serBufUsed       = $805C = 32860          rom.asm:66
serInPtr         = $8058 = 32856          rom.asm:64
serRdPtr         = $805A = 32858          rom.asm:65


total time: 0.1381 sec.
no errors
